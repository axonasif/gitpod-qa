[["0",{"pageContent":"__SPLIT_HERE__\nCookies Policy\n\nDate: 13th of June, 2022\n\n__SPLIT_HERE__\nGeneral statement on Cookies\n\nThe Website uses cookies and/or other similar technologies to collect and store certain information. This typically involves pieces of information or code transferred to or accessed from your computer hard drive or mobile device to store and sometimes track information about you, and to distinguish you from other users of the Website. This helps us to provide you with a good experience when you browse (e.g. storing searches and presenting personalised content) and also allows us to improve the Website. This document should be read in conjunction with Gitpod&#39;s Privacy Policy.\n\nA number of cookies and similar technologies last only for the duration of your web or app session and expire when you close your browser or exit the Website. Others are used to remembering you when you return to the Website and will last for longer.\n\nWe use strictly necessary cookies if they are necessary for the performance of a contract with you, or because using them is in our legitimate interests (where we have considered that these are not overridden by your rights). We use all other cookies with your consent.\n\nWe use the following types of cookies, the specific details of which are set out in the table further below:\n\n__SPLIT_HERE__\nStrictly necessary cookies\n\nThese are cookies that are required for the operation of our Site and under our terms with you. They include, for example, cookies that enable you to log into secure areas of our Site or (on other sites) use a shopping cart or make use of e-billing services.\n\n__SPLIT_HERE__\nFunctionality cookies\n\nThese may be used to recognise you when you return to our Site. This enables us, subject to your choices and preferences, to personalise our content, greet you by name and remember your preferences (for example, choice of language or region).\n\n__SPLIT_HERE__\nAnalytical / Performance cookies\n\nThese allow us to recognise and count the number of visitors and to see how visitors move around our Stie when they are using it. This helps us improve the way our Website works, for example, by ensuring that users are finding what they are looking for easily.\n\nTargeting/Advertising cookies\n\nThese cookies record your visit to our Website, the pages you have visited and the links you have followed. We will use this information subject to your choices and preferences to make our Website and the advertising displayed on it more relevant to your interests. We may also share this information with third parties for this purpose.\n\n__SPLIT_HERE__\nDisabling cookies\n\nThe effect of disabling cookies depends on which cookies you disable but, in general, the Site may not operate properly if all cookies are switched off. If you want to disable cookies on our Website, you can click on &quot;Cookie Preferences&quot; in the footer.\n\nYou can also change your browser settings to reject cookies. How you can do this will depend on the browser you use and you can find more information here: https://www.allaboutcookies.org/","metadata":{"source":"https://gitpod.io/cookies"}}],["1",{"pageContent":"Specific details on Cookies","metadata":{"source":"https://gitpod.io/cookies"}}],["2",{"pageContent":"Product/Website Cookie Name Type Purpose Cookie Duration Third-Party Cookie More Information\nProduct, Website gitpod-user Strictly Necessary Recognises if a user visited the Gitpod product 1 year No\nProduct gitpod_io Strictly Necessary Session sign-in cookie to recognise user login status 1 week No\nWebsite GCLB Strictly Necessary Load balancing to quickly provide our website and services Session Yes https://policies.google.com/privacy?hl=en\nProduct gitpod-ui-experiments Strictly Necessary Describes if a Gitpod user enabled UI beta Persistent No\nProduct open-in-gitpod-search data Strictly Necessary Provides latest search results in Gitpod to enable better loading times Persistent No\nProduct team-selection  Strictly Necessary Describes if a Gitpod user selected a team to be working with Persistent No\nWebsite algoliasearch-client-js Strictly Necessary Necessary in order to optimize the website&#39;s search -bar function . The cookie ensures accurate and fast search results. Persistent No","metadata":{"source":"https://gitpod.io/cookies"}}],["3",{"pageContent":"Website algoliasearch-client-js Strictly Necessary Necessary in order to optimize the website&#39;s search -bar function . The cookie ensures accurate and fast search results. Persistent No\nWebsite CONSENT Strictly Necessary Used to detect if the visitor has accepted cookies on our website. This is necessary for privacy compliance. 2 years Yes https://policies.google.com/privacy?hl=en\nWebsite ajs_anonymous_id Strictly Necessary Cookie used to identify reoccurring website visitors and contact form submissions 1 year Yes https://segment.com/legal/privacy/\nWebsite ajs_anonymous_id Strictly Necessary Local Browser Storage used to identify reoccurring website visitors and contact form submissions Persistent Yes https://segment.com/legal/privacy/\nProduct rc::a Strictly Necessary This cookie is used to distinguish between humans and bots. This is necessary for the website, in order to make valid reports on the use of their website. Persistent Yes https://policies.google.com/privacy?hl=en","metadata":{"source":"https://gitpod.io/cookies"}}],["4",{"pageContent":"Product, Website gp-analytical Strictly Necessary Stores and indicates cookie consent preferences of an user for a certain category 1 year No\nProduct, Website gp-necessary Strictly Necessary Stores and indicates cookie consent preferences of an user for a certain category 1 year No\nProduct, Website gp-targeting Strictly Necessary Stores and indicates cookie consent preferences of an user for a certain category 1 year No\nWebsite _gcl_au Targeting/Marketing Used by Google Ad sense to store and track conversions and advertising efficiency 3 months Yes https://policies.google.com/privacy?hl=en\nWebsite tld Targeting/Marketing Used to track users across multiple website in order to present relevant advertisement Session No\nWebsite VISITOR_INFO1_LIVE Targeting/Marketing Tries to estimate the users&#39; bandwidth on pages with integrated YouTube videos 6 months Yes https://policies.google.com/privacy?hl=en","metadata":{"source":"https://gitpod.io/cookies"}}],["5",{"pageContent":"Website VISITOR_INFO1_LIVE Targeting/Marketing Tries to estimate the users&#39; bandwidth on pages with integrated YouTube videos 6 months Yes https://policies.google.com/privacy?hl=en\nWebsite YSC Targeting/Marketing Registers a unique ID to keep statistics of what videos from You Tube the user has seen Session Yes https://policies.google.com/privacy?hl=en\nWebsite yt.innertube::nextId Targeting/Marketing Registers a unique ID to keep statistics of what videos from You Tube the user has seen Persistent Yes https://policies.google.com/privacy?hl=en\nWebsite yt.innertube::requests Targeting/Marketing Registers a unique ID to keep statistics of what videos from You Tube the user has seen Persistent Yes https://policies.google.com/privacy?hl=en\nWebsite ytidb::LAST_RESULT_ENTRY_KEY Targeting/Marketing Stores the user&#39;s video player preferences using embedded You Tube video Persistent Yes https://policies.google.com/privacy?hl=en","metadata":{"source":"https://gitpod.io/cookies"}}],["6",{"pageContent":"Website ytidb::LAST_RESULT_ENTRY_KEY Targeting/Marketing Stores the user&#39;s video player preferences using embedded You Tube video Persistent Yes https://policies.google.com/privacy?hl=en\nWebsite yt-remote-cast-available Targeting/Marketing Stores the user&#39;s video player preferences using embedded You Tube video Persistent Yes https://policies.google.com/privacy?hl=en\nWebsite yt-remote-cast-installed Targeting/Marketing Stores the user&#39;s video player preferences using embedded You Tube video Persistent Yes https://policies.google.com/privacy?hl=en\nWebsite yt-remote-connected-devices Targeting/Marketing Stores the user&#39;s video player preferences using embedded You Tube video Persistent Yes https://policies.google.com/privacy?hl=en\nWebsite yt-remote-device-id Targeting/Marketing Stores the user&#39;s video player preferences using embedded You Tube video Persistent Yes https://policies.google.com/privacy?hl=en","metadata":{"source":"https://gitpod.io/cookies"}}],["7",{"pageContent":"Website yt-remote-device-id Targeting/Marketing Stores the user&#39;s video player preferences using embedded You Tube video Persistent Yes https://policies.google.com/privacy?hl=en\nWebsite yt-remote-fast-check-period Targeting/Marketing Stores the user&#39;s video player preferences using embedded You Tube video Persistent Yes https://policies.google.com/privacy?hl=en\nWebsite yt-remote-session-app Targeting/Marketing Stores the user&#39;s video player preferences using embedded You Tube video Persistent Yes https://policies.google.com/privacy?hl=en\nWebsite yt-remote-session-name Targeting/Marketing Stores the user&#39;s video player preferences using embedded You Tube video Persistent Yes https://policies.google.com/privacy?hl=en\nWebsite ajs_user_id Analytics/Performance Generates a userID to identify reoccurring website visitors Persistent Yes https://segment.com/legal/privacy/","metadata":{"source":"https://gitpod.io/cookies"}}],["8",{"pageContent":"Website ajs_user_id Analytics/Performance Generates a userID to identify reoccurring website visitors Persistent Yes https://segment.com/legal/privacy/\nWebsite gitpod-marketing-website-visited Analytics/Performance Recognises if a user visited http://gitpod.io 1 year No","metadata":{"source":"https://gitpod.io/cookies"}}],["9",{"pageContent":"__SPLIT_HERE__\nList of Sub-processors\n\n‚ÑπÔ∏è This page has been created in the context of the European üá™üá∫ General Data Protection Regulation (GDPR) and sub processor relationships in Gitpos&#39;s Data Processing Agreement (DPA).\n\nProcessor entity name Location Description of processing\nGoogle, LLC United States of America Cloud Infrastructure for gitpod.io\nAmazon Web Services, Inc. United States of America Cloud Infrastructure for Gitpod Dedicated\nGoogle, LLC United States of America Business Emails and Collaboration\nSlack Technologies, LLC United States of America Instant Messaging and Collaboration\nFrontApp, Inc United States of America Platform to handle customer support inquiries and questions\nSalesforce, Inc United States of America Customer Relationship Management\nTwillo, Inc d/b/a Segment.io United States of America Customer Data Platform\nPearberry Software, Inc United States of America Email service for Account Notifications, Product Updates and Newsletters\nTwillo, Inc United States of America Phone number and user account verification service\nStripe, Inc United States of America Payment Service\nGong.io, Inc United States of America Meeting Transcript Service\nLacework, Inc United States of America Threat Detection Solution\nStrongDM, Inc United States of America Access Management Platform","metadata":{"source":"https://gitpod.io/sub-processors"}}],["10",{"pageContent":"On the 27th of April there will be a one-day virtual conference where members from the Gitpod team will be spending dedicated time with you, our community.\n\nAt the Gitpod Community day you&#39;ll learn about the north stars that are guiding product development from our CEO - Sven Efftinge and the inner technical architecture of Gitpod from our Chief Architect - Christian Weichel. Michael Friedrich from GitLab will be making an appearance to provide insights into how Gitpod makes it easier for open-source maintainers to attract contributors and, finally, Gitpod will also be revealing some exciting initiatives but Shhh...Spoilers!\n\nAfter the talks, the conference is largely unstructured as it is about spending time with each other. Sven, Christian and other members of Gitpod will be available all day to spend time with you.\n\nLast week we announced a $13m funding round led by General Catalyst to accelerate our roadmap and continue to build out a fully distributed world-class team to define a new product category in modern software development and move software development to the cloud. We are hiring (internationally + remote) and this the perfect opportunity to ask any questions you may have about life at Gitpod.\n\nThe Gitpod discord channel is where the event will be taking place. Make sure you have your microphone + camera set up and ready as there will be many video breakout opportunities.\n\nRegistration for the Gitpod Community Day is now open and more information can be found at https://gitpodcommunityday.org/","metadata":{"source":"https://gitpod.io/blog/a-day-with-gitpod"}}],["11",{"pageContent":"Today, we&#39;re excited to bring you instant developer environments for all Bitbucket projects.\n\nSimply type gitpod.io/# in front of any Bitbucket repository URL, and get a fully prebuilt and ready-to-code dev environment in seconds.\n\nyoutube: hIpFTGwsv-o\n\n__SPLIT_HERE__\nGetting started with Gitpod for Bitbucket\n\nStarting a fresh dev environment for a Bitbucket project works just as with GitLab and GitHub: Simply prefix your Bitbucket project URL with gitpod.io/#.\n\nFor example, you could try opening this Spring PetClinic (Java) repository in Gitpod:\n\nhttps://gitpod.io/#https://bitbucket.org/gitpod/spring-petclinic\n\nFor more convenience, you can also install Gitpod&#39;s browser extension (for Chrome and Firefox), which will add a Gitpod button to all Bitbucket projects or alternatively use our browser bookmarklet.\n\nGitpod also supports other types of Bitbucket URLs, like:\n\nOpening file URLs\n\n\nOpening branches\n\n\nOpening issues\n\n\nOpening pull requests\n\nDepending on the context, your dev environment will be initialized differently.\n\nFor instance, if you start a workspace from the issue context above, you‚Äôll get a fresh workspace with a new local branch based on the repository&#39;s default branch (e.g. master).\n\nThe new local branch will be named like &lt;username&gt;/&lt;issue-title&gt;-&lt;issue-nr&gt;, in my case it is:\nsvenefftinge/allow-skip-first-name-1 (if the issue title is too long, only the first few words will be included in the branch name).\n\nGitLab Issue Context\n\nConfigure your project\n\nTo get the most out of Gitpod, you should describe your project&#39;s dev environment with code. Dev environments are based on containers which you can configure through a custom Dockerfile.\n\nFurthermore you can specify which tasks should run after a fresh checkout in a .gitpod.yml file. Usually these tasks include build steps, downloading dependencies and running some unit tests. Read the section below on prebuilds to make Gitpod automatically run these steps ahead of time, as a CI pipeline whenever some changes are pushed to your project.\n\nThere is much more you can do to make sure every organization member gets a ready-to-code dev environment when they need one. Please refer to the docs for details.\n\nPrebuilds\n\nGitpod‚Äôs prebuilt workspaces are key to providing ephemeral, ready-to-code dev environments for your branches and projects. You can configure Gitpod to run your project&#39;s build asynchronously every time someone pushes new commits or branches to your repository. So when a developer wants to start coding, she can start immediately, because everything is already prepared.\n\nEnabling prebuilds on your Bitbucket project is done by configuring a Webhook. This can be done automatically: Just trigger the first prebuild on your project manually, and Gitpod will take it from there. To do that, use the prefix https://gitpod.io/#prebuild/, as in\n\nhttps://gitpod.io/#prebuild/https://bitbucket.org/&lt;myuser&gt;/&lt;myrepo&gt;\n\n__SPLIT_HERE__\nWe Need Your Feedback\n\nIf you have ideas how Gitpod can be improved for you, or if you notice a bug, please always feel free to let us know. We would also be glad to welcome you in our community. ‚ù§Ô∏è","metadata":{"source":"https://gitpod.io/blog/bitbucket"}}],["12",{"pageContent":"TL;DR\n\nApple M1 and M2 are not compatible with a lot of old and specialized software\nExisting workarounds like Rosetta or Docker Desktop aren‚Äôt optimized for all software written for x86-based hardware\nGitpod moves the workload to a Linux container in the cloud and creates a uniform developer experience for everyone on the team independent of their hardware\n\nApple‚Äôs introduction of M1 system-on-a-chip (SoC) processors in late 2020 marked a shift away from traditional x86 processors, and a step towards an ARM architecture across their devices. The key benefits of the M1 are high performance, energy efficiency, and importantly, the same CPU architecture type of their iPad and iPhone devices. Starting at a thousand dollars per machine, developers get computers with 3.5x improved CPU performance and 2x improved battery life over their old MacBooks running on Intel‚Äôs architecture.\n\nUnfortunately, the difference in CPU architectures can lead to unexpected bugs in libraries originally written for x86-64.\n\nThe M1 is based on ARM architecture, which is different from the x86 architecture used in most personal computers and servers. This means that the M1 is not natively compatible with all software that is available for x86 devices. Although Apple is working towards making a wider range of software available for M1 devices, developers frequently face compatibility issues.\n\nIn fact, the Apple M1 compatibility problem in container development even sparked the creation of a dedicated website: Is Apple Silicon ready?\n\n__SPLIT_HERE__\nExisting workarounds\n\nRosetta is a virtualization layer provided by Apple to translate the x86-64 instructions to ARM-compatible instructions. It makes applications require more resources and run more slowly. An alternative, Docker Desktop on Mac M1 is considered a ‚Äúbest-effort‚Äù solution that has to emulate Intel images for programs that don‚Äôt support ARM architecture. This can cause the program to break, run more slowly, and consume more resources.\n\nAs an example, existing containers written for the x86 CPU architecture can be built using QEMU and Docker buildx, allowing you to build containers for multiple platforms in a single command.\n\nThis comes with a speed tradeoff during build processes. Some organizations find the speed worth it, and others set up dedicated systems for build processes on native architecture.\n\nIf you use an ARM-based device like an M1 or M2 Mac, you can move the working load of your applications to run in an x86-based Linux container in the cloud with Gitpod.","metadata":{"source":"https://gitpod.io/blog/better-container-development-on-apple-m1-macbooks-with-gitpod"}}],["13",{"pageContent":"CDEs help with developing x86-64 software on Mac\n\nCloud development environments like Gitpod offer a robust solution to do container development for x86-64 software on Apple M1. Gitpod enables you to use any Linux-based software, CLIs, or developer tools to use in your daily routine with more power and without hardware limitations. The setup cost is minimal as new users can start from any Git repository at the click of a button. Additionally, using Gitpod eliminates the need to pay for a Docker Desktop license.\n\n‚ÄúCDEs are like perfectly configured, high-powered developer laptops that you can use and discard as easily as sticky notes. One perfect laptop for every project you work on, so you can say goodbye to dependency collision issues between unrelated projects.\n\nNever again stress over updating your operating system, only to spend the next three days figuring out why iconv won&#39;t link properly anymore or spend hours tracking down why that one header file can&#39;t be found. Less time on StackOverflow means more time creating awesome stuff.\n\nNeed to work on that project from five years ago? What do you think the probability is that your dev environment is still compatible? Exactly. CDEs make working on old stuff a breeze.‚Äù\n\n~ Tom Preston-Werner\n\nUsing a CDE like Gitpod for software development, the laptop layer is abstracted away and every engineer gets access to a standardized development environment. This is most relevant to engineering teams that use different types of computers. Regardless of whether your team runs Mac with Intel, Mac with ARM, Linux, or Windows machines, everyone will get a uniform developer experience. The CDE does not dictate the choice of the editor and other developer tools, however. Running Gitpod, engineers can continue to use their local VS Code or JetBrains IDE but their code runs in a CDE in the cloud.\n\nIf you encounter M1 and M2 compatibility issues in your engineering org, contact us to learn about our enterprise solutions. If you want to get a better idea of how a CDE works, spin up a Gitpod workspace from any git repository just now.\n\nGet started for free","metadata":{"source":"https://gitpod.io/blog/better-container-development-on-apple-m1-macbooks-with-gitpod"}}],["14",{"pageContent":"Are you tired of apt-get? Can&#39;t use sudo right now? ‚Ä¶\n\n__SPLIT_HERE__\nYou can now &#39;brew install anything&#39; in Gitpod! üéâ\n\n‚úì Easily install any Linux tool or package with one command\n‚úì Doesn&#39;t require sudo permission\n‚úì Works in your .gitpod.Dockerfile or directly in Gitpod&#39;s Terminal\n\nIf you use a Mac, or have friends who use a Mac, you&#39;ve probably heard of the trusty brew command which allows you to install pretty much any software, from git to clang to htop.\n\nHomebrew is quite convenient, and its packages are very well maintained: You&#39;ll usually get the latest stable version of any tool (e.g. Git 2.24.1) while other package managers can typically lag several versions behind (e.g. Ubuntu 18.04 only gives you Git 2.17.1 by default).\n\nWhat you may not necessarily know is that Homebrew now works on Linux too (it was originally announced as &quot;Linuxbrew&quot;, but now it&#39;s just called Homebrew on Linux). This got us pretty excited, because we saw it as an opportunity for developers to easily install any software package in Gitpod, without needing to set up a Dockerfile and then fire up another workspace to test it. With Homebrew you can simply run brew install z and get going!\n\nWe&#39;ve pre-installed brew for all Gitpod workspaces (using workspace-full) and now that we&#39;ve played with it for a while and are happy with the experience, we&#39;re excited to announce it so that you can try it too:\n\nJust open any repository in Gitpod (e.g. the Spring PetClinic)\nTry running brew install fzf (this should give you the awesome fzf tool)\n\nHomebrew in Gitpod screenshot\n\nHere are a couple details to be aware of:\n\nPackages installed with brew have a low priority in the $PATH. This means that if you brew install a package that already exists in Gitpod, you&#39;ll just continue using the old package. If you don&#39;t like that, simply apt-get remove the old package in your .gitpod.Dockerfile.\n\n\nbrew installs everything under /home/linuxbrew/, but Gitpod only backs up your Docker image plus everything inside /workspace/. This means that if you brew install fzf in a Gitpod terminal, and then your workspace stops running, when you restart it later the package fzf will be gone. If that&#39;s a problem, simply move the brew install fzf command into your .gitpod.Dockerfile to make it permanent.\n\nWe hope this feature makes you as happy as it made us! Please share any feedback, thoughts or bugs you found.","metadata":{"source":"https://gitpod.io/blog/brew"}}],["15",{"pageContent":"This post is all about how to build your webhook for your Google Assistant action and host it temporarily on Gitpod and test your code.\n\n__SPLIT_HERE__\nPrerequisites\n\nNode JS\nExpress JS\nBasics on how to use GitHub\n\nIf you have these in place, Let&#39;s get started.\n\n__SPLIT_HERE__\nWhat is Gitpod?\n\nFirst of all I would like to start this section by saying, I ‚ù§ Gitpod. Gitpod is an online IDE for GitHub. Gitpod provides you with a fully working developer environment, including a VS Code-powered IDE and a cloud-based Linux container configured specifically for the project at hand. Just prefix your GitHub repo URL with &quot;https://gitpod.io/#&quot;, So that the final link looks something like this &quot;https://gitpod.io/#https://github.com//&quot; or you can also use the Gitpod browser extension to add the Gitpod button to GitHub page.","metadata":{"source":"https://gitpod.io/blog/build-a-webhook-for-google-assistant"}}],["16",{"pageContent":"Let&#39;s start building\n\nI have created a GitHub repo which will help you get started without any hassle. The repo is basically a boilerplate to get started with building your webhook. The code is written in Node JS, So it would be easier for you to build on top of it if you are already familiar with Node JS. We will be using the action-on-google Node JS library (This client library makes it easy to create Actions for the Google Assistant and supports Dialogflow, Actions SDK, and Smart Home fulfillment.).\n\nCreate your Action\n\nHead over to https://console.actions.google.com/ and click on New Project.\n\nGoogle Actions Console\n\nEnter your project name and click on create project.\n\nGoogle Actions Create New Project Prompt\n\nNow select a category for your Action.\nNow under the Develop menu, give your action a name.\nNow head over to actions menu in Develop tab and click on Add your first action.\n\n&#39;Add your first action&#39; button","metadata":{"source":"https://gitpod.io/blog/build-a-webhook-for-google-assistant"}}],["17",{"pageContent":"&#39;Add your first action&#39; button\n\nIn the next section choose custom intent and click on build. Doing this will redirect you to the Dialogflow console and it should look something like this.\n\nDialogflow console\n\nClick on create to create your agent on Dialogflow.\nOnce your agent is ready, you will already have two default Intents (Default Fallback Intent and Default Welcome Intent) in place and these two do pretty good at their job.\nNow it&#39;s time to create a new intent and enable fulfillments for that intent so that we can serve responses from the webhook that we will be building in the next section.\nClick on create a new intent, give it a name and training phrase (training phrase will be used to invoke the intent). Now that your intent is almost ready scroll down and under fulfillments enable webhook call for the new Default welcome intent and the new intent you just created.\n\nUnderstanding .gitpod.yml","metadata":{"source":"https://gitpod.io/blog/build-a-webhook-for-google-assistant"}}],["18",{"pageContent":"Understanding .gitpod.yml\n\nThe .gitpod.yml file is used to automate setting up the environment required to run your app.\n\n.gitpod.yml environment setup for running your app\n\nIf you want to access services running in your workspace, e.g. a development HTTP server on port 8080, you need to expose that port first. Gitpod has two means of doing that:\n\nOn-the-fly: when you start a process which listens on a port in your workspace, Gitpod will ask you if you want to expose that port to the internet.\nIn your configuration: if you already know that you want a particular port exposed, you can configure it in the .gitpod.yml file and skip the extra click later on. For example:\n\n```yaml\nports:\n  - port: 3000\n```\n\nWhen starting or restarting a workspace you typically want to run certain tasks. Most probably that includes the build and maybe also running tests and automatically start the application in e.g. a dev server.\n\nGitpod allows you to configure start tasks in the .gitpod.yml file.","metadata":{"source":"https://gitpod.io/blog/build-a-webhook-for-google-assistant"}}],["19",{"pageContent":"Gitpod allows you to configure start tasks in the .gitpod.yml file.\n\nFor instance, the start script for this repository is defined as:\n\n```yaml\ntasks:\n  - init: npm install\n    command: npm start\n```\n\nYou can have multiple tasks, which are opened on separated terminals.\n\n```yaml\ntasks:\n  - init: npm install\n    command: npm start\n  - command: echo -e \"\\n\\nwebhook url - $(gp url 3000)/webhook \\n\\nCopy and paste this url in the Dialogflow console\"\n```\n\ninit command\n\nThe init property can be used to specify shell commands that should only be executed after a workspace was freshly cloned and needs to be initialized somehow. Such tasks are usually builds or downloading dependencies. Anything you only want to do once but not when you restart a workspace or start a snapshot.\n\nIn our case the init command is\n\n```yaml\ntasks:\n  - init: npm install\n```\n\nGet the Gitpod setup running","metadata":{"source":"https://gitpod.io/blog/build-a-webhook-for-google-assistant"}}],["20",{"pageContent":"In our case the init command is\n\n```yaml\ntasks:\n  - init: npm install\n```\n\nGet the Gitpod setup running\n\nFork my repo (dialogflow-webhook-boilerplate-nodejs) or just click on the run in gitpod button in my repo. (If you do this you have to fork it from the workspace so that you can commit your own changes to your repo).\nNow you can just prefix your repo url with &quot;https://gitpod.io/#&quot;. This should take you to Gitpod and start your workspace. The workspace take a little while to start.\nOnce the workspace is running you should see something like this.\n\nGitpod Workspace\n\nIf you notice the Node app is already running in the first terminal. This is automated by a Gitpod configuration file. And the webhook URL is printed on to the second terminal. All the dependencies that are required are also installed while creating the workspace.\n\nGitpod integrated Linux Terminals","metadata":{"source":"https://gitpod.io/blog/build-a-webhook-for-google-assistant"}}],["21",{"pageContent":"Gitpod integrated Linux Terminals\n\nNow that the webhook is running and i presume that you already have your agent on Dialogflow (If not create an agent), Next thing you need to do is to copy the webhook URL from the terminal and paste it in the Fulfillments section in the Dialogflow Console.\n\nDialogflow console Fullfillments section\n\nOpen the index.js file which contains the code for the webhook.\n\nFile index.js which contains the source code for the webhook\n\nThe file initially contains this code. Now lets add some more code to it to display a card when we invoke the new intent we created in the previous section.\nactions-on-google library provides many functionalities to can simplify your task to render rich responses in your action.\n\nWe will be adding the following code to display a card when the new intent is invoked.\n\nCode to display a card when the new intent is invoked","metadata":{"source":"https://gitpod.io/blog/build-a-webhook-for-google-assistant"}}],["22",{"pageContent":"We will be adding the following code to display a card when the new intent is invoked.\n\nCode to display a card when the new intent is invoked\n\nReplace the URL&#39;s and other contents in the code and stop the previous instance of the app from running and start it again after you have made changes to the code by running npm start in the terminal.\n\nTo test your action you can click on See how it works in Google Assistant in the Dialogflow console.\n\nSee how it works in Google Assistant\n\nInvoking the intent would give you response similar to this.\n\nResponse on invoking the intent\n\nRefer to the links below to add your own functionalities.","metadata":{"source":"https://gitpod.io/blog/build-a-webhook-for-google-assistant"}}],["23",{"pageContent":"Links to Refer\n\nIf you would like to learn more about the actions-on-google library, you can find it here - https://www.npmjs.com/package/actions-on-google\nGo through these examples - https://developers.google.com/assistant/conversational/df-asdk/samples/github\nRich responses example - https://github.com/actions-on-google/dialogflow-conversation-components-nodejs\n\n__SPLIT_HERE__\nConclusion\n\nGitpod can make your life much simpler by automating your development setup just by adding a simple configuration file to your repo. You can refer to the Gitpod Docs to learn more about the platform. Gitpod lets you work with unlimited workspace but with 100hrs/month runtime. It also provides Personal and unlimited plans as well.\n\nAnimated character waving hand with a smile","metadata":{"source":"https://gitpod.io/blog/build-a-webhook-for-google-assistant"}}],["24",{"pageContent":"Welcome to DevX Digest - the place to hear all about Developer Experience, brought to you by Pauline Narvas (@paulienuh) and Mike Nikles (@mikenikles) from Gitpod. You&#39;re reading another newsletter from us üéâ! In this edition, we talk about developer experience in cloud-based,ephemeral dev environments.\n\nThis edition is particularly exciting as we‚Äôve launched DevX Pod which is a podcast ALL ABOUT developer experience. Inspired by the conversations from DevX Conf that we hosted earlier this year and the growing interest in DevX space recently... we were both like, üí° ‚ÄúPeople seem interested in this and there isn‚Äôt a lot of information out there on it yet. Let‚Äôs contribute to the space and do this!‚Äù üí°","metadata":{"source":"https://gitpod.io/blog/building-devx-teams"}}],["25",{"pageContent":"How do you build a DevX Team? üõ†\n\nOur first episode features Cirpo, Head of Developer Experience at DAZN Engineering and Lou, Product Manager at Gitpod. In a previous life, Lou worked with Cirpo as one of the founding figures in DevX at DAZN, they even wrote a blog post all about their values, focus, team structure, learnings and more.\n\nDevX Podcast Episode 1\nDevX Pod is available wherever you get your podcasts!\n\nUnlike more ‚Äúexternal-facing‚Äù DevX content that is seen more often in the wild, this episode focused more on ‚Äúinternal-facing‚Äù DevX i.e. from the POV of an internal team (also known sometimes as platform/tooling/infrastructure teams) where improving developer experience was the full-time responsibility.\n\nThere were so many gems in the episode, we encourage you to listen to it! However, if you prefer you can also read the full transcript here.\n\nOur key take-home messages were:\n\nDeveloper Experience is still a very new space, but clearly a very hot topic!","metadata":{"source":"https://gitpod.io/blog/building-devx-teams"}}],["26",{"pageContent":"Our key take-home messages were:\n\nDeveloper Experience is still a very new space, but clearly a very hot topic!\n\n\nWhen we talk about developer experience, it falls into two areas: internal DevX (sometimes companies have a dedicated team to improving internal developer experience) or applying user experience to a developer product (e.g. Netlify)\n\n\nHow do we measure the success of DevX? How can we get buy-in from leadership to invest in DevX? There are no specific frameworks that can give you consistent data when it comes to tracking developer experience. This can make getting buy-in from stakeholders difficult, however, Cirpo shared that he thinks his main success in DAZN‚Äôs DevX team was the fact that they started small, showing the impact by the result of fewer complaints on using internal tooling (and the number of happy faces!) which led to gaining more trust and investment from leadership.","metadata":{"source":"https://gitpod.io/blog/building-devx-teams"}}],["27",{"pageContent":"Although in the developer experience space there is a burning lens on tooling, it doesn‚Äôt end there. We discuss how it‚Äôs also all about people, all about community and that empathy is important more than ever in DevX!\n\n\n‚ÄúTools got us into this, will tools get us out?‚Äù A great question by Lou. Technology is complicated nowadays. With the vast amount of tools we have at our disposal, it can be overwhelming trying to piece them all together so that they work seamlessly in our ecosystem. That glue itself is developer experience. How can we productively use all these tools?\n\n\nThe DevX that made Cirpo mind explode was the first time he customised his terminal to be colourful. The reason this was mind blowing was because ‚Äúback in the day‚Äù, it was black and white. Now with the infinite customisation opportunities, developers can really feel like their toolkit works for them.","metadata":{"source":"https://gitpod.io/blog/building-devx-teams"}}],["28",{"pageContent":"Lou shared an integration that was built at DAZN. Something that he has wanted in every single tool since and that is an integrated error map. This error map helps devs understand what is going on when they hit an issue so they can unblock themselves quicker and stay in flow. This is exactly what developer experience is all about!\n\n\nEven if you don‚Äôt have the time to integrate some StackOverFlow like solution into your product, Cirpo reminds us that sometimes the most simple actions can have a big impact on DevX. For instance, writing meaningful error suggestions could make someone‚Äôs experience trying to debug issues 100x better.\n\n\nThe final parts of our fun conversation, we all shared our hopes and dreams of DevX. Cirpo‚Äôs answer was one that we needed to highlight. He hopes that in the future, we all move towards a more 360 degrees approach in DevX. Not just this obsession with tools, but equally with people and community.","metadata":{"source":"https://gitpod.io/blog/building-devx-teams"}}],["29",{"pageContent":"It was also mentioned that having more content like this to help educate and bring more folks into the DevX world is so needed. Sharing is caring: we can collectively improve developer‚Äôs daily experience by just sharing our learnings with each other.\n\nDevX Digest is community-driven ü§ù\n\nThere‚Äôs clearly folks excited about DevX, so let‚Äôs continue talking ‚ö°Ô∏è In fact, Lou‚Äôs recent Twitter Thread is a great reinforcement of why we are doing this.\n\nAs a result, we‚Äôve recently improved the dedicated area in our Discord server to build up on the developer experience community. If you‚Äôre interested in developer experience either from a team-building perspective or from the tooling side of things, come and join us!\n\nDevX Podcast Episode 1\n\nThat‚Äôs it for now, thanks folks! See you over on our Discord. üëãüèº","metadata":{"source":"https://gitpod.io/blog/building-devx-teams"}}],["30",{"pageContent":"CEO Johannes Landgraf sent the following note earlier today to all Gitpod employees.\n\nToday I have some tough news to share. I decided to reduce the size of the Gitpod team by 28%, saying goodbye to 21 Gitpodders. This is the most difficult decision I‚Äôve made to-date and it impacts the lives and families of colleagues and friends we care about. It hurts, and I apologize for hiring too aggressively for the macroeconomic environment we are in today.\n\nWe want to treat Gitpodders leaving with respect and make the process as caring as possible. I want to openly share the reasons that led to the decision:\n\nDuring the market upswing of 2021 and early 2022, we built up the organization counting on a continued period of low interest rates and cheap capital. We increased operating costs too quickly and over-hired for the market environment we face today.\nWith the strategic decision on Nov-22 to replace our self hosted product with an enterprise cloud offering, we turned away from immediate cash flow and have optimized for development velocity and eventually faster growth rates. This left us with a larger team than we needed for the phase we are now in.\n\nAt that point I had all the data to make today‚Äôs call. Instead, the Nov-22 announcement of our $25m Series A tripling our company valuation lulled me into a false sense of security. I avoided fully embracing the new market reality we find ourselves in. I apologize for this and corrected that mistake today.\n\nOur world has now flipped. I agree with Howard Marks when he writes about a macroeconomic sea change. Inflation and rising interest rates have led to cash becoming expensive and efficiency paramount. Gitpod now operates under the premise that this will not change within the next 3 years. We will use the fresh capital we raised to scale from a venture-backed company to one that is capital-efficient, with profitability and independence within reach. A company focused on sustainable growth that serves our customers for the long run.\n\nHowever difficult, I am convinced this is the right decision.\n\n__SPLIT_HERE__\nTo those leaving\n\nWe are deeply grateful for your lasting impact on our culture, product and company. We want you to have confidence in your superpowers ‚Äì knowing that you will bring them to your next job.\n\nHere are some ways we want to support you:\n\nSeverance. We are paying 5 weeks‚Äô salary for anyone under 2 years and at least 10 weeks of salary for anyone over 2 years (this may vary by tenure-related local regulations).\nEquity. We are shortening the vesting period by three months for everyone, and if you‚Äôve had more than 2 years of tenure, we are shortening it by 6. We are also increasing the exercise window of all grants from 90 days to 10 years.\nEquipment. You can keep all Gitpod-owned home office equipment including your laptop.\nStipend. Everyone will still have access to a $500 stipend to use in line with our existing education, physical and mental health benefits. You know what‚Äôs best for you.\nCareer support. You can opt-in to our talent and recruiting partners offer for resume and LinkedIn profile review, interview training and introductions to available job opportunities.\n\nThis transition is not easy and my hope is that you remember just how valuable you are and find a place where you can thrive. And if you put the dedication that you put into Gitpod into yourself, I am certain you will.","metadata":{"source":"https://gitpod.io/blog/building-for-the-long-run"}}],["31",{"pageContent":"To those staying\n\nAny layoff necessitates space and time to process. This week all of us - including leadership and myself - are free to dedicate our time and energy to supporting our leaving teammates. Not from obligation or guilt, but from a place of gratitude and care.\n\nFor Gitpodders who want to be supported below are some ways you may choose to do:\n\nReach out and ask how you can be there for them - it might be different from what you assume\nOffer access to your own networks and share a public message listing former Gitpodders you want to personally recommend on LinkedIn (make sure they opt-in)\nWrite a recommendation on individual LinkedIn profiles\nOffer time for reference calls throughout their job search\nWrite one or two sentences about what you are grateful for about the other person. We will collate and share with those leaving\n\nNext week we‚Äôll recalibrate, connect, and then move forward with a clear mind. We have ambitious goals and there is a lot to do in 2023. This week, however, is not the right time to talk about that. Let‚Äôs live up to our core values and show gratitude to our leaving friends and colleagues with whom we loved working.","metadata":{"source":"https://gitpod.io/blog/building-for-the-long-run"}}],["32",{"pageContent":"This is a story about a cake. Following a long standing tradition in technology we decided to send an edible Gitpod workspace to GitHub&#39;s San Francisco office last week. No trojan horse - just a tasty üéÅ üéÇ sending them kudos for their GitHub Codespaces release.\n\nCredit: Rui Kowase\nPhoto Credit: Rui Kowase\n\nI don&#39;t know if you have ever tried ordering a cake over the internet but let me tell you it&#39;s not the easiest thing in the world, especially when:\n\n‚ò†Ô∏è We are in the middle of a pandemic.\nüéÇ You don&#39;t know anything about cakes - at all.\nüò± Time-zones - Sunny Toowoomba in Queensland, Australia, is on the other side of the world to San Francisco.\n\nCredit: Geoffrey Huntley\nPhoto Credit: Geoffrey Huntley","metadata":{"source":"https://gitpod.io/blog/cake"}}],["33",{"pageContent":"Credit: Geoffrey Huntley\nPhoto Credit: Geoffrey Huntley\n\nAfter checking with an insider at GitHub, we got confirmation that people in the San Francisco office had started to return to the office, that food is being served in their cafeteria and that they would serve our cake. With that knowledge under our belt, at the crack of sparrows, skype was downloaded, and I was off to the races cold calling bakers in San Francisco. Gitpod needed a baker that we should trust with our brand and one that would act autonomously because timezones would make further communication impossible.\n\n&quot;Bakers in San Francisco&quot; was punched into Google Maps, and top-to-bottom, I called every single one. The responses were somewhat mixed:","metadata":{"source":"https://gitpod.io/blog/cake"}}],["34",{"pageContent":"&quot;Bakers in San Francisco&quot; was punched into Google Maps, and top-to-bottom, I called every single one. The responses were somewhat mixed:\n\nü¶ò Wait, you are actually Australian and are calling from a McDonalds in Australia at 5am?\nüñ® We can print (üò±) your logo on a cake, but that&#39;s it.\nüíæ Please go to our website, we don&#39;t want to speak with you.\nü§∑‚Äç‚ôÄÔ∏è We aren&#39;t making custom cakes because we can&#39;t find any staff.\nü§´ I didn&#39;t tell you this, but our competitor might be able to help you out.\n\nThat last tip-off was the tasty butter...\n\nCredit: Camisha&#39;s Cakes\nCredit: Camisha&#39;s Cakes\nPhoto Credit: Camisha&#39;s Cakes\n\nThe brief\n\nThe baker of our cake was none other than Camisha Green of Camisha&#39;s Cakes. A professional, independent small business baker who is seriously talented...\n\nüåê https://camishascakes.com\nüì∏ https://www.instagram.com/camishascakes/\n\nCredit: Camisha&#39;s Cakes","metadata":{"source":"https://gitpod.io/blog/cake"}}],["35",{"pageContent":"üåê https://camishascakes.com\nüì∏ https://www.instagram.com/camishascakes/\n\nCredit: Camisha&#39;s Cakes\n\nUnfortunately, due to timezones, I was unable to contact camishascakes.com by phone, so an email was dispatched:\n\nüëã I&#39;m Geoff, from Gitpod, and this email is coming to you from Australia. A competitor of ours in San Francisco launched their product a couple hours ago, and Gitpod would love to send a Gitpod cake to their office in celebration. In the software industry, there is a long standing tradition between competitors sending each other cakes.\n\nWe would like to know your availability and hear your thoughts about commissioning a cake that uses the Gitpod branding to serve 60-80 people by next Friday.\n\nOur style guide can be found at https://www.gitpod.io/assets/style-guide.pdf and the Kumquat fruit is a signature part of the Gitpod brand.\n\nCan you please confirm production availability and share your thoughts about cake designs?","metadata":{"source":"https://gitpod.io/blog/cake"}}],["36",{"pageContent":"Can you please confirm production availability and share your thoughts about cake designs?\n\nWe are thinking something like this would be mint but instead of the Firefox logo use our brand. The top text would be CONGRATULATIONS ON SHIPPING CODESPACES and the bottom text would be LOVE GITPOD.\n\nCasmisha promptly replied with:\n\nThank you for your email and what a fun idea! I&#39;d be happy to give you a quote for this cake :) A half sheet cake, 3 layers high will serve about 60 guests And yes, we can take video and photos of the making as well! Here&#39;s the link to my cake menu, let me know if you have any questions or if you&#39;d like me to start an order for you\n\nand I promptly replied with:\n\nI&#39;ve been scrolling through your facebook page and would love üß° to work with you. Yes, around 60 people would suffice. What if we increased the price of the cake and we made the cake really pop? What that means - I&#39;ll leave that up to you.","metadata":{"source":"https://gitpod.io/blog/cake"}}],["37",{"pageContent":"Our style guide is at https://www.gitpod.io/assets/style-guide.pdf\n\nHave a look at our website at https://www.gitpod.io/ and you&#39;ll notice:\n\nthe background colour is white\nwe accentuate primary using orange\nthere are other colours that can be optionally used\n\nThe place where the cake is being sent to has a mascot called the Octocat - go check out Mona at https://octodex.github.com/\n\nExpectations\n\nAs a person who knows nothing about cakes, here&#39;s what I had in mind and shared with Camisha...\n\nCredit: Softpedia\nPhoto Credit: Softpedia\n\nTruth be told, I was ü§¨ &#39;ing myself. To trust someone in a completely different country that you haven&#39;t met before is a huge, huge leap of faith. Meanwhile, over in the company slack, a vote was cast:\n\nCredit: Gitpod","metadata":{"source":"https://gitpod.io/blog/cake"}}],["38",{"pageContent":"Credit: Gitpod\n\nWhilst Gitpod is a fully distributed company, that hires people from anywhere in the world our origins are from Kiel, Germany thus a lot of our employees are German. After an unfair vote, German Chocolate was declared the winner, but it wasn&#39;t without some office debate as to what German Chocolate tastes like:\n\nüßî &quot;German Chocolate&quot;? I only know of Swiss Chocolate.\nüë©üèº There are &quot;German Chocolate&quot; and &quot;True Chocolate&quot;. It seems that they are implying something‚Ä¶\nüëßüèº We have a lot of cows up here. So they need to dump all the milk somewhere.\n\nConcept\n\nCamisha, a couple days later, came back with:\n\nOk here&#39;s a rough looking idea I came up with. We create a desk scene with an edible mug, cube, monitor, keyboard, octocat, mouse, and kumquat all sitting on the desk that is the cake. On the front of the cake we write the congratulatory message. What do you think?\n\nand attached to the email was this image:","metadata":{"source":"https://gitpod.io/blog/cake"}}],["39",{"pageContent":"and attached to the email was this image:\n\nCredit: Camisha&#39;s Cakes\nPhoto Credit: Camisha&#39;s Cakes\n\nI started ü§¨ &#39;ing myself. Had I chosen the wrong baker? I am IN OVER MY HEAD HERE as I absolutely could not imagine what the end result would look like from this concept. We jumped on a quick video call (which was the first time we had spoken with each other), and it became super clear that Gitpod had indeed found a baker we could trust with our brand.\n\nReality\n\nyoutube: urICsOsNd94\nyoutube: zyR5MFojBXY\nyoutube: dsKKJGaeL50\nyoutube: ym_zuviJ25c\n\nDelivery\n\nCamisha, being the legend that she is, included 2 dozen gluten-free vegan cupcakes in the delivery just in case some wouldn&#39;t be able to have the actual cake.\n\nCredit: Camisha&#39;s Cakes\nPhoto Credit: Camisha&#39;s Cakes\n\nHere is the cake in all its glory. The edible Gitpod workspace was sent to the GitHub office - we know it arrived and made an extremely positive impression, but unfortunately never got feedback on how it tasted.","metadata":{"source":"https://gitpod.io/blog/cake"}}],["40",{"pageContent":"Dear GitHub please let us know as our office remains heavily divided over what does German chocolate taste like? üá©üá™üç´\n\nThanks for reading! Did you know our free tier is open to every developer with a GitLab, GitHub, and/or Bitbucket account? You will have access to both public and private repositories for 50 hours per month for free.\n\nGo ahead and experience the peace of mind and productivity boost on your own.\n\nLearn how to use Gitpod in less than 5 minutes!\n\nCredit: Camisha&#39;s Cakes\nPhoto Credit: Camisha&#39;s Cakes","metadata":{"source":"https://gitpod.io/blog/cake"}}],["41",{"pageContent":"TL;DR\n\nWelcome to the party, GitHub Codespaces!\nGitpod is now free for public and private repositories!\n\nAt Gitpod, we believe that\n\nBy 2023 working with ephemeral cloud-based dev environments will be the standard. Just like CI/CD is today.\n\nThis week, we got a step closer to our product vision becoming a reality. We welcome Microsoft and GitHub Codespaces to join forces in improving the developer experience status quo with ephemeral, cloud-based developer environments. The obligatory cake is on its way to our friends at GitHub and VS Code! üéÇ\n\n__SPLIT_HERE__\nSoftware development moves to the cloud\n\nToday&#39;s modern engineering teams use automation everywhere. They automate infrastructure, CI/CD build pipelines, linting, formatting and even writing code, and numerous other places where automation is used to help teams avoid costly errors and focus on product and customer value.\n\nDeveloper environments, however, have not experienced this same adoption rate. They are brittle, an intimidating hurdle during onboarding and a constant source of friction during development.\n\nThe question is not if but when ephemeral, container-based dev environments are becoming the norm. Based on conversations with users there are a couple of recurring reasons accelerating this:\n\nMulti-track development (develop and review complicated features with ease)\nLocal machine limits (larger workloads, more data, more dependencies, more testing)\nSecurity (no source code on laptops policies)\nConsistency (end of all ‚Äúworks on my machine‚Äù problems)\nOnboarding (shave off a few initial days of tedious workspace setups)\nRemote work (fully distributed or hybrid companies)\n\nGoogle, Facebook and a few others have internally built solutions for these issues for a few years already. Gitpod and GitHub Codespaces bring container-based development in the cloud to the rest of the world.\n\nEphemeral Developer Environments\n\nPutting developer experience first means working in developer environments that are fast, secure and most importantly ephemeral. Just moving your manually created and maintained dev environment to the cloud wouldn‚Äôt quite cut it. To get rid of configuration drift and ‚Äúworks on my machine‚Äù issues, we need to continuously create fresh dev environments based on configuration as code. Only then you are always ready-to-code‚Ñ¢.\n\nFor your day-to-day workflow this means that your developer environments become:\n\nTask-based - for each Git context you start them, you code, you push your code, and you forget about them. For your next task, you‚Äôll use a fresh one.\nPrebuilt - Gitpod continuously builds all your Git branches like a CI server. Whenever your code changes (i.e. when new commits are pushed to your repository), Gitpod will prebuild workspaces, i.e. run the init commands in your .gitpod.yml configuration file before you even start a workspace.\nShareable - similar to preview environments in CI/CD dev environments ephemeral dev environments become easily shareable with your colleagues via a URL.\n\nIn the screencast below, @paulienuh explains how that workflow has supercharged our development velocity while developing Gitpod in Gitpod.\n\nyoutube: n7Ca3jHFtZg\n\nThe peace of mind, productivity boost and collaboration benefits you are experiencing once you adopt that task-based workflow make you never want to go back.\n\n__SPLIT_HERE__\nGitpod dev environments are available to everyone ‚Äî today\n\nStarting today our free tier is open to every developer with a GitLab, GitHub, and/or Bitbucket account. You will have access to both public and private repositories for 50 hours per month for free.\n\nGo ahead and experience the peace of mind and productivity boost on your own.\n\nLearn how to use Gitpod in less than 5 minutes!","metadata":{"source":"https://gitpod.io/blog/cloud-based-development-for-everyone"}}],["42",{"pageContent":"I am Anton and I am leading IDE development at Gitpod. Almost a decade ago, I joined Sven Efftinge and the team to work on open-source developer tools and help companies around the world to adopt them. We learned the intricacies of different desktop IDEs (Eclipse, IntelliJ, VS Code) and web editors (Monaco, Ace, Orion, and CodeMirror) - and eventually ended up building Gitpod.\n\nA big part of my journey was shaped by the editing experience of cloud-based developer environments and today I want to share our decisions, underlying thought process, connection to VS Code and where we go from here - both as an industry and as a company.\n\nWhen we improved developer tooling for a San Francisco based client five years ago, we realized that the technology is now finally there to bring to the mainstream what Google, Facebook and several others already started years ago: moving software development to the cloud by providing fully automated and ephemeral developer environments.\n\nThis recap is solely about the editing experience. This is important to stress because a big misconception in our ecosystem is that those remote, cloud-based developer environments are web or online IDEs. While IDEs are an important building block, platforms such as Gitpod are so much more.\nThink orchestration, provisioning, operating system, databases, compilers and all other tools you require to be productive.\n\nStackoverflow Survey 2021\n\n__SPLIT_HERE__\nThe promise of VS Code\n\nTo convince developers to say goodbye to local development, it is important to not reinvent the wheel but offer an editing experience that:\n\nIs backed by a thriving community\nWins hearts and minds of developers\nWorks on modern web technology\n\nThis is VS Code. The team around Erich Gamma struck the right balance between an editor and a full-blown IDE building a lean but powerful product that today is the world&#39;s most popular editing experience and will continue to rise in popularity. **I want to take this as an opportunity to thank the whole VS Code team for their hard work - me personally and also everybody at Gitpod is very grateful for what you are doing for the developer community. When we started working on the idea around Gitpod there was however a problem.\n\n&amp;nbsp\n\nTheia Logo\n\n__SPLIT_HERE__\nWhy Theia?\n\nBack in late 2017 VS Code could not run in a browser and was not (yet) refactored to support remote development. Because we wanted to offer a VS Code-like developer experience in Gitpod, we started the open-source project Theia under the roof of the Eclipse Foundation. The idea was to use VS Code technology (i.e. Monaco editor, LSP, DAP protocols, Xterm.js) to implement a vendor-neutral, remote-first IDE framework accessible from both browser and desktop. The framework was widely adopted by companies such as Gitpod, Google, Ericsson, SAP, RedHat, ARM, Arduino, and several others. While we at Gitpod moved to VS Code in late 2020 (more on that below), today Theia powers online IDEs such as Eclipse Che, Stackblitz, Google Cloud Shell Editor, Acquia Cloud IDE and several others.\n\n&amp;nbsp\n\nOpenVSX","metadata":{"source":"https://gitpod.io/blog/cloud-ide-history"}}],["43",{"pageContent":"Why OpenVSX marketplace?\n\nFrom the start the number one feature request for Theia was to support VS Code extensions out of the box. Building that required a steep learning curve as you need to understand the semantics behind all VS Code extensions APIs and port them to Theia. By early 2020, Theia was compatible with the most important APIs. It could securely run web views, apply themes, languages, and so on. There was one problem left: components that make VS Code as an application complete compared to the open source repository Code - OSS are proprietary, including access to Microsoft services such as the VS Code extension marketplace. To fill that gap we built and released the Open VSX marketplace as an open-source alternative, which we also donated to Eclipse. Today OpenVSX has almost extension parity for the most popular VS Code extensions and is used by Gitpod, OpenVSCode Server, code-server, Eclipse Che and can be Self-Hosted on your own infrastructure.\n\n&amp;nbsp\n\nVS Code\n\n__SPLIT_HERE__\nVS Code refactoring for remote development\n\nBy 2020 the brilliant team behind VS Code added remote support and the web workbench ultimately powering github.dev was already open-sourced. However, they decided to not open-source the server implementing the remote protocol. In summer 2020, while porting a new VS Code file system API in Theia, I began to understand how the internal remote protocols are working and decided to build a quick prototype for a server implementation of stock VS Code. After 4 days of focused work we had a first working version at the beginning of September. There were still many missing pieces (auto-sync settings, port forwarding etc.), but it became clear that we can run stock VS Code in Gitpod.\n\n&amp;nbsp\n\nGitpod\n\n__SPLIT_HERE__\nGitpod switches to VS Code\n\nGitpod is an open-source orchestration and provisioning platform for developer environments. The goal was always to open Gitpod to all IDEs as soon as they support remote development (we are very excited about the work of our friends at Jetbrains!). We built Theia because we initially had to. The architecture of VS Code just wasn&#39;t there when we started back in 2017. Theia is the closest we could get, to offer a VS Code-like experience in Gitpod. With the prototype we showed that we could drop &quot;like&#39;&#39; and run actual VS Code in Gitpod.\n\nI admit that it was a hard decision to stop supporting Theia after almost 4 years, but the maintenance and catch-up effort required to support the ever growing and changing API surface became increasingly a burden. And more importantly: Theia did not allow us to provide the best developer experience we could.\n\nWe spent the next months polishing the server implementation and added missing pieces such as the setting sync server and port tunneling via the local companion app. In December 2020 we started giving users the choice between Theia and VS Code and officially switched to VS Code as the default editing experience in Gitpod in early 2021.\n\nSince then a lot of individual developers as well as larger companies building internal developer platforms reached out and asked how we run the latest VS Code in a browser. As everything happened in public repositories it was no secret and we happily shared pointers to the GitHub URLs. But our server implementation still was bound to Gitpod services. For example, we had a custom remote terminal implementation while MS open-sourced its pty service. After the requests became more and more frequent we decided to separate concerns and provide a clean-cut between the server and parts which we add to integrate with Gitpod. OpenVSCode Server was born.","metadata":{"source":"https://gitpod.io/blog/cloud-ide-history"}}],["44",{"pageContent":"OpenVSCode Server\n\nHonestly, we never expected to receive such a positive response and were impressed with the feedback even before our launch announcement. Within several days we were joined by large companies such as GitLab, VMware, Uber, SAP, Sourcegraph, RStudio and SUSE. We went from 62 to more than 1.6k stars in a week and are working now with a vibrant community to further improve the project.\n\nOpenVSCodeServer\n\nAs a positive side effect, we streamlined the server implementation and dropped some unnecessary complexity. By imposing constraints such as never changing Microsoft code, we enabled a straightforward, fully automated upgrade path. We run a nightly sync job which brings all upstream changes to our fork. After that, we run smoke and integration tests from Code - OSS with some additional tests for Open VSX. This enables us to release OpenVSCode Server the same day when Microsoft releases its version of VS Code.\n\nI hope this gives some context on the origin and scope of OpenVSCode Server. Right now we see a lot of feature requests such as adding settings sync, GitHub auth, tunneling, secure access. As the project‚Äôs scope is to keep the changes to upstream VS Code as minimal as possible we will not bloat the server, but (similar to upstream VS Code) use their extension model and external services to add missing functionality. Examples of that would be syncing VS Code settings via a VS Code extension connecting to the Gitpod server or providing guides explaining how to put the server behind SSH or a reverse proxy.\n\n__SPLIT_HERE__\nRoad ahead\n\nAs VS Code and cloud-based, remote development continue to grow in popularity, we hope to see the server-side implementation powering GitHub Codespaces being open-sourced in the upstream repository by Microsoft. Outside of VS Code, Jetbrains will give our whole ecosystem a big boost with their remote development support.\n\nThis means that more than 80% of the IDE market will have built-in functionality to connect to developer environments running in the cloud, while keeping the editing experience you are used to from your Desktop application. With Gitpod you can provision, automate and orchestrate those workloads for yourself and your team with the least friction possible. After four years it feels we are at a tipping point and I am excited about what comes next.","metadata":{"source":"https://gitpod.io/blog/cloud-ide-history"}}],["45",{"pageContent":"DevOps has been all the rage for the last couple of years. Today, something like GitHub / GitLab with Continuous Integration seems to be the absolute minimum for a decent development toolchain. Such tools allow faster feedback cycles, better reproducibility, and generally more productivity.\n\nHowever, in one crucial aspect most of us are still wasting many hours every day.\n\nGetting our dev environments into a ready-to-code state is usually still done manually, wasting an endless amount of precious developer time and energy.\n\nDev environment provisioning can and should be automated.\n\nContinuous dev environments are a crucial part in a fully optimized DevOps toolchain, that allow to instantaneously spin up a ready-to-code developer environment from any Git state. Continuous dev environments reduce friction in onboarding and task switching and improves reproducibility across the project.\n\n__SPLIT_HERE__\nAutomated Dev Environments\n\nAutomating dev environments is not new and usually focuses on the initial setup, but that doesn&#39;t quite cut it. Of course, we all have felt the pain of being on-boarded in a new project, spending the first week figuring out what tools to install and how to configure them correctly. Manually setting up a dev environment is a waste of energy. Surprising that we still do such things, given that we developers are usually busy automating everything else in the world.\n\ndisposable dev environments\n\nBut it is not only the one-off onboarding I want to discuss. Our projects change over time, and so do our dev environments. Developers are switching between different versions of a project. They, therefore, have to adjust parts of the dev environment accordingly, all the time.\n\nWe should automate dev environments using code, just as we do with testing, staging and production environments for continuous deployments.\n\nWhen a developer wants to start a task, on some branch, in some project, she should be able to do so without spending hours on getting into the right environment.\n\n__SPLIT_HERE__\nDisposable Dev Environments\n\nAutomating a dev environment means we can recreate it any time. Starting fresh every time will make sure the setup works correctly and that you get a clean state.¬†Since the build and the tests ran through and the dependencies are all fresh, you can be sure that any problems come from your changes. Such a setup makes it super easy to reproduce bugs, as well.\n\nSelf-service rack with available pairs of bowling shoes\n\nMoreover, a use-once dev environment frees you from cleaning up afterward. You never pollute your local system with any heavy checkouts, dependencies, builds, databases, and the like. Enter zero-waste coding.\n\nIt&#39;s almost 2020 and we understand that automating complex systems through code and configuration is vital. Now, let&#39;s apply those lessons learned to our dev environments.\n\n__SPLIT_HERE__\nPrebuilt Dev Environments - No More Waiting for Builds!\n\nInitial setups are annoying, but the real time sink is waiting for builds. Compilers, generators, downloading dependencies, and running tests all need to be executed before you can use your dev environment.\n\nJust like CI tools that build your project after you have submitted a change, a continuous dev environment service builds your project before you need it. That way you can start on a clean state immediately.\n\nA tool for providing continuous automated dev environments should prebuild your project, so you don&#39;t have to wait.\n\nGitpod prebuilds your branches continuously, so that you can start coding immediately without having to wait for builds to complete. Starting a new dev environment and seeing below output in the terminal makes me smile every time:\n\nüçå This task ran as part of a workspace prebuild. üéâ You just saved 5 minutes of watching your code build.\n\nTry below&#39;s example to see the effect of prebuilds in action. üëá","metadata":{"source":"https://gitpod.io/blog/continuous-dev-environment-in-devops"}}],["46",{"pageContent":"Browser-based Dev Environments?\n\n&quot;Browser-based? I need professional tools!&quot;\n\nYes, I hear you. Until recently, browser-based tools haven&#39;t been as powerful as what we use locally.\n\nBut times have changed. Today, we can run a VS Code compatible IDE in a browser tab together with complete terminals to dedicated Linux containers. And everything is specially configured for your project.\n\nThe Theia IDE open-source project is fully configured with continuously prebuilt dev environments. You can try it out yourself by clicking the link below.\n\nhttps://gitpod.io/#https://github.com/theia-ide/theia\n\nTheia in Gitpod\n\n__SPLIT_HERE__\nBut my environment is different than those from my teammates!\n\nYes, of course, there are personal preferences like themes, keybindings, or even one or the other tool. Some developers heavily use command-line tools and have very advanced configurations. Others use particular VS Code extensions that improve their workflow significantly.\n\nIndividual\n\nWhy don&#39;t we share all that goodness within the team?\n\nWhile Gitpod lets you have user-specific settings, we see an opportunity in sharing the wisdom within the team to build a perfect, friction-free setup for everyone. This way, you can share your impressive terminal skills and configuration with your team, and you might learn a new thing or two as well.\n\n__SPLIT_HERE__\nThe missing piece in DevOps\n\nI&#39;m pretty sure, automated ready-to-code dev environments will become mainstream. The advantages and implications are just too good to be ignored. Everyone who has understood and experienced the benefits of a proper DevOps toolchain should understand how providing dev environments on-demand completes that experience. Ironing out that last area of non-reproducible and very annoying yak-shaving should be high on our todo list as it will improve developer productivity drastically.\n\nGitpod is available to open-source projects for free and affordable for commercial projects, through the Saas offering (www.gitpod.io). Gitpod Enterprise will soon be released, allows self-hosting Gitpod on any Kubernetes cluster, and integrates with GitHub Enterprise, GitLab, Jenkins, JIRA and other tools in your DevOps toolchain.\n\nComments?","metadata":{"source":"https://gitpod.io/blog/continuous-dev-environment-in-devops"}}],["47",{"pageContent":"Update (July 2022): You can now also access workspaces with an SSH key.\n\nDeveloper experience is sometimes about making big changes, such as migrating to a new industry-defining tool or technology. But sometimes developer experience is about paying attention to the little things. Taking actions that we do as developers every day, and making them quicker, easier and removing friction.\n\nRecently, we shipped a feature on Gitpod that we‚Äôre excited to share with you, and we hope that it brings some more joy to your developer experience with Gitpod.\n\nAs of today, in Gitpod you can now get access to a Gitpod workspace directly via SSH with a one-liner copy/paste from the Gitpod dashboard.\n\n__SPLIT_HERE__\nHow does workspace access via copy/paste SSH work?\n\nFor those using Gitpod, you‚Äôll know that you can already get SSH access into a Gitpod workspace via the Gitpod Local Companion (currently in beta). However, we still saw the need from our users for a super easy, quick way to get direct SSH access to a workspace.\n\nAll you have to do is visit the Gitpod dashboard, click the more actions menu at the right-hand side of your workspace list, copy/paste the SSH command into a terminal, and voila!\n\nYou‚Äôre SSH‚Äôed into your Gitpod workspace‚Äî‚Äúready to code‚Äù.\n\nYou can also copy/paste your SSH access from the workspace start page, which is shown to users who have selected a desktop IDE or editor as their preference.\n\nNote: SSH authentication is provided using a shared workspace token that is refreshed on each workspace start. So, as always, be careful where you copy/paste the link.\n\nIf you&#39;re one of our many users who lives in the command-line, rather than in an editor or IDE, you can also combine SSH copy/paste access to Gitpod workspaces with Gitpod features like dotfiles, to get your workflow running just the way that you like it.\n\nNow, some of you might be wondering why we‚Äôre so excited about SSH copy/paste access to Gitpod workspaces? And that‚Äôs because it‚Äôs one of the many ways we‚Äôre making Gitpod seamless for professional teams to use Gitpod for developing using any language, technology or workflow.\n\n__SPLIT_HERE__\nRemote Development for every team\n\nAt Gitpod, we‚Äôve been working very closely with our customers to remove any friction we see for the professional development teams who are using Gitpod. Any developer should be able to use Gitpod in as seamless way as possible‚Äîcertainly a challenge!\n\nBecause, not all tech companies are set up with the same architecture or technology. Not all developers work in exactly the same way, using the same tools, languages or frameworks. And not all development work looks exactly the same.\n\nBut that‚Äôs a good thing. Choice and flexibility to choose the right tool for the job is essential. And that‚Äôs precisely why we build Gitpod to be flexible, eg. by building Gitpod on top of ubiquitous technologies like Docker. We integrate, we don‚Äôt dictate.\n\nFor editing your code, you can use VS Code in the browser, VS Code on desktop, and using JetBrains IDE‚Äôs via JetBrains Gateway. Adding copy/paste SSH support just makes it that little bit easier for developers who prefer to work directly in their terminal, or for those times you need to hop into a Gitpod workspace to execute some commands.\n\nGive the new Gitpod copy/paste SSH access a go, and let us know what you think by joining the community. We look forward to hearing from you!","metadata":{"source":"https://gitpod.io/blog/copy-paste-ssh-workspace-access"}}],["48",{"pageContent":"Imagine that only a decade ago system administrators deployed, configured, and maintained software systems manually. Doing so burned an endless amount of their precious lifetimes and energy.\n\nToday, in the age of microservice architectures, systems have become even more complicated. Trying to maintain operations and deployments by hand isn‚Äôt optional anymore. These days we do ‚ÄúDevOps‚Äù or ‚ÄúInfrastructure as code‚Äù. We have learned that describing a software system in a declarative and formal way is mandatory to deploy applications automatically and continuously.\n\n__SPLIT_HERE__\nWhat about our dev environments?\n\nWhile we have automated deployments of our applications, most of us don‚Äôt apply the same techniques to developer environments, yet. Instead, on-boarding a new team member on any non-trivial project usually is a multiple hour (if not days) exercise.\n\nIt often goes like that:\n\nA new developer gets pointed to the readme\n\n\nReads lengthy, mostly outdated setup procedure\n\n\nInstalls requirements on the developer machine,\nupdates/downgrades versions, etc.\n\n\nTries to run the build ‚Ä¶ waits 20 minutes\n\n\nBuild Fails. Try figure out what went wrong.\n\n\nAsks colleague. ‚ÄúOh, yes. You also need to do X &amp; Y‚Äù\n\n\ngoto 3\n\nAfter many iterations at some point, the build somehow works. You don‚Äôt know why, but that doesn‚Äôt matter now. Of course, you are not updating the document, as you are not sure and don‚Äôt know how you ended up with a working setup. Is that current state even reproducible? So if you update the readme, you better only add what you figured out. You don‚Äôt dare to remove parts that you didn‚Äôt understand or skipped because they didn‚Äôt work for you.\n\nToo bad the setup only worked on first glance. During the following weeks, you will have to solve smaller issues here and there and add some tools that were not listed. Maybe debugging doesn‚Äôt work yet, or you don‚Äôt see the sources from upstream dependencies. Eventually, it smoothes out. Only when a colleague changes something in the requirements, it usually takes two days until the whole team has noticed and changes their environments accordingly.\n\nUnfortunately, the pain doesn‚Äôt stop here.\n\n__SPLIT_HERE__\nIt works on my machine\n\nYou probably know the famous phrase ‚ÄúIt works on my machine‚Äù? The situation when a bug only appears on one machine and is hard to reproduce on others? That feeling when a bad thing happens in production, but you can‚Äôt reproduce it locally? Not very surprising, though, as long you are running the code on a different platform based on a different setup.\n\nBut it works... On my machine\n\n__SPLIT_HERE__\nGoing back to fix something on an old branch\n\nAnother pet peeve is when you need to fix something on a maintenance branch. Fixing the actual bug could have been so easy, as you know how to fix it. However, before you can call it done you need to be able to build and test that old beast. This is costing you an endless amount of time.\n\nTinkering with a six months old technology stack can be so annoying. You have to deal with all those old libraries and versions of them. However, you still have to make it work somehow.\n\nWoman biting a pen in front of a laptopPhoto by JESHOOTS.COM on Unsplash\n\nAll this suffering can end if we applied the ‚Äòinfrastructure as code‚Äô idea to our dev environments, too. Why not make dev environment setups automated, reliably reproducible, and versioned by writing them down in an executable format and checking them into the project‚Äôs source code repository?","metadata":{"source":"https://gitpod.io/blog/dev-env-as-code"}}],["49",{"pageContent":"Dev environment as code\n\nAfter all, dev environments are often even more complicated than the runtime application they are used for. You typically need to add all the development tools such as build tools, compilers, linters, and a decent editor / IDE on top of the runtime requirements.\n\nIf you want to ensure that changes don‚Äôt break anything down the line, everybody needs to code, run, and test on the same environment the CI builds run on.\n\nSo let‚Äôs please stop polluting our readme files and start writing setup instructions down formally, so they can be executed.\n\nDockerfiles\n\nDocker files are a pretty neat way to describe a developer environment. Imagine you want to add something like ‚Äò_asciidoctor_‚Äô to your project‚Äôs toolchain. You could just add the following line to your dev environment‚Äôs Dockerfile:\n\n```undefined\nRUN apt-get install -y asciidoctor\n```\n\nOnce you push the change to the repository and the Docker image gets updated (automatically), all team members have the new tool in their developer environment. We need to get to coding with a single click.\n\nLaptop with code on the screenPhoto by Cl√©ment H on Unsplash\n\nAutomated IDE Setup\n\nThe Docker approach gets a bit clumsy if your development tools have a UI such as a desktop IDE. You can package them in Docker, but you have to expose the IDE‚Äôs UI through X11. Another alternative is to go with a terminal editor like vim, but of course, that is not an option for most of us.\n\nSome desktop IDEs have tools that allow automating setups. Eclipse, for instance, has a tool called Oomph. Oomph allows you to declaratively describe an Eclipse IDE including plug-ins, configuration and even workspace setup. (i.e. Git information).\n\nBy far the best option is an IDE that runs in browsers, like the new Theia IDE. Theia is open-source under the Eclipse Foundation. It can be seen as VS Code that runs on browsers and desktops and is a bit more customizable.\n\nFor a simple Docker-based dev environment you could add Theia to your Docker image. It offers a full IDE including terminals to your workspace image.\n\nThe next step would be to treat your developer environment as some serverless function which you only spawn when needed and forget about when done. The online service Gitpod does exactly that.\n\nIt integrates with code hosting platforms such as GitHub. It eliminates all the tedious transitions by automating them. You see code on some website and want to give it a spin in a real dev environment? Gitpod does everything it can to get you there with a single click. It lets you provide custom Docker files or Docker images and runs Theia IDE.\n\n__SPLIT_HERE__\nSummary\n\nApplying the lessons learned from DevOps to our development setup can save us so much precious time and energy. ActiveState‚Äôs Developer Survey 2018  underlines this with some numbers:\n\nActiveState‚Äôs Developer Survey 2018: How much time do you spent on managing dependencies and development tools\n\nDo we really need to welcome new colleagues or contributors with a painful on-boarding experience? Let‚Äôs skip the prose in the readme and write code to have our dev environment setup automated, reproducible, and versioned.","metadata":{"source":"https://gitpod.io/blog/dev-env-as-code"}}],["50",{"pageContent":"A walk-through to create a fully working Nuxt.js web application with only a browser, using Gitpod.io the online IDE for GitHub.\n\nVersion 2.0 of Nuxt.js has just been released. It comes with a convenient scaffolding tool that let‚Äôs you get started in no time. In the following I will explain the steps necessary to create, run and develop a Nuxt.js application with only a browser using Gitpod.io.\n\n__SPLIT_HERE__\nStep 1: Go to GitHub and create a fresh repository.\n\nGitpod.io uses GitHub as its dashboard. That means you start your workspaces from any states of any GitHub project. So new projects are created through GitHub, too:\n\nGitHub Dashboard &#39;repositories&#39; tab\n\nClicking anywhere on GitHub‚Äôs Octocat logo on the top left will bring you to your dashboard, where you can create a new repository.\n\nEnter any name description, you can later change it.\n\nGitHub &#39;Create a new repository&#39; page\n\n__SPLIT_HERE__\nStep 2: Start a Gitpod workspace\n\nFrom your newly created but still empty project you can now start a Gitpod workspace. To do so prefix the GitHub URL with gitpod.io/#:\n\nStart a new Gitpod workspace by prefixng the repo URL with gitpod.io#\n\n__SPLIT_HERE__\nStep 3: Run yarn create nuxt-app.\n\nNow a workspace with an online IDE is started for you. It will open up the readme (if you have created one) and a terminal.\n\nUsing the terminal you can use create-nuxt-app to create an initial project:\n\n```bash\n**yarn create nuxt-app**\n```\n\nNow simply answer all the prompts as you want.\n\n__SPLIT_HERE__\nStep 4: Allow external access to the dev server\n\nBy default the dev server doesn‚Äôt allow external IPs. To change that so we can access the application running in our cloud container, we need to pass an additional argument to the dev command.\n\nTo do so open the package.json file and add the parameter\n\n```bash\n**‚Äî-hostname 0.0.0.0**\n```\n\nas shown below:\n\npackage.json allow external access to the dev server\n\n__SPLIT_HERE__\nStep 5: Start the dev server\n\nNow we can start the dev server and see the application in action.\n\nIn the terminal type\n\n```bash\n**yarn dev**\n```\n\nA notification window will pop up asking you to either open the web app externally or in a view side-by-side to the editor area.\n\nRunning app in the Gitpod workspaceRunning app in the Gitpod workspace\n\n__SPLIT_HERE__\nBonus Points\n\nNow you can start changing the application and of course committing to your repo. Also you should consider adding a .gitpod file to the root directory, so the build and dev server automatically startup next time you open a Gitpod workspace.\n\nHere‚Äôs the contents:\n\n```yaml\nports:\n    - port: 3000\n    protocol: \"http\"\ntasks:\n    - command: |\n        yarn install\n        yarn dev\n```\n\n__SPLIT_HERE__\nDive deeper into Nuxt.js\n\nNow you are all set to dive a bit deeper into Nuxt.js. Checkout the awesome-nuxt repository or the website for further tips and tutorials.\n\nHave fun!","metadata":{"source":"https://gitpod.io/blog/developing-nuxtjs-in-browser"}}],["51",{"pageContent":"Welcome to DevX Digest - the place to hear all about Developer Experience, brought to you by Pauline Narvas (@paulienuh) and Mike Nikles (@mikenikles) from Gitpod. You‚Äôre reading another newsletter from us üéâ!","metadata":{"source":"https://gitpod.io/blog/devrel-link-devx"}}],["52",{"pageContent":"Developer Experience is the new DevRel\n\nAnother awesome guest which means another great DevXPod episode! This time, we spoke to Kurt Kemple from Forthright who talked to us about how developer experience is very much part of developer relations and how it could be ‚Äúthe new DevRel‚Äù.\n\nAs usual, we‚Äôve summarised the key points from our conversation and you can also listen to the episode anywhere you get your podcasts! Don‚Äôt forget to subscribe and leave us a rating ‚≠êÔ∏è\n\nDevX Podcast Episode 1\nDevX Pod is avaliable wherever you get your podcasts!\n\nKey Takeaways\n\nKurt joins us with a very interesting perspective on developer experience. Prior to founding Forthright - a developer experience consultancy - Kurt has extensive experience in developer relations working in advocacy at various companies from AWS, GraphQL to Gatsby.\n\n\nPrevious guests on DevXPod we‚Äôve primarily discussed developer experience in the context of in-product experience with the tools itself. Kurt describes DevX as, _‚Äúan event or an occurrence within an ecosystem that leaves an impression on a developer.‚Äù _ This can include out-of-product experiences such as support, community, docs and content.\n\n\n‚ÄúIf I&#39;m asking even another person for help and I have a bad experience, I tie that to the company. So we can&#39;t pin developer experience down to just ‚ÄòI build integrations.‚Äô‚Äù With this in mind, it naturally makes sense that developer relations which is often the out-of-product experience falls naturally in making sure developer experience is positive. Kurt wrote a fantastic article about this, check it out here!\n\n\nTo be effective in the growing developer experience space, Kurt recommends that the best skills to hone aren‚Äôt engineering-specific skills but technical writing, empathy and the ability to prioritise. ‚ÄúI actually think the lack of specificity it&#39;s going to do us a significant amount of damage as companies try and understand DevX and build that out as they grow.‚Äù Although these roles are very fluid, we‚Äôre starting to see specialisation areas including community builders, docs educator, DevX engineering (i.e. building pipelines and infrastructure.)\n\n\nDevX is increasing in relevancy to everyone in tech. For example, Mike noted how many people have recently announced their new DevX jobs on Twitter. Kurt mentioned that he‚Äôs seen a DevX role in the first 10 hires at start-ups. Both of these showcase how important DevX is more than ever! ‚Äú2022 is the year of developer experience!‚Äù\n\n\nAdditionally, developer experience is important to bring more developers into tech. Our tools and product that we‚Äôre optimising for developer are opening the doors for more people, especially in a world that relies on software more than ever.\n\n\nNot only does doubling down on developer experience benefit with accessibility and productivity, but it‚Äôs also in a company‚Äôs best interest as it‚Äôs seen as a competitive advantage for hires. Engineers are more likely to join a company with a better experience, in some cases that could be a determining factor.\n\n\nWhen sharing some of the best developer experiences Kurt has seen, he reflected on the time he had built Bert CLI for PHP where he had the first taste of building to improve the lives of other developers. He also mentioned AWS Amplify as another DevX that folks should check out!\n\n\nMoving onto the future, Kurt shared that he‚Äôs excited to see the explosion of a diverse set of roles in out-of-product developer experience including content creators, illustrators, community engineers with more defined career ladders.\n\nDevX Digest is community-driven\n\nAnother thing about Gitpodders is that we‚Äôre all driven by community feedback, and this newsletter is no exception! Please send us your thoughts, feedback and help us navigate this conversation. We may even feature some of your takes and comments in future newsletters!\n\nCome and hang out with us over on our Discord. üëãüèº","metadata":{"source":"https://gitpod.io/blog/devrel-link-devx"}}],["53",{"pageContent":"Welcome to DevX Digest - the place to hear all about Developer Experience, brought to you by Pauline Narvas (@paulienuh) and Mike Nikles (@mikenikles) from Gitpod. You&#39;re reading another DevX Digest from us üéâ!\n\nOn another episode of DevXPod, we sat down with Brittney Postma, Founder of Svelte Sirens, Content Creator at CodingCat.dev and Software Engineer about her thoughts on the way developer experience affects all of us.\n\nAs usual, in today‚Äôs newsletter, we‚Äôll be sharing some of our key takeaways from the podcast episode. If you‚Äôd like to listen to the full episode, head over to your favourite podcast platform and search for DevXPod. Don‚Äôt forget to subscribe and leave us a rating ‚≠êÔ∏è Alternatively, if you‚Äôd prefer to read a transcript of our conversation head over to our Buzzsprout site!\n\nDevX Podcast Episode 1\nDevX Pod is avaliable wherever you get your podcasts!\n\nKey take-home messages\n\nBrittney started her tech journey learning React on FreeCodeCamp and Udemy. She‚Äôs been recognised in several communities for her contributions and for being one of the first to finish the complete react developer by zero to mastery course. Today, she focuses mostly on Svelte. Her story was particularly interesting coming as all got into tech in different ways and learned in different ways too!\n\nRelating to developer experience, the onboarding into the tech world is constantly evolving. For example, in the past developers would learn from books but today there are videos, playgrounds and more! Simply put, ‚ÄúWe‚Äôre all in the business of developer experience‚Äù Brittney shared. No matter what your role is, DevX affects us all from education to developer productivity.\n\nClosely related, DevX improves end user experience as it will allow developers to ship more, build faster and focus on other tasks. Netlify once again received a shoutout for their brilliant developer experience. Brittney also commented on how she believes that the future of developer experience lies in automating as much of the developer lifecycle as possible which will boost all the developer productivity benefits.\n\nThis week‚Äôs shoutout by our guest is Svelte Sirens - a place for women and non-binary folks to learn about Svelte and the JAMStack Community. Don‚Äôt forget to check them out!\n\nDevX Digest is community-driven ü§ù\n\nAnother thing about Gitpodders is that we‚Äôre all driven by community feedback, and this newsletter is no exception! Please send us your thoughts, feedback and help us navigate this conversation. We may even feature some of your takes and comments in future newsletters!\n\nCome and hang out with us over on our Discord. üëãüèº","metadata":{"source":"https://gitpod.io/blog/devx-affects-us-all"}}],["54",{"pageContent":"Welcome to DevX Digest - the place to hear all about Developer Experience, brought to you by Pauline Narvas (@paulienuh) and Mike Nikles (@mikenikles) from Gitpod. You&#39;re reading another newsletter from us üéâ! In this edition, we talk about developer experience in cloud-based,ephemeral dev environments.\n\nIn this edition, we‚Äôre looking back on an awesome conversation we had for DevXPod with Jamon Holmgreen, the Co-founder and CTO of Infinite Red. We encourage you to listen to the full episode, however, if you prefer reading our key takeaways from the episode, here they are! We also have a full transcript available here.\n\nDevX Podcast Episode 2\nDevX Pod is avaliable wherever you get your podcasts or over on our Buzzsprout page!","metadata":{"source":"https://gitpod.io/blog/devx-evolution"}}],["55",{"pageContent":"Key takeaways\n\nüí¨ If you‚Äôre building anything in the tech space, **you will always have developer experience. **The question is whether it‚Äôs going to be good, bad or indifferent. Developer experience has exploded recently, but it‚Äôs always been around. When Jamon first got started in tech, he recalls his initial developer experience with the ‚Äúonline‚Äù help tool on QBasic which was essentially a help page that popped up after hitting F1.\n\n\nüôèüèº Developer experience has improved over the years, as we have become more mindful of when we create tools, libraries, APIs for others! We discussed how nicer it is to for instance develop a headless CMS in comparison to the days of updating WordPress PHP theme files via FTP. Throwback, right?\n\n\nüí° ‚ÄúIf you are contributing in some way to developer experience, you&#39;re sort of like giving a gift to the user who is going to be using or the next developer, which might be you.‚Äù Often when we talk about developer experience, we think about other developers, but Jamon points out that it might also be your future self trying to figure out the same thing. Therefore, **improving DevX is crucial and takes intentionality. **\n\n\nüö´ Mental fatigue and low team morale are all signs of bad DevX. If developers are constantly feeling frustrated by your onboarding experience or documentation that isn‚Äôt clear, it could do more harm than good. Constantly hitting issues is never a good experience._ ‚ÄúCoding is hard enough.‚Äù_ Jamon described, ‚Äúlet‚Äôs not add more to it.‚Äù\n\n\nüíª React-native-popover-view is a library that Jamon recommends as one of the best DevX that he has recently found. It‚Äôs a simple, highly customisable Popover component for React-native and has a great API with plenty of examples in the README. It was also another great example of progressive disclosure, a concept we mentioned in another Digest.\n\n\n‚ôªÔ∏è Jamon wrote React Native Colo Loco library with developer experience in mind, he spent more time intentionally making sure that documentation was clear, written in plain English and not overwhelming for new folks. It took a lot more time but is worth it long-term. This brought to our attention how we speak a lot about developer experience being mainly about the product, but we sometimes forget the other pieces including community, docs, error messages...i.e. The Developer Experience Ecosystem.\n\n\nüöÄ From painfully onboarding ourselves to interesting open-source environments to sandboxed developer environments like Gitpod; interactive documentation instead of docs that leave you with more questions; or more meaningful error messages (a good example is Elm) and less searching the ends of the internet for answers dated back to 10 years ago‚Ä¶ DevX has changed so much over the years. The approach towards ‚Äúthe Developer Experience Ecosystem‚Äù as a whole is definitely something we all discussed as something we hope to see evolving in the future.\n\nDevX Digest is community-driven ‚ú®\n\nAnother thing about Gitpodders is that we‚Äôre all driven by community feedback, and this newsletter is no exception! Please send us your thoughts, feedback and help us drive this conversation. We may even feature some of your takes and comments in future newsletters!\n\nCome and hang out with us over on our Discord. üëãüèº","metadata":{"source":"https://gitpod.io/blog/devx-evolution"}}],["56",{"pageContent":"Welcome to DevX Digest - the place to hear all about Developer Experience, brought to you by Pauline Narvas (@paulienuh) and Mike Nikles (@mikenikles) from Gitpod. You&#39;re reading another newsletter from us üéâ! In this edition, we talk about developer experience in cloud-based,ephemeral dev environments.\n\nThe recent episode of DevX Pod is a special one! We spoke to our Chief Technology Officer (CTO) at Gitpod, Chris about his thoughts on developer experience. We also are very excited to welcome him as a future podcast host! You&#39;ll be hearing more from him. üé∂\n\nAs usual, in today‚Äôs newsletter, we‚Äôll be sharing some of our key takeaways from the podcast episode. If you‚Äôd like to listen to the full episode, head over to your favourite podcast platform and search for DevXPod. Don‚Äôt forget to subscribe and leave us a rating ‚≠êÔ∏è Alternatively, if you‚Äôd prefer to read a transcript of our conversation head over to our Buzzsprout site!\n\nDevX Podcast Episode \nDevX Pod is avaliable wherever you get your podcasts!\n\n__SPLIT_HERE__\nKey Takeaways\n\nBefore joining Gitpod as employee #2, Chris worked at an IT startup that came out of Bosch as a System Architect for a couple of year. He also did a PhD on Human Computer Interaction. Today, he‚Äôs Gitpod‚Äôs CTO.\n\nChris described developer experience as user experience, but for developers. Similar to how we use a pen when writing but don‚Äôt really think about it, we want every developer experience to be the same. I.e. it just fades to the background!\n\nDeveloper experience is more than just the end product experience however. It‚Äôs not just the documentation that surrounds it either! DevX should be seen from the lens of the ecosystem. As Chris shared on the podcast, ‚ÄúIt is the way it is applied. It is the way you, as a developer can influence the tools that you are using. And this is really puts us in a very unique perspective.‚Äù\n\nThe reality is developers are expected to do a lot these days. It‚Äôs not ‚Äújust‚Äù coding! Good developer experience is important more than ever to help reduce individual developer burnout and maximise productivity. For example: instead of doing the same thing over, let‚Äôs automate it, remove the friction and using working in factors to illustrate this: reducing repetitive strain injury. From a company perspective, DevX is becoming more relevant as well especially from a hiring point of view. Have you got a developer experience that is ‚Äú_bad_‚Äù? Some engineers actively avoid using specific tools and technologies because of it!\n\nLooking ahead, Chris compared DevX to CI/CD. In a similar fashion, in a few years if you aren‚Äôt doing CI/CD in your organisation (or doing it well), you don‚Äôt have good DevX.\n\n‚ÄúIf you&#39;re building a product that is aimed at developers. Or even remotely touches on developers! You&#39;ll need to provide good developer experience for that too, because otherwise it will be a hurdle for people to adopt your product.‚Äù\n\n__SPLIT_HERE__\nDevX Digest is community-driven\n\nAnother thing about Gitpodders is that we‚Äôre all driven by community feedback, and this newsletter is no exception! Please send us your thoughts, feedback and help us navigate this conversation. We may even feature some of your takes and comments in future newsletters!\n\nCome and hang out with us over on our Discord. üëãüèº","metadata":{"source":"https://gitpod.io/blog/devx-with-chris"}}],["57",{"pageContent":"And it&#39;s a wrap. We want to thank everyone who joined us last month at DevX Conf and welcome readers who are reading about the conference for the first time. The talks are available for viewing and USD $22,600 is being distributed to Open-source projects that conference attendees voted for.\n\nThe conference is evolving to be a space where developer tool founders share what they&#39;ve been working on all year. The themes that stood out in 2022 were automation (think, Fig, Warp, Supabase), collaboration (think, Zed), and integration testing (think, AtomicJar). The continued transition to cloud development was a centrepiece of discussions at DevX Conf. Next to Gitpod, we saw Okteto and Codespaces talk about remote developer environments.\n\nLast year was the first year of the DevX Conference, and over USD $10,000 was raised and donated to unpaid volunteers and the maintainers of Open-source projects that underpin our digital infrastructure.\n\nDevX Conf - Sponsors\n\nThis year, thanks to the support of the conference sponsors AtomicJar, CodeSee, JetBrains, slim.ai, Tailscale, WorkOS, okteto and swimm we are pleased to share that we raised more than twice the amount of last year, that is, $22,600 USD. The funds are in the process of being distributed.","metadata":{"source":"https://gitpod.io/blog/devxconf-2022-wrap"}}],["58",{"pageContent":"Distribution of Open-source Funding\n\nLike last year, attendees voted on how to distribute profits from DevX Conf between Open-source tools maintained almost exclusively by unpaid volunteers. Here is the breakdown of how attendees voted to distribute this year&#39;s funds:","metadata":{"source":"https://gitpod.io/blog/devxconf-2022-wrap"}}],["59",{"pageContent":"Name URL Split of funding from $22.6k USD\n01. ccls is a C/C++/ObjC language server supporting cross references, hierarchies, completion and semantic highlighting. https://github.com/MaskRay/ccls $1,040.79\n02. erlang_ls is an implementation of Language Server Protocol for the Erlang programming language. https://github.com/erlang-ls/erlang_ls $594.74\n03. ElixirLS is a frontend-independent IDE &quot;smartness&quot; server for Elixir. Implements the &quot;Language Server Protocol&quot; standard and provides debugger support via the &quot;Debug Adapter Protocol&quot; https://github.com/elixir-lsp/elixir-ls $594.74\n04. elm-language-server is an implementation of Language Server Protocol for the ELM programming language. https://github.com/elm-tooling/elm-language-server $892.11","metadata":{"source":"https://gitpod.io/blog/devxconf-2022-wrap"}}],["60",{"pageContent":"04. elm-language-server is an implementation of Language Server Protocol for the ELM programming language. https://github.com/elm-tooling/elm-language-server $892.11\n05. hadolint is a smarter Dockerfile linter that helps you build best practice Docker images. The linter is parsing the Dockerfile into an AST and performs rules on top of the AST. It is standing on the shoulders of ShellCheck to lint the Bash code inside RUN instructions. https://github.com/hadolint/hadolint $2230.26\n06. Haskell IDE Engine aims to be the universal interface to a growing number of Haskell tools, providing a fully-featured Language Server Protocol server for editors and IDEs that require Haskell-specific functionality. https://github.com/haskell/haskell-ide-engine $743.42","metadata":{"source":"https://gitpod.io/blog/devxconf-2022-wrap"}}],["61",{"pageContent":"07. Ionide is an organization which builds high quality, cross platform developer tools for F#. Our flagship project is Ionide-VSCode - a Visual Studio Code plugin, with more than 1 million downloads, transforming VSCode into a fully-fledged F# IDE https://github.com/ionide $743.42\n08. lsp-mode is a Emacs client/library for the Language Server Protocol with multiples languages support. https://github.com/emacs-lsp/lsp-mode $1189.47\n09. ruby-together is a grassroots initiative committed to supporting the critical Ruby infrastructure you rely on: Bundler, RubyGems, and other shared tools. https://rubytogether.org/ $1040.79\n10. Rust-analyzer is an implementation of Language Server Protocol for the Rust programming language. It provides features like completion and goto definition for many code editors, including VS Code, Emacs and Vim. https://github.com/rust-analyzer/rust-analyzer $1635.53","metadata":{"source":"https://gitpod.io/blog/devxconf-2022-wrap"}}],["62",{"pageContent":"11. rvm is the acronym of Ruby enVironment Manager. It manages Ruby application environments and enables switching between them.. https://github.com/rvm/rvm $1189.47\n12. shellcheck is a tool that gives warnings and suggestions for bash/sh shell scripts: https://github.com/koalaman/shellcheck $2676.32\n13. patch-package lets app authors instantly make and keep fixes to npm dependencies. A vital band-aid for javascript developers living on the bleeding edge. https://github.com/ds300/patch-package $1189.47\n14. php-language-server is an implementation of Language Server Protocol for the PHP programming language. https://github.com/felixfbecker/php-language-server $743.42\n15. pre-commit is a framework for managing and maintaining multi-language pre-commit Git hooks. https://github.com/pre-commit/pre-commit $2527.63\n16. vim-lsp is an async Language Server Protocol plugin for vim8 and neovim. https://github.com/prabirshrestha/vim-lsp $1337.16","metadata":{"source":"https://gitpod.io/blog/devxconf-2022-wrap"}}],["63",{"pageContent":"16. vim-lsp is an async Language Server Protocol plugin for vim8 and neovim. https://github.com/prabirshrestha/vim-lsp $1337.16\n17. yamllint is a linter for YAML. https://github.com/adrienverge/yamllint $2230.26","metadata":{"source":"https://gitpod.io/blog/devxconf-2022-wrap"}}],["64",{"pageContent":"Only a fraction of funds has been distributed at this stage because, as an industry, we haven‚Äôt documented and established straightforward ways where companies can give Open-source projects money. If you are the steward of one of the above projects, please go sign up to GitHub Sponsors or Open Collective and/or publically document the process of how companies can support your project.\n\nAt Gitpod, we often wonder what the future would look like if these high achievers that our digital society is built upon were empowered to become independent artists. If just one of those people can help more people better understand a technology or improve the developer experience for an entire ecosystem what is the worth/value of that and why isn‚Äôt our industry doing that yet? In business terms, Open-source maintainers are unpaid and unsecured vendors.\n\nOpen-source supply chain decision tree","metadata":{"source":"https://gitpod.io/blog/devxconf-2022-wrap"}}],["65",{"pageContent":"Open-source supply chain decision tree\n\nGitpod hopes other companies will also start taking steps to mitigate this critical risk in their technology stack. Paying for resources that are being consumed broadens the list of people who can do Open-source. Additionally, money enables maintainers to buy services and outsource the activities that do not bring them joy.","metadata":{"source":"https://gitpod.io/blog/devxconf-2022-wrap"}}],["66",{"pageContent":"So what did we learn at DevX Conf?\n\nThe current generation of product creators is building developer tools with developer experience top of mind. It‚Äôs inspiring to see how much effort is invested into making small details shine - to help developers get the job done.\n\n\nDeveloper experience also touches on the soft aspects that make teams succeed. Companies increasingly care more about developer productivity. As almost every company on the planet is turning into a company that writes and works with software, developer experience will become ever more important.\n\n\nModern engineering teams are mostly distributed and work on highly complex technology stacks. Tooling should not constrain; it should enable them.\n\n__SPLIT_HERE__\nThe conference videos are now available\n\nAt DevX Conf 2022, we created a space where new concepts and ways of doing things were discussed and provided the stage to the growing number of contributors to the DevX ecosystem by highlighting projects that are at the forefront of developer experience.\n\nSome notable talks by speakers at DevX Conf shared how to build an internal team focused on developer experience, how to onboard developers in a day, and approach product design and product management from a developer-first perspective.\n\nAll twenty seven talks from the conference are now available on YouTube and over in the Discord server you&#39;ll find dedicated rooms filled with people who deeply care about the topic of DevX. We will be back next year, bigger than ever but until then cya in Discord?","metadata":{"source":"https://gitpod.io/blog/devxconf-2022-wrap"}}],["67",{"pageContent":"On April 28- 29 we hosted the DevX Conference, a space where creators could collaborate, listen, discuss and declutter dev workflows, toolchains and minds. To improve developer experience. We wanted to foster an ecosystem that sparks dialogue and establishes best practices and frameworks across the areas of coding, testing, building, deploying, collaborating on, and running software.\n\nSpeakers included Jason Warner (CTO GitHub), Beyang Liu (CTO Sourcegraph), Josh Long (Spring), Shanea Leven (Founder Codesee), Ellen Chisa (Founder Darklang), Henry Zhu (Steward of BabelJS), Ma√´l Nison (Creator Yarn), Nader Dabit (GraphQL &amp; Serverless), Anurag Goel (Founder Render), Yihong Cheng (Github1s), Tuomas Artman (Founder Linear) and many more.\n\n__SPLIT_HERE__\nEvent retrospective\n\nFirst of all, we were amazed by the attention that was drawn by this topic. It was the first conference ever organized by this team and it was being driven by a Gitpod, a company that&#39;s still on the starting line of its potential. More than 1.5k curious minds signed up for the event and more than 40% of them attended the live conference. There, 28 great speakers shared their expertise and unique knowledge with us. In case you missed a talk or would like to see them again, all recordings are now available on YouTube. To provide a space for attendees and speakers to interact live during the talks, we created a discord server. In total 550+ users signed up to join the live discussions. If you haven&#39;t joined the channel yet and would like to stay connected with the community, you can still join.\n\nI&#39;m very glad developer experience is picking up so much steam that there&#39;s now a dedicated conference for it: http://devxconf.org. Not only that, Gitpod is donating all the commercial proceeds from sponsors to open source projects they rely on!! Exploding ü§Øüëè\n\n__SPLIT_HERE__\nEvent Highlights\n\nHere are just a few highlights of the event:\n\nAn interview with Erich Gamma, the lead developer of VS Code, about the Evolution of DevX Conf\nA talk by Ellen Chisa, the co-founder of Dark Lang, who discussed the hypothesis that DevX isn‚Äôt good, because developers don‚Äôt want it to be\nA talk about being trapped in the open source supply chain by Henry Zhu, the Steward of BabelJS\n\nAll talks are now available for watching via this playlist on YouTube.","metadata":{"source":"https://gitpod.io/blog/devxconf-wrap"}}],["68",{"pageContent":"Funding open source\n\nü§Ø @gitpod is starting an Open-Source Sustainability Fund to help FOSS maintainers. What is more amazing that based on voting, Emacs&#39;s lsp-mode received almost 3% of the initial pool from @devxcommunity! Check https://gitpod.io/blog/gitpod-open-source-sustainability-fund/ for more.\n\nThe truth is free software isn&#39;t free. How much is a task going to cost in person hours? Hours have rates. Rates require payment. Yet, an entire community of developers provide their services outside of their day job to produce tools consumed by businesses.\n\nDid you know there are less than 2100 people in the inner GitHub open-source maintainer community?\n\nMaintainer Community","metadata":{"source":"https://gitpod.io/blog/devxconf-wrap"}}],["69",{"pageContent":"Did you know there are less than 2100 people in the inner GitHub open-source maintainer community?\n\nMaintainer Community\n\nAt Gitpod, we often wonder what the future would look like if these high achievers that our digital society is built upon were empowered to become independent artists. If just one of those people can help more people better understand a technology or improve the developer experience for an entire ecosystem what is the worth/value of that and why isn&#39;t our industry doing that yet?\n\nThe word volunteer, by definition, means those who have the ability and time to give freely.\n\nPaying for resources that are being consumed broadens the list of people who can do open-source. Additionally, money enables open-source maintainers to buy services and outsource the activities that do not bring them joy.","metadata":{"source":"https://gitpod.io/blog/devxconf-wrap"}}],["70",{"pageContent":"At Gitpod, we firmly believe that working for an open-source project should be a legitimate alternative to a career working for a for-profit corporation. Additionally, we&#39;d like everyone to be able to maintain open-source projects, not just people with the right financial background or youth that enables the ability to volunteer.\n\nThe myriad of tools that are relied upon by developers everyday are built and maintained almost exclusively by unpaid volunteers, and the maintainers of open-source projects, our digital infrastructure. Just like physical infrastructure, digital infrastructure needs regular upkeep and maintenance. Without effective support for open-source authors work, not only will their labor go uncompensated, but the digital world risks security breaches, interruptions in service, and slowed innovation.\n\nCredit: Sajjad Ahmadi\nCredit: Sajjad Ahmadi","metadata":{"source":"https://gitpod.io/blog/devxconf-wrap"}}],["71",{"pageContent":"Credit: Sajjad Ahmadi\nCredit: Sajjad Ahmadi\n\nAs part of Gitpod&#39;s Open-Source Sustainability Fund initiative attendees of the DevX Conf were able to decide where $10,000 USD of funds (the profits from DevX Conf plus an additional donation by Gitpod) were to be distributed. We thought long and hard about what projects to include in the competition and pondered about:\n\nwhat exactly is digital infrastructure?\nwhat tools are relied upon by developers every day that are built and maintained almost exclusively by unpaid volunteers?.\n\nAfter some dialectical thinking, the answer became clear: projects built by unpaid volunteers in the category of linters and language server protocol implementations.\n\nOver the last month Gitpod has been emailing maintainers and distributing the funds.\n\nü§Øüëè\n\nü§Øüëè","metadata":{"source":"https://gitpod.io/blog/devxconf-wrap"}}],["72",{"pageContent":"Over the last month Gitpod has been emailing maintainers and distributing the funds.\n\nü§Øüëè\n\nü§Øüëè\n\nAttendees of the DevX Conference were able to vote once for each of the projects, and the distribution of funds was calculated using Quadratic Funding (Paper). See wtfisqf.com for a breakdown of how the fund was split. Each vote was considered a share (or $1 matched), and then a total amount was set to $10,000.\n\nü§Ø Woah Gitpod just donated ‚ú®$212‚ú® to patch-package! They&#39;re democratically dividing $10k between a small set of OSS dev tools https://devxconf.org/opensource ‚Äì what a lovely idea, I&#39;m so honored to be included Smiling face I&#39;ll keep $5 for a beer and forward the rest to worthy causes. \n\nIn total there were 17 projects that were available for voting:","metadata":{"source":"https://gitpod.io/blog/devxconf-wrap"}}],["73",{"pageContent":"Name URL Split of funding from $10k USD\n01. ccls is a C/C++/ObjC language server supporting cross references, hierarchies, completion and semantic highlighting. https://github.com/MaskRay/ccls $281.69\n02. erlang_ls is an implementation of Language Server Protocol for the Erlang programming language. https://github.com/erlang-ls/erlang_ls $281.69\n03. ElixirLS is a frontend-independent IDE &quot;smartness&quot; server for Elixir. Implements the &quot;Language Server Protocol&quot; standard and provides debugger support via the &quot;Debug Adapter Protocol&quot; https://github.com/elixir-lsp/elixir-ls $211.27\n04. elm-language-server is an implementation of Language Server Protocol for the ELM programming language. https://github.com/elm-tooling/elm-language-server $281.69","metadata":{"source":"https://gitpod.io/blog/devxconf-wrap"}}],["74",{"pageContent":"04. elm-language-server is an implementation of Language Server Protocol for the ELM programming language. https://github.com/elm-tooling/elm-language-server $281.69\n05. hadolint is a smarter Dockerfile linter that helps you build best practice Docker images. The linter is parsing the Dockerfile into an AST and performs rules on top of the AST. It is standing on the shoulders of ShellCheck to lint the Bash code inside RUN instructions. https://github.com/hadolint/hadolint $774.65\n06. Haskell IDE Engine aims to be the universal interface to a growing number of Haskell tools, providing a fully-featured Language Server Protocol server for editors and IDEs that require Haskell-specific functionality. https://github.com/haskell/haskell-ide-engine $492.96","metadata":{"source":"https://gitpod.io/blog/devxconf-wrap"}}],["75",{"pageContent":"07. Ionide is an organization which builds high quality, cross platform developer tools for F#. Our flagship project is Ionide-VSCode - a Visual Studio Code plugin, with more than 1 million downloads, transforming VSCode into a fully-fledged F# IDE https://github.com/ionide $352.11\n08. lsp-mode is a Emacs client/library for the Language Server Protocol with multiples languages support. https://github.com/emacs-lsp/lsp-mode $281.69\n09. ruby-together is a grassroots initiative committed to supporting the critical Ruby infrastructure you rely on: Bundler, RubyGems, and other shared tools. https://rubytogether.org/ $633.8\n10. Rust-analyzer is an implementation of Language Server Protocol for the Rust programming language. It provides features like completion and goto definition for many code editors, including VS Code, Emacs and Vim. https://github.com/rust-analyzer/rust-analyzer $845.07","metadata":{"source":"https://gitpod.io/blog/devxconf-wrap"}}],["76",{"pageContent":"11. rvm is the acronym of Ruby enVironment Manager. It manages Ruby application environments and enables switching between them.. https://github.com/rvm/rvm $422.54\n12. shellcheck is a tool that gives warnings and suggestions for bash/sh shell scripts: https://github.com/koalaman/shellcheck $1690.14\n13. patch-package lets app authors instantly make and keep fixes to npm dependencies. A vital band-aid for javascript developers living on the bleeding edge. https://github.com/ds300/patch-package $211.27\n14. php-language-server is an implementation of Language Server Protocol for the PHP programming language. https://github.com/felixfbecker/php-language-server $492.96\n15. pre-commit is a framework for managing and maintaining multi-language pre-commit Git hooks. https://github.com/pre-commit/pre-commit $1197.18\n16. vim-lsp is an async Language Server Protocol plugin for vim8 and neovim. https://github.com/prabirshrestha/vim-lsp $492.96","metadata":{"source":"https://gitpod.io/blog/devxconf-wrap"}}],["77",{"pageContent":"16. vim-lsp is an async Language Server Protocol plugin for vim8 and neovim. https://github.com/prabirshrestha/vim-lsp $492.96\n17. yamllint is a linter for YAML. https://github.com/adrienverge/yamllint $1056.34","metadata":{"source":"https://gitpod.io/blog/devxconf-wrap"}}],["78",{"pageContent":"Only a fraction of funds has been distributed at this stage because, as an industry, we haven&#39;t documented and established straightforward ways where companies can give open-source projects money.\n\nü§Øüëè\n\nSending hand crafted emails (assuming an email address is publically available üò¢) asking projects these questions isn&#39;t scalable, and most companies would not do this manual grunt work. üòâ\n\nIf you are the steward of one of the above, open-source projects, then there&#39;s one simple, easy step you can do to enable Gitpod and other companies to provide financial support...\n\nGo sign up to GitHub Sponsors or Open Collective\n\n\nPublically document the process of how companies can support your project.\n\n\nSend an email to contact@gitpod.io.\n\n\nNominate where funding should be directed (if you wish to divert the funds to a cause that helps improve diversity in open-source such as Outreachy that&#39;s possible!)","metadata":{"source":"https://gitpod.io/blog/devxconf-wrap"}}],["79",{"pageContent":"Thanks\n\nThanks to everyone who participated in DevX Conf and who voted to support these great open-source projects. Shout out to Vercel for creating the Event Starter Kit and making it open-source. It facilitated our lives a lot and basically gave us the confidence to organize the conference in the first place. Thanks a lot! üôá‚Äç‚ôÄÔ∏è üôá‚Äç‚ôÇÔ∏è\n\nA big thanks also goes to the whole team organizing the event including Johannes Landgraf, Nisar Hassan Naqvi, and Mike Nikles üôå\n\nWe&#39;re looking forward to growing the community around developer experience and can&#39;t wait to see you all at the next DevX Conf! üß°","metadata":{"source":"https://gitpod.io/blog/devxconf-wrap"}}],["80",{"pageContent":"Since we released Gitpod into Public Beta it has been incredibly exciting to see people from all over the world use our service. Even more so with feedback like this:\n\nGeorge Kalpakas Tweet about Gitpod\n\nOf course, there is always room for improvement, especially with a service as new as Gitpod. Luckily, people have started to share their questions and ideas with us on https://github.com/gitpod-io/gitpod. One of the most often asked questions was:\n\nAnd indeed that hasn‚Äôt been straight forward. You had to:\n\ncreate a Dockerfile on your machine\n\n\nbuild that Dockerfile on your machine\n\n\npush it to hub.docker.com (no account? Create one first!)\n\n\ncreate a branch in your project with a customized .gitpod.yml file which references that specific image\n\n\nvisit gitpod.io/#\n\n\nget no feedback except ‚ÄòBuild has status FAILURE‚Äô‚Ä¶\n\n\nrinse and repeat from step 2\n\nThat was way too tedious for everyone to start playing around.","metadata":{"source":"https://gitpod.io/blog/docker-in-gitpod"}}],["81",{"pageContent":"visit gitpod.io/#\n\n\nget no feedback except ‚ÄòBuild has status FAILURE‚Äô‚Ä¶\n\n\nrinse and repeat from step 2\n\nThat was way too tedious for everyone to start playing around.\n\nTo improve this experience we introduced Dockerfile support (#62), which lets you reference your Dockerfile directly from inside your .gitpod.yml file:\n\n```yaml\nimage:\n  file: docker/Dockerfile\n```\n\nNow, Gitpod knows about the Dockerfile and builds that image for you. Whenever you access the repository on Gitpod it checks whether the Dockerfile has been updated and rebuilds the image if needed. When this happens you‚Äôll be shown the log output of the build for easier debugging, too.\n\nLet‚Äôs get concrete. As an exercise we‚Äôll use a minimal REST service written in Rust using Rocket and Diesel that talks to a PostgreSQL DB. It also has a nice  blog post to get started.","metadata":{"source":"https://gitpod.io/blog/docker-in-gitpod"}}],["82",{"pageContent":"Let‚Äôs get concrete. As an exercise we‚Äôll use a minimal REST service written in Rust using Rocket and Diesel that talks to a PostgreSQL DB. It also has a nice  blog post to get started.\n\nThe example relies on a very specific nightly build of the Rust compiler from May 2018. Thus, a simple git clone ‚Ä¶ &amp;&amp; cargo build &amp;&amp; cargo run won‚Äôt get you up-and-running. Of course, you could switch Rust toolchains but then other projects on your machine might stop working. Furthermore, there is more setup and tools to install: A database, a CLI tool‚Ä¶\nGitpod to the rescue!\n\nI went to gitpod-io/definitely-gp and added a *.*gitpod.yml and Dockerfile there. The *.*gitpod.yml file looks like this:\n\n```yaml\nimage:\n  file: Dockerfile\ntasks:\n  - command: |\n      echo DATABASE_URL=$DATABASE_URL >> .env\n      echo ROCKET_ADDRESS=$ROCKET_ADDRESS >> .env\n      echo ROCKET_PORT=$ROCKET_PORT >> .env\n      pg_start.sh\n      diesel setup\n      cargo build\n      cargo run\nports:\n  - port: 8000\n```","metadata":{"source":"https://gitpod.io/blog/docker-in-gitpod"}}],["83",{"pageContent":"It references the Dockerfile next to it, says that the resulting app should be accessible on port 8000 and contains the command executed on workspace startup: set config, start postgres, build and run app (I basically copied those from the repo‚Äôs .md file).\n\nThe Dockerfile itself inherits from our default image gitpod/workspace-full¬π and contains:\n\nPostgreSQL (+ some configuration for the gitpod user)\n\n\nspecific Rust toolchain\n\n\nsome project specific setup\n\nHere it is:\n\n```bash\nFROM gitpod/workspace-full:latest\n\n# Install postgres\nUSER root\nRUN apt-get update && apt-get install -y \\\n        postgresql \\\n        postgresql-contrib \\\n    && apt-get clean && rm -rf /var/cache/apt/* && rm -rf /var/lib/apt/lists/* && rm -rf /tmp/*","metadata":{"source":"https://gitpod.io/blog/docker-in-gitpod"}}],["84",{"pageContent":"# Setup postgres server for user gitpod\nUSER gitpod\nENV PATH=\"/usr/lib/postgresql/10/bin:$PATH\"\nRUN mkdir -p ~/pg/data; mkdir -p ~/pg/scripts; mkdir -p ~/pg/logs; mkdir -p ~/pg/sockets; initdb -D pg/data/\nRUN echo '#!/bin/bash\\n\\\npg_ctl -D ~/pg/data/ -l ~/pg/logs/log -o \"-k ~/pg/sockets\" start' > ~/pg/scripts/pg_start.sh\nRUN echo '#!/bin/bash\\n\\\npg_ctl -D ~/pg/data/ -l ~/pg/logs/log -o \"-k ~/pg/sockets\" stop' > ~/pg/scripts/pg_stop.sh\nRUN chmod +x ~/pg/scripts/*\nENV PATH=\"$HOME/pg/scripts:$PATH\"\n\n# Project specifics\n# Setup diesel_cli\nENV PATH=\"$HOME/.cargo/bin:$PATH\"\nRUN cargo install diesel_cli --no-default-features --features postgres\n\n# Some transitive dependencies are very picky: We need the nightly build build on the 2018-04-14, meant for the 2018-04-15\nRUN rustup default nightly-2018-04-15\n# Set some environment variables\nENV DATABASE_URL=postgres://gitpod@127.0.0.1/rust-web-with-rocket\nENV ROCKET_ADDRESS=0.0.0.0\nENV ROCKET_PORT=8000\n\n# Give back control\nUSER root\n```","metadata":{"source":"https://gitpod.io/blog/docker-in-gitpod"}}],["85",{"pageContent":"# Give back control\nUSER root\n```\n\nRemember, this is done once per project. Most projects already have those setup descriptions, they are just buried inside their README.\n\nNow whenever anyone accesses the repository through Gitpod, be it a branch, a particular commit, an issue or a  PR, they will get a custom workspace with all the tools set up and running, out of the box. Give it a spin!\n\nOnce the service has build and is running, we just follow the tutorial:\n\nOpen /people: Click Open on the appearing messagebox¬≤ and change the path in the integrated browser to http://8000-/people , click Reload : The query results in an empty []\n\n\nHit F1 -&gt; &quot;Open new Terminal&quot; and paste:\n\n```bash\ncurl -XPOST [http://localhost:8000/people](http://localhost:8000/people) -H \"Content-Type: application/json\" --data '{\"id\": 123, \"first_name\": \"Jon\", \"last_name\": \"Doe\", \"age\": 64, \"profession\": \"Engineer\", \"salary\": 1024}'\n```\n\nHit Reload again to see Jon Doe‚Äôs people entry","metadata":{"source":"https://gitpod.io/blog/docker-in-gitpod"}}],["86",{"pageContent":"Try it yourself\n\nYou can either create a PR on gitpod-io/definitely-gp ‚Äî or dive right in and create the .gitpod.yml in your repositories! For details on how this works and what is possible please head over to the docs.\n\n¬π It is not required to inherit from that image at all. You can even start with a plain alpine or debian based image. I used it here for convenience.\n\n¬≤ Alternatively, go to View -&gt; Ports and click Open","metadata":{"source":"https://gitpod.io/blog/docker-in-gitpod"}}],["87",{"pageContent":"Welcome to DevX Digest - the place to hear all about Developer Experience, brought to you by Pauline Narvas (@paulienuh) and Mike Nikles (@mikenikles) from Gitpod. You&#39;re reading another newsletter from us üéâ! In this edition, we talk about developer experience in cloud-based,ephemeral dev environments.\n\nDisclaimer: Gitpod is mentioned quite a bit here. Apologies in advance for the product placement -- we promise that the next 10 editions won&#39;t be about our product! But we were super excited to share our take on ephemeral developer environments, especially with the excitement recently in the developer community.","metadata":{"source":"https://gitpod.io/blog/ephemeral-dev-envs"}}],["88",{"pageContent":"The move to the Cloud ‚òÅÔ∏è\n\nLet‚Äôs name the üêò in the room: GitHub announced the release of CodeSpaces to Team and Enterprise Cloud plans recently. This generated quite some buzz online, with many asking how moving our developer environments to the cloud would benefit us.\n\nPainting the picture: our local developer environment\n\nThe reality for most developers is this: a local developer environment that is difficult to set up and maintain and eats up productivity significantly.\n\nThink about your current workflow when getting started to code. What do you need to do?\n\nClone source code\nInstall runtimes &amp; dependencies\nEnsure these are the correct versions\nSet up any tooling\n\nAnd then you can finally start coding! üòÖ\n\nBut in the familiar situation of reviewing a colleague&#39;s features and hotfixes for production, we are again going through a similar list of steps that we must do before we can even START the review.","metadata":{"source":"https://gitpod.io/blog/ephemeral-dev-envs"}}],["89",{"pageContent":"Stash our current changes\nSwitch branches\nPotentially install new runtimes or upgrade dependencies\nAnd then, we can finally review the change. üò∞\nOnce we&#39;re done with the review, we have to switch back to our branch to continue coding.\nEnsure that we return to our previous state to continue working.\n\nThere is so much friction for developers when there shouldn&#39;t be. Ideally, all we really wanted to do is look at the code, run it and approve the PR. Ephemeral developer environments can do this, ensuring that you&#39;re always ready to code.\n\nConsider an ephemeral developer environment\n\n&quot;Treat your infrastructure as cattle, not pets&quot;\n\n...is the saying often used in the DevOps world. The value of describing infrastructure as repeatable code became apparent and reaped many benefits: no more dreaded configuration drift, consistent infrastructure and many automation possibilities!","metadata":{"source":"https://gitpod.io/blog/ephemeral-dev-envs"}}],["90",{"pageContent":"Bringing that peace of mind to developer environments makes sense and is already possible. For instance, a single .gitpod.yml file is used to describe your dev environment, including what dependencies and start-up commands are needed to get you to the position where you can start coding.\n\nYour dev environment then becomes ephemeral. Gitpod continuously builds all your Git branches like a CI server. You have a new, consistent environment for every single task, and once you&#39;re done with a workspace, you can close it and start another super quickly because it has already been prebuilt.\n\nEphemeral developer environments reduce friction and improve developer experience massively - let us demonstrate that with specific workflows in more detail.\n\nWorkflow #1: Onboarding üíº","metadata":{"source":"https://gitpod.io/blog/ephemeral-dev-envs"}}],["91",{"pageContent":"Ephemeral developer environments reduce friction and improve developer experience massively - let us demonstrate that with specific workflows in more detail.\n\nWorkflow #1: Onboarding üíº\n\nThink back to when you were first onboarding to a new company. Onboarding has been normalised as a slow process with common issues related to outdated information, unique issues, &quot;that&#39;s strange, it works on my machine&quot; scenarios. Over the years, we&#39;ve just accepted it and hold on to the fact that once your local dev environment is eventually set up, you&#39;ll never have to go through the pain again.\n\nUntil you do because you have a new laptop, a new engineer comes along or external developers and experts join your project and experience that same pain.\n\nThere is no hiding that our local developer environments are fragile. This fact can cause new engineers onboarding to your new codebase to feel frustrated and overwhelmed.","metadata":{"source":"https://gitpod.io/blog/ephemeral-dev-envs"}}],["92",{"pageContent":"There is no hiding that our local developer environments are fragile. This fact can cause new engineers onboarding to your new codebase to feel frustrated and overwhelmed.\n\nEphemeral dev environments can improve this: no more local developer environments mean that it will always work on your machine, no matter what machine you have. You can quickly access your whole environment in a browser that new engineers can easily jump right into.\n\nWorkflow #2: Developing a Feature üõ†\n\nThe uphill battle of developing a new feature locally, does not happen in cloud developer environments. It‚Äôs no longer such an energy-inducing task!\n\nInstead of creating a new feature branch, pulling the latest code, fixing errors related to dependencies or runtime versions, then finally starting a dev server and database, you can start developing straight away with literally a click of a button or prefixing a repo with https://gitpod.io/#","metadata":{"source":"https://gitpod.io/blog/ephemeral-dev-envs"}}],["93",{"pageContent":"This creates a fresh workspace with a feature branch already created, dependencies installed, dev servers ready to go. The most important part of developing a feature is developing the feature, so why waste any more time on anything else?\n\nWorkflow #3: Reviewing a PR ‚úÖ\n\nAs we described above, reviewing a PR is no easy feat either in local dev environments.\n\nWith an ephemeral dev environment, they load instantly because the environment has already been prebuilt, therefore enabling you to do what is important: reviewing the PR and getting on with your day.\n\nWorkflow #4: Helping another team with some code üêû\n\nAnother familiar workflow is when you want to help another team or colleague with their code.","metadata":{"source":"https://gitpod.io/blog/ephemeral-dev-envs"}}],["94",{"pageContent":"Workflow #4: Helping another team with some code üêû\n\nAnother familiar workflow is when you want to help another team or colleague with their code.\n\nIn the local dev environment world, you have to go through the pain of stashing your current changes and switching branches. You may even have removed a dependency or two as part of your change, so you have to reinstall it for your colleague‚Äôs branch. Only until you‚Äôve done that is when you‚Äôre ready to help.\n\nAfter you&#39;ve done your part, you have to switch back and spend some additional time to return to the state your environment was in before.\n\nWith ephemeral dev environments, all you have to do is start a new workspace with the context of your colleague&#39;s branch. Your dev server is ready, your code prepared, your dependencies are all there, and you guessed it‚Ä¶you‚Äôre ready! Within VS Code in Gitpod, you can also leave comments directly on the code (which syncs seamlessly with GitHub.)","metadata":{"source":"https://gitpod.io/blog/ephemeral-dev-envs"}}],["95",{"pageContent":"Done with that? You can confidently close that workspace and open up a new one with the context of your branch. Everything is ready to go.\n\nWorkflow #5: Checking out an Open Source Project to help with ü§ù\n\nWant to contribute to an open-source project?\n\nThe friction that comes with onboarding to open-source projects can cause eager contributors to lose their interest quickly. Trying to get themselves set up is almost not even worth the pain!\n\nOnboarding is easy with ephemeral environments, as we described in workflow #1. You have a one-click button accessible from anywhere that allows those eager contributors to get started instantly. Win for everyone!\n\nRunning Prometheus using our local companion app on Gitpod\nLook at us running Prometheus on Gitpod using our Local Companion App!","metadata":{"source":"https://gitpod.io/blog/ephemeral-dev-envs"}}],["96",{"pageContent":"Are ephemeral, cloud developer environments the future?\n\nGitpod and GitHub Codespaces are leading the way in this new future -- one where friction is removed from the developer experience, so that developers are always ready-to-code.\n\nWe‚Äôd be interested to hear your thoughts, would you switch to a cloud developer environment? Why, or why not?\n\nJoin us for the ride!\n\nWe hope to highlight DevX further and bring to you curated content about what truly makes for great developer experiences!\n\nDevX newsletter is community-driven\n\nAnother thing about Gitpodders is that we&#39;re all driven by community feedback, and this newsletter is no exception! Please send us your thoughts, feedback and help us drive this conversation. We may even feature some of your takes and comments in future newsletters!\n\nCome and hang out with us over on our Discord channel.","metadata":{"source":"https://gitpod.io/blog/ephemeral-dev-envs"}}],["97",{"pageContent":"To celebrate Open Source and Hacktoberfest, we&#39;re stoked üßô‚ú®ü•∞ to announce contribute.dev, a list of welcoming open-source projects featuring ready-to-code Gitpod setups.\n\ncontribute.dev projects list\n\nSetup for all of the listed projects is completely automated with the help of Gitpod. So within seconds, you get a fully working developer environment, including a VS Code-like interface and a cloud-based Linux container configured specifically for the project. All you need is a browser!\n\nFor getting started with the project of your choice just hit the blue Open in Gitpod button in the bottom right corner:\n\ncarbon, a project on contribute.dev\n\nThis will launch a ready-to-code environment with everything setup (like the dependencies pre-installed and the web server running) as shown below.\n\nGitpod Workspace\n\nNow you can make your contribution and once you&#39;re done you can do all sorts of cool stuff from within the full-featured Gitpod IDE like reviewing the changes that you made in the diff editor or making a Pull Request.\n\n##Want the same for your project?\n\nIf the project that you&#39;re looking for is not in the list please file an issue here &rarr; with a link to your repository and we&#39;ll help you set it up. Once the experience is great we&#39;re happy to add your project to the list.\n\nHappy contributing! ü•∞","metadata":{"source":"https://gitpod.io/blog/frictionless-oss-contributions"}}],["98",{"pageContent":"tl;dr:\n\nGitpod recently announced new funding and a completely new brand (read more) üçä.\nAs part of that, we rebuilt the website from scratch, replacing React &amp; Gatsby with Svelte &amp; SvelteKit.\nLook at the source code on GitHub or start the website in a Gitpod developer environment by visiting https://gitpod.io#https://github.com/gitpod-io/website.\nListen to the Svelte Radio episode &quot;Migrating from Sapper to SvelteKit&quot; where I shared more details.\n\n__SPLIT_HERE__\nWhat we had previously...\n\nPrior to April 8, 2021 the Gitpod website was built with React &amp; Gatsby and the source code is available on GitHub. A static site was deployed to Netlify and a Netlify function took care of processing HTML form submissions by sending the form content via email to the Gitpod team (e.g. contact us, enterprise license requests, etc.)\nWe leveraged the Gatsby ecosystem by adding plugins to the gatsby-config.js file which took care of things like Markdown parsing and embedding Youtube videos, among other things.\n\n... and why we started from scratch\n\nWhat was wrong with the previous stack? Why did we decide to rewrite the website with different technologies?\nOverall, Gatsby &amp; React is a great choice and gets the job done just fine. Many people are already familiar with React and are ready to contribute with minimal effort.\n\nHowever, at Gitpod we care deeply about developer experience &amp; productivity - this is what our product is all about afterall. This is where we believe Svelte and SvelteKit lead the pack in today‚Äôs web application development. By leveraging Vite, developing a SvelteKit web app is as instant as it gets, it even persists local state when hot reloading the web application!\n\nIn addition, we had an extremely tight timeframe from the start of the project to the announcement of our funding and the new brand. While I have had two years of experience with Svelte &amp; Sapper, the other three developers had not worked together previously and were not familiar with Svelte. Nevertheless, I was confident the rest of the team would pick up Svelte and be productive right away. To learn Svelte, all you really need is work your way through the tutorial.\n\nTo me, building a SvelteKit app from scratch felt less risky than modifying an existing Gatsby codebase!\n\nThis is especially true in our case where we had to apply a completely new brand across all pages and would have had to learn Gatsby too.\n\n__SPLIT_HERE__\nThe implementation\n\nSvelteKit‚Äôs public beta was announced at around the same time as we started our project. Knowing there would be bugs - the maintainers explicitly warned about that - we decided to start with a Sapper app. Sapper is the predecessor of SvelteKit and was well established. There was also a promise from the maintainers to provide a frictionless migration path.\n\nWith one week to go, we migrated from Sapper to SvelteKit (pull request). The team‚Äôs feedback was clear:\n\nVote on the SvelteKit developer experience\n\nRemember that frictionless migration we were promised? It was indeed smooth as butter! At this point, a huge thank you to the Svelte maintainers &amp; contributors for their incredible work ‚ù§Ô∏è !\n\nWe also configured Tailwind CSS, mdsvex and the adapter-netlify.\n\nGatsby plugins\n\nThe Svelte ecosystem is not (yet) as established as the Gatsby ecosystem. However, thanks to the flexibility of mdsvex, we were able to use some Markdown related remark plugins. For some use cases, we wrote our own plugins to cover specific needs.\n\nDana Woodman recently shared an interesting thought on the Svelte ecosystem that is worth paraphrasing: Many existing, vanilla JS libraries work effortlessly with Svelte which opens up an even wider ecosystem than what you get with React.","metadata":{"source":"https://gitpod.io/blog/from-gatsby-to-svelte"}}],["99",{"pageContent":"Lessons learned\n\nSvelte &amp; SvelteKit\n\nSvelteKit is in public beta and you may run into a rough edge or two - nothing though that makes it a showstopper. For example, we weren‚Äôt able to use prerendering to deploy static pages and launched the website with server-side rendering through a Netlify function instead. This has since been fixed, we upgraded to the latest version and the majority of pages are now static HTML files - taking full advantage of SvelteKit‚Äôs flexibility to mix &amp; match SSR, SPA and static pages.\n\nTailwind CSS\n\nWe configured Tailwind because the product team uses it and we want to align as much as possible. On the website team, only one out of four team members was familiar with it and we decided not to enforce the use of Tailwind. In hindsight, this was probably a mistake as there is now a mix of custom CSS and Tailwind that needs to be cleaned up over time. However, it was a risk mitigation worth applying given the tight deadline.\n\nGoing forward, we are likely going to develop a lightweight pattern library either by abstracting Tailwind classes in Svelte components or extracting components as per the Tailwind CSS docs.\n\nNetlify adapter\n\nA bug in the Netlify adapter caused a short-term headache because it completely ignored any redirects configured in the netlify.toml file. This is being worked on at the moment and we were able to apply a temporary workaround.\n\nDifferences between development &amp; production environments\n\nDue to the use of SvelteKit adapters, you may run into different behavior when you run in development vs production. I recommend you set up automated preview deployments for each pull request and also test locally with the generated production web app. In our case, we can start a production-like environment with npm run deploy &amp;&amp; npm start to verify code changes before we push the code.\n\nNo CSS on the error page\n\nWe noticed the routes/$error.svelte page lost all CSS when we deployed the web app (GitHub issue). We had to extract the header, footer and error page CSS into a separate CSS file and include it on the error page. Three days before our go-live date, that bug was fixed in SvelteKit.\n\n__SPLIT_HERE__\nConclusion\n\nWould we do it again?\nAbsolutely!\n\nWas it risky?\nA bit, due to the unknowns of SvelteKit‚Äôs beta label when we started the project, but given we had Sapper as a fallback option it was calculated risk. With today‚Äôs state of SvelteKit and the very recent bug fixes, the Sapper fallback is no longer needed and I recommend starting with SvelteKit.\n\nShould you use SvelteKit in production?\nI can now say with confidence, go for it. As you work on your web app, deploy it to a production-like environment frequently to avoid any deployment surprises.\n\nAll in all, I am excited about the future of web development not least because Svelte is redefining what modern web development looks like - both from a developer and end user experience!\n\nWhat‚Äôs next?\n\nHead over to https://github.com/gitpod-io/website to look at the source code or experience how we work by opening an ephemeral developer environment with the following button:\n\nOpen in Gitpod\n\nTo explore your own project in an online developer environment, prefix your GitHub, GitLab or Bitbucket repository URL with gitpod.io#. Learn more about that in the documentation.\n\nWe welcome community contributions üôè . Please let us know what you think of the website and its implementation.","metadata":{"source":"https://gitpod.io/blog/from-gatsby-to-svelte"}}],["100",{"pageContent":"TL;DR\n\nFrom static and brittle development environments to consistently reproducible, instant, ephemeral Cloud Development Environments (CDEs)\n\n\nAnnouncing our $25m Series A led by Tom Preston-Werner (Founder of GitHub) with existing investors increasing ownership and pebblebed, MongoDB Ventures, GTMfund, Tobi Lutke, Kent Beck, and Oliver Pomel joining the round\n\nDevelopers brought creative workflows of almost all knowledge workers to the cloud. At the same time, the workflow of writing software itself never left local computers. The hours of yak-shaving and friction this causes every week wastes calories and drags us away from flow. Gitpod exists to change that: from history-dependent cobbled local development environments to consistently reproducible, instant, ephemeral Cloud Development Environments (CDEs).\n\nIt feels good to give what we have been working on over the last years a name and shape the principles of it. CDEs lower the barrier and increase the ceiling - they enable more people to do more. For us, they are our internal product north star. We believe that the principles define the convenience threshold that, when surpassed, will make working with CDEs the standard for developers. Not because your engineering organisation dictates that, but because the developer experience is faster, more joyful, collaborative and secure.\n\nDeveloping software in the cloud is not about simply replicating an existing local workflow to somebody else&#39;s machine that happens to run remotely in a datacenter. Remote development is not the solution. The ‚Äòworks on my machine‚Äô problem continues to exist - it just moves from a local computer to a computer in the cloud. Long-lived development environments are stateful and brittle, wasting countless hours due to drifting configuration within software teams. We believe that the true opportunity is to remove friction and relentlessly improve the developer experience with the automation, collaboration and security benefits that the cloud provides.\n\nNo more configuration drift. CDEs are automatically created afresh for every task. This way code and development environment always align, and all contributors operate from a consistent configuration. No more ‚Äúworks on my machine‚Äù.\n\n\nPeace of mind. CDEs are independent of each other. Breaking one has no effect on others. Because CDEs are ephemeral, mistakes are no longer costly. No more struggling to ‚Äúfix your laptop‚Äù after upgrading to the latest version of something.\n\n\nParallelism and multi-track development. CDEs are plentiful. Quickly reviewing the change of someone else no longer means you have to ‚Äústash‚Äù or replace what you‚Äôre currently working on. Parallel activities can coexist independently. Inviting peers to what you‚Äôre currently doing does not break their current work stream.\n\n\nSpace to learn and play. CDEs remove barriers to play, learn and experiment with code, projects and repositories. Because there is no setup effort, and no risk of breaking the environment you‚Äôre working in, CDEs offer a great space to explore and learn about new technologies.\n\n\nSafe and Secure. Cloud Development Environments are short-lived, which shortens the attack windows in which resources, secrets or infrastructure could be at risk. Because CDEs are ephemeral, secrets and other credentials should be tightly scoped and short-lived, i.e. should they get compromised they would not be of much use for long. Cloud development environments are isolated from other work which reduces the impact of supply chain attacks. E.g. arbitrary code execution as part of a software build can only affect what‚Äôs in the CDE, and not everything that‚Äôs running on your laptop.","metadata":{"source":"https://gitpod.io/blog/future-of-software-cdes"}}],["101",{"pageContent":"Principles\n\nCDEs value the following principles:\n\nEphemeral over long lived\nA fresh, disposable development environment for every task.\n\n\nReproducible over cobbled together\nConsistently replicable without manual intervention.\n\n\nEffortless over arduous\nWith minimal friction and difficulty.\n\n\nIndependent over tangled\nIsolated and self-sufficient.\n\n\nAbundant over scarce\nInstantaneously obtainable, seemingly infinite.\n\n\nPowerful over constrained\nSupports the most expansive development activities.\n\n\nEquitable over requiring specialised skills\nLowers the barrier to software development.\n\n\nCollaborative over solitary\nEnables collaboration across time, space and practice.\n\nYou can read more under www.gitpod.io/cde.\n\n__SPLIT_HERE__\n$25m Series A to cross the convenience threshold for CDEs\n\nWe are proud that Tom Preston-Werner leads our $25m Series A with his largest investment to date in a private company. All existing investors including General Catalyst, Crane Venture Partners, Vertex Ventures US and Speedinvest are participating. New investors include amongst others pebblebed; GTMfund; MongoDB Ventures; Tobi L√ºtke (CEO Shopify) and Olivier Pomel (CEO Datadog) and Kent Beck, (signatory of the Agile Manifesto). We also extend our leadership with Mike Brevoort as Head of Product, Matthew Du Pont, Head of Sales and Sara Parker, Head of Customer Success &amp; Support. Sven decided to follow his passion and became Gitpod‚Äôs first Technical Fellow a couple of weeks ago - since that decision, he has the biggest smile on his face since we met.\n\nSo.. what will we do with the additional capital? We want CDEs to become the standard for modern software development. Everybody is rallied around crossing the convenience threshold and we will work on the following areas:\n\nPerformance and Security - CDEs should be available in an instant - seemingly infinite and secure. Customers trust Gitpod with their code, their data and their time. With this comes a great responsibility. Last week we announced our SOC2 Type II compliance. Roadmap items include dramatically faster startup times, improved resiliency and a new Gitpod Cloud offering for larger companies.\n\n\nIntegrations - Gitpod is a next-generation developer experience platform empowering developers to seamlessly assemble all of the resources they need, just in time. We are fostering a community of partners to create an ecosystem around better templates, plugins, provisioning and integrations. Roadmap items include a workspace plugin system, APIs, and increased extensibility.\n\n\nCollaboration - software development teams collaborate across time, team and roles. CDEs will create entirely new opportunities for team members to work more closely together. Roadmap items include preview environments and new collaborative workflows.\n\nWe want to build a lasting company on top of a paradigm shift that will change how the world writes software - for the better.","metadata":{"source":"https://gitpod.io/blog/future-of-software-cdes"}}],["102",{"pageContent":"Today, GitHub announced the private beta of GitHub Codespaces, which provide container-based dev environments for GitHub projects. At Gitpod, we are building a similar solution, and while GitHub‚Äôs Codespaces don‚Äôt fully implement everything we do, they truly embrace the notion of dev environments as code.\n\nThis is great news, because it really helps to explain why this is going to change professional software development entirely.\n\nDescribing developer environments in code has many benefits:\n\nIt eliminates onboarding friction: no matter if you are new to a project, need to go back to an old branch or just picking up development after a few weeks. Just go to your project and start coding immediately.\n\n\nRemote work becomes a breeze: now everyone can access source code more securely (no local copies) from any device, including Chromebooks and tablets.\n\n\nEverybody gets the same setup: this means that ‚Äúworks on my machine‚Äù situations are a problem of the past.","metadata":{"source":"https://gitpod.io/blog/github-codespaces"}}],["103",{"pageContent":"Everybody gets the same setup: this means that ‚Äúworks on my machine‚Äù situations are a problem of the past.\n\n\nWith Gitpod, you can even take snapshots of any state of your dev environment and share exact clones of it.\n\nIt is our vision that everybody can immediately start working in a fully set-up dev environment on any project, any branch, with any device, and at any time.\n\nAs software systems become more complex so do dev environments. Have you ever tried to develop a Kubernetes application locally, set up all the required infrastructure, and launch all microservices on your local machine? Halfway through you‚Äôll find that your expensive MacBook Pro is not a suitable replacement for a datacenter. Even if you eventually manage to get things working it won‚Äôt be smooth or remotely close to what you run in production.","metadata":{"source":"https://gitpod.io/blog/github-codespaces"}}],["104",{"pageContent":"When we started working on Gitpod, we had everything running locally in minikube, too. Very quickly we realized that this would not scale. Our SaaS offering is deployed in Kubernetes clusters across the globe‚Äîthat‚Äôs nothing you‚Äôd want to replicate locally.\n\nFor the past year the whole team has developed Gitpod in Gitpod. Everyone in the team can start coding on any branch immediately. That includes their own preview deployment which is already connected to and fully debuggable from their browser-based developer environment. For a more in-depth look at our development pipeline‚Äîand what‚Äôs in it for you‚Äîcheck out Chris‚Äô talk (inlined below) and our previous post on the matter.\n\nyoutube: dFMpXUsJcGM\n\nWhen reviewing a PR or starting work on that new cool feature, no developer wants to accidentally work with an old state. Imagine wasting hours hunting a bug that‚Äôs already fixed on master. Fresh working copies‚Äîand ideally dev environments‚Äîfor each task would be great.","metadata":{"source":"https://gitpod.io/blog/github-codespaces"}}],["105",{"pageContent":"Once dev environments have become code you can pre-build those dev environments ahead of time. Think CI for your development setup: on each change in the repository, Gitpod prepares a new dev environment for that change. Rather than having to manually adjust the tool versions, wait for all dependencies to download and for the code to compile, things are ready when you are. We call this continuous dev environments.\n\nGiven all these benefits, you might wonder why no one did this earlier. After all, developers automate the world on a daily basis. Thinking about it, it‚Äôs strange that most developers still set things up manually before they can get down to business.","metadata":{"source":"https://gitpod.io/blog/github-codespaces"}}],["106",{"pageContent":"There have been attempts to automate dev environments in the past (e.g. Docker, Vagrant, Cloud9). These early approaches always came with too many compromises, and their benefits did not quite outweigh the drawbacks. The biggest blocker was that developers could no longer use the powerful tools they normally would, most importantly an awesome Editor/IDE.\n\nThis has changed since, with VS Code, a web-technology based IDE has become so popular among developers. However, Microsoft has not open-sourced the browser version of VS Code. For GitHub, a Microsoft-owned company, this is obviously not an issue. For everyone else we have developed Eclipse Theia.","metadata":{"source":"https://gitpod.io/blog/github-codespaces"}}],["107",{"pageContent":"Theia provides the same functionality as VS Code, even supports VS Code extensions, and comes with an architecture that allows everyone to customize the IDE easily. It is developed as a true open-source, vendor-neutral project at the Eclipse Foundation *) and is adopted by Google, IBM, RedHat, SAP, arm, Arduino and many more. Mike Milinkovich wrote about the differences between Theia and VS Code recently.\n\nThis new generation of Theia-based Web-IDEs go way beyond online-playgrounds which are barely sufficient for web development or quick prototypes. Today, we can finally run a professional IDE in a browser tab.\n\n*) To avoid misunderstandings: Theia has technically nothing in common with the classic Eclipse IDE, but is an independent project under the umbrella of the Eclipse Foundation.\n\nWe are thrilled to see GitHub/Microsoft investing in automated developer environments as it will help convince developers around the world and get this new way of developing software adopted faster.","metadata":{"source":"https://gitpod.io/blog/github-codespaces"}}],["108",{"pageContent":"We are thrilled to see GitHub/Microsoft investing in automated developer environments as it will help convince developers around the world and get this new way of developing software adopted faster.\n\nBut most professional development happens on other platforms such as GitLab, Atlassian‚Äôs stack and of course good old GitWeb. Oftentimes companies even employ a mixture of these.\n\nTo also serve users beyond just GitHub, we have been focussing on integrating Gitpod with other platforms as well. In December we released support for GitLab, and integration with Atlassian‚Äôs Bitbucket (and Jira) will be available soon.\n\nChances are that you host your Git repositories or other dev infrastructure in a private cloud, or on a local network where they can&#39;t be accessed from the outside. Thus, a hosted IDE service must be on the same private cloud or network. This is possible with Gitpod Self-Hosted which can be installed on Kubernetes and does not require a connection to the public internet.","metadata":{"source":"https://gitpod.io/blog/github-codespaces"}}],["109",{"pageContent":"Today we are releasing a new version which brings Gitpod Self-Hosted on par with Gitpod.io. The new release includes better GitLab integration and a new admin UI. With Gitpod Self-Hosted you can now enjoy this liberating way of developing software with your own GitLab installation.\n\nGitpod Self-Hosted is free for up to five users, and a free trial month for unlimited users is available, too.\n\nWe are quickly headed into a wonderful future, where developers are no longer intimidated by tedious and outdated setup procedures. Professional software projects will provide automated, prebuilt developer environments that enable teams to start contributing, doing code reviews, reproducing bugs or just exploring new ideas immediately from any device securely.","metadata":{"source":"https://gitpod.io/blog/github-codespaces"}}],["110",{"pageContent":"CI/CD has taught us how versioned, reproducible infrastructure as code is key to scale modern software development. Now it is time to apply these lessons to our developer environments and furthermore improve our lead times getting from ideas to production.\n\nExperience the future of software development now!\n\nTry Gitpod.io","metadata":{"source":"https://gitpod.io/blog/github-codespaces"}}],["111",{"pageContent":"As software developers, we already spend a lot of our time in browsers. Be it for searching Google/StackOverflow, checking our latest Continuous Integration builds on Jenkins resp. Travis, or doing code reviews on GitHub, Bitbucket, or Gerrit. Also, communication with the team happens in web applications, such as Gmail, Google Hangout or Slack. The convenience of web applications and OAuth-based authentication allows us to use any computer to do most of our work immediately.\n\nHowever, when it comes to the actual coding and debugging, we have to prepare our local developer environments manually. We do this based on often outdated, incomplete or just plain wrong documentation. The transition from an online repository to the actual coding is a barrier that hinders thousands of possible contributions every day. Coding needs to get more accessible.","metadata":{"source":"https://gitpod.io/blog/github-flow"}}],["112",{"pageContent":"(Programming Environment - Dilbert by Scott Adams. Source: [http://dilbert.com/strip/2017-01-02)](http://dilbert.com/strip/2017-01-02))(Source: http://dilbert.com/strip/2017-01-02))\n\nBut that only needs to be done once, right? Unfortunately, no. Coding is a team sport. We are not just adding code, but also do code reviews or fix bugs on maintenance branches which often require a different setup. Moreover, today‚Äôs applications are loosely coupled compositions of independent microservices and sub-projects, written in different languages requiring different development setups. Consequently, we have to maintain setups for multiple projects and branches, trying to keep documentation in sync including all the cases for the different platforms. As a result, we are wasting precious time every day. We should spend this time and effort on more fun and productive things.","metadata":{"source":"https://gitpod.io/blog/github-flow"}}],["113",{"pageContent":"Once we have the setup, we run builds and test suites. Those processes are usually an excellent reason to grab a coffee because it is blocking our machine. Wouldn‚Äôt it be nice to push such workload to the cloud, where it not only runs faster but can easily be parallelized? Your computer stays calm and cool, and you still can have your coffee if you want.\n\nIn this article, I will walk you through an automated, cloud-based development workflow. Gitpod is based on Kubernetes, GitHub, and the new Eclipse Theia project ‚Äî a VS Code-like IDE that runs in modern browsers. You can think of it as an online IDE with deep GitHub integration (and soon other platforms), providing fully-featured developer environments with a single click for any GitHub project, issue, branch or pull request.\n\nAutomation","metadata":{"source":"https://gitpod.io/blog/github-flow"}}],["114",{"pageContent":"Automation\n\nStarting a workspace with Gitpod is much easier than with other cloud IDEs. Gitpod doesn‚Äôt require you to configure workspaces with container images, Git information and so on. Instead, you directly go to a GitHub repository and click the Gitpod-Button [see below]. Gitpod provides you with a ready to use workspace, so that you can immediately start coding without any configuration steps.\n\nButton provided by Gitpod‚Äôs browser extensionButton provided by Gitpod‚Äôs browser extension\n\nTo see the Gitpod button on the GitHub page, you would have to install a browser extension. Alternatively, you can manually prefix any GitHub URL with https://gitpod.io/#. For instance, clicking the following link will instantly provide you a development workspace for the Eclipse Theia project: https://gitpod.io/#https://github.com/theia-ide/theia","metadata":{"source":"https://gitpod.io/blog/github-flow"}}],["115",{"pageContent":"Of course, different projects need different setups. Gitpod has a three-stage process to determine the workspace configuration, e.g. what Docker image to use for development, what startup script to run, and which ports to expose:\n\nIt first looks for a .gitpod configuration file in the repository. Note, that it will check the state of the currently viewed commit. This allows you to keep working configuration for old states as well as trying a new configuration in a pull request.\n\n\nSecond, if there is no configuration in the cloned repository, a central repository called ‚Äòdefinitely-gp‚Äô is checked for configuration. It is a public repository which contains configurations for arbitrary GitHub projects. That is useful if you want to provide configuration for a repository you don‚Äôt have write access to. Everybody is invited to contribute to this.","metadata":{"source":"https://gitpod.io/blog/github-flow"}}],["116",{"pageContent":"As a last resort, Gitpod analyzes the repository and derives a suitable configuration from there. For instance, if the repository contains a yarn.lock file it will automatically run yarn install in the beginning.\n\nThe key takeaway here is that you can handcraft a Docker file that includes all the development tools you need for your project as well as any ports to be exposed or scripts you want to run when a workspace starts. You can put that configuration under version control, replacing the onboarding documentation with a formal, executable description. But there is more information in a GitHub URL that can be leveraged to keep us in the flow.\n\nIt‚Äôs All About The Context\n\nWhen creating a workspace, Gitpod will analyze the provided GitHub URL. If you are looking at a particular branch it will check out that branch; if you are looking at a specific file, it will automatically open that file in Gitpod‚Äôs IDE.","metadata":{"source":"https://gitpod.io/blog/github-flow"}}],["117",{"pageContent":"Some great features, which are heavily used on GitHub, are issues and pull requests. If you want to start working on a GitHub issue, you simply spawn a fresh workspace from the issue page on GitHub. Gitpod puts you into the right context, by automatically creating a local branch using the issue number and even pre-configures the commit message accordingly. All is set up for you to start coding and testing. Once you are happy with the changes you made, use the Git integration to create a commit and push it to a remote branch. Finally, you can even create the actual pull request right from within Gitpod.","metadata":{"source":"https://gitpod.io/blog/github-flow"}}],["118",{"pageContent":"Lastly, of course, when clicking the Gitpod button on a pull request, Gitpod beams you right into code review mode. A panel on the left will list the changed files, allowing you to go through them one by one. Changes are opened in the diff editor where you can also read and add review comments. And because it is a full IDE, we can navigate through the entire code base, run code or add commits at will. Approving the pull request is supported, too.\n\nInline code review commentsInline code review comments\n\nTheia IDE\n\nAll the smart automation doesn‚Äôt help if you end up with a bad development experience. So let‚Äôs talk about the IDE that powers Gitpod.","metadata":{"source":"https://gitpod.io/blog/github-flow"}}],["119",{"pageContent":"Inline code review commentsInline code review comments\n\nTheia IDE\n\nAll the smart automation doesn‚Äôt help if you end up with a bad development experience. So let‚Äôs talk about the IDE that powers Gitpod.\n\nTheia is an open-source project that has been in development for over a year now. In addition to the TypeFox team, other companies like Ericsson and RedHat are actively contributing to it. The Eclipse Che team is replacing their existing IDE with Theia, and companies like IBM already have public offers based on it. Theia just recently became an Eclipse project, to make sure it is developed in a truly open and democratic manner and that no single company is controlling its future.\n\nEven with all that momentum, it seems to be an unrealistic effort to develop a new IDE from scratch. Just consider how many years of development were put into projects like the classic Eclipse IDE or Visual Studio. Gladly, this is not what the Theia team is doing.","metadata":{"source":"https://gitpod.io/blog/github-flow"}}],["120",{"pageContent":"The most important building blocks for Theia are probably the Monaco editor and the use of protocols. Monaco is the code editor that supports VS Code and is very flexible, high-quality code editor written in TypeScript (JavaScript). Unlike VS Code, the Monaco editor widget can run in browsers.\n\nThe second ingredient is the use of protocols. The most popular one being the language server protocol [4].\n\nThe Language Server Protocol (LSP)\n\nThe LSP is an effort started by VS Code to allow using language services in a technology- and UI-independent manner. One of the first popular reusable language services came from the TypeScript team. Such a service is a simple headless process that provides language smartness to an editor / IDE through messaging.","metadata":{"source":"https://gitpod.io/blog/github-flow"}}],["121",{"pageContent":"For instance, a text editor, supporting the LSP, can ask a language server for completion proposals given a document and a cursor position. All the heavy lifting such as parsing, type resolution, and linting is done in the language server. The IDE only needs to know how to represent the returned information for the user, e.g. propose the completion proposals in a pop-up.\n\nAs of May 2018, there are 64 language servers listed on the official site covering all of the mainstream programming languages, such as JavaScript, Python, Java, C++ or Go. If something is missing, it is a good idea to search the web as the list is incomplete and new language servers are released every other week. If you want to build your own language server, there are SDKs for various languages ranging from TypeScript, Java and C# to Haskell. Finally, Xtext provides a full framework for implementing a language server for domain-specific languages.","metadata":{"source":"https://gitpod.io/blog/github-flow"}}],["122",{"pageContent":"The LSP allows moving mature code bases for language smartness to the future. The very popular Java language server which is not only used in Theia but also in Atom and VS Code is really a headless version of Eclipse‚Äôs Java Development tools.\n\nTheia uses and supports other protocols as well. For instance, debugging support is in the works and will support the Debug Adapter Protocol which connects Theia to 50+ existing debuggers.\n\nExtensibility","metadata":{"source":"https://gitpod.io/blog/github-flow"}}],["123",{"pageContent":"Extensibility\n\nBesides the ability to run Theia in browsers there is another important difference to VS Code: VS Code extensions are limited to what is exposed in the VS Code‚Äôs extension API. For instance, it is not possible to create a new view in a VS code extension. This is a serious blocker for more advanced extensions. Contrarily in Theia where extensions are first class building blocks an extension can deep integration and make use of everything. Even fully white-labeled products are possible due to its flexible architecture. That said, the Theia team is working on supporting VS Code extensions, additionally.\n\nOutlook","metadata":{"source":"https://gitpod.io/blog/github-flow"}}],["124",{"pageContent":"Outlook\n\nProviding automated and disposable workspaces that tightly integrate with GitHub projects and the different contexts eliminates time-consuming transitions and streamlines the developer experience. No more ‚Äòit works on my machine‚Äô conversations can happen, because everybody uses the very same setup, which matches the production environment. The smooth onboarding experience will not only help professional developers but lower the barrier for contributions on open-source projects and start coding in general.\n\nGitpod is currently going through a public beta phase, where it can be used on public repositories. We are working on improved security, better performance and more cool features. Also, Gitpod is getting support for integration with additional applications, such as Bitbucket, GitLab, and Gerrit.","metadata":{"source":"https://gitpod.io/blog/github-flow"}}],["125",{"pageContent":"Open-source projects like Kubernetes, Theia, TypeScript, VS Code and thousands of other libraries are the giant‚Äôs shoulders Gitpod is based on. We hope by offering free usage of Gitpod for public GitHub projects we can further support the flourishing landscape of open-source projects, making it easier for everyone to contribute and for maintainers to review those contributions.","metadata":{"source":"https://gitpod.io/blog/github-flow"}}],["126",{"pageContent":"At Gitpod we want to make developers‚Äô lives easier. Starting automated dev environments for your daily coding tasks is already very easy: Just prefix your repository URL with gitpod.io/# and you are ready to go. To make this even better, you can install a browser extension which adds a convenient button to any GitLab, GitHub, or Bitbucket repository that lets you launch a Gitpod workspace with one click.\n\nRecently we asked ourselves how we could streamline the integration with your daily routine even more. Today, we are super excited to share that we‚Äôve partnered with GitLab and built a native Gitpod integration in GitLab‚Äôs UI.\n\n__SPLIT_HERE__\nThe last missing piece in your GitLab DevOps pipeline\n\nGitLab is one of the most popular DevOps tools/platforms out there, used by more than 100,000 organisations across the globe. Through its Web IDE, simple edits can already be made today from within the application. However, for more advanced programming tasks, developers require a full developer environment.\n\nSuch dev environments not only include a professional IDE/editor with all the convenient plugins for the project at hand, but also things like compilers, build tools, code generators, databases, and application servers.\n\nUntil now GitLab users would set up and maintain a single dev environment on their local machines. It‚Äôs time to free engineers from wasting their time with such tedious tasks and apply the lessons learned from CI/CD and infrastructure as code to dev environments.\n\nWhy not automate the provisioning of dev environments? Teams should be able to spin up fresh environments for each new task without waiting or any manual steps involved.\n\nGitLab and Gitpod started a partnership to bring Gitpod&#39;s ready-to-code dev environments to GitLab. As a first result of this collaboration you can now launch cloud-based dev environments with one click directly from gitlab.com (even without the Gitpod browser extension).\n\nGitpod button on GitLab project page\n\n__SPLIT_HERE__\n‚ÄúEveryone can contribute‚Äù\n\nGitLab‚Äôs credo ‚ÄúEveryone can contribute‚Äù is a perfect fit for Gitpod because contributing becomes much simpler when you allow anyone to spin up a ready-to-code developer environment in a few seconds.\n\nGitLab‚Äôs engineers have worked on lowering the barrier to contributions on GitLab itself through a comprehensive contribution guide and even a GitLab Development Kit (GDK) that sets up your dev environment on your machine. But still, running the GDK installer takes at least 30 minutes to download and install dependencies, clone the GitLab repository, and start all services you need like the database, a webserver, etc.\n\nWe are currently helping the GitLab team to build a fully-automated Gitpod configuration for the GitLab source code. This makes contributing to the GitLab source code itself as easy as clicking a button. Instead of waiting half an hour for a bunch of libs and tools to get installed, with Gitpod you are productive within just a few minutes. Once this configuration is merged, you will be able to just click on the Gitpod button of the GitLab repository, and everything will be set up for your first GitLab contribution.\n\nGitLab integration quote\n\n__SPLIT_HERE__\nHook up your GitLab Self-Managed with Gitpod.io\n\nThe Gitpod integration is already live on gitlab.com today and is going to be part of GitLab&nbsp;13.5 which is released on October 22nd. At that point, you‚Äôll be able to connect your GitLab self-managed installation to gitpod.io, through a new feature that lets you register additional Git providers.\n\nFurthermore, you can Self-Host Gitpod (which is open source) on your own Kubernetes cluster and configure it with your GitLab instance. We have convenient installation scripts for GCP and AWS.","metadata":{"source":"https://gitpod.io/blog/gitlab-integration"}}],["127",{"pageContent":"What‚Äôs next?\n\nWe are continuously working on improving the GitLab integration and implementing new features for GitLab users (e.g. managing merge requests within Gitpod, adding a Gitpod button on Merge Requests, etc.). You can also install the GitLab VS Code Extension in Gitpod to interact with GitLab. Just go to the Extensions view (in the left vertical menu), search for ‚ÄúGitLab‚Äù and choose ‚ÄúInstall‚Äù.\n\nGitpod button on GitLab project page\n\n__SPLIT_HERE__\nTry the Gitpod integration now!\n\nThe GitLab integration is available at GitLab.com and in your self-managed GitLab soon. Don‚Äôt have a project at hand? Try the demo project Spring PetClinic which has a proper Gitpod configuration committed.\n\nYou are a passionate GitLab user? Please share your experiences with the Gitpod integration with us! Visit our community forum at community.gitpod.io, report bugs in the Gitpod repository, or send us an e-mail at &#115;&#117;&#x70;&#x70;&#111;&#114;&#x74;&#x40;&#103;&#105;&#x74;&#112;&#111;&#x64;&#46;&#x69;&#111;!","metadata":{"source":"https://gitpod.io/blog/gitlab-integration"}}],["128",{"pageContent":"Reviewing merge requests is part of a developer&#39;s everday life. The quality of code reviews is a crucial aspect of the development process. In reality, it often leads to just skiming the code changes and approving the merge request with a simple ‚ÄúLGTM‚Äù. One reason is that doing code reviews requires a context switch for the reviewer. For a careful review one needs to checkout the branch of the merge request, navigate through the code changes, build and test the changed software, ‚Ä¶ and hope that there will be no configuration drift or other inferences with the existing local development setup.\n\nThis is a situation where ephemeral development environments show their full strength. With Gitpod, you get a fresh development environment just for your review. It has everything set-up for reviewing the changes and will be closed once the job is done. For a head-to-head comparison between local and cloud based workflows for MRs I recommend reading Mike&#39;s blog post.\n\n__SPLIT_HERE__\nLaunch a preconfigured Gitpod workspace from a GitLab merge request\n\nStarting a Gitpod development environment is easy: Just add gitpod.io/# in front of a GitLab, GitHub, or Bitbucket URL in your browser&#39;s address bar and hit Enter. That&#39;s it.\n\nGitpod loves GitLab\n\nWith the native Gitpod integration in GitLab, it&#39;s even easier! Next to the Web IDE button you&#39;ll find a Gitpod button in a drop-down menu that has been introduced in GitLab 13.5. With the GitLab 14.2 release you&#39;ll find this button on all merge request pages. Just hit the button and a cloud development environment waits for your review.\n\nGitpod button on GitLab merge request\n\nThe GitLab docs provide you with further information on how to enable the Gitpod integration in your self-managed GitLab instance and how to use the Gitpod integration.\n\n__SPLIT_HERE__\nContribution to GitLab awarded with ‚ÄúGolden Fork‚Äù\n\nEvery release, GitLab selects a community contributor as a most valuable person (MVP) of the release which is recognized with the prestigious golden fork. In the 14.2 release Cornelius from Gitpod has been awarded for the contribution of the Gitpod integration in GitLab.\n\nGitLab MVP of release 14.2\n\n__SPLIT_HERE__\nFurther reading\n\nGitLab 14.2 release blog post\nBlog post ‚ÄúNative GitLab Integration‚Äù\nGitLab docs about the Gitpod integration","metadata":{"source":"https://gitpod.io/blog/gitlab-mr-gitpod-integration"}}],["129",{"pageContent":"We are happy to announce that you can finally enjoy Gitpod&#39;s frictionless ready-to-code dev environments on GitLab as well.\n\ngitpod loves gitlab\n\n__SPLIT_HERE__\nGetting started with GitLab and Gitpod\n\nStarting a dev environment for a GitLab project works just as with GitHub, i.e. you prefix any GitLab project URL with gitpod.io/#.\n\nYou can try it out with the Spring PetClinic example:\nhttps://gitpod.io/#https://gitlab.com/gitpod/spring-petclinic\n\nBesides the standard project URL, Gitpod supports\n\nopening file URLs\n\n\nopening branches\n\n\nopening issues\n\n\nopening merge requests\n\nDepending on the context, your dev environment will be initialized differently.\n\nFor instance, if you start a workspace from the issue context above, you‚Äôll get a fresh workspace with a new local branch based on master.\n\nThe new local branch will be named like &lt;username&gt;/&lt;issue-title&gt;-&lt;issue-nr&gt;, in my case it is:\nsvenefftinge/allow-skip-first-name-1 (if the issue title is too long, only the first few words will be included in the branch name).\n\nGitLab Issue Context\n\n__SPLIT_HERE__\nConfigure your project\n\nTo get the most out of Gitpod, you need to tell it how a perfect dev environment for your project looks like. Dev environments run as containers which you can configure through custom Docker files.\n\nFurthermore you can specify which tasks should run after a fresh checkout. Usually this includes build steps, downloading dependencies and running some unit tests. Read below&#39;s section on prebuilds, to make Gitpod automatically run these steps as a CI pipeline whenever someone pushes changes to your project.\n\nThere is much more you can do to make sure every team member gets a ready-to-code dev environment when they need one. Please refer to the docs for details.\n\n__SPLIT_HERE__\nPrebuilds\n\nGitpod‚Äôs prebuilt workspaces are key to providing ephemeral, ready-to-code dev environments for your branches and projects. You can configure Gitpod to run your project&#39;s build asynchronously every time someone pushes new commits or branches to your repository. So when a developer wants to start coding, she can, because everything is already prepared.\n\nEnabling prebuilds on your GitLab project is done by configuring a Webhook. But don&#39;t fear, you don&#39;t have to do that manually, just run a prebuild on your project and it will be configured automatically. To do that, use the prefix https://gitpod.io/#prebuild/, as in\n\nhttps://gitpod.io/#prebuild/https://gitlab.com/&lt;myuser&gt;/&lt;myrepo&gt;\n\n__SPLIT_HERE__\nWe Need Your Feedback\n\nAll important features in Gitpod go through a beta phase, so you get the chance to try it early and participate in further development of the feature. So, please let us know with anything that bugs you or any ideas you have that could make your daily life with GitLab and Gitpod more seamless. ‚ù§Ô∏è\n\n__SPLIT_HERE__\nI run GitLab Self-Managed!\n\nIf you want to use Gitpod with your self-managed instance of GitLab, you&#39;ll need to wait a bit longer for Gitpod Enterprise (or apply for our private beta).\n\nGitpod Enterprise will be released soon and allows to run Gitpod either self-managed or managed by us. Gitpod Enterprise runs on Google Cloud or any vanilla Kubernetes installation and can be configured to connect with any GitLab or GitHub installation.","metadata":{"source":"https://gitpod.io/blog/gitlab-support"}}],["130",{"pageContent":"Last Monday, we hosted our first ever in-person community meet-up in Paris, France. Our passionate French community and Heroes helped guide our decision on choosing France as our kick-off location. It seemed like a fitting initial location to bring us all together. ü´∂\n\nThe Heroes program recognises developers that go above and beyond to contribute to Gitpod. By being part of the program you get exclusive perks and benefits. For example, Gitpod community heroes get to preview upcoming features and are involved in discussions with Gitpod engineers and product managers.\n\nWe want to empower Heroes to create opportunities with Gitpod for them to succeed! For instance, recently, Heroes Palani and Henit have been building a Raycast extension using the upcoming Gitpod public API with support from IDE product manager, Lou and DevRel Engineer, Siddhant. We‚Äôve also brought Heroes on our virtual community stage during our Office Hours and reviewed content by Heroes.\n\nFor the last two years, the Gitpod Community has mostly existed in the digital world. Although distributed across different platforms, we wanted to explore fostering real life connections.\n\nGitpod Paris at Zenika\n\nOur Hero, Jean-Phi Baconnais who is a serial conference speaker and events organizer was super enthusiastic about hosting our first meet-up. When I approached him with the idea in December, we already had the ball rolling from that first chat and in just a few weeks, the event was live and happening in\nZenika‚Äôs Paris office. üá´üá∑\n\nTalk about Shipping Skateboards! üõπ\n\n__SPLIT_HERE__\nLightning talks are the core of the meetup ‚ú®\n\nThe evening was structured with four lightning talks from myself, Jean-Phil, Oliver and Horacio. All the talks except mine were in French, where our Heroes shared their use cases and demos of using Gitpod. At future local meetups, we also want to explore discussion rounds and Gitpod hackathons. If you have an idea, let me know on Discord or Twitter.\n\nYou can catch up with the talks from our Paris meetup below!\n\n__SPLIT_HERE__\nConnecting with our community around the world üåé\n\nThe topic of connection is both a personal and professional goal of mine - connecting with myself and others - and so, this opportunity with our community, users and Heroes excited me! There are many learnings from this meet-up that we‚Äôre looking forward to applying to future community events.\n\nThank you to attendees and speakers for the energy and love for Gitpod, we‚Äôre so excited to continue supporting and collaborating with you all. üß°\n\nGitpod Paris selfie\n\n__SPLIT_HERE__\nHost a Gitpod meetup in your city üåÉ\n\nAre you interested in hosting a local Gitpod meet-up in your city?\n\nThey are an opportunity to connect with others in the community and learn and share the best Gitpod practices and knowledge. It is also a way to bring our primarily virtual Gitpod community to life! üòä\n\nThe Gitpod Community Team is here to help you be as successful as you can be with your local group! These are the ways we can help:\n\nSpreading the word: We will also help spread the word to users in your area and share it on our official communications channels\nOffering swag for attendees\nA budget for food and beverages\nDepending on location, we could also have a Gitpodder in your area attend to give a talk or support in person\nCreating a channel on our Discord server for you to chat with attendees and organizers\n\nReady to go? Follow our guidelines and let us know in the #contribute channel on Discord. Hopefully see you in the next event! üëã","metadata":{"source":"https://gitpod.io/blog/gitpod-comes-to-your-city-host-a-community-meet-up-with-gitpod"}}],["131",{"pageContent":"Developers architect our future. Moving software development to the cloud is the next logical step in automating our software delivery pipelines on our path to build the developer experience company.\n\nWith Gitpod we want to remove all friction from the developer experience to be always ready-to-code and make software engineering more collaborative, joyful, and secure.\n\nAs we scale the company around the globe, we started to formalize our culture, write down what we stand for and how we will move towards our purpose. We hope this helps you to understand who we are.\n\nThis is what core values are about. Core values define who we are. They are an authentic representation of where we are coming from and a guiding compass on where we are going. They are horizontal to our work, our community, and the products and services crafted on Gitpod. As we are growing, who we are matures side-by-side and while some of these values stay with us, others will need to be adapted over time.\n\n__SPLIT_HERE__\nWe, not me\n\nWe show up for the team, not for ourselves. We trust and empower each other. We make heroes and unblock others.\n\nPsychological safety and diversity of gender, race, thought, and otherwise are foundational for high-performing teams. When people feel safe and know they are valued for who they are, everything they produce becomes excellent. We make equitable space at the table.\nEgo is the enemy - we think more about each other than ourselves. In turn, you get a team that is rooting for you every single day.\nAsynchronous work allows for more time to build and less time wasted in meetings. It is inclusive for our global team and enables collaboration, no matter the timezone.\n\n__SPLIT_HERE__\nIntegrate, don‚Äôt dictate\n\nWe are humble and kind. We first seek to understand, then be understood - with products and people around us.\n\nOrthogonality is baked into our product design and How we work. We don&#39;t build new solutions if there is an existing widely adopted one. We strive for sane reusable abstractions that can be composed in ways we haven&#39;t anticipated. We build on the success of others.\nOur community is the heartbeat of Gitpod. Their feedback drives our product and helps shape how and what we prioritize. We are committed to fostering connection by supporting and empowering our community.\nBuild in the open. Transparency helps build a community of trust. Openness creates access between Gitpod and our community helping us stay ahead. Public when possible, private when necessary.\n\n__SPLIT_HERE__\nStudents of the game\n\nWe build and learn in the open - always with curiosity. We invest in our personal and professional development.\n\nA culture of feedback helps us grow. With positive intent and selflessness in mind, we freely and respectfully give and receive feedback to better ourselves and Gitpod as a whole.\nWe stay entrepreneurial developing resilience and agility. We commit to being stretched and increase our tolerance in adversity.\nWe operate as managers of one, taking personal responsibility for commitments, growth, and development. Everyone takes ownership of their responsibilities and is accountable for accomplishing them.","metadata":{"source":"https://gitpod.io/blog/gitpod-core-values"}}],["132",{"pageContent":"Ship skateboards\n\nWe tackle hard problems with simple solutions that delight. We commit and ship the minimal viable change, then iterate quickly.\n\nShip it. We can produce value only when we put our work in front of users. Work in progress amounts to cost; loose ends never pay back those costs. Only when we ship things does our work pay off.\nMinimal viable change. The simplest and quickest solution to a problem is often the best solution. We break problems down as small as possible to create the biggest impact. We build skateboards, then cars and we don‚Äôt stop there.\nImpeccable agreements. Trust with each other is vital to ship. We are committed to doing what we say we‚Äôll do and communicating when something changes.\n\nWhen we announced the core values during our (first ever!) offsite in Portugal in March 2022, we gave every Gitpodder an actual Gitpod skateboard with a print of our value 3D icons and a hanger to put the deck on the wall. We‚Äôve also included the icons as Emojis in Slack and we already start seeing new habits from Gitpodders asking during their day to day work: &#39;What‚Äôs the üõπ for this problem?&#39;\n\nyoutube: IMpl5dtWIlU","metadata":{"source":"https://gitpod.io/blog/gitpod-core-values"}}],["133",{"pageContent":"TL;DR","metadata":{"source":"https://gitpod.io/blog/gitpod-for-opensource"}}],["134",{"pageContent":"Today we are announcing our ‚ÄúGitpod for Open Source‚Äù program.\nGitpod has formed a new team to support open source (ps we are hiring) and personalized support is now available to open source maintainers / communities.\ncomplimentary Gitpod Self-Hosted licenses are now available for projects that maintain their independence via running their own infrastructure (ie Haskell, Drupal, Rust). Apply via this form.\nFree and open source software projects aligned with FOSSHost can request an account upgrade to a complimentary professional open source account via this form.","metadata":{"source":"https://gitpod.io/blog/gitpod-for-opensource"}}],["135",{"pageContent":"Free and open source software projects aligned with FOSSHost can request an account upgrade to a complimentary professional open source account via this form.\nOver 18,000 people in the GitHub ecosystem have been pre-qualified for complimentary professional open source accounts with unlimited hours. If you are in the short-list your account will be automatically upgraded either upon account creation or when you next start a workspace with your existing account. No action is required.If you had published a Visual Studio Code extension, Emacs or Vim plugin on GitHub before this blog post went live then you are likely on the shortlist.\nIf your membership was public before this blog post went live on one of more of the following GitHub organizations then you are likely on the shortlist:","metadata":{"source":"https://gitpod.io/blog/gitpod-for-opensource"}}],["136",{"pageContent":"alpinelinux, angular, apache, apple, archlinux, babel, caddyserver, cake-build, cakephp, centos, clojure, cncf, cockroachdb, curl, darktable-org, dart-lang, django, docker, dotnet, eclipse, elastic, elixir-lang, endeavouros-team, erlang, expressjs, facebook, flutter, fody, freebsd, fsprojects, ghc, gnome, golang, haproxy, hashicorp, haskell, homebrew, illumos, jaegertracing, jetbrains, julialang, jruby, k3s-io, kubernetes, laravel, libressl-portable, llvm, lua, maintainers, mathworks, microsoft, moby, mongodb, mono, mozilla, mysql, neovim, netbsd, nginx, nixos, nodejs, npm, obsproject, ohmyzsh, open-telemetry, openjdk, openresty, openssl, particular, perl, phoenixframework, php, pnpm, postgres, python, r-lib, rails, redhat-developer, redis, rethinkdb, rstudio, ruby, rust-lang, scala, serilog, sixlabors, sparklemotion, spring-projects, statiqdev, sveltejs, symfony, tailwindlabs, tc39, tmux, twbs, videolan, vim, vuejs, wolfssl, womenwhocode and xunit","metadata":{"source":"https://gitpod.io/blog/gitpod-for-opensource"}}],["137",{"pageContent":"Projects, communities and maintainers that use GitLab (or Bitbucket) or that are not in the above list can use this form to request an upgrade of your account to our complimentary professional open-source plan.\n\nHowdy folks,\n\nI‚Äôm gonna assume this is the first time you have heard about Gitpod and build from there because context is important. Gitpod is an open-core open source project and company that provides reproducible software developer environments. Gitpod can be consumed as a service or Self-Hosted on your own infrastructure.\n\n‚ÄúGitpod totally changed the development velocity for RedwoodJS ‚Äî it removed any issues related to configurations of dev environments and made it incredibly easy to contribute. Reviewing pull requests is delightful because they are prebuilt and ready for review!‚Äù\n\nTom Preston-Werner, Co-founder of RedwoodJS (and GitHub)","metadata":{"source":"https://gitpod.io/blog/gitpod-for-opensource"}}],["138",{"pageContent":"Tom Preston-Werner, Co-founder of RedwoodJS (and GitHub)\n\nSimilar to developer experience, Open Source is part of Gitpod‚Äôs DNA. It wouldn‚Äôt have been possible for us to create Gitpod without all of the amazing open-source work it‚Äôs built upon. And still, we‚Äôre developing huge parts of Gitpod out in the open. Not only is Gitpod an open source company, but our product is positioned to remove one of the biggest hurdles before developers can contribute to open source: setting up the developer environment..\n\n‚ÄúI&#39;m using Gitpod almost daily when trying out new technologies, working on OSS PRs/repros or when giving demos. Welcome to the promised land of cloud developer environments.‚Äù\n\nJohannes Schickling, Co-founder of Prisma\n\nIf we critically look at how commercial software is currently developed, people have cobbled-together sets of build tools, packages, runtime environments, and IDEs that they all desperately try to maintain as needed to ship their own software to their customers.","metadata":{"source":"https://gitpod.io/blog/gitpod-for-opensource"}}],["139",{"pageContent":"That‚Äôs a rather simplistic view of the world however. Software in 2022 is made up of other software and a myriad of tools that are built and maintained almost exclusively by unpaid volunteers. Each one of these open source dependencies also have cobbled-together sets of build tools, packages, runtime environments that are needed to produce the artifacts that are needed by the consuming software.\n\nThese toolchains can be incompatible with each other thus introducing friction and risk that contributing patches back to open source projects will break the ability to ship software to customers. To make matters worse, this problem can be easily solved and an incredible amount of time is expended on toolchain setup activities that are no longer required because Docker now exists.","metadata":{"source":"https://gitpod.io/blog/gitpod-for-opensource"}}],["140",{"pageContent":"Consider the common scenario where people work different Python apps with different dependencies (including C/FFI) running against different Python environments. What if you didn‚Äôt have to remember to run the right commands and click the right buttons in your editor to get everything working correctly? Instead, you just clicked a button and spun up an environment isolated from everything else, with the right tools and packages and runtime environment for that codebase?\n\nCloud-based, reproducible developer environments are a sleeper technology that‚Äôs going to ramp up for a decade in usage until, one day, everyone will be ‚Äúbehind the times‚Äù if they‚Äôre not already using them. I see it as similar to git, where the possibilities are endless, the model is superior, work evolves around it as an ecosystem builds up around it, and then it‚Äôs the new normal.\n\nPhillip Carter, Senior Product Manager at Honeycomb","metadata":{"source":"https://gitpod.io/blog/gitpod-for-opensource"}}],["141",{"pageContent":"Phillip Carter, Senior Product Manager at Honeycomb\n\nThat isn‚Äôt some dream. It‚Äôs actually possible today, and it&#39;s only going to become more capable and widespread over time. By converting the steps in an open-source project‚Äôs ‚ÄòCONTRIBUTING.md‚Äô into a Dockerfile contributors that use Gitpod can spin up an environment with a single button press, author contributions, debug it, do whatever from any device and from anywhere. Everyone can contribute even if they don&#39;t have access to powerful (expensive) computers.\n\nGitpod is equally delightful for open source maintainers as well:","metadata":{"source":"https://gitpod.io/blog/gitpod-for-opensource"}}],["142",{"pageContent":"Gitpod is equally delightful for open source maintainers as well:\n\nCode anywhere, on any device. No need for over powered laptops, a chrome book and even an iPad will work just fine.\nGitpod prebuilds developer environments whenever there&#39;s a commit to a repository or a pull-request is raised.\nGone are the days of typing ‚Äúgit clone‚Äù &amp;&amp; ‚Äúgit pull‚Äù by hand. Open each pull‚Äìrequest you wish to review in a new browser tab or another desktop editor window and everything is restored, precompiled and ready to go.\nWith Gitpod, people can contribute to your project with a single click. Tedious environment setups, contributing guides and maintenance activities no longer exist. You&#39;ll receive more contributions and contributions are easier to review!\nBy using Gitpod, no packages or dependencies are downloaded to your devices which helps contain security incidents by inhibiting malicious actors pivoting towards completely compromising your workstation.","metadata":{"source":"https://gitpod.io/blog/gitpod-for-opensource"}}],["143",{"pageContent":"‚ÄúWith Gitpod, I can review any pull request in a full coding environment where I can edit, build, and test the contribution, by just prepending &quot;http://gitpod.io#&quot;. Gitpod makes the pull-request review process so much nicer for me and I no longer have to do any local checkouts.‚Äù\n\nJulius Volz, Co-founder of Prometheus","metadata":{"source":"https://gitpod.io/blog/gitpod-for-opensource"}}],["144",{"pageContent":"Benefits\n\nPeople and projects who qualify for Gitpod‚Äôs Open Source program are provided with unlimited hours for usage on public repos. Contributors to an open-source project are provided with a generous free plan for up to 50h a month, including private repos.\ncomplimentary Gitpod Self-Hosted licenses are available for projects that maintain their independence via running their own infrastructure (ie Haskell, Drupal, Rust).\nPersonalized support is now available to open source maintainers / communities.\n\n__SPLIT_HERE__\nWho is eligible?\n\nTo qualify for Gitpod‚Äôs Open Source program, you need to meet one of this criteria:","metadata":{"source":"https://gitpod.io/blog/gitpod-for-opensource"}}],["145",{"pageContent":"__SPLIT_HERE__\nWho is eligible?\n\nTo qualify for Gitpod‚Äôs Open Source program, you need to meet one of this criteria:\n\nYou are a maintainer, core contributor to a well-established free software or open-source project.\nYou regularly contribute to free software or open source communities in other ways (e.g. producing regular content like blog posts, videos, live streams, translations, or organizing meet-ups, conferences, hackathons, etc).\nYou are an author, core contributor of extensions for editors such as VSCode, VIM, Emacs, et al. or of developer tools such as build systems, programming languages, compilers, and editor tooling such as Language Server Protocol (LSP) implementations.\nA significant part of your income (employment or via community support) is from maintaining or producing open source work.\n\n__SPLIT_HERE__\nHow do I apply?","metadata":{"source":"https://gitpod.io/blog/gitpod-for-opensource"}}],["146",{"pageContent":"__SPLIT_HERE__\nHow do I apply?\n\nVia this form but you might not need to. Over 18,000 people in the GitHub ecosystem have been pre-qualified for complimentary professional open source accounts with unlimited hours. If you are in the short-list your account will be automatically upgraded either upon account creation or when you next start a workspace. No action is required.\n\nIf you had published a Visual Studio Code extension, Emacs or Vim plugin on GitHub before this blog post went live then you are likely on the shortlist.\n\n\nIf your membership was public before this blog post went live on one of more of the following GitHub organizations then you are likely on the shortlist:","metadata":{"source":"https://gitpod.io/blog/gitpod-for-opensource"}}],["147",{"pageContent":"alpinelinux, angular, apache, apple, archlinux, babel, caddyserver, cake-build, cakephp, centos, clojure, cncf, cockroachdb, curl, darktable-org, dart-lang, django, docker, dotnet, eclipse, elastic, elixir-lang, endeavouros-team, erlang, expressjs, facebook, flutter, fody, freebsd, fsprojects, ghc, gnome, golang, haproxy, hashicorp, haskell, homebrew, illumos, jaegertracing, jetbrains, julialang, k3s-io, kubernetes, laravel, libressl-portable, llvm, lua, maintainers, mathworks, moby, mongodb, mono, mozilla, mysql, neovim, netbsd, nginx, nixos, nodejs, npm, obsproject, ohmyzsh, open-telemetry, openjdk, openresty, openssl, particular, perl, phoenixframework, php, pnpm, postgres, python, r-lib, rails, redhat-developer, redis, rethinkdb, rstudio, rust-lang, scala, serilog, sixlabors, sparklemotion, spring-projects, statiqdev, sveltejs, symfony, tailwindlabs, tc39, tmux, twbs, videolan, vim, vuejs, wolfssl, womenwhocode and xunit","metadata":{"source":"https://gitpod.io/blog/gitpod-for-opensource"}}],["148",{"pageContent":"For projects, communities and maintainers that use GitLab (or Bitbucket) or that are not in the above list please use this application form to request an upgrade of your account to our complimentary professional open-source plan.\n\n__SPLIT_HERE__\nHow do I know if my account has been pre-qualified?\n\nStart a Gitpod workspace then head to your dashboard. If you don&#39;t have an account then you can create one by starting any workspace (ie. such as Doom). If you see ‚ÄúYou are currently using the Professional Open Source plan‚Äù on your dashboard then your account has been upgraded.\n\n__SPLIT_HERE__\nHow do I get started?\n\nYou can start your first Gitpod workspace by prefixing https://gitpod.io# to your project&#39;s source control address.\n\nFor example:\n\nhttps://github.com/gitpod-io/doom becomes https://gitpod.io#https://github.com/gitpod-io/doom\n\n__SPLIT_HERE__\nRecommended Reading","metadata":{"source":"https://gitpod.io/blog/gitpod-for-opensource"}}],["149",{"pageContent":"For example:\n\nhttps://github.com/gitpod-io/doom becomes https://gitpod.io#https://github.com/gitpod-io/doom\n\n__SPLIT_HERE__\nRecommended Reading\n\nhttps://www.gitpod.io/screencasts/getting-started-with-gitpod\nhttps://www.gitpod.io/docs/configure/projects/prebuilds\nhttps://www.gitpod.io/docs/configure/user-settings/dotfiles\nhttps://www.gitpod.io/docs/references/gitpod-yml","metadata":{"source":"https://gitpod.io/blog/gitpod-for-opensource"}}],["150",{"pageContent":"Anything else?\n\nEmail me at geoff@gitpod.io. Happy hacking!\n\nps. If your open-source software appears in our bill of materials then Gitpod would like to unconditionally shout you some beers or more as our way of saying thank-you. Thanks for reading üß°","metadata":{"source":"https://gitpod.io/blog/gitpod-for-opensource"}}],["151",{"pageContent":"TL;DR\n\nWith ‚ÄúGitpod for Startups‚Äù, we offer eligible companies a 50% discount for up to 2 years\nGitpod remains discounted, even as you scale your workload and your engineers\nCDEs enable startups to build great things, faster\n\nWhen building great things, the last thing you need is unnecessary friction that slows you down and diverts your focus. We understand that, we‚Äôre in the same boat ‚õµÔ∏è.\n\nWith Gitpod you&#39;ll improve your developer experience, morale and productivity to be able to focus more on what really matters: being creative and writing code.\n\n__SPLIT_HERE__\nFor startups, that‚Äôs even more important. Why?\n\nWell, to start with, there‚Äôs usually too much to do but not enough people (that‚Äôs normal). But exactly because of that we need to focus on the things that create value - and spending hours per week to set up and maintain dev environments surely doesn‚Äôt.\n\nWith a cloud based developer environment like Gitpod you can on-board new colleagues in seconds and can collaborate efficiently: Share running workspaces for pair programming, use port forwarding or share a snapshot as a copy of your dev environment with teammates.\n\nYou‚Äôll also likely work on features, bugs and PR reviews at the same time, but switching context usually is a hassle and time intensive task. With Gitpod, multi track programming is easy as you‚Äôre able to spin up multiple context-aware dev environments with a click. And close them when you‚Äôre done.\n\nIt also enables your team to code from anywhere, on any device. Don‚Äôt worry about getting expensive laptops or source code security. This comes in handy as most companies are moving towards (hybrid) remote work, so even working from the road wouldn‚Äôt be a problem.\n\nThe fact that big tech companies like Google, Facebook or Shopify or are working on similar, internal solutions for remote development strongly leads just emphasizes the trend that in a few years from now, cloud based, ephemeral developer environments will be the norm.\n\nSo we think you&#39;ll benefit from saying goodbye to local development early on, which is why we are providing a 50% discount as part of our ‚ÄúGitpod for Startups‚Äù program.\n\n__SPLIT_HERE__\nThe benefits\n\nUse Gitpod at a 50% discount for at least 1 year with unlimited users and usage. For your whole team, no matter how big you scale and how many engineers you hire during that time. If you‚Äôre affiliated with one of these organisations, you‚Äôll even get the benefits for 2 years.\n\n__SPLIT_HERE__\nWho is eligible?\n\nYour startup is eligible if it was founded less than 3y ago, has raised a maximum of $10m in capital and hasn‚Äôt been on a paid plan yet.\n\n__SPLIT_HERE__\nHow do I apply?\n\nCheck out our website for more details and the link to the application form. Once you‚Äôre part of the program, you‚Äôll get the chance for a personal onboarding call with our community engineers.\n\nWant to share program details with your colleagues or other startups? This Notion page might be handy.\n\nNote from authors: This blog post was updated on December 14, 2022 to reflect our updated pricing policy.","metadata":{"source":"https://gitpod.io/blog/gitpod-for-startups"}}],["152",{"pageContent":"We at Gitpod believe in making developer experiences better, and we are super excited to introduce Gitpod Installer üéâ, which makes Gitpod installations a breeze!\n\nGitpod is available as a SaaS and self-hosted product. It is composed of many components working together in a Kubernetes cluster. You can install everything in a single cluster or place separate components in multiple clusters. Initially, we used Helm to orchestrate the installation, but our Helm charts became complicated over time. Hence, the new Gitpod Installer came into existence.\n\n__SPLIT_HERE__\nThe fault with our Helm charts\n\nIn the last couple of years, as we kept building more and more features for Gitpod, our Helm charts started accumulating a lot of logic with an ever-expanding configuration surface. It all quickly grew out of hand. The Helm charts values.yaml rose to 750 lines. Many of these were not configurations but necessities to workaround due to Helm limitations.\n\nTo make the matter worse, we had many undocumented configuration values that we used only in production or core-dev but did not make sense for any other environment. The entirety of the Helm charts grew into a mammoth 7000 lines to accommodate all the variations. Helm charts are made from templated YAML using Go templates. At this scale, it was a tough job to maintain them. It became easy to make mistakes such as missing whitespaces and realising it much later while deploying and then spending hours spotting the root issue. Lack of editor support and static checks for Helm charts forced you to refer to the documentation often. All of this made it tedious to write Kubernetes configurations. It sometimes led to config drift between what your application expects and what Helm generated, leading to production outages.","metadata":{"source":"https://gitpod.io/blog/gitpod-installer"}}],["153",{"pageContent":"Gitpod Installer, the saviour\n\nWe started building the Gitpod Installer to make installation of Gitpod and maintenance of the installation scripts less painful. We wrote Gitpod Installer in Go, making it easier to manage, structure and reuse the code. Instead of dealing with YAML and templates, we deal with structs and functions which gets us type safety, runtime checks, and composition.\n\nUser-centric Installation surface","metadata":{"source":"https://gitpod.io/blog/gitpod-installer"}}],["154",{"pageContent":"User-centric Installation surface\n\nOne of the primary goals of the Gitpod Installer is to express the installation from the user&#39;s point of view. We want the Installer to reduce the knobs and switches the user has to encounter. Clever use of logic and abstractions in the Gitpod Installer helped us make the configuration much more expressive, and we could automatically deduce values for several technical configurations. It helped to reduce the configuration file from 750 lines to fewer than 50. It not only reduced the configuration surface but also removed the Helm specific hacks we had in place. In the ideal case, a user can generate a configuration, render the Kubernetes YAML and apply it to a cluster to get a Gitpod installer up and running in no time!\n\nBackwards compatibility to provide a clean update path","metadata":{"source":"https://gitpod.io/blog/gitpod-installer"}}],["155",{"pageContent":"Backwards compatibility to provide a clean update path\n\nWe chose to make the configuration file used by the Gitpod Installer carry an apiVersion. While loading the configuration, the Installer looks for the version and uses the corresponding loader. Each version contains its own set of validations, default settings and a migration path to higher versions. It allows us to introduce breaking changes in the configuration when needed while still providing compatibility and a migration path to configuration written for an older version.\nAchieving this is extremely difficult with Helm charts. We had to provide additional logic for backward compatibility on a best effort basis.\n\nVersion Manifest","metadata":{"source":"https://gitpod.io/blog/gitpod-installer"}}],["156",{"pageContent":"Version Manifest\n\nA Gitpod installation is a collection of builds of numerous projects. The version manifest provides the bill-of-materials required to run a complete Gitpod installation for a particular release. It guarantees that a specific release of Gitpod always runs with a deterministic set of services and dependencies. We generate the version manifest during build time and embed it into the Gitpod Installer.\n\nHelm Dependency Integration\n\nGitpod also depends on several third-party dependencies such as Minio, MySQL and RabbitMQ. Instead of reimplementing all the services to fit into the Installer framework, we reuse the community maintained Helm charts. We embed the respective Helm charts into the Installer, and during installation, we provide the required values and render the templates in isolation just like helm template would do. It helps us to leverage the excellent work already done by the Helm community while retaining control over the installation process.","metadata":{"source":"https://gitpod.io/blog/gitpod-installer"}}],["157",{"pageContent":"Eliminate drift between installation and services\n\nWhile using Helm charts, everything was defined using templated YAML. The developer&#39;s responsibility was to make sure that the config generated by Helm was in sync with the configuration the application expected. There were no additional checks beyond this until the application tried to load the configuration during deployment. In the past, it has created instances of drift between the Helm generated configuration and the application expectations, leading to production outages.\n\nInstaller directly utilises the config structs of applications and structs defined in the Kubernetes API library. It helps enforce type safety that will catch any configuration drift during compile time. The structs also define validation, which helps validate the user-supplied configuration to help catch errors early.\n\nSeparation of infrastructure and application concerns","metadata":{"source":"https://gitpod.io/blog/gitpod-installer"}}],["158",{"pageContent":"Separation of infrastructure and application concerns\n\nWe often merge the infrastructure and application concerns when we think of requirements. The requirements will vary per use-case for a product like Gitpod, which has both self-hosted and SaaS offerings. To isolate the requirements of application and infrastructure, the Installer performs validations separately. We have implemented infrastructure validations in Installer as cluster validations which checks whether the Kubernetes cluster meets all the requirements and has all dependencies required for Gitpod installation. We have defined configuration validations as the part of respective components, which checks the configuration separately while rendering or validating it.\n\nScalability within the Gitpod organisation","metadata":{"source":"https://gitpod.io/blog/gitpod-installer"}}],["159",{"pageContent":"Scalability within the Gitpod organisation\n\nThe Gitpod Installer sits horizontally across all teams at Gitpod and it was built with scalability across teams in mind. The Installer comprises building blocks called components that are strongly cohesive and independent of others. Each component is responsible for managing a single service in the Gitpod installation. Teams take complete ownership of their respective components and are free to evolve along with their services.","metadata":{"source":"https://gitpod.io/blog/gitpod-installer"}}],["160",{"pageContent":"Technical differences from Helm charts\n\nWhile developing the Gitpod Installer, we made the decision to be opinionated at times to build something that just works. This allows us to provide our experience of running Gitpod SaaS to owners of self-hosted implementations. Being opinionated provides stability and keeps everything on a standards track. It reaps immense benefits while troubleshooting when something goes wrong. We enforced these decisions as validation constraints for the Gitpod Installer at config and cluster levels. These are some of the decisions we took,\n\nThere can be only one installation per cluster which is due toFixed node affinities for services.\nFixed NodePorts for daemonsets.\n\n\nFix replica counts for services.\nExternal helm dependencies are embedded, hence non-configurable. We chose to do this because it gives us confidence that Gitpod is always running against a dependency that we have validated (like a known MySQL/RabbitMQ version)\nCert-manager is a required dependency for creating internal SSL certificates for components like the Docker registry as it eliminates manual cert renewal.\nThe Installer requires external certificates to be provided as a Kubernetes secret (tls.key and tls.crt). By requiring just the secret to be present, it allows for users who want to user cert-manager to provide their certificates as well as those who want to provide their certificates via a specific certificate authority.\n\n__SPLIT_HERE__\nBuilding Over Helm\n\nWhile building Gitpod, we have reused a lot of logic from Helm. We use the logic from helm template render to embed Helm charts for third-party dependencies and render them together with Installer components.\n\nWe also borrow the dependency sorting from Helm. Kubernetes objects have dependencies on each other and are best installed in a specific order. For example, if a secret changes after a pod has started, it will have the old value. Hence secret update needs to go before deployment. Since we also allow embedding Helm charts, we have no control over the generated YAML. To guarantee things work as expected, we parse and sort the generated YAML using the same strategy as Helm, which has been well-tested out.\n\n__SPLIT_HERE__\nWhat is Next?\n\nGitpod Installer has improved the installation experience of Gitpod. It helped us elegantly overcome Helm&#39;s limitations while simplifying the orchestrating of a project as complex as Gitpod. Both Helm chart and Installer remain supported for the time being, and we aim to have feature parity between the both.","metadata":{"source":"https://gitpod.io/blog/gitpod-installer"}}],["161",{"pageContent":"We are delighted to announce that Gitpod is officially SOC 2 Type II compliant effective today ü•≥. From the very beginning this has been a team effort. It involves every part of our organization, which is committed to continuously improve our security posture by designing, implementing and maintaining appropriate controls.\n\nInterested in the details? üïµÔ∏è‚Äç‚ôÇÔ∏è You can request a copy of our report by submitting our contact form and signing a non-disclosure agreement.\n\n__SPLIT_HERE__\nWhat was SOC 2 again?\n\nSOC 2 is the ‚Äúgolden standard‚Äù of security frameworks based on the Trust Services Criteria maintained by the American Institute of Certified Public Accountants (AICPA). It defines criteria for managing customer data and is well-recognized among companies across the globe üåç. For many, SOC 2 compliance is the requirement before considering a new vendor.\n\nSOC 2 shares similarities to ISO 27001, and comes with a top-down approach to implement security policies/technical controls that cover aspects of encryption, information handling, vulnerability and risk management as well as incident response, and business continuity.\n\nType I audits focus on one specific point in time while Type II audits capture a period of 6-12 months while also considering the effectiveness of controls. We skipped Type I in favor of a Type II as we know this would provide better assurance to you about our security program. üöÄ\n\n__SPLIT_HERE__\nGitpod Security Program\n\nWe acknowledge the relevance of providing a secure product and hence go beyond the scope of SOC 2 in protecting customer data and strive to improve everyday. In the following we want to highlight some key-aspects of our security program:\n\nüëÄ Gitpod is Open Source - ensuring more transparency and eyes on the code to spot issues\n\n‚òÅÔ∏è Gitpod is 100% cloud based - storage, computing resources and physical security measures are provided by the Google Cloud Platform (GCP)\n\nüì¶ Gitpod workspaces are isolated - each workspace operates in their own set of Linux namespaces, so that they cannot interfere with each other\n\nüß∞ Gitpod integrates with best-in-breed solutions such as Tailscale - to provide the best possible user experience and secured access to remote development environments\n\nüîë Gitpod is passwordless - authentication to Gitpod is established via OAuth with code repositories like GitHub, GitLab and Bitbucket\n\nüîí Data is encrypted - during transit (TLS 1.2 or above) and at rest (AES 256)\n\n‚úîÔ∏è Artifact provenance - Gitpod artifacts produce SLSA Level 1 compliant provenance allowing you to understand what went into our builds\n\nüì¢ Vulnerability Disclosure - we encourage feedback from Security Researches to help improve our security https://www.gitpod.io/security/report\n\nüëÆ‚Äç‚ôÇÔ∏è Security Governance - we continuously monitor our environment to detect and respond to emerging threats\n\n__SPLIT_HERE__\nLast but not least\n\nWant to find out more? Visit our Security Website or reach out to us anytime. We are thrilled for what comes next in an ever evolving landscape üöÄ","metadata":{"source":"https://gitpod.io/blog/gitpod-is-soc-2-type-ii-compliant"}}],["162",{"pageContent":"TL;DR\n\nGitpod and JetBrains announce partnership and deep product integration to bring remote development to developers around the world\nStarting today professional software engineers can work in reproducible developer environments provisioned by Gitpod using their favorite desktop IDE from JetBrains including IntelliJ IDEA, PyCharm, GoLand, and PhpStorm\nGitpod is the first 3rd party service that is natively integrated into JetBrains Gateway for a seamless remote development experience\nBenefit from improved developer experience, security, and collaboration while keeping the local editing experience with all shortcuts, keybindings and themes\nSkip the talking and get started now\n\nSince we started the company, we never wanted to be in the IDE or editor business. In fact, we are quite allergic to people thinking Gitpod is an online or web IDE. Gitpod is an open-source orchestration and provisioning platform for automated developer environments.\n\nThe goal has always been to integrate Gitpod with all editing experiences as soon as they support remote development - independent of the operating system (Windows, MacOS, Linux, Browser).\n\nToday we are making a big step towards that goal.\n\n03\n\n__SPLIT_HERE__\nKeep your tools, just automate them\n\nIf you look at professional software development, JetBrains IDEs remain the gold standard when it comes to programming language intelligence and tooling smartness. This holds true across all major programming languages. Period. Their depth and attention to detail is something we have always admired at Gitpod. We are not alone in this. The number one feature request of our larger customers is to connect their locally running JetBrains IDEs to automated Gitpod workspaces running in the cloud.\n\nWe now seamlessly integrate and bundle with their standalone Gateway application. This means we run an instance of your favourite JetBrains IDE on your Gitpod developer environment. All indexing, compiling and language processing happens in the cloud, while a thin client runs locally and provides the rich user experience you are already familiar with from your desktop IDE. To enable this experience we have internally built a SSH gateway (which also makes our vim and emacs users happy), re-designing our loading screen and expanding our /preferences to enable both Desktop and Browser based workflows. The result is available in today&#39;s beta release.\n\nWith our native Gitpod integration in JetBrains Gateway application, professional software developers can connect ephemeral developer environments provisioned by Gitpod to their favorite desktop IDE from JetBrains without any friction. Think power of the cloud including all developer experience, security, and collaboration benefits paired with the world&#39;s best professional IDEs.\n\n01","metadata":{"source":"https://gitpod.io/blog/gitpod-jetbrains"}}],["163",{"pageContent":"Entering the era of remote development\n\nIn August last year, we shipped a cake to GitHub for their Codespaces launch üéÇ. With today&#39;s announcement and product partnership, our industry reached a tipping point in the adoption curve of remote development. The large majority of the IDE/editing market now has built-in functionality to connect to developer environments running in the cloud. Keep the editing experience you are used to from your desktop IDE/editor/terminal including all your shortcuts, keybindings and themes that your muscle memory got used to.\n\nTake a step back and look at the benefits which led companies such as Google, Facebook, LinkedIn and Shopify to move software development to the cloud and form the basis of our purpose:\n\nBetter developer experience. Automated setup with cloud-based, remote developer environments connected with a developer‚Äôs editing experience of choice. This means developers no longer have to endure nerve-wracking set-up and maintenance of local developer environments. Start coding and get creative with one click - with the tools you are most productive with\n\n\nEfficient multi-track development. Have multiple workspaces with different configurations open at once - one for your feature, one for reviewing a PR/MR, or one for a bug.\n\n\nRemove the ‚Äòworks on my machine‚Äô discussion. Always start from a clean state - the end of all &quot;works on my machine&quot; situations due to long-living stateful environments. Spin up a workspace, code, push your code, and forget about it. For your next task, you‚Äôll use a fresh dev environment. Onboard new developers with one click.\n\n\nSecuring our software supply chain. No packages or dependencies are downloaded to users&#39; devices. Developer environments run in the cloud and are short-lived, protecting your local machines and other company resources from malicious attacks through execution of arbitrary code.\n\n\nPower of the cloud. Don&#39;t bother upgrading your developer&#39;s machine, with cloud-based, remote development the data center becomes your computer.\n\n\nBringing developer environments closer to production. Gitpod provisions powerful Linux containers under the hood. Workloads running on production are for a large part similarly running in containers on Linux. One operating system for both development and production.\n\n02\n\n__SPLIT_HERE__\nGetting started in 5 minutes\n\nIf you are interested in setting up a new Spring Boot project using Gitpod and JetBrains Gateway we wrote a detailed guide together with JetBrains. If you want to start your own project with Gitpod in your JetBrains IDE read on or refer to our documentation.\n\nyoutube: 8djaRYT2FAY\n\nInstall JetBrains Gateway\nInstall the Gitpod plugin - Open JetBrains Gateway and you&#39;ll see the Gitpod logo on the main page. Simply click &quot;install&quot; to install the Gitpod plugin within JetBrains Gateway.\nUpdate your Gitpod preferences - Select your preferred JetBrains IDE on the Gitpod preferences page to set your default IDE for future Gitpod workspace starts.\nStart (or restart) your workspace - Either start a workspace directly from within the JetBrains Gateway via the Gitpod plugin OR open a new workspace directly in Gitpod where on workspace start you will be prompted to open your preferred JetBrains IDE for that workspace. That&#39;s it.\n\nTo guide you and your team through the different adoption phases towards remote software development, other engineering organisations found the following resources helpful:\n\nCustomer Stories\nGitpod Adoption Stage 1 - Educate\nGitpod Adoption Stage 2 - Configure\nGitpod Adoption Stage 3 - Develop\n\nAnd if you haven&#39;t done so join our active Discord community - we are here to help! www.gitpod.io/chat\n\n&amp;nbsp\n\n05","metadata":{"source":"https://gitpod.io/blog/gitpod-jetbrains"}}],["164",{"pageContent":"DevX Conf on May 2-3rd\n\nIn case you are interested in learning more about remote development, next week we are hosting devxconf.org, a virtual &amp; free conference focused around making developers happier/more productive. The first panel will discuss all things remote development and will include folks from JetBrains and Gitpod.","metadata":{"source":"https://gitpod.io/blog/gitpod-jetbrains"}}],["165",{"pageContent":"Every day developers waste millions of hours switching contexts between projects and branches, setting up developer environments, or simply waiting for builds to complete.\n\nThis friction is not only time consuming but is a serious barrier for contributors. Reading through a long list of setup instructions and messing up your own laptop is just too much effort.\n\nToday, we are happy to announce the launch of Gitpod.io, an online service that provides disposable, ready-to-code developer environments for GitHub projects.\n\n__SPLIT_HERE__\nOne-Click Dev Environments for GitHub\n\nHere&#39;s how Gitpod works: You are on GitHub and want to start working on a project. Instead of going through the manual setups, etc. you simply click a button to start a ready-to-code dev environment in your browser. You can now code, review, or just try out the project. Once you are done you simply close the tab.\n\nGitpod button added by Gitpod browser extension\n\nDon‚Äôt see the button on GitHub yet? You need to install a small browser extension to get it. Alternatively, you can just prefix any GitHub URL with ‚Äúgitpod.io/#‚Äù.\n\nYou can try Gitpod right now. It&#39;s free for public repositories.\n\n__SPLIT_HERE__\nNo Setup\n\nNot all projects are equal. We maintain a developer friendly Docker image that includes all the commonly used tools and version managers. But you can point to your own Docker image in a .gitpod.yml file. Gitpod will pick it up and even build the image if needed. Read Gero&#39;s post for more details.\n\nWith Gitpod, contributors don‚Äôt need to go through a list of usually outdated setup instructions. Instead, they get exactly what they need for the project at hand with no additional effort. As a side-effect, any &quot;works-on-my-machine&quot; scenarios are eliminated, because every team member uses the same working setup on the same kind of machine in the cloud. Since the .gitpod.yml is versioned with the code, going back to old releases and branches becomes super easy, too. We call this dev environment as code.\n\nTo optimize the experience, the .gitpod.yml accepts further configuration, where you can automatically start builds, watchers and dev servers in multiple terminals. You can configure how they appear in the IDE layout and hook up all your web ports and previews.\n\nAs a project owner you should do everything you can to streamline the experience for contributors, so everybody including yourself can focus on being creative and writing code. Gitpod lets you automate the setup and make sure developers can access a dev environment that really is ready to code.\n\nA great example is ssloy&#39;s tinyraytracer project. It&#39;s a tutorial for raytracing in C++ and is configured so it runs the build and automatically opens the rendered graphics. The author has even added Gitpod buttons to individual steps in the tutorial to make following along easier.\n\nTinyraytracer Gitpod workspace\n\n__SPLIT_HERE__\nLess Waiting\n\nThere is an additional bit of friction that every developer has to go through regularly:\n\nRunning the build and downloading dependencies.\n\nStarting today, the new Gitpod app is available on the GitHub marketplace. It is the first of its kind and the only one in the new IDE category.\n\nOnce you&#39;ve installed the app for your GitHub repository, it will pre-build dev environments on every commit. So when anybody opens a Gitpod environment on your project, the dev environment is opened as described above. But now also the build ran through and all dependencies are already there.\n\nWe call this feature prebuilt workspaces and you can read more about it in Chris&#39; post.\n\nPrebuilt Workspaces","metadata":{"source":"https://gitpod.io/blog/gitpod-launch"}}],["166",{"pageContent":"More Flow\n\nYour dev environment opens differently depending on the GitHub page you are coming from. You can, for instance, open branches or files by simply going to the respective GitHub page and pressing the button (or prefixing the URL) there.\n\nWhen coming from an issue, Gitpod understands you want to fix it, so you‚Äôll get a fresh local branch and the commit message is prepared with a reference to the issue.\n\nStarting a workspace from a pull request will open in code-review mode. The list of changes is opened on the left so you can easily go through them and view the details in diff editors on the right. Of course, you can comment within the IDE and even submit your code review.\n\nEven if you prefer your local machine for development, being able to do deep code reviews in a browser is a great way to improve your workflow.\n\nInlined Code Review\n\n__SPLIT_HERE__\nA Complete IDE Running in the Cloud\n\nWhile Gitpod keeps the convenience and accessibility of online coding playgrounds and sandboxes, it is not a toy but a complete dev environment running in the cloud.\n\nWe teamed-up with Google, Ericsson, Arm and Red Hat to develop the open-source project Eclipse Theia. The project puts VS Code‚Äôs state-of-the-art technology and UX into the browser based on an extensible architecture that is optimized for the cloud.\n\nGitpod already comes with several VS Code extensions pre-installed (such as Go support from Microsoft‚Äôs own extension). We will be adding more popular VS Code extensions shortly, and later allow users to define any extensions they want.\n\nIn addition to one of the best code editors, Gitpod environments provide full featured terminals backed by Linux containers running in the cloud. As a result, you get the same command line tools you would use locally together with the hottest IDE tech available today. And all of that in a browser tab.\n\n__SPLIT_HERE__\nCollaboration\n\nGitpod comes with two major features supporting collaboration.\n\nSharing running dev environments with other users comes in handy if you want to look at code with a colleague to hunt down a bug together or do some pair programming. Collaborators will see the same code you see and even the terminals are synced and shared.\n\n\nSnapshots are useful in many ways. In a nutshell, they allow taking an immutable copy of your dev environment at any point in time. You can share the provided link wherever you want. Users opening such a snapshot link will get an exact clone of the environment including all state and even UI layout. This feature is great for sharing reproducibles in issues, but also good for blog posts or solutions on Stack Overflow.\n\nCollaboration: Share Running Workspace or Snapshot\n\n__SPLIT_HERE__\nPricing\n\nAn important part of leaving the beta was to find a good pricing model that addresses the needs for the various user groups.\n\nWe think we have found a good balance by providing the following individual subscription options:\n\na free 100-hour per month plan for open-source development\na paid 100-hour per month plan for individuals working privately\na paid unlimited plan for professional use\n\n(I know some of you are lucky enough to do professional open-source. Decide what works best for you in that case ;-))\n\nWe also offer team subscriptions, which allow managers to buy a batch of seats and assign them to the team.","metadata":{"source":"https://gitpod.io/blog/gitpod-launch"}}],["167",{"pageContent":"Thank You ‚ù§Ô∏è\n\nI want to take the opportunity to thank all the people who have helped to make Gitpod a reality: all the enthusiastic early adopters who provided great feedback during the beta phase; contributors who have helped by identifying bugs and by sharing their use cases; and of course the Eclipse Theia community working with passion on an open-source IDE platform for the future.\n\nFurthermore, I want to thank Michael Bernstein from Reify for clarifying our messaging with us and Kelly Fitzpatrick and the rest of the Redmonk team for their guidance and helpful feedback.\n\nFinally, of course, I want to send a big shout out to my friends at TypeFox. You are absolutely awesome and being able to work with you on such a great product is everything I want.","metadata":{"source":"https://gitpod.io/blog/gitpod-launch"}}],["168",{"pageContent":"The myriad of tools relied upon by developers every day is built and maintained almost exclusively by unpaid volunteers. The maintainers of open-source projects - our digital infrastructure - are in desperate need of support. Because code is less charismatic than a hit YouTube video or Kickstarter campaign, there is little public awareness and appreciation for this work.\n\nOpen-source, by design, is not financially sustainable. Finding reliable, well-defined funding sources is exceptionally challenging. As projects grow in size, many maintainers burn-out, find themselves unable to satisfy increasing support/maintenance demands and, unfortunately, in my particular case, irrevocably harm their marriage.\n\nRussell Keith-Magee delivered this beautiful keynote at PyCon, which captures the essence better than I can put in writing because it is such a personal topic.\n\nyoutube: 0t85TyH-h04\n\nMuch has changed since Russells&#39; keynote and the infrastructure to financially support open-source maintainers now exists thanks to the efforts of Open Collective and GitHub Sponsors.\n\n__SPLIT_HERE__\nShape the future you want to live in\n\nThe truth is free software isn&#39;t free. How much is a task going to cost in person hours? Hours have rates. Rates require payment. Yet, an entire community of developers provide their services outside of their day job to produce tools consumed by businesses.\n\nDid you know there are less than 2100 people in the inner GitHub open-source maintainer community?\n\nMaintainer Community\n\nI often wonder what the future would look like if these high achievers that our digital society is built upon were empowered to become independent artists. If just one of those people can help more people better understand a technology or improve the developer experience for an entire ecosystem what is the worth/value of that and why isn&#39;t our industry doing that yet?\n\nThe word volunteer, by definition, means those who have the ability and time to give freely.\n\nPaying for resources that are being consumed broadens the list of people who can do open-source. Additionally, money enables open-source maintainers to buy services and outsource the activities that do not bring them joy.\n\nMoney enables diversity\n\nAt Gitpod, we firmly believe that working for an open-source project should be a legitimate alternative to a career working for a for-profit corporation. Additionally, we&#39;d like everyone to be able to maintain open-source projects, not just people with the right financial background or youth that enables the ability to volunteer.","metadata":{"source":"https://gitpod.io/blog/gitpod-open-source-sustainability-fund"}}],["169",{"pageContent":"Actions speak louder than words\n\nToday we are announcing five things:\n\nOpen Source Sustainability Fund\n\nGitpod has created an open-source sustainability fund and allocated an initial amount of USD 30,000 towards securing our open-source supply chain by paying open-source maintainers.\n\n$1 for each new community member\n\nFor every registration to our newly created discord channel during the next month we‚Äôll donate an additional $1 to open-source projects we depend upon.\n\nDevX Conf\n\nThe upcoming (28th of April from 5pm CEST) non-profit conference on developer experience - DevX Conf will donate all surplus and USD 500 for each Gold Sponsor to open-source projects. Additionally attendees of the conference will have a say how an additional USD 10,000 in open-source funding will be distributed between open-source projects that are unseen digital infrastructure.\n\nBuild in the open\n\nOver the coming months, Gitpod will share our experiences with funding open-source projects for other companies to follow and share insights for maintainers who wish to become financially independent.\n\nDemocratize contributions\n\nWe recognise that money isn&#39;t the only way to resolve open-source sustainability. Often the problem is access and the initial project setup friction. To address this Gitpod has made Gitpod free for open-source communities so that open-source maintainers can onboard new contributors to their project with standardized developer environments. With Gitpod people from all over the world can contribute from any device without the typical $3,000 Macbook Pro barrier to entry.\n\n__SPLIT_HERE__\nIt&#39;s time to start giving back\n\nOver the last couple months Gitpod has been emailing maintainers of dependencies that Gitpod consumes (npm/golang/Docker) and asking them to get themselves signed up into the GitHub Sponsors or Open Collective programs.\n\nIf you appear in our bill of materials then Gitpod would like to unconditionally shout you some beers, some nice food or more as our way of saying thank-you for helping make Gitpod possible.\n\nFunding Open-Source Projects Email\n\nI hope more companies will follow Gitpod&#39;s lead and do this simple act en masse because maintainers must have income diversity because diversity creates a freedom that enables roadmap and project independence.\n\nThank-you for sponsoring tweet\n\nIf you are a maintainer of an open-source project, then there&#39;s one simple, easy step you can do to enable Gitpod and other companies to provide financial support...\n\nGo sign up to GitHub Sponsors or Open Collective as sending hand crafted emails asking you to signup isn&#39;t scalable and most companies would not do this manual grunt work. üòâ","metadata":{"source":"https://gitpod.io/blog/gitpod-open-source-sustainability-fund"}}],["170",{"pageContent":"Think ahead, secure your supply chain.\n\nNadia Eghbal, in 2016 with the support of the Ford Foundation, authored an extensive report into the unseen labour behind our digital infrastructure. She recently published the successor of the report: Working in Public: The Making and Maintenance of Open Source Software. If you haven&#39;t read her work before, then start there.\n\nCredit: XKCD\nCredit: XKCD\n\nEghbal, in her work outlines, digital infrastructure should be treated as a necessary public good. Free public source code makes it exponentially cheaper and easier for companies to build software and makes technology more accessible across the globe. However, there is a common misconception that the labour for open source projects is well-funded. In reality, it is largely created and maintained by volunteers who do it to build their reputations, out of a sense of obligation or simply as a labour of love.\n\nThe thing about open-source software that&#39;s too often forgotten, it&#39;s AS-IS, no exceptions. There is absolutely no SLA. That detail is right there in the license!\n\nIn business terms, open-source maintainers are unpaid and unsecured vendors.\n\nGitpod hopes other companies will also start taking steps to mitigate this critical risk in their technology stack. In future blog posts, we will be sharing our experiences with funding open-source projects and insights for maintainers who wish to become financially independent.\n\n__SPLIT_HERE__\nTowards a maintainer economy\n\nHere is what you can do today:\n\nIn practice, this involves going through each one of your projects in your dependency tree and deciding on the appropriate strategy for that particular dependency.\n\nGitpod has plenty of smaller dependencies for doing activities such as parsing TOML. As that dependency isn&#39;t of strategic importance, the strategy to mitigate the risk would be to fund the project.\n\nOpen-source supply chain decision tree\n\nFor dependencies that are of strategic importance, then the strategy would be a combination of financial support, becoming regular contributors to the project or even hiring the maintainers of these projects as engineers for [short|long]-term engagements.\n\nDo you have more ideas on how funding can foster a diverse community? ‚Üí Please get in contact.\n\n__SPLIT_HERE__\nSee you at DevX Conference\n\nThat&#39;s it for now. I hope you&#39;ll join us for non-profit DevX Conf, a two-day virtual conference focusing on developer experience. Attendees of the conference will have a say how an additional USD 10,000 in open-source funding will be distributed between open-source projects that are unseen digital infrastructure.","metadata":{"source":"https://gitpod.io/blog/gitpod-open-source-sustainability-fund"}}],["171",{"pageContent":"After over one year of intensive work, we are proud to announce the public Beta of Gitpod.\n\nGitpod is a Remote Developer Environment which can be launched from any GitHub page. Simply *prefix any GitHub-URL with ‚Äúhttps://gitpod.io/#*‚Äù** or use our browser extension that adds a button to GitHub pages.\n\nWithin seconds, Gitpod provides you with a fully working developer environment, including a VS Code-powered IDE and a cloud-based Linux container configured specifically for the project at hand.\n\n__SPLIT_HERE__\nYet Another Cloud IDE?\n\nGitpod is not another cloud IDE, aiming at replacing desktop development. Instead, Gitpod is a natural extension to GitHub. The limited editing capabilities of GitHub are far too often forcing context switches to our local machines. Gitpod extends our life on GitHub.\n\nAlso, Gitpod is super simple: You don‚Äôt maintain your projects or workspaces using overwhelming and complicated dashboards. Instead, any configuration is safely stored and versioned on GitHub.","metadata":{"source":"https://gitpod.io/blog/gitpod-remote-developer-environment"}}],["172",{"pageContent":"Also, Gitpod is super simple: You don‚Äôt maintain your projects or workspaces using overwhelming and complicated dashboards. Instead, any configuration is safely stored and versioned on GitHub.\n\n__SPLIT_HERE__\nStay In The GitHub Flow\n\nGitpod is highly contextual, such that it opens the IDE in the correct mode depending on the context:\n\nIf you are looking at a particular file of a certain commit on GitHub, starting a Gitpod workspace will check out the right version and open the file you‚Äôve been looking at in the IDE.\n\nStarting a Gitpod workspace from an issue will automatically create a branch and preconfigure the commit message.\n\nStarting Gitpod from a pull request beams your right into code review mode.\n\n__SPLIT_HERE__\nGitHub Integration\n\nOnce you are in the IDE, you can interact with GitHub in various ways. Besides the obvious Git integration, you can do things like commenting inline in editors, approving and even merging PRs.\n\nInline Comments For Pull RequestsInline Comments For Pull Requests","metadata":{"source":"https://gitpod.io/blog/gitpod-remote-developer-environment"}}],["173",{"pageContent":"Inline Comments For Pull RequestsInline Comments For Pull Requests\n\n__SPLIT_HERE__\nAutomated Setup\n\nGitpod is built on Kubernetes and you can use any Docker image for your developer environments. This allows to fully automate the setup and frees everybody from manually going through long and outdated setup documentation. No more ‚Äúworks on my machine‚Äù scenarios.\n\nGitpod provides your collaborators a single-click-to-contribute experience.\n\nMore information on how to configure Gitpod can be found here.\n\n__SPLIT_HERE__\nFire and Forget\n\nGitpod workspaces are disposable. You simply create a fresh one whenever you need. Once you are done with your task, the IDE brings you back to GitHub, so you can continue on the next task.\n\nYou usually never need to go back to any workspace, but of course you can in case you need to.\n\n__SPLIT_HERE__\nFull Terminal Access","metadata":{"source":"https://gitpod.io/blog/gitpod-remote-developer-environment"}}],["174",{"pageContent":"You usually never need to go back to any workspace, but of course you can in case you need to.\n\n__SPLIT_HERE__\nFull Terminal Access\n\nGitpod gives developers full featured terminals to run any processes such as compiling, linting or simply running tests or your application. Any Docker image works and you can even configure Gitpod to automatically launch certain tasks on start.\n\nTerminal\n\n__SPLIT_HERE__\nOpen Source\n\nThe IDE in Gitpod is based on Theia, an open-source project that we (TypeFox) have started together with our friends from Ericsson in early 2017. You can think of it as the online version of VS Code. We love VS Code, but needed some additional properties, like a more extensible architecture and the ability to run in browsers connected to a remote backend. Theia is a true open-source project, hosted at the Eclipse Foundation and developed by a diverse crowd of engineers backed by TypeFox, Ericsson, Red Hat, Arm and others.\n\nLanguage Tooling In ActionLanguage Tooling In Action","metadata":{"source":"https://gitpod.io/blog/gitpod-remote-developer-environment"}}],["175",{"pageContent":"Language Tooling In ActionLanguage Tooling In Action\n\n__SPLIT_HERE__\nSupports Many Languages\n\nBeing based on VS Code and its Language Server Protocol, Theia supports most major programming languages. The table below provides a good overview of the current state.\n\nCurrent State of Supported Programming LanguagesCurrent State of Supported Programming Languages\n\nAdditional languages like C#, Swift, Clojure, Groovy, Objective-C, Markdown, Less, XML and many others are supported with syntax coloring, as well. Because it is so easy to create an extension for Theia, support will improve both in breadth (more languages) and depth, shortly.","metadata":{"source":"https://gitpod.io/blog/gitpod-remote-developer-environment"}}],["176",{"pageContent":"Use It For Free!\n\nYou can use Gitpod with any GitHub repository. The login is done through GitHub OAuth. At first, Gitpod will ask for accessing public repos, only. If you want to use it with a private repository, Gitpod will ask again for more permissions.\n\nWhy not try it now? If you don‚Äôt have a particular repository in mind, you can pick one of the below:\n\nJavaScript:\nhttps://gitpod.io/#https://github.com/ooade/NextSimpleStarter\n\n\nGo:\nhttps://gitpod.io/#https://github.com/demo-apps/go-gin-app\n\n\nJava:\nhttps://gitpod.io/#https://github.com/gitpod-io/spring-petclinic\n\n\nRuby:\nhttps://gitpod.io/#https://github.com/gitpod-io/rails_sample_app\n\n\nPython:\nhttps://gitpod.io/#https://github.com/sibtc/django-beginners-guide\n\n\nPHP:\nhttps://gitpod.io/#https://github.com/symfony/demo\n\n__SPLIT_HERE__\nWhere Are We Going From Here?\n\nMany other features are ready to use, such as Git integration or the search functionality. But also exciting new features are in development, such as **debugging, collaboration **and support for GitLab and Bitbucket. Even support for VS Code extensions is on its way.\n\nBesides more features, we are focussing on improving the overall experience by streamlining rough edges, fixing bugs and improving performance. New releases will come out continuously.\n\nIf you have feedback or find bugs, please file them here.\n\nHappy coding!","metadata":{"source":"https://gitpod.io/blog/gitpod-remote-developer-environment"}}],["177",{"pageContent":"We are excited to announce the new release of Gitpod Self-Hosted in version 0.4.0. Gitpod Self-Hosted allows everyone to set-up and run a service with the same features as gitpod.io in your cloud or corporate network.\n\nGitpod Self-Hosted runs on Kubernetes and is easily installed via &quot;helm install&quot;. On gitpod.io you can find detailed documentation and some automation to install Gitpod on vanilla Kubernetes or on Google Cloud Platform. For the next release, we plan to add support for AWS, Azure, and OpenShift.\n\nUsers log into Gitpod via OAuth from your self managed GitLab or GitHub enterprise. This ensures that all access privileges from your Git hosting solution are taken into account and that there is no additional administrative effort for managing user accounts.\n\nGitpod Self-Hosted is truly self-hosted: it does not require an internet connection to operate as every single bit runs on your network, and Gitpod Self-Hosted won&#39;t call home.\n\nOperating Gitpod in production on gitpod.io has enabled us to battle-harden this product at scale. Both offerings share the same codebase, hence offer the same qualities regarding scalability, cloud-density, reliability, and security. All improvements that we make on Gitpod‚Äôs SaaS offering directly benefit the Self-Hosted version.\n\nThis release ships a plethora of bugfixes and improvements, particularly in the area of GitLab integration.\nThere is one major feature that I want to show in more detail since you can&#39;t try this on gitpod.io:\n\nThis release ships with a new web UI for administrative tasks. The UI is particularly handy when providing support fo users.\nIt allows for easy listing and searching of users and worksapces.\nWhen selecting a user, the UI will show the user&#39;s details and workspaces, as you can in the following screenshot:\n\nGitpod Admin UI\n\nTo try the new admin interface in Gitpod Self-Hosted, you&#39;ll need to assign the &quot;admin&quot; privilege to your user and open /admin in your browser.\n\nThe fastest way to get started is by installing Gitpod Self-Hosted on Google Cloud Platform. There is also more in-depth documentation available on how to install Gitpod on vanilla Kubernetes.\n\nGitpod Self-Hosted is free for up to five users. For more users, you can obtain a free one month trial or see our pricing page.\n\nFor Gitpod‚Äôs next releases you can expect support for Atlassian‚Äôs Bitbucket, as well as install guides for Azure, AWS and OpenShift.","metadata":{"source":"https://gitpod.io/blog/gitpod-self-hosted-0.4.0"}}],["178",{"pageContent":"Key Takeaways\n\nIndividual developer efficiency is hard to measure, but directly impacts a company‚Äôs bottom line and team morale.\nRemote work requires developers to onboard in isolation, a process that was already challenging when teams were co-located.\nOnboarding instructions are often outdated, as are automated onboarding scripts because only new hires run them.\nwww.gitpod.io provides automated, one-off developer environments you spin up in the cloud for each task. In seconds, repeatedly, and securely.\n\n__SPLIT_HERE__\nTable of contents\n\nWhat it‚Äôs like todayOpen source project onboarding\n\n\nMeet Alice and BobSet up a new project\nDevelop a new feature\nSwitch context\nSet up a new computer\nContribute to open source projects\n\n\nWhat‚Äôs the catch?\nConclusion\n\n__SPLIT_HERE__\nWhat it‚Äôs like today\n\nWhether you recently joined a new team or contributed to an open source project for the first time, I‚Äôm quite sure you spent anywhere from an hour to a few days onboarding. If you were lucky, other contributors provided detailed, up-to-date instructions you could follow. Possibly even commands you could copy &amp; paste and watch your developer environment set itself up one step at a time. If this is your experience, congratulations on finding such a great and diligent team - tell them what an awesome job they did ü§©!\n\nMore often than not though, this is not what an onboarding experience is like.\n\nIt is more likely that there are no automated scripts while instructions, if there are any, are slightly outdated or incomplete - leaving you struggling to figure things out on your own. The techlead to the rescue, who then asks you to update the documentation so the next team member who joins does not run into the same issues. Except, the project evolves, and instructions fall behind again. This is no fault of anyone in particular, but simply a fact of life because once a developer sets up their local developer environment, there is no need to set it up again when the code changes. Every team member applies incremental changes to their developer environment without starting from scratch, leave alone following the onboarding documentation.\n\nThis process is costly, both in terms of time and team morale. The larger your team, the more time is lost on setting up developer environments and keeping them maintained. At the same time, I don‚Äôt know anyone who enjoys reading outdated documentation. Feeling helpless on the first day working on a new project is certainly not a great way to get started üòï.\n\nOpen source project onboarding\n\nIn addition, there is a cost that applies to open source projects that is almost impossible to measure: the % of people who would like to contribute to a project, but give up because getting started is too complex or interferes with their other projects in their local environment!\n\nTo illustrate this with an example, imagine you usually work with Java 8 and want to contribute to two open source projects. Project A requires Java 7, while project B only runs with Java 11. In order for you to contribute to these projects, you need to install a Java version manager and remember to switch Java version every time you change the project you work on.\nThe exact same applies to databases (no need to install MySQL, MongoDB, Postgres, etc. locally), operating system libraries, anything you currently install locally.\n\nLet‚Äôs look at a day in the life of two developers and see how cloud-based developer environments simplify workflows significantly.","metadata":{"source":"https://gitpod.io/blog/i-said-goodbye-to-local-development-and-so-can-you"}}],["179",{"pageContent":"Meet Alice and Bob\n\nBob is like most of us, he works on a desktop or laptop where he installs development tools, clones Git repositories and installs dependencies for the projects he works on. He may or may not have had a great onboarding experience üòâ. Once every so often, Bob is required to upgrade his tools and dependencies, a task he dreads because upgrading the version of an installed programming language may impact projects that are not compatible with that newer version. With every new version he installs, his cognitive load increases as he needs to remember to switch to the correct version based on the project he works on. Bob is very, very careful in the way he treats his computer because he really doesn‚Äôt want it to break‚Ä¶ Just imagine setting everything up again from scratch üò±.","metadata":{"source":"https://gitpod.io/blog/i-said-goodbye-to-local-development-and-so-can-you"}}],["180",{"pageContent":"Alice is not like Bob, not anymore! Alice too lived a life like Bob where she carefully set up and maintained her local developer environment over the lifetime of her laptop (we will talk about her experience when she gets a new laptop later). However, she has since realized there is a better way not only for herself, but for her entire team and anyone who contributes to their projects.\n\nAlice no longer has any code on her computer, none whatsoever. She does that thanks to cloud-based, ephemeral developer environments provided by www.gitpod.io.\n\nLet‚Äôs dive in and learn more about Bob and Alice and how you can turn yourself from being a traditional Bob to being a modern, efficient version of Alice ü•∞.\n\nSet up a new project\n\nBob","metadata":{"source":"https://gitpod.io/blog/i-said-goodbye-to-local-development-and-so-can-you"}}],["181",{"pageContent":"Let‚Äôs dive in and learn more about Bob and Alice and how you can turn yourself from being a traditional Bob to being a modern, efficient version of Alice ü•∞.\n\nSet up a new project\n\nBob\n\nBob starts by cloning the source code, then ensures he has the correct runtime versions installed (e.g. Java, Node, .NET) and also makes sure the project supports his operating system.\nOnce that‚Äôs all good, he looks for onboarding instructions and works his way through that, potentially spending up to a few days on this task.\n\nAlice\n\nAlice creates a .gitpod.yml configuration file at the root of her project, then adds start tasks such as the following:\n\n```yaml\ntasks:\n  - init: npm install\n    command: npm run dev\n```\n\nShe also enables Gitpod Prebuilds - telling Gitpod to continuously create new developer environments as soon as her project‚Äôs source code changes! This significantly reduces the startup time when she or anyone who works on her project needs a developer environment.","metadata":{"source":"https://gitpod.io/blog/i-said-goodbye-to-local-development-and-so-can-you"}}],["182",{"pageContent":"Set up a new project\nSet up a new project\n\nDevelop a new feature\n\nBob\n\nBob is very familiar with this workflow, it‚Äôs something he does many times a week, possibly even a few times per day.\n\nHe starts by making sure his new feature branch is based on the latest code. He does that by first pulling the latest default branch and then creating a feature branch.\n\nSince one of his colleagues may have added a new dependency or changed a required runtime version, Bob needs to ensure he has the latest versions. You know, otherwise he starts the dev server only to be presented with an error message telling him a dependency is missing. You know what I‚Äôm talking about üòâ.\n\nThen, Bob is ready to shift into feature development mode. Well... after he started the database and dev servers.\n\nAlice","metadata":{"source":"https://gitpod.io/blog/i-said-goodbye-to-local-development-and-so-can-you"}}],["183",{"pageContent":"Then, Bob is ready to shift into feature development mode. Well... after he started the database and dev servers.\n\nAlice\n\nShe‚Äôs keen to get started right away. Once she looks at the issue on GitHub, GitLab or Bitbucket, she simply clicks the ‚ÄúGitpod‚Äù button*. This opens a new workspace with a feature branch already created, all dependencies installed and the database and dev servers started!\n\n* She gets that by installing the Gitpod browser extension. Alternatively, she could prefix the issue URL with gitpod.io/#&lt;issue-url&gt; to open a new developer environment.\n\nSet up a new project\nSet up a new project\n\nSwitch context\n\nImagine this: You‚Äôre working on a feature when your team member contacts you, letting you know she needs your review for a production hotfix pull request. Here‚Äôs how Bob and Alice handle this situation:\n\nBob","metadata":{"source":"https://gitpod.io/blog/i-said-goodbye-to-local-development-and-so-can-you"}}],["184",{"pageContent":"Bob\n\nHm... ü§î Bob is a bit hesitant. He has a bunch of code changes that are not ready to be committed, he also removed a dependency that is no longer needed thanks to his feature - yay! The timing to review a pull request is less than ideal.\n\nHe stashes his changes, pulls the PR branch and switches to it. Since he removed a dependency in his feature branch, he needs to install that again because the production hotfix PR still requires it.\n\nTime to start the dev server and review the hotfix. Looks good, LGTM üëç.\n\nTo get back to his feature branch and continue development, he first switches back to his branch. Next, Bob needs his stashed files back, then drops that dependency his feature no longer requires and eventually starts the servers.\n\nAlice","metadata":{"source":"https://gitpod.io/blog/i-said-goodbye-to-local-development-and-so-can-you"}}],["185",{"pageContent":"Alice\n\nAlice‚Äôs workflow is no different than when she develops a new feature. She opens a new browser tab, navigates to the pull request and opens a new developer environment based on that PR. Within seconds, the environment starts and the database and dev servers already run - ready for Alice‚Äôs review.\n\nShe can even leave review comments right within VS Code and have them synced with GitHub.\n\nWhen she‚Äôs done with the review, Alice closes the browser tab. This brings her back to her previous developer environment where she continues to work on her feature.\n\nSet up a new project\nSet up a new project\n\nSet up a new computer\n\nBob\n\nOh boy... where to start?! Ah right, from scratch üò∞!\n\nAlice\n\nAlice, well Alice is excited to get a new computer and is up and running as soon as she installs her favourite browser üöÄ. Way to go, Alice!\n\nSet up a new project\nSet up a new project\n\nContribute to open source projects","metadata":{"source":"https://gitpod.io/blog/i-said-goodbye-to-local-development-and-so-can-you"}}],["186",{"pageContent":"Set up a new project\nSet up a new project\n\nContribute to open source projects\n\nRemember the example with the three open source projects earlier that use different versions of Java? In Alice‚Äôs case, she does not have Java installed locally at all. She starts any open source project in an ephemeral developer environment and uses whatever version of Java is configured for that project. She can even contribute to two projects in parallel - if she really wanted to üòõ.","metadata":{"source":"https://gitpod.io/blog/i-said-goodbye-to-local-development-and-so-can-you"}}],["187",{"pageContent":"What‚Äôs the catch?\n\nWell, for the time being you need an internet connection to work like Alice. The good news, it doesn‚Äôt have to be high bandwidth since the data exchange between Gitpod and your browser is minimal. A decent latency is all you need for a smooth experience.\n\nIf you read this and think ‚ÄúWell, what about X?‚Äù please get in touch, I‚Äôd love to work with you and set up Gitpod for your project.\n\n__SPLIT_HERE__\nConclusion\n\nAlice &amp; Bob, two not-so-fictional characters living their life as software developers. I used to be a Bob for close to two decades before I found www.gitpod.io which gives me everything Alice has! Want to get a sneak peek? Click the following button to start your first developer environment in the cloud (it will open the source file of this blog post):\n\nOpen in Gitpod\n\nI‚Äôd love to hear your thoughts and feedback, please get in touch üôè.","metadata":{"source":"https://gitpod.io/blog/i-said-goodbye-to-local-development-and-so-can-you"}}],["188",{"pageContent":"TL;DR\n\nGitpod Dedicated is our new enterprise cloud product - a secure installation of Gitpod managed by us for you\nGitpod exists to remove friction from the developer experience, and the best way to do that is with a managed product in the cloud\nWe no longer actively support self hosting Gitpod\n\nIn December 2019, we announced that it was possible to self-host Gitpod. Our goal was to make Gitpod accessible for teams that cannot use a SaaS offering. We tried hard to provide a decent self-hosted installation and operation experience by shipping our own installer to reduce configuration complexity, regular releases of self-hosted with in-depth reference architectures, support for GKE, AKS, and EKS, and the release of Gitpod Local Preview. We have been working closely with various companies and helped them to install and operate their self-hosted Gitpod installation.\n\nDespite all that effort, self-hosted Gitpod has been increasingly difficult for us to support and it has shown to be a burden for our clients to manage and operate their own Gitpod instances. The open-ended requirements to run on commoditised Kubernetes services (GKE, AKS, EKS) forced us to manage variance and prevented us from driving innovation and fully realizing the potential of Cloud Development Environments (CDEs). There must be a better way to get Gitpod in the hands of those who can‚Äôt use our SaaS offering.\n\n__SPLIT_HERE__\nGitpod Dedicated managed by us, for your organization\n\nCustomers choose our SaaS product for convenience. They want to be ready to code and productive in an instant. Customers choose to self-host because of the security benefits it enables through isolation. This is especially important in environments that are highly regulated or have specific data residency rules. Gitpod Dedicated combines the convenience of SaaS with the security benefits of self-hosting.\n\nGitpod Dedicated is the same Gitpod that you know and love, but as a customer you get a completely isolated, single tenant instance of Gitpod that we create and manage just for you. This allows us to combine the efficiency and ease of use of a managed cloud offering with the security, isolation and compliance characteristics you get from having your own dedicated instance.\n\nGitpod Dedicated will be initially available in AWS because that‚Äôs where the majority of our customers are. We can run in your cloud account or ours, in the region of your choice, and customers will have the ability to manage encryption keys for data at rest. Every detail of Gitpod Dedicated has been designed to meet the security requirements of our enterprise customers.\n\nJoin the waitlist\n\nWe are excited to announce limited availability of Gitpod Dedicated for enterprise customers and an expanded beta in 2023. Sign-up for the waitlist and receive bi-weekly architecture and product updates.","metadata":{"source":"https://gitpod.io/blog/introducing-gitpod-dedicated"}}],["189",{"pageContent":"Ending support for Self Hosted and moving our source code to the open-source AGPL licence\n\nWe have decided to stop supporting self-hosting Gitpod for the reasons mentioned above. The focus on Gitpod SaaS and Gitpod Dedicated enables us to ship improvements much faster.\n\nWe know that some members of our community will be disappointed by our decision to end Gitpod self-hosted as a product. And we apologize for any inconvenience or stress this may cause. We did not take this decision lightly. We will continue to adhere to any existing contractual agreements with our customers regarding support and security fixes.\n\nWe have informed our enterprise customers about this decision and have been pleasantly surprised by the excitement around Gitpod Dedicated. For the community, the end of self-hosted as a product means:\n\nThe November 22 release will be our last Self-Hosted release. Both the product and its documentation will be frozen.\nYou will be able to continue installing and using the currently available free KOTS based community edition until January 24.\nWe will move all of our source code to open-source AGPL and remove the proprietary Enterprise License from our source code.\n\nWe originally open sourced Gitpod because working in open source is in our DNA. Everything we have created over the past 10 years, including Theia, Xtext, Open VSX, and many other projects have been open source. This stays true for Gitpod. What is going to change is, that we are focused on creating the best managed experience possible, rather than trying to make it as flexible as possible for self-hosting.\n\nAs we close 2022 by introducing new workspace classes, flexible pricing and a new enterprise cloud offering, we couldn‚Äôt be more excited for 2023. Our vision for Cloud Development Environments (CDEs) is ambitious, and we are just getting started. There‚Äôs still a long way to go to remove all friction from the developer experience to be always ready-to-code and make software engineering more collaborative, joyful, and secure.\n\nPS: today, we also launched larger workspaces and flexible pricing. Read the launch blog post.","metadata":{"source":"https://gitpod.io/blog/introducing-gitpod-dedicated"}}],["190",{"pageContent":"Today, we are announcing workspace classes and flexible pricing üéâ\n\nWorkspace classes give you access to workspaces with more computational power. You can choose between standard and large workspaces, unlocking more powerful CDEs and new use cases. Workspace classes are made possible by a new flexible pricing model. Gitpod usage is now measured in credits and you are charged based on your usage. Our free tier remains virtually unchanged and you can continue to use Gitpod for up to 50 hours per month for free.\n\nContinue to read below on why we are making this change or go straight to the documentation for configuring workspace classes and billing.\n\n__SPLIT_HERE__\nWorkspace classes\n\nDifferent projects and workloads require different amounts of computational power and developers want the flexibility to choose the workspace size that best fits their needs.\n\nUntil now, all Gitpod workspaces were given the same computational resources - up to 4 vCPUs, 8GB RAM and 30GB of storage. Starting today developers can choose a larger option of up to 8 vCPUs, 16GB RAM and 50GB of storage. ‚ö°\n\nWorkspace Class vCPUs RAM Storage\nStandard Up to 4 Up to 8GB 30GB\nLarge Up to 8 Up to 16GB 50GB\n\nTo get started head over to your Gitpod project settings and select the desired workspace class. This option is available to free tier users, and to paid subscribers with the new flexible pricing. If you are on one of our old plans, consider switching now to access large workspace classes.\n\nWe are thrilled to be able to offer this new level of flexibility and we can&#39;t wait to see what developers will create with it. We believe that the added flexibility will help developers to be more productive and efficient, and we are excited to see how it will improve their Gitpod experience. üöÄ\n\nHow you can help us: We are just getting started! üëÄHead over to Issue 13950 and share your feedback on workspace classes and your need for even more powerful machines.","metadata":{"source":"https://gitpod.io/blog/introducing-workspace-classes-and-flexible-pricing"}}],["191",{"pageContent":"Flexible Pricing\n\nOur new pricing model allows us to bring the benefits of workspace classes to all of our users.\n\nInstead of billing for each user based on their monthly plan, Gitpod can now charge for usage based on how long workspaces run, and the resources consumed by different workspace classes.\n\nHow does flexible pricing work?\n\nIndividual users on the free plan can use up to 500 credits each month. This is equivalent to 50 standard workspace hours.\n\nIndividual users who upgrade to paid billing at $9.00 per month can use up to 1,000 credits, and pay for additional usage beyond that, at the pay-as-you-go rate of $0.036 per credit.\n\nWith team billing, Gitpod will meter the usage of team members on team projects, and charge that usage to the team billing account, at the same pay-as-you-go rate of $0.036 per credit.\n\nFree Paid Users Paid Teams\nBase price $0/mo $9/mo $0/mo\nCredits included in base price 500 1000 0\nAdditional credits available with paid plans none (Upgrade to paid) Pay-as-you-go Unlimited Pay-as-you-go Unlimited\nPrice per additional credit n/a (Upgrade to paid) $0.036 $0.036\n\nWhat changes today?\n\nWorkspace classes and the new pricing are now generally available for all Gitpod users.\n\nIf you are already a paying Gitpod user, you can switch to the new pricing model or stay on your existing paid plan. In order to access large workspaces and pay-as-you-go, you will first need to cancel your old plan. Existing plans will keep working until the end of March, 2023.\n\nIf you are a free Gitpod user, you can continue using Gitpod for free. Users on the Free plan can use up to 500 credits each month without charge. That is equivalent to 50 hours of Standard workspace usage. You don‚Äôt need a credit card to use Gitpod.\n\nIf you are new to Gitpod, you can sign up and start using Gitpod for free. If you are interested, check out all our features and prices on the new pricing page.\n\nGitpod for startups, students, and open source\n\nGitpod for Open Source users will now receive 2,500 credits per month on their free plan.\n\nGitpod for Startups participants will receive a discount of 50% on their team usage. Existing Gitpod for Startups participants can continue using their old plans.\n\nStudents and educators are encouraged to check out the generous new free and paid offerings described above. Our pricing plans which require student verification have been discontinued. Existing paid student plans will keep working.\n\nPS: we‚Äôve also announced Gitpod Dedicated, a fully-isolated, private installation of Gitpod managed by us. Read blog post.","metadata":{"source":"https://gitpod.io/blog/introducing-workspace-classes-and-flexible-pricing"}}],["192",{"pageContent":"Gitpod is changing the way developers code. We&#39;re breaking the paradigm of relying on local environments to develop applications, by making those environments available through a web browser. Those environments are hosted in the cloud, they are ephemeral and they can be customized through automation to make them perfect for the project being developed.\n\nThose cloud-based environments provide everything that our users have in their local machines, including sudo access and Docker, and thanks to configuration-as-code (that can be automated) they remove the friction of installing and managing all different kinds of dependencies that we have when working on multiple projects. We want the world to forget about local environments and completely focus on our cloud-based environments.\n\nWe gave those cloud-based environments a unique name: &quot;Workspaces&quot;.\n\nWorkspaces are the core of Gitpod, it is impossible to be a user of Gitpod without using Workspaces. To achieve the goal of making the world forget about local environments, we need to be a service provider that developers can trust and rely on, therefore, Workspaces need to be just as reliable as local environments!\n\nGitpod is scaling! We are glad to be backed by fantastic investors and the topic &quot;Cloud-based development&quot; is on fire right now! Being the pioneers in this topic, it&#39;s only natural that we&#39;re getting more and more users every day. This is truly a great thing for us! We are honored to receive so much love in the last couple of months and we want to keep this momentum going, but this extra love also puts an extra load on top of our clusters and extra load sometimes leads to unreliability. It is awesome that people are starting to forget about their local environments thanks to Gitpod, therefore we want Workspaces to maintain a fantastic performance, doesn&#39;t matter if we host ten, ten thousand, or ten million Workspaces concurrently.","metadata":{"source":"https://gitpod.io/blog/journey-to-site-reliability-engineering-at-gitpod"}}],["193",{"pageContent":"Reliability vs¬†Velocity\n\nOf course, Gitpod is a lot more than just an IDE with a terminal in the cloud. We have tons of features that make Gitpod shine amongst all other cloud-based developer environments, such as Prebuilds, Sudo and Docker support, Shareable Workspaces, while not mentioning our Roadmap that is pretty ambitious too.\n\nDeveloping and shipping new features is one of the things that make us more excited about our work, and hopefully our users too üòÖ, but making changes to production also comes with the risk of breaking stuff that was working just fine previously. Breaking small things is usually okay and we can keep focusing on new features, but we may break Gitpod so much that user experience decreases to a level that makes our users unhappy. That is a big no-no for us. If our users are unhappy then we need to do something about it, even if that means slowing down new features or completely stop them to fully focus on reliability depending on how bad the situation is. But how do we decide if we should be focusing on reliability or feature velocity?\n\nToday we are not doing a great job when it comes to proactively identify degraded user experience. While we do have some metrics about Workspace startup latency and errors, most of our incidents were identified by noticing too many users complaining at our contact platforms, such as GitHub issues, email, and Twitter. Damn, we even got an incident that caused 100% unavailability because our SSL certificates expired back in February this year, and it took us almost half an hour to notice that üòÖ!\n\nWe do have things to be proud of though! Our Incident Response process, while it can be improved even further, has gotten a lot better since December 2020. We&#39;re coming up with post-mortems after almost all incidents and the team is tackling every action item raised. On these occasions, reliability usually has a higher priority than feature velocity. Some action items are taking a little longer to implement though, and these items are exactly the ones that will solve the problem mentioned before: we need to get better at proactively identify degraded user experience.\n\n__SPLIT_HERE__\nAlerting on symptoms instead of¬†causes\n\nUnfortunately, today we can&#39;t have clear insights if our changes have a direct impact on user experience. We come from a mindset of measuring compute resources, e.g. CPU, RAM, and disk utilization, as a way to know if Gitpod is running smoothly. This strategy worked just fine for some time, it was simple to horizontally or vertically increase our nodes, but now we are often seeing that lack of resources are not the reason why Workspaces start to fail. Not to mention that keeping a high number of nodes under a certain threshold is quite challenging.\n\nToo many nodes to keep an eye on\n\nWe want to change this mindset completely! Compute resource metrics may be good for debugging degraded performance during incidents, but shouldn&#39;t be the way we look for degraded user experience. We should be gathering metrics that measure exactly the symptoms that our users complain about during incidents:\n\nIncident reporting\n\nAs previously said, Workspaces are the core of Gitpod. We should be measuring metrics that tell us how our users are interacting with them:\n\nHow many workspaces are being created and how many fail during this process?\nHow many of those Workspaces start in an acceptable time frame?\nAfter they start, do they remain working until the user chooses to stop them?\n\nGitpod has a lot more features than just hosting Workspaces but, as a first step, getting metrics and alerts around Workspace behavior will cover most of the complaints we had so far.","metadata":{"source":"https://gitpod.io/blog/journey-to-site-reliability-engineering-at-gitpod"}}],["194",{"pageContent":"Service Level Objectives\n\nThese Workspace metrics will be key to our team when performing Site Reliability Engineering, but they alone aren&#39;t enough. They still don&#39;t answer the question: should we be focusing on reliability or feature velocity? We need to set clear expectations about when we consider Gitpod unstable or not.\n\nService Level Indicators and Service Level Objectives will be our North Stars. And they will be implemented with the metrics mentioned in the previous section of this blog.\n\nSLIs are simple once we implement those metrics. It&#39;s a simple ratio calculation over some time period. E.g.:\n\nThe SLOs, on the other hand, are a little bit more complicated. The SLO is a target of reliability that will better represent our users&#39; &quot;happiness&quot;, and measuring happiness is not really straightforward. We do know that aiming for 100% is not what we nor our users want though. Aiming for 100% means that 0 Workspaces can fail to start. Once we have a stable system, making changes to it, e.g. changing infrastructure to save costs or shipping a new exciting feature, is often the reason why said system becomes unstable even though those changes will often make us and our users more satisfied with our final product.\n\nNow that we agreed that we won&#39;t aim for 100% availability, then what will be our target? Well, internally we do have an informal agreement that:\n\n95% of Workspaces should start in less than 2 mins\n50% of Workspaces should start in less than 15s\n99.8% of Workspaces should start successfully\n99.8% of Workspaces should remain working after they start\n\nTo be honest, however, in our first interaction it is a little bit unreal to write those targets in stone already. As we already mentioned in this blog post, we still don&#39;t have that measurement very well established, so we don&#39;t know what is the reality that we live in right now. It could be that to achieve those targets, we will need to stop feature development completely just to manually keep everything stable, and this is not what we want!\n\nAfter implementing our metrics and SLIs, we can create dashboards and reports based on the SLOs&#39; targets that we&#39;re aiming for in the future, but we will only establish real policies after we get some war experience and develop a good grasp of what we&#39;re dealing with üí™.","metadata":{"source":"https://gitpod.io/blog/journey-to-site-reliability-engineering-at-gitpod"}}],["195",{"pageContent":"We care deeply about developer experience. As omnipresent as the term seems these days, developer experience is an emerging field that is often misunderstood.\n\nCompanies of all sizes have introduced teams focused on developer experience over the past years. The folks working on these teams have different titles: Head of Developer Experience, Head of Platform, DevX Engineer, DX Engineer, Staff Engineer - and many more.\n\nWhat all of them have in common is the desire to improve the tooling and processes that software developers employ in their day-to-day work. That‚Äôs no easy feat. Developer experience is a broad domain that requires practitioners to understand the latest technologies just as much as the intricacies of human behavior.\n\nWe are launching a shared space for those that work on creating a better developer experience for all of us:\n\nDevX Community ‚Äì a curated community for DevX leaders that want to connect, create and exchange learnings and insights. DevX Community was seeded by 8 DevX practitioners from GetDX,Gitpod, Honeycomb, Qualtrics, Spotify, Upvest, and Warp. We will carefully expand the community over time to maintain a high-quality forum that is solely dedicated to the world of developer experience.\n\nLearn more about the community on our new website ‚Äì  developerexperience.us \n\nGitpod is committed to developer experience. DevX Community is the latest addition to a number of activities and formats we have started to help create a better developer experience for every software developer in the world.\n\n__SPLIT_HERE__\nDevX Conf\n\nDevX Conf is a virtual conference on developer experience that happens every year. DevX practitioners at leading companies discuss their best tools, processes, and latest learnings.\n\n__SPLIT_HERE__\nDevX Pod\n\nDevX Pod features in-depth interviews with DevX experts. Hosts Pauline Narvas and Chris Weichel speak with developer experience leaders to unpack the ins-and-outs of the field.\n\n__SPLIT_HERE__\nDevX Community\n\nDevX community is a curated community for DevX leaders to share their knowledge and learnings.\n\nHead over to  our new website  to see more","metadata":{"source":"https://gitpod.io/blog/launching-devx-community"}}],["196",{"pageContent":"While Gitpod can seamlessly integrate into your workflow in the vast majority of cases, there are times where you may want to access a workspace from localhost and were required to workaround some limitations, particularly with respect to framework features such as live reload.\n\nGitpod is pleased to announce a preview release of the Gitpod Local Companion app that is designed to allow localhost access to any TCP port in a remote workspace regardless of protocol.\n\nThe app runs locally and enables automatically tunneled connections to your workspace, either privately or, if required, publicly (on your laptops IP for example).\n\nIn particular, this opens up any environment or framework that assumes localhost access i.e. web frameworks such as Svelte and enables bundlers such as Parcel or Webpack hot reloading without requiring any changes. It also enables the use of non-HTTP protocols, most notably MQTT based brokers or the AMQP based services.\n\nAs a preview release, not all of the features are implemented, most notably the tunneling is 1-way only: local -&gt; workspace.\n\nüí° Notice: A lot has improved on local-companion and the port-forwarding aspect since the publication of this blog post. You could also simply open a Gitpod workspace in VSCode Desktop or any other supported local editor client and your ports would be automatically forwarded for you! See the below links to learn more:\n\nhttps://www.gitpod.io/docs/references/ides-and-editors#supported-ideeditors\nhttps://www.gitpod.io/docs/configure/workspaces/ports#port-forwarding\n\n__SPLIT_HERE__\nSee it in action\n\nAs a simple example, with the Gitpod Local Companion app installed and running, open the standard Svelte template in Gitpod, using this link or the Gitpod button directly. This will create an ephemeral environment for you without requiring any local setup or installation. As per the template instructions, run the following:\n\n```shell\nnpm install && npm run dev\n\n\n```\n\nVS Code will detect the service on port 5000 and offer 3 options. Click on the &#39;Open Browser&#39; icon or navigate to directly to localhost to see &#39;Hello world!&#39;. Edit app.svelte and the page will live reload with your changes!\n\nWe love feedback here at Gitpod, so please give it a try and let us know what you think!\n\n__SPLIT_HERE__\nInstallation\n\nTo get started, download the preview release of the Gitpod Local Companion app for your platform (right click, &#39;Save (Link) As&#39;)\n\nMac Intel Chip - you will need to grant permission as it is not yet notarised. See ‚Äúopen an app that hasn‚Äôt been notarised or is from an unidentified developer‚Äù or click on the app in Finder while holding the Control key down and select &#39;Open&#39; from the menu and then &#39;Open&#39; in the prompt.\nMac Apple Silicon\nLinux 64 bit\nLinux ARM 64\nWindows 64 bit\nWindows 32 bit\n\nAlternatively, in a terminal run the following:\n\n```shell\n  # Mac Intel Chip\n  curl -OL https://gitpod.io/static/bin/gitpod-local-companion-darwin\n  chmod +x ./gitpod-local-companion-darwin\n\n  # Mac Apple Silicon\n  curl -OL https://gitpod.io/static/bin/gitpod-local-companion-darwin-arm64\n  chmod +x ./gitpod-local-companion-darwin-arm64\n\n  # Linux 64 bit\n  curl -OL https://gitpod.io/static/bin/gitpod-local-companion-linux\n  chmod +x ./gitpod-local-companion-linux\n\n  # Linux ARM 64\n  curl -OL https://gitpod.io/static/bin/gitpod-local-companion-linux-arm64\n  chmod +x ./gitpod-local-companion-linux-arm64\n\n  # Windows 64 bit\n  curl -OL https://gitpod.io/static/bin/gitpod-local-companion-windows.exe\n\n  # Windows 32 bit\n  curl -OL https://gitpod.io/static/bin/gitpod-local-companion-windows-386.exe\n```","metadata":{"source":"https://gitpod.io/blog/local-app"}}],["197",{"pageContent":"Running\n\nTo run it using your local keyring for long term storage of the access token:\n\n```shell\n  ./gitpod-local-companion-[darwin|linux|windows]\n\n\n```\n\nTo run it without storing the access token (it will generate a new token every time);\n\n```shell\n  ./gitpod-local-companion-[darwin|linux|windows] --mock-keyring\n\n\n```\n\nIf you are not logged in to Gitpod, it will take you through that flow. If you haven&#39;t run the local app previously it will also ask you to approve access to the control data of all your workspaces, returning a token that grants the access. This token will be stored in your local keyring for future use (unless you specify otherwise).\n\nOnce approval has been granted it will connect to your currently active workspaces and tunnel between the remote workspace and your local environment.\n\n__SPLIT_HERE__\nSSH Access\n\nAdditionally, the Gitpod Local Companion preview release also has basic support for SSH access into your workspace. It currently requires that you have a default SSH key setup in the ~/.ssh directory i.e. id_rsa.pub &amp; id_rsa. The public key will be copied to the workspace to permit access.\n\nThis opens up all the usual SSH-based features, such as secure copying, tunneling and remote execution.\n\nOnce you have installed the Gitpod Local Companion app and connected it to your workspaces, it dynamically creates entries for each workspace in the /tmp/gitpod_ssh_config file. You can use this to SSH into your workspace as follows:\n\n```shell\nssh -F /tmp/gitpod_ssh_config <your-workspace-id e.g.apricot-harrier-####>\n\n\n```\n\nYou will be prompted to add the address to your known hosts file and you will be connected to your workspace!\n\n__SPLIT_HERE__\nWhat is next?\n\nWe have big plans for the Gitpod Local Companion App! Future features may include:\n\n2-way tunnelling\nListing what workspaces are running\nListing what ports are currently tunneled and in which direction (workspace to/from local)\nStarting/stopping port forwarding from the command line\nConnecting a local VS Code instance to a workspace\nSSH into a workspace from the command line in a simple, straight forward way","metadata":{"source":"https://gitpod.io/blog/local-app"}}],["198",{"pageContent":"Some things just aren&#39;t exposed to the internet. Either because we do not want them out in the open, think some on-prem database, or because they cannot easily be made available like the Docker daemon on your laptop.\nWith your Gitpod workspace running in the cloud it does not have access to local services, which could render Gitpod unsuitable in those cases.\n\nThere&#39;s a range of different offerings that aim to expose local services to the internet. However, they all do so indiscriminately. I.e. if one knows the URL to your now-public endpoint, they have access to your service.\nOn top of that, they do incur additional cost if used often.\n\n__SPLIT_HERE__\nInlets to the rescue\n\nInlets to the Rescue\n\nInlets is a great piece of kit written by Alex Ellis which is basically the Open-Source version of the services mentioned above.\n\nOf course you can contribute to inlets itself using Gitpod.\n\nIt consists of a server which would run in your workspace, and a client which would run on your local machine. The client then acts as a kind of reverse proxy into your local network opening it up to programs running in your Gitpod workspace.\n\nMaking this work involves running both, the server and client:\n\ndownload and run inlets in your workspace:\n\n```bash\ncurl -sLS https://get.inlets.dev | sh\nexport token=$(head -c 16 /dev/urandom | shasum | cut -d\" \" -f1)\necho \"token:  $token\"\necho \"remote: $(gp url 8090 | sed -e 's/https/wss/')\"\n./inlets server --port 8080 --control-port=8090 --token=\"$token\"\n```\n\nGitpod will show you notifications that there are new services on the ports 8080 and 8090. Expose the port 8090 and leave the other one as is.\n\nrun the inlets client on your local machine. The remote address and token are printed by the commands executed in step one.\n\n```bash\ninlets client --remote=<see-above> --token=<see-above> --upstream=<local-addr>\n```\n\nThere&#39;s a lot going on there, so let&#39;s look at things in detail.\nIn the workspace we first download inlets using its shell installer (we could have used brew install inlets, too, but that&#39;s a tad slower). Then we produce a token which prevents unauthorized access to our inlets server. Note that without tokens, the handshake performed by the inlets client and server fails.\n\nWhen starting the inlets server, we separate the control port from the server port. We do this so that we can expose one port, but not the other. This way the control port is exposed to the internet (albeit secured with the access token), but the server port is not. This way we do not expose our local service globally, but only make it available within our Gitpod workspace.\n\nOn the client side (where I just assumed you already have inlets installed), we need to connect to the server we just started. To that end we use the corret remote URL (note the wss://) and token.\nWhat you choose as --upstream depends on which kind of service you want to expose. Suppose you had a webserver running on port 8080 (e.g. curl lama.sh | sh), then this would be --upstream localhost:8080.\n\n__SPLIT_HERE__\nExample 1: your local Docker daemon\n\nRunning a container engine like Docker or containerd in a Gitpod workspace is still work-in-progress. Until that&#39;s possible your only recurse is to connect to a remote daemon.\nUsually that daemon would run somewhere in the cloud, too, e.g. in your dev-cluster. However, some of us don&#39;t have a Kubernetes cluster laying around or just need access to Docker to try something real quick.\n\nThis is not how we plan to ultimatively support Docker/other containers in a Gitpod workspace.\n\nUsing inlets you can make the Docker enging running on your local machine (or in your local network) available in your Gitpod workspace.\n\nI&#39;ve gone ahead and prepared a prepared an example repository that demonstrates this idea:\n\nOpen in Gitpod\n\nOnce the workspace is up and running, follow the instructions in the upper-left terminal to complete the setup.","metadata":{"source":"https://gitpod.io/blog/local-services-in-gitpod"}}],["199",{"pageContent":"Example 2: Home Automation and IoT\n\nSuppose you&#39;re developing a Flutter based app for your disruptive new smarthome product.\nChances are that the device side of that product isn&#39;t exposed to the internet just yet, but only available in your local network.\nIf that thing, as in Internet of Things, is speaking something akin to HTTP (like Yamaha&#39;s MusicCast or anything gRPC based) you could just replicate the setup above, except that you&#39;d substitute Docker for the API you&#39;re trying to talk to.\n\nWhile there are plenty of other services in this space that speak HTTP, think InfluxDB, OpenHAB or Prometheus, some don&#39;t.\nMost notably MQTT based broker or the bulk of AMQP based services.\n\nInlets does not support tunneling TCP. There is yet another project that can shovel TCP through an HTTP tunnel: chisel.\nBy combining the two, you can have programs in your workspace talk to TCP services in your local network/on your machine.\n\n__SPLIT_HERE__\nWrapping up\n\nThis day and age it&#39;s rare enough to find a situation where the service you want to talk to isn&#39;t available on the Internet (outside of corporate policy, that is).\nIf you do find yourself in that situation however, that&#39;s no reason to relinquish the convenience and benefits of Gitpod.","metadata":{"source":"https://gitpod.io/blog/local-services-in-gitpod"}}],["200",{"pageContent":"Shipping applications to production requires them to be battle-tested in the dev environment. The dev environment should mimic the production environment as closely as possible. This comes with a cost: testing cloud applications is cumbersome as they have many moving parts. For instance, if you build a simple Lambda function in AWS, you might use services such as CloudWatch, S3, IAM, etc.\n\nImagine configuring your project and provisioning these cloud resources in a test environment every time for developing new features. It‚Äôs a tiring and time-consuming cycle üò´ -- making the entire development and test feedback loop slow and inefficient.\n\nDeveloping and running cloud applications is simplified with Gitpod and LocalStack ‚ú® Gitpod‚Äôs fully automated, ephemeral workspaces provide a great developer experience. When you open a new workspace, all the required tools and packages get installed. You can also parallelly work on features in multiple ephemeral workspaces, which can be shared with your peers.\nLocalStack accelerates your dev and test feedback loop. It provides you with a fully functional local AWS cloud stack that gives immediate feedback on your changes without waiting on cloud resources. This saves you time and resources.\n\nIn this blog, we describe how you can leverage Gitpod and LocalStack to set up a cloud development workspace without requiring access to your production cloud - allowing you to get productive within seconds.\n\nWhat is LocalStack\nWhat is Gitpod\nHow it works - the combined power of LocalStack and Gitpod\nExample Scenario - Sample application on LocalStack x Gitpod\nKey Benefits\n\n__SPLIT_HERE__\nWhat is LocalStack?\n\nLocalStack is a cloud development platform that aims to turbocharge dev&amp;test feedback loops, team collaboration, and easily reproducible ephemeral cloud environments. At its core, LocalStack provides a fully functional local AWS cloud stack that ships as a Docker image and provides some 70+ high-quality emulated cloud services (e.g., Lambda, S3, DynamoDB, etc). With LocalStack, cloud applications can be developed and executed entirely on your local machine, or in a CI pipeline or other ephemeral environment, without ever talking to the real cloud, reducing dev&amp;test cycles from minutes to seconds.\n\nLocalStack offers entirely new ways for local debugging of Lambdas and containerized apps (e.g., ECS/EKS), as well as some advanced new features that can radically improve productivity and team collaboration patterns.\n\nThere is also a large and growing ecosystem of tools that LocalStack natively integrates with - from Infrastructure-as-Code (IaC) frameworks like Terraform or Pulumi, to application frameworks like Serverless or Architect, to a whole suite of tools provided by AWS itself (CDK, SAM, Copilot, Chalice, etc).\n\n__SPLIT_HERE__\nWhat is Gitpod ?\n\nGitpod is an open-source remote development platform for remote development. It provides an automated setup with cloud-based, remote developer environments connected with a developer‚Äôs editing experience of choice, making developer experiences better.\n\nRather than having a single static environment (like your local machine), Gitpod encourages you to codify your dev environment as code. With your project codified, you‚Äôll be able to spin up a new workspace, start coding and throw away the workspace when you‚Äôre done. You can have multiple workspaces with different contexts open at once - one for your feature, one for a bug or one for your code review directly in Gitpod.","metadata":{"source":"https://gitpod.io/blog/localstack-and-gitpod"}}],["201",{"pageContent":"How it works - the combined power of LocalStack and Gitpod\n\nCombining the development environment of Gitpod with the cloud sandbox provided by LocalStack minimizes friction when developing cloud applications and getting up and running with cloud development within a few minutes.\n\nThe figure below illustrates how the components fit together - on the left-hand side, we can see the user‚Äôs machine and their Web browser, whereas, on the right-hand side, we see the Gitpod workspace running in the Gitpod backend infrastructure.\n\nThe figure is also segmented vertically - in the upper part, we see the code view, i.e., the Gitpod developer environment. Gitpod is not a browser-based IDE but provides fully-automated workspaces (think Linux workstations) in the cloud. You can access them with the code editor of your choice. Gitpod works best with VS Code (browser and desktop), JetBrains IDEs like IntelliJ or GoLand, and Vim. New IDE integrations are added over time.\n\nThe lower part contains the runtime view, i.e., an instantiation of your app that can be used for previewing the application logic and quickly iterating on the logic. The runtime makes use of a LocalStack container that runs inside the Gitpod environment - and allows you to conveniently deploy your cloud application assets into this sandbox, to then preview the results.\n\n\n\nThe screenshot below illustrates how things fit together when spinning up this Gitpod workspace. In the tree view on the left-hand side of VS Code in the browser, we can see the files of your application. The main view shows the source code of your app (e.g., an AWS Lambda handler file), and the terminal view in the lower part shows the log output of the LocalStack Docker instance running in the environment.\n\nThis setup gives us the full power of a cloud development environment where we can develop our AWS cloud app - without the need for any local installation whatsoever, and without ever talking to the production environment in the cloud (hence, not incurring any cloud costs).\n\nGitpod automates the steps for installation of your tools and packages and ensures servers and processes are running, enabling you to develop your cloud application on multiple ephemeral workspaces.LocalStack helps you to test and deploy your cloud application by emulating the AWS cloud services.\n\nLet‚Äôs dive into a concrete example in a bit more detail in the next section üöÄ","metadata":{"source":"https://gitpod.io/blog/localstack-and-gitpod"}}],["202",{"pageContent":"Example Scenario - Sample application on LocalStack x Gitpod\n\nWe demonstrate a sample application, provided as an open source project (https://github.com/whummer/localstack-gitpod-demo), that illustrates how cloud apps can be seamlessly developed using Gitpod and LocalStack.\n\nThe goal of this example is to develop an AWS cloud application that represents a classical asynchronous request worker pattern. Below is a simplified architecture diagram of the application that shows the different components of the application, and how they fit together:\n\nNote: This is a simplified and synthetic application for demonstration purposes, but it is easy to see that a similar application architecture could be used for different real-life purposes - e.g., in a helpdesk application that processes user requests, or some order fulfillment system that processes purchases of a customer. The key part is - even though the application will eventually be deployed on AWS cloud, we can develop and run this entire application with LocalStack running in Gitpod, without ever interacting with a costly production environment in the cloud.\n\nOnce deployed on LocalStack, the sample application will spin up a simple Web user interface to create user requests, which are then processed by the application logic. The timestamps and status updates can be seen in the screenshot below - notice how the request is passing through the different stages - from QUEUED, to PROCESSING, to FINISHED.\n\nNote that - in order for the request to go through these stages, it follows all the steps outlined above - entering through an API Gateway, being processed by an application handler Lambda function that puts a new item to an SQS queue, being picked up by another Lambda that starts a StepFunctions state machine workflow with two steps - a processing Lambda that updates the state in a DynamoDB table, and an archiving Lambda that puts the final result to an S3 bucket, making it available for download by the user. All the steps of this non-trivial application are being executed within the LocalStack container, running in the Gitpod environment.\n\n__SPLIT_HERE__\nTechnical Details\n\nLet‚Äôs dive into some of the technical details of this example, and how to run the sample cloud application entirely within the Gitpod environment, using LocalStack.\n\nFirst open the sample application in Gitpod Workspace.\nOn opening the demo, gitpod.yml configures the project by installing the tools and running the app.\nUpon deployment, the sample app opens a network port 3000 that serves the Web application of the example.\nGitpod opens the demo app in the browser that sends API requests to the LocalStack edge endpoint on 4566 port, which then gets forwarded to the LocalStack instance running within the remote Gitpod environment.\n\nCongratulations üéâ Now, you are ready to develop and run cloud applications using Gitpod and LocalStack. You can also watch the following video, which thoroughly walks you through the whole process:\n\nyoutube: CihxsFcHyEk","metadata":{"source":"https://gitpod.io/blog/localstack-and-gitpod"}}],["203",{"pageContent":"Key Benefits\n\nThere are a number of key benefits of using Gitpod and LocalStack to develop cloud applications:\n\nReproducibility: The setup with the Gitpod workspace running LocalStack makes it extremely easy to create a reproducible environment with all application artifacts pre-configured, allowing team members to become productive within literally a few minutes.\nCollaboration: You can also share running workspaces which makes it possible to quickly look at a workspace together with a (remote) colleague. You can read more about it in Collaboration &amp; Sharing of Workspaces doc.\nSeamless transition into CI: The application configuration can be taken 1:1 and directly transferred to a CI/CD pipeline that deploys the application and executes integration tests to ensure quality, as the business logic of the cloud app evolves over time.\nCost savings: Last but not least, it becomes very easy to run your applications in a sandbox environment, without ever talking to the real cloud, hence not incurring any costs for using any of the real cloud resources.\n\nIf you have any questions about configuring and running your project, drop by Gitpod‚Äôs community Discord server or LocalStack Slack Community. We would love to hear your feedback in the Community.\n\n__SPLIT_HERE__\nResources and Further Reading\n\nLocalStack Website\nGitpod Documentation\nLocalStack GitHub\nGitpod x LocalStack Sample application GitHub Demo\nDevX Pod - The inner feedback loop w/ Waldemar Hummer &amp; Oleg ≈†elajev","metadata":{"source":"https://gitpod.io/blog/localstack-and-gitpod"}}],["204",{"pageContent":"As described earlier this year, Microsoft&#39;s investment into GitHub Codespaces is helping to move more into the mainstream what Gitpod has been pioneering on during the past years. This week is GitHub Universe which is why we thought it&#39;s time to share some additional context and information around the rapidly spreading idea of automated, cloud-based dev environments within the developer community. Furthermore we&#39;d like to congratulate GitHub for joining us in moving software development to the cloud üôå\n\nSince we&#39;ve started building Gitpod in July-2017, we firmly believe that fully-automated developer environments will be the standard for professional developers in 5-10 years. With a big player like Microsoft entering the market this whole space will gain additional velocity üöÄ\n\nWe certainly welcome the additional push Codespaces will bring, but it is important to communicate how Gitpod compares to Codespaces.","metadata":{"source":"https://gitpod.io/blog/moving-software-development-to-the-cloud"}}],["205",{"pageContent":"We certainly welcome the additional push Codespaces will bring, but it is important to communicate how Gitpod compares to Codespaces.\n\nGitpod is an open-source platform which means you get full transparency over how Gitpod works and can even contribute to it. The vibrant open-source community of Gitpod welcomes everyone, and empowers them to develop additional features without restrictions.\n\nFurthermore, you can run Gitpod on your own infrastructure and any cloud provider. Gitpod seamlessly works with GitHub, GitLab and Bitbucket and can be deployed to public, private or hybrid clouds, neatly integrating into your infrastructure, giving you full control of your system and your source code.\n\nAs a highly-optimized Kubernetes application Gitpod is built on next-gen container technology instead of VMs. This allows Gitpod to be extremely resource efficient giving you the best üí• for the üíµ","metadata":{"source":"https://gitpod.io/blog/moving-software-development-to-the-cloud"}}],["206",{"pageContent":"As a highly-optimized Kubernetes application Gitpod is built on next-gen container technology instead of VMs. This allows Gitpod to be extremely resource efficient giving you the best üí• for the üíµ\n\nCompared to virtual machines, isolating workspace containers from each other is harder. At Gitpod we‚Äôve integrated the latest container isolation mechanisms that securely allow users to benefit from the resource efficiency of containers while still having root privileges. For the user this means full access to sudo and docker üê≥ Here‚Äôs a great technical presentation explaining how we make this happen.\n\nThe result is that Gitpod offers more powerful dev environments with a small ecological footprint. Furthermore, we run Gitpod.io on a 100% carbon-neutral cloud service ‚ù§Ô∏èüåç\n\nGitpod is not only extremely fast because of the higher efficiency, but also because of what we call prebuilds. Let‚Äôs take a closer look.","metadata":{"source":"https://gitpod.io/blog/moving-software-development-to-the-cloud"}}],["207",{"pageContent":"Gitpod is not only extremely fast because of the higher efficiency, but also because of what we call prebuilds. Let‚Äôs take a closer look.\n\nThe metric that matters here is the time it takes until a dev environment is ready-to-code. Ready-to-code means that developers can actually start writing code and don‚Äôt have to wait for builds, dependencies to download or code generators to run.\n\nWith GitHub Codespaces and other solutions whenever you start a new dev environment, you are left with a raw copy of the code. So before you start writing code, you‚Äôll need to run a bunch of processes and wait until they are finished.\n\nInstead Gitpod prebuilds dev environments when a new commit is pushed to the remote repository. The following diagram illustrates the idea:\n\nPrebuilds Diagram\n\nThe advantages of having your dev environments prebuilt can not be overstated. For the vscode repository we measured a 15x difference.","metadata":{"source":"https://gitpod.io/blog/moving-software-development-to-the-cloud"}}],["208",{"pageContent":"Prebuilds Diagram\n\nThe advantages of having your dev environments prebuilt can not be overstated. For the vscode repository we measured a 15x difference.\n\nWe believe prebuilding dev environments the way Gitpod does it, is key towards ‚Äúdev environments as code‚Äù. Without prebuilds, developers have to manually maintain and reuse their dev environments, because of the manual labour put into them. Those stateful environments drift apart over time and teams are once again working in very different setups, wasting time and energy with the resulting problems and surprises. With Gitpod &quot;it works (or doesn&#39;t work) on my machine is a thing of the past.\n\nThe real competition is the habit of maintaining stateful environments on overpowered local machines. We welcome GitHub and Microsoft to join forces in convincing developers around the world about the workflow and productivity benefits of automated, cloud-based dev environments ü•∞","metadata":{"source":"https://gitpod.io/blog/moving-software-development-to-the-cloud"}}],["209",{"pageContent":"We are excited about the things we announced yesterday around Root, Docker and VS Code and are already working on big plans we have for next year ü§ì\n\nEphemeral dev environments are going to democratize software development. Allowing anyone to get into a productive coding state on any of their projects and branches with the click of a button is a massive productivity boost. In addition we keep the entire devops pipeline in a centralized, managed system, which provides more security and observability to today‚Äôs developer teams.\n\nWe will continue to focus on automating the provisioning of dev environments that blend in with your existing workflow, integrate into your existing infrastructure and run on any cloud or your own clusters. We do all of this in the open and invite everyone to join us in building an open platform for secure, collaborative and always-ready-to-code developer environments for all developers.\n\nIf you want to learn more you can start with our Introduction to Gitpod.","metadata":{"source":"https://gitpod.io/blog/moving-software-development-to-the-cloud"}}],["210",{"pageContent":"Gitpod is a web-based IDE. As such one would think it only works for web-based projects or anything else that does not require a native UI. However, there‚Äôs still a plethora of native UI applications around and many of them are here to stay. In this article we‚Äôll go through how to use Gitpod for developing native desktop UI applications.\n\nVSCode in Gitpod\n\nA few days ago Gero introduced Docker builds to Gitpod with which you can bring your own Dockerfile (instead of a pre-built image), and Gitpod will build the image for you. We‚Äôll use that feature to setup a cloud-based developer environment for native UI applications.\n\n__SPLIT_HERE__\nHello World\n\nLet‚Äôs use Gitpod to write a simple desktop-native application in Go using libui. First, we create a GitHub repo and a little bit of configuration: we need a Dockerfile to install libui‚Äôs dependencies (see below), and we need to tell Gitpod to use that Dockerfile.\n\n```dockerfile\nFROM gitpod/workspace-full-vnc\nRUN sudo apt-get update && \\\n    sudo apt-get install -y libgtk-3-dev && \\\n    sudo rm -rf /var/lib/apt/lists/*\n```\n\nThis Dockerfile uses the gitpod/workspace-full-vnc image which supports the setup necessary to run X11 and VNC in Gitpod. It runs a web-based VNC viewer on port 6080 ‚Äî during startup, Gitpod will ask you if you want to open this page.\n\nThe Hello World UI example running in GitpodThe Hello World UI example running in Gitpod\n\n__SPLIT_HERE__\nNative UI in Gitpod = X11 + VNC\n\nGitpod runs on Linux, so we need an X11 server that our UI application can connect to. As we do not have a physical display attached, we‚Äôll use a framebuffer based X server, namely Xvfb. Using x11vnc, we can serve the virtual screen of the X server to a VNC client. There are a few VNC clients that run in the browser out there, but we‚Äôll go with one that‚Äôs battle tested: novnc. The combination of Xvfb, x11vnc and novnc is a proven one, and it happens to be the same that e.g. Janitor relies on.\n\nTo make this setup work in Gitpod, we first create a Docker image that has the required tools installed, and a small bash script to tie things together. I went ahead and prepared those things in the workspace images repo. Any Gitpod workspace started using the workspace-full-vnc image, has a DISPLAY environment variable set in the .bashrc and comes with a running X11 server. No need for any manual setup.\n\n__SPLIT_HERE__\nLet‚Äôs go big: running Visual Studio Code in Gitpod\n\nUsing this setup, we can build and run Visual Studio Code in Gitpod. VS Code needs a few more libraries than the bare-bones X11 setup we‚Äôve built so far. But again those libraries are easy enough to install in a Dockerfile:\n\n```dockerfile\nFROM gitpod/workspace-full-vnc\n\nRUN sudo apt-get update && \\\n    sudo apt-get install -y libx11-dev libxkbfile-dev libsecret-1-dev libgconf2‚Äì4 libnss3 && \\\n    sudo rm -rf /var/lib/apt/lists/*\n```\n\nI added this setup to definitely-gp, so that when you open the VS code repository in Gitpod, it will build the application, and start it. To see and interact with the application, open the noVNC session that‚Äôs served on port 6080:\n\nHow to open noVNC served on port 6080\n\n__SPLIT_HERE__\nConclusion\n\nBy plugging together a handful of tools we can develop native UI applications in Gitpod, and stay in the browser altogether. Naturally, this comes with a few limitations, e.g. at the moment this is Linux only, so testing on different platforms is not feasible. Also, noVNC disconnects from the VNC server every now and then; reloading noVNC brings it back.\n\nSurprisingly, frame-rate is not one of those limitations: you could open a browser inside a Gitpod and watch YouTube videos; it‚Äôs best you pick one without sound, though. :)","metadata":{"source":"https://gitpod.io/blog/native-ui-with-vnc"}}],["211",{"pageContent":"At Gitpod our focus has always been to remove all friction from the developer experience and empower developers to be always ready-to-code. Today we are excited to announce a $13m funding round led by General Catalyst, a fully revamped visual &amp; brand identity as well as several product milestones aimed at defining a new product category in modern software development.\n\nAn enter key on its own\n\n__SPLIT_HERE__\nFunding\n\nWe did not need to raise money and actually did not plan for it. We reconsidered when Steve Herrod reached out last November. The first thing he mentioned during our inital call was that he spent the night before configuring and automating his Python environment with Gitpod and was blown away by the automation possibilities. His experience and personality are a 100% match with Gitpod and we feel great adding him as our first external board member. Steve and General Catalyst on our side let us accelerate our roadmap and continue to build out a fully-distributed world class team (we‚Äôre hiring) to move software development to the cloud. Next to General Catalyst all of our early backers participated in the round including Speedinvest, Crane Venture Partners and Vertex Ventures. Thank you for your continous support üôå\n\nA mug with the Gitpod logo\n\n__SPLIT_HERE__\nBrand\n\nWe believe there are standards to be set when it comes to establishing brands in developer tooling. Over the last 2 months we set out to institutionalise design as a key part of the company and will continue to work closely together with our friends at MAD as well as Vic - giving our visual identity a style &amp; feel that is on par with our backend architecture. What we launch today is a back to basics approach where we present a complex, feature-rich developer tool in a clear and simple way. On the way we also learned about kumquats! üçä\n\nA monitor with three open windows\n\n__SPLIT_HERE__\nProduct\n\nProduct is at the core of everything we do. We believe that by 2023 ephemeral cloud-based developer environments will be as common as CI/CD is today. With our new product updates we take a big step towards realizing that vision. Starting today we willl switch to VS Code as the default editing experience in Gitpod. We are also announcing general availability of sudo privileges and Docker support allowing developers to build Docker images and run containers within their Gitpod workspace. This is based on advanced namespace layering technology and a great collaborative effort with our friends from Kinvolk. Lastly, we completely rebuilt the dashboard frontend to speed-up developers‚Äô workflows and bring our UX and UI to 2021 ‚ú®\n\nThe DevX Conf logo\n\n__SPLIT_HERE__\nConference\n\nWe build Gitpod to improve the daily experience of devs when trying to get the job done. Developers should focus on what really matters: being creative and writing code. Instead they borrow time from their primary task to manually do what could be automated, fight accidental complexity, or get surprised by poorly designed tools, APIs, and programming languages. Today we publicly announce DevX Conf (28-29 April) to start from first principles, collaborate, listen, discuss and declutter our workflows, toolchains and minds. We want to spark dialogue across the areas of coding, testing, building, deploying, collaborating on and running software. Speakers include Jason Warner (CTO GitHub), Beyang Liu (CTO Sourcegraph), Josh Long (Spring), Shanea Leven (Founder Codesee), Ellen Chisa (Founder Darklang), Henry Zhu (Steward of BabelJS), Ma√´l Nison (Creator Yarn), Nader Dabit (GraphQL &amp; Serverless), Anurag Goel (Founder Render), Yihong Cheng (Github1s), Tuomas Artman (Founder Linear) and many more. Hope to see you there!","metadata":{"source":"https://gitpod.io/blog/next-chapter-for-gitpod"}}],["212",{"pageContent":"On January 25th Gitpod experienced a global outage that resulted in workspaces not being able to be started, as well as already running workspaces experienced a data loss. The outage lasted for a little over an hour.\n\n__SPLIT_HERE__\nWhat happened?\n\nAt around 5.44pm UTC (all times in this article will be in UTC) we noticed a high error rate when pulling images from the Google Container Registry (GCR or gcr.io) with an error cannot get manifest. Our team immediately started to diagnose what might have caused this, if this was on our end or if Google services were experiencing issues. We started looking at logs and noticed another error while trying to pull an image: dial tcp: i/o timeout failed to do request which showed there was some sort of connectivity problem with GCR. We immediately checked Google‚Äôs status page to see if there are active outages, but there was only one message: The Service Usage API is experiencing elevated error rates when listing &quot;available services&quot; or listing &quot;disabled services&quot; resulting in API call failures. That did not seem related to GCR service, so we assumed that an issue must be on our end instead.\n\nAbout 10 minutes later we started getting reports from users not being able to start workspaces and our on-call team started an incident response process.\n\nWhile we were digging into why we are having problems connecting to GCR, as a precaution, we started to spin up new workspace clusters in EU and US. This was just in case something went bad with existing clusters and we needed to move users to new clusters (that was a good idea). Due to our recent work in automating cluster creation, we were able to start the spin up process in the background via a werft job to create new clusters (which takes about 20 minutes).\n\nAfter looking at logs, we noticed that we were having a lot of DNS errors coming from our CoreDNS pods: [ERROR] plugin/errors: 2 storage.googleapis.com. A: read udp 192.168.60.206:55169-&gt;8.8.8.8:53: i/o timeout. So now it seems like we are not able to talk to Google‚Äôs DNS. But checking DNS and status page again showed no errors. Clearly, we were having networking issues in our clusters, but it was still not clear as to why (no recent changes were done to our clusters).\n\nAt this time new clusters were ready and we checked if those were having issues as well or not. Turns out they were not affected and were working fine. We made a decision to start redirecting traffic to new clusters so that our users will be able to use Gitpod again, while we will continue looking into what happened with the existing cluster.\n\nOnce traffic was diverted to new clusters, we immediately saw workspaces starting up and users reporting in Discord that they are able to start workspaces.\n\nAfter we confirmed that Gitpod is working, we marked the incident as ‚ÄúMonitoring‚Äù and we started the process of trying to understand what happened to the old cluster.\n\n__SPLIT_HERE__\nWhy was there data loss?\n\nWe upload workspace content backups into a private Google Cloud Storage (GCS) bucket. Unfortunately, if our backup service is not able to connect to GCS, then any backup will fail. And that‚Äôs exactly what happened in this case due to the DNS outage. The backup service attempted to resolve the address of GCS but was not able to, and the backup process failed. We are prioritizing work on improving our backup process. As engineers, we truly understand how soul-crushing it is to lose several hours of your work and are fully committed to improving our backup procedures to ensure that it doesn‚Äôt happen again.","metadata":{"source":"https://gitpod.io/blog/no-way-it-is-dns"}}],["213",{"pageContent":"So what exactly happened during the outage?\n\nIt was DNS\n\nWe had a DNS failure inside our cluster. We are using Google‚Äôs primary DNS server (8.8.8.8) to resolve any public addresses, and our cluster was not able to communicate with that server. It looked like any traffic on port 53 UDP was just not getting through, resulting in timeout errors.\n\nWe checked ARP table for overflow, but it appears to be within normal limits before, during, and after the outage.\n\nWe also checked the conntrack table if it got full, but our conntrack utilization was at about 10% only.\n\nWhen we switched traffic away from this cluster, it appears to have recovered shortly after. Indicating some sort of load issue.\n\nAdditional tests were performed on the old cluster to try to reproduce the problem (without the time pressure of recovering as fast as possible), to better understand why we were not able to reach 8.8.8.8 from our cluster. Unfortunately, we were unable to recreate the conditions that led to the network failure.\n\nIn the meantime, we can take solid steps on improving our DNS resiliency and storage durability, more about it in the section below.\n\n__SPLIT_HERE__\nHow are we improving Gitpod?\n\nThere are two big areas of improvement that we can do in light of this outage.\n\nThe first one, most critical, is to avoid any data loss. For this we have created an epic on GitHub to track the work that needs to be done. User data (/workspace) is persisted to individual nodes in workspace clusters. If a node or cluster fails before a backup finishes, and we miss our chance to manually backup (which doesn&#39;t scale well), data loss occurs.\n\nTo protect your data, we&#39;ll use cloud provider persistent volumes, which can survive node and cluster failures. Also, if a workspace enters a state where it cannot be started, we&#39;ll make it possible for you to download your files. Presently, you can only download your files if the workspace is stopped.\n\nThe second one is to improve DNS resilience. Instead of relying on just one DNS server, we now have 3 different ones: an internal one to GCP, Google‚Äôs public 8.8.8.8, and another one is Cloudflare‚Äôs 1.1.1.1. That way if something happens to one of them, we should still be able to connect to the others.\n\nWe are also planning on doing more DNS resiliency work and you can track it in this epic.\n\n__SPLIT_HERE__\nConclusion\n\nAs hard as we try to prevent outages, they sometimes happen. The best we can do is learn from them and improve our infrastructure going forward. We have plans on better support for multi-region clusters (currently we only have two, US and EU), as well as going multi-cloud at some point in the future.\n\nAs an apology to our users, we are also issuing credits to out customers. If you are a paid user, we‚Äôd like to offer you a refund for the last three months. If you are on the free plan, we‚Äôd like to offer you a coupon for 3 months of our unleashed plan.","metadata":{"source":"https://gitpod.io/blog/no-way-it-is-dns"}}],["214",{"pageContent":"Nowadays, there are many collaborative platforms for showcasing JS code snippets and frameworks. Most of them run in your browser, some even manage to magically run Node.js applications in the cloud. They abstract away many possibilities in order to focus on prototyping and learning.\n\nThis simplification (or even magic) eventually turns out to be a hard wall. Once we leave the prototype stage, we need to be able to control and freely combine different versions of frontend and Node.js frameworks, connect to the database that best fits our use case, use different JS flavors and deployment services.\n\nIn this blog post, I will show you a transparent way of getting started with Node.js easily without the magic. The approach taken provides a low entry barrier without the wall once you grow out of it. You will learn how to write Node.js applications in a browser-based environment, that has all the depth of a full local dev environment with VS Code but the friendly onboarding of JSFiddle. These environments can be freely shared to work together and showcase your applications.\n\nThe dev environment is called Gitpod and is entirely free for open-source development.\n\nHello World\n\n\nAutomating Node.js setup\n\n\nWorking with Pull Requests\n\n\nWorking Together\n\n\nDeveloping full-stack Node.js applications\n\n\nSummary","metadata":{"source":"https://gitpod.io/blog/node-js-development"}}],["215",{"pageContent":"Hello World\n\nLet‚Äôs get started by developing a simple ‚ÄúHello World‚Äù application and learning the basics of Node.js development.\n\nStart a new project\n\nGitpod treats any GitHub repository as a project which can be opened. Let‚Äôs start by creating a new repository for our Hello World project:\n\nopen your GitHub dashboard and select New Repository;\n\n\nenter a repository name and click Create repository.\n\nNow, we can open the created project in Gitpod. You can do it by simply prefixing the repository URL with gitpod.io/#. For example, I‚Äôve called my repository node-hello-world and it can be opened in Gitpod with gitpod.io/#https://github.com/akosyakov/node-hello-world.\n\nThe first time, you will need to sign in Gitpod with your GitHub account. GitHub will ask you to authorize read access to your email address. Write access to repositories can be granted later on your access control page.\n\nGitHub Authorize Gitpod Page\n\nGitpod starts a new workspace, which is a Linux-based cloud container, and provides access to it via a VS Code powered online IDE. Workspaces are started on demand and automatically shut-down if you don‚Äôt use them. They are continuously replicated and never deleted, so you always can restart a workspace later from your Gitpod dashboard.\n\nIf you don‚Äôt want to create a new project from scratch, click on a snapshot link of my workspace to try Hello World application. I will cover later how one can make a workspace snapshot.\n\nWriting a Node.js application\n\nBy default, each workspace is preconfigured with standard tools like Node.js, npm, yarn and nvm. Later we will learn how to change the Node.js setup. Now, let‚Äôs code something and run it:\n\nopen the command palette (F1) and select New File command;\n\n\ncreate a new file with app.js name and type the following content:\n\nconst message = &#39;Hello World&#39;;\n\nconsole.log(message, &#39;from Gitpod!&#39;);\n\nAs you type, you can see that Gitpod validates your code. It also provides you with smart completions and documentation on hover.As you type, you can see that Gitpod validates your code. It also provides you with smart completions and documentation on hover.\n\nRun / Debug a Node.js application\n\nIn order to run the application, type node app.js into the terminal.\n\nHow to run a Node.js application in Gitpod\n\nOf course, you can have more than one terminal to your cloud workspace.\n\nNext up, let‚Äôs see how we can debug the application:\n\ncreate a debug configuration (Debug-&gt; Add Configuration) and select Node.js: Launch Program configuration snippet in the content assist of the opened editor;\n\n\nadd a breakpoint into app.js file, by clicking on the gutter on the left;\n\n\nopen the Debug View (View -&gt; Debug),\n\n\npress the green play icon to start debugging (or press F5).\n\nOur program should run, and when a breakpoint hits you can inspect call stack, variables and even use the debug console to evaluate expressions.\n\nWorking with Git\n\nLet‚Äôs have a look at how we can share our changes through Git. Open the Git view, stage your changes, enter a commit message and click commit. You can also open a diff editor by clicking on changed files and push new commits to GitHub with Git: Push... command.\n\nHow to make a commit in Gitpod\n\nIf you have not granted write access to your repositories yet, Gitpod will ask for it. Grant permissions and try to push again.\n\nGitpod prompt grant write access to your repositories","metadata":{"source":"https://gitpod.io/blog/node-js-development"}}],["216",{"pageContent":"Automating Node.js setup\n\nAs mentioned above each workspace by default is preconfigured with standard tools, like Node.js 8.x.\n\nLet‚Äôs assume that we agreed on using Node.js 10.x for our project instead. Usually, all developers have to update their local Node.js versions and often switch between them depending on what project or branch is used.\n\nWith Gitpod, it is different. You can configure a workspace with a specific Node.js version for each branch via Docker images, without changing the local setup for any developer at all.\n\nThe easiest way to initialize the config is to use Gitpod‚Äôs CLI. The CLI will walk you through the most important configuration options and create a .gitpod.yml file that is located in the root of your repository.\n\nIn the terminal type gp init.\n\nFor the first option choose: docker file. It will create a Dockerfile that sits next to .gitpod.yml. Here you can add any kind of tools and dependencies you will need for development. When starting a fresh workspace, Gitpod will pick that Dockerfile up and provide a cloud container based on that.\n\n\nNow press enter until the tasks section. Type node app.js. The tasks are automatically started whenever a workspace gets started. You can have multiple tasks and use different lifecycles. Each task will be opened in a separate terminal.\n\nThe created files will be automatically opened in the editor. Let‚Äôs change the config so that it starts two tasks in separate terminals:\n\n```yaml\nimage:\n  file: Dockerfile\n\ntasks:\n  - init: node --version\n\n  - command: node app.js\n```\n\nAnd change the Dockerfile to use Node.js 10.x as the base image:\n\n```undefined\nFROM node:10\n```\n\nTo try it our we need to push the config back to GitHub and open a new workspace. Let‚Äôs do this through a pull request, so we learn about the GitHub integration on the way.\n\nHere is another snapshot link to try our configuration without opening a pull request. You can learn more about workspace configuration here.\n\n__SPLIT_HERE__\nWorking with Pull Requests\n\nGitpod provides seamless integration with GitHub features like creating and reviewing pull requests.\n\nCreating a new Pull Request\n\nLet‚Äôs open a new pull request from Gitpod:\n\ncommit your changes using the Git view (see above);\n\n\nuse Git: Checkout command or click the branch item in the status bar to create a new branch. Name it somehow, e.g. gitpodify;\n\n\nnext up open the Pull Request view on the right. You cannot create a new pull request yet, because first the new branch should be published to GitHub, click publish changes;\n\n\nafter that, the Pull Request view will be updated and you can open a new pull request.\n\nReviewing a Pull Request\n\nAs I‚Äôve mentioned at the beginning Gitpod treats each GitHub repository as a project. Actually, it is even smarter and can figure out from any GitHub URL which branch should be opened and how.\n\nLet‚Äôs go to the pull request page on GitHub and prefix its URL with gitpod.io/#, just like we did initially:\n\nOpening a PR with new workspace image can take some time since Gitpod needs to build the image. But it is only rebuilt when changed.\n\nAs you can see, Gitpod opens with a branch for your pull request. PR file changes are presented on the left sidebar to review. Our init and command workspace tasks are executed in terminals, Node.js is 10.x now, and Hello World is printed.\n\nWhile reviewing in Gitpod, you can comment, change the code to address comments, suggest new changes, etc. When you are done, merge your pull request from Gitpod as well.\n\nHow to review a PR in Gitpod","metadata":{"source":"https://gitpod.io/blog/node-js-development"}}],["217",{"pageContent":"Working Together\n\nSince Gitpod workspaces are running in the cloud, we can share them in similar ways how you share documents in Google Docs.\n\nHelping others with Node.js development\n\nYou can share your running workspaces with colleagues to collaborate on exactly the same codebase, development tools, running terminals, and applications. It is particularly useful to assist each other on some tricky configuration, dependency or code problem.\n\nIn order to share a running workspace: click on your account avatar, select Share Running Workspace, enable sharing, copy a link and share the copied link with your colleagues.\n\nBoth users use exactly the same workspace and see the shared output in terminals.\n\nShowcasing Node.js applications\n\nYou can take a complete snapshot (clone) of your workspace, even including your IDE layout, and share it as a link. Think about workspace snapshots like code snippets on JSFiddle. It is useful in the same way: to share reproducible examples on issues, Stack Overflow answers, for tutorials and workshops. But at the same, you share the complete development setup and present it in the appropriate way.\n\nIn order to share a workspace snapshot: click on your account avatar, select Share Workspace Snapshot, copy a link and share the copied link where you want.\n\nThe shared workspace snapshot preserves not only the development setup but the IDE layout and even selection in the editor.\n\n__SPLIT_HERE__\nDeveloping full-stack Node.js applications\n\nSo far, we‚Äôve only had a look at a simple Node.js application. In case you wonder whether it will scale to sophisticated applications you can try any of the following repositories:\n\nNode.js Shopping Cart is a reference Node.js application demonstrating how to use the Express framework. You can open it in Gitpod with one-click and follow along this blog post explaining in details how to debug the app.\n\n\nGitpod is based on an open-source IDE framework ‚Äî Theia. It‚Äôs built with a lot of JS technologies, including Node.js, Express, TypeScript and React. And, of course, Gitpod is used to develop Theia.\n\n\nYou even can develop Electron applications in Gitpod, like VS Code. Chris demonstrates it in this blog post.\n\n__SPLIT_HERE__\nSummary\n\nGitpod provides the complete Node.js development experience right from a browser. It enables you to automate your development setup, quickly onboard developers, streamline code review and testing processes on GitHub, help each other in real time, showcase your applications and setups. Also, it is entirely free for open source development!\n\nIf you have any questions, join the Gitpod Community! We are listening intensely to all feedback.","metadata":{"source":"https://gitpod.io/blog/node-js-development"}}],["218",{"pageContent":"Gitpod is based on the open-source Theia IDE Framework, which is highly inspired by VS Code, reuses its major components like the Monaco editor and intelligent-language support and is designed to run as a web application.\n\nAt TypeFox, we use Gitpod to develop Theia and all its satellite projects, like Theia extensions and language servers. We‚Äôve discovered that for most use cases we don‚Äôt need to go to local development anymore. Development, testing, and the review processes are streamlined, leading from source code to a proper developer environment accessible from a browser with a single click.\n\nUp to now, there was one important use case that forced us back to local tools, because it was not supported by Gitpod: Debugging.\n\nNow, it is available, and I would like to give you a run through the basics of Node.js debugging in Gitpod based on an example.\n\n__SPLIT_HERE__\nStep 0: Open Node.js Shopping Cart example in Gitpod\n\nStart a new workspace for the example GitHub repository: https://gitpod.io/#https://github.com/gitpod-io/nodejs-shopping-cart\n\nStart a new Gitpod workspace for the shopping cart example via prefixing the URL with gitpod.io#\n\nA new Gitpod workspace will be opened. Required dependencies are installed automatically since the repository is configured with a .gitpod.yml file. You can see it in the terminal, opened in the bottom area.\n\n__SPLIT_HERE__\nStep 1: Start debugging\n\nGitpod workspace\n\nIn order to start debugging, you should open the debug view first. You can do it via Viewmain menu or with Ctrl/Cmd+Shift+D.\n\nThe debug view allows you to configure launch configurations, start and manage debug sessions. Configurations are persisted debugging setups. They are stored in a VS Code compatible format in a launch.json JSON-file located in your workspace‚Äôs .theia folder. If your project already has the VS Code launch file, then Gitpod will recognize and use it instead.\n\nNode.js Shopping Cart is an Express.js web-application. The repository already has a pre-configured Launch Program configuration, which starts the web server Node.js process in the debug mode. Let‚Äôs run it with F5 or by pressing the run button left to the configuration drop-down.\n\nGitpod Debug Tab\n\n__SPLIT_HERE__\nStep 2: Preview the application\n\nA notification should pop-up suggesting you open an application side-by-side with an editor or externally, in a new browser tab. Let‚Äôs open it side-by-side to be able to debug and use our app at the same time.\n\nGitpod Preview Notification\n\nTake your time and play with the app. You can review items to buy and in your cart, move them into or out of your cart.\n\nGitpod workspace shopping cart application preview\n\n__SPLIT_HERE__\nStep 3: Pause on a breakpoint\n\nIn this step we debug what happens when a user navigates to the homepage.\n\nFirst, we need to add a breakpoint to the routing logic. It is defined in routes/index.js. You can open that file from the navigator or using the quick file palette (Ctrl/Cmd+P) .\n\nGitpod quick file pallete\n\nNext, add a breakpoint in the editor margin against a line which you want to debug. A route callback handling / path looks promising.\n\nDebugging: BreakpointsBreakpoints are displayed in the debug view and applied to currently running sessions.\n\nNow, in the app, try navigating to the homepage. The debug session will pause on the breakpoint. You can traverse the current stack trace, inspect variables and control the execution flow with the debug actions toolbar:\n\nGitpod Debug Menu\n\n__SPLIT_HERE__\nStep 4: Inspect and modify data\n\nThere are several ways to see variables‚Äô values:\n\nyou can traverse current scopes and variables in the debug view;\n\n\nyou can hover over expressions in the editor to evaluate them with a current session;\n\n\nor you can use the debug console (REPL) to evaluate custom expressions.\n\nYou can always double-click on any variable to modify its value.\n\nDebug: Inspect and Modify data","metadata":{"source":"https://gitpod.io/blog/node-js-gitpod"}}],["219",{"pageContent":"Next steps\n\nDebugging is an important feature to provide the complete development experience. The Node.js debugging support is the first step for Gitpod in this direction. We are working to bring more debug features and add support for more runtimes. We would also love to hear what features and runtimes you want to see supported. Tell us.","metadata":{"source":"https://gitpod.io/blog/node-js-gitpod"}}],["220",{"pageContent":"It has been a month already since we went public with Gitpod.io. We want to take a moment and send out a big thank you for all the great feedback and kind words! ‚ù§Ô∏è\n\nWe are working to incorporate all your feedback continuously, adding new features, fixing bugs and improving the overall usability and performance.\nPlease keep sending all that useful feedback!\n\nToday, we are pleased to announce a new version of Gitpod.\n\nA Cake with Sparkles by [Audrey Fretz](https://unsplash.com/@parkstreet?utm_source=medium&amp;utm_medium=referral) on [Unsplash](https://unsplash.com?utm_source=medium&amp;utm_medium=referral)Photo by Audrey Fretz on Unsplash\n\nHere are the most important new features and improvements:\n\n__SPLIT_HERE__\nUnlimited Gitpod Hours! üéÅ\n\nTo allow you using Gitpod as much as you want, during the beta you can now\nadd extra Gitpod Hours whenever you run low on them!\n\nGitpod Dashboard add extra hours\n\n__SPLIT_HERE__\nDocker File Support ‚öôÔ∏è\n\nMost projects need special tools, which can be provided by naming a custom Docker image in your .gitpod file.\n\nStarting today, you can point to a Dockerfile that sits next to the .gitpod file. Gitpod will take care of building and caching it for you. Instead of managing your own Docker builds and versions, simply put the Dockerfile into the repository and you will always have a working setup for the branch at hand.\n\nPlease read Gero‚Äôs post explaining this feature in more detail.\n\nGitpod Workspace startup phase building workspace\n\n__SPLIT_HERE__\nIntroduced CLI ‚å®Ô∏è\n\nWe have introduced a CLI which allows controlling the IDE from the command line, for instance you can open files. Try:\n\n```bash\ngpopen path/to/file\n```\n\nor just\n\n```bash\nopen path/to/file\n```\n\nor in case your muscle memory is taking over :)\n\n```bash\ncode path/to/file\n```\n\nWe will add more features to the CLI. If you have ideas or demands please file tickets over here.\n\n__SPLIT_HERE__\nGitHub Bot ü§ñ\n\nThe Gitpod Bot for GitHub can automatically add Gitpod-links to issues and pull-requests. For instance, if you want to improve onboarding for new contributors you should configure the bot so it adds links to good_first_issue or **help_wanted **tagged issues.\n\nGitpod Bot for GitHub\n\nWe will shortly write a post dedicated to streamlining the contributor‚Äôs experience.\n\n__SPLIT_HERE__\nUser Preferences ü§ì\n\nPreferences and user preferences now allow for customizing your experience individually or per workspace. The workspace preferences are stored in the git repository, while the user preferences are stored in your account and will be used across all your workspaces.\n\nUser Preferences\n\n__SPLIT_HERE__\nChange Language Mode üí¨\n\nSometimes you want to manually change syntax coloring because e.g. no file extension is present. Clicking on the language name in the status bar now allows to quick pick what language to use for an opened editor.\n\nChange Language Mode\n\n__SPLIT_HERE__\nEnhanced Dashboard üíÑ\n\nIn case you want to work a bit longer on a workspace you can now change its description. Also the workspace id is shown in the dashboard so you can tell apart multiple workspaces for the same context.\n\nEnhanced Gitpod Dashboard\n\n__SPLIT_HERE__\nOther Improvements üöÄ\n\nThere are plenty of other improvements and fixes that didn‚Äôt make it to the list. For instance, Go-projects are now automatically set up correctly even without any configuration. Also there are plenty of enhancements that have been added to the TypeScript language server. TSLint now works great and we laid out the foundation to add specific editing support for more frameworks and linters such as Vue.js, Angular and ESLint.\n\nIn addition to the explicitly mentioned features you can find a full list of fixes and changes in the Theia repository.","metadata":{"source":"https://gitpod.io/blog/october-2018-release"}}],["221",{"pageContent":"Next Release üîÜ\n\nWe are targeting a regular release cycle of one month with smaller continuous updates in-between. For the next release we will focus heavily on improving the startup time as well as the lagging dashboards in the US and the Asian region. Besides that we have some exciting new features up our sleeves as well.\n\nStay tuned and have fun! üéâ\n\n(emoji-mode off)","metadata":{"source":"https://gitpod.io/blog/october-2018-release"}}],["222",{"pageContent":"Welcome to DevX Digest - the place to hear all about Developer Experience, brought to you by Pauline Narvas (@paulienuh) and Mike Nikles (@mikenikles) from Gitpod. You‚Äôre reading another newsletter from us üéâ!\n\n__SPLIT_HERE__\nOffloading pressure off developers - can it improve DevX?\n\nHappy New Year, everyone!\n\nTo kick off the year of all things developer experience, we‚Äôre reflecting on our latest DevXPod episode, where we spoke to Shanea Leaven from CodeSee.\n\nOur conversation highlighted some important topics, and we‚Äôll leave you with our key takeaways below. You can also listen to the episode anywhere you get your podcasts! Don‚Äôt forget to subscribe and leave us a rating ‚≠êÔ∏è\n\nDevX Podcast Episode 3\nDevX Pod is available wherever you get your podcasts!\n\nKey Takeaways\n\nThe inspiration behind building CodeSee came after the first-hand frustration of not knowing what a system did. Of course, the only people that knew anything about it had already left the company.\n_‚ÄúI just like, why do we not understand our code? I just kind of yelled it out in desperation. This happens all the time. It wasn&#39;t the first or the second or the third or the fourth time that it happened.‚Äù _\nUnderstanding this system was critical for a feature she was working on to release. Unfortunately, in the end, the feature did not ship.\n\n\nUnlike other careers like architecture, where you have a blueprint of how everything fits together, this is absent in tech. Why is that? This results in frustration, mental fatigue and productivity losses.\nAs Shanea put it, ‚ÄúWe&#39;ve treated code as like this big black box, right? We&#39;ve built this entire industry around this black box. Is it happy? Is it not happy? Does it send us an alert? Can we poke the black box to give us the information that we want?‚Äù\n\n\nCodebases are constantly changing and increasingly getting more complex. Filling developers‚Äô time and mental space with trying to understand all the changing dependencies can slowly eat away at your developer productivity. Our industry should double down and shift focus in helping developers and offloading the mental fatigue.\n\n\n**The concept of ‚Äúcontinuous onboarding‚Äù and ‚Äúcontinuous learning‚Äù came up a lot. **When we discuss onboarding, we usually say it‚Äôs a one-time, fixed-amount time event. Shanea argues it‚Äôs a continuous process that everyone goes through, no matter if they have been in the company for a long time or not. ‚Äú_We have thought about onboarding as continuous onboarding and made our tool to provide, continuous understanding because that&#39;s what you&#39;re trying to do. Some team, some upstream team might&#39;ve made a change. It&#39;s still an understanding that you need to have regardless of when you joined or not._‚Äù\n\n\nShanea recommended Code HS and educative.io as organisations taking developer experience (from an education POV) to another level. For example, Educative breaks down the barriers to learning and makes sure it‚Äôs a positive experience for those who learn differently.\n\nDevX Digest is community-driven\n\nAnother thing about Gitpodders is that we‚Äôre all driven by community feedback, and this newsletter is no exception! Please send us your thoughts, feedback and help us navigate this conversation. We may even feature some of your takes and comments in future newsletters!\n\nCome and hang out with us over on our Discord. üëãüèº","metadata":{"source":"https://gitpod.io/blog/offload-pressure-to-improve-devx"}}],["223",{"pageContent":"Until now, you installed VS Code extensions in Gitpod by drag-and-dropping .vsix files into your workspace. Today, we&#39;re excited to introduce a new, simpler way to install extensions: Just search the new open-source, vendor-neutral marketplace Open VSX directly from your workspace, and install extensions in one click.\n\n__SPLIT_HERE__\nOpen VSX Adoption\n\nSince we&#39;ve announced the Open VSX marketplace a few weeks ago, adoption has been extremely quick.\n\nTo seed the registry, we&#39;ve initially added the most popular open-source extensions ourselves, so that early adopters could immediately find important extensions. We could double down on adding more extensions this way, but it doesn‚Äôt seem to be necessary, because today, there are already more than 200 developers publishing their own extensions to Open VSX. üéâ\n\nAdoption from the tool-side is going well, too. We started by supporting Open VSX from within Theia. Just a couple of days ago, VSCodium, the true open-source version of VS Code, shipped a new release that connects directly to Open VSX instead of Microsoft&#39;s proprietary marketplace. Today, we&#39;re excited to bring you Open VSX support in Gitpod as well.\n\n__SPLIT_HERE__\nInstalling Extensions in Gitpod\n\nAs you may already know, Gitpod lets you describe your dev environment as code. This means that you write configuration and code that makes Gitpod automatically generate ready-to-code dev environments for your project.\n\nAn important part of such a configuration is the set of IDE extensions you need. In Gitpod you have two choices, you can either\n\n[1] Install an extension for your project&#39;s dev environment, or\n\n[2] Install an extension for your personal user profile\n\nOption [1] installs the extension for everyone starting a workspace on the same project. Programming language-specific extensions or those that support certain frameworks, databases, and so on usually go here.\n\nSome extensions however are a matter of personal taste, such as themes and keybindings. You neither want to install and manage those extensions for every project nor do you want to enforce them on your entire team. That‚Äôs when you choose option [2].\n\nyoutube: eD_GQ2lQug8\n\n__SPLIT_HERE__\nWhat If I Can‚Äôt Find the Extension I‚Äôm Looking For?\n\nWhile more and more extensions land in Open VSX on a daily basis, there still might be cases where you are missing a certain extension that exists in the MS marketplace. There are three things you can do:\n\nIdeally, you go to the extension&#39;s repository itself and kindly ask the developer to publish it to Open VSX. Publishing is a one-liner (npx ovsx publish), so it&#39;s really low effort.\nDownload the extension&#39;s .vsix file (e.g. from the extension&#39;s GitHub Releases) and drag and drop it into the IDE&#39;s Extensions view. That will install and activate it automatically.\nCreate a PR over at https://github.com/open-vsx/publish-extensions ‚Äî that&#39;s where we seed the Open VSX registry by automatically publishing popular open-source extensions.\n\nYou can find more information in our docs.","metadata":{"source":"https://gitpod.io/blog/open-vsx-in-gitpod"}}],["224",{"pageContent":"VS Code is used by more than 50% of all developers worldwide. Its extension protocol enabled the broader developer community to create over 16,000 extensions supporting all major programming languages, frameworks, and tools used in modern software projects. While large parts of VS Code are developed as open-source, the actual product (Visual Studio Code) is not open-source.\n\nEclipse Theia, the IDE powering Gitpod, Google Cloud Shell and others, offers a vendor-neutral alternative and is based on parts of the same open-source codebase as VS Code. Theia not only works as an Electron-based desktop app, but also runs in browsers. Furthermore, a highly flexible architecture allows extensive customizations. Arduino‚Äôs new Pro IDE or Arm‚Äôs Mbed Studio are great examples of Theia‚Äôs flexibility. On top of that built-in flexibility, Theia can run VS Code extensions as well.\n\nAnother project, VSCodium, offers a 100% open-source version of VS Code.\n\n__SPLIT_HERE__\nOnly Visual Studio Products May Access The Marketplace\n\nWhile all the projects above support VS Code extensions, only Microsoft products can use and connect to Microsoft‚Äôs Extension Marketplace. Its Terms of Use prevent any non Visual Studio products to access the marketplace.\n\nGitpod employs a workaround where users can upload .vsix files to install extensions. This causes unnecessary friction as users have to download those files directly from GitHub, just to re-upload them to Gitpod. Downloading from the Microsoft Marketplace for any use other than in Microsoft products is prohibited, too.\n\nMost extensions are developed by the community and published under permissive Open Source Licenses. Having to distribute and access these community-owned extensions in a system with such restrictive terms of services does not seem right. We want to fix this and host an open-source extension registry at the vendor-neutral Eclipse Foundation.\n\n__SPLIT_HERE__\nYou Can Host Your Own Registry\n\nIn addition to providing a publicly hosted, vendor-neutral extension registry, we also make the code available as open-source. This way everyone can install their own registry and use it, e.g. inside a company network. As a result, you are not forced to publish proprietary extensions to a public marketplace, but maintain precise control over their availability. This is very similar to common practice found in other ecosystems such as npm, Cargo or Maven.\n\nOpen VSX Registry\n\n__SPLIT_HERE__\nOpen VSX\n\nThis new registry is developed and maintained under the Eclipse Open VSX project. It contains the registry server, a web interface and a CLI to make publishing easy.\n\nThe publicly hosted instance is available at https://open-vsx.org, and the upcoming Theia version 1.0 will use this installation as default registry.\n\nOpen VSX defines its own API, because Microsoft‚Äôs VS Code Marketplace API is proprietary and undocumented. An adapter between these two APIs is possible, planned and required to connect VS Code/VSCodium to Open VSX.\n\n__SPLIT_HERE__\nPublishing\n\nWe would love to see extension developers publish to our registry in addition to Microsoft‚Äôs. To that end we developed a CLI that makes publishing a breeze. The basic four steps to publish your extensions are:\n\nRegister on open-vsx.org through GitHub OAuth\nCreate an access token and copy it\nRun npx ovsx create-namespace &lt;publisher&gt; -p &lt;token&gt; with the publisher name specified in the extension‚Äôs package.json\nRun npx ovsx publish -p &lt;token&gt; in the directory of the extension you want to publish\n\nVisit the Open VSX Wiki for a more in-depth explanation of the publishing process.","metadata":{"source":"https://gitpod.io/blog/open-vsx"}}],["225",{"pageContent":"Seeding the Registry\n\nUntil extension developers start publishing to open-vsx.org themselves, we will publish open-source extensions through a script that is maintained in a GitHub repository. A continuous integration build regularly runs through the list of changes and automatically deploys all the listed projects. If you are missing a certain extension, you can do the following:\n\nAsk the original maintainer to publish to open-vsx.org, pointing them to this post for context.\nIf the maintainer does not respond, create a PR to https://github.com/open-vsx/publish-extensions\n\n__SPLIT_HERE__\nFinal Words\n\nThe VS Code team is doing a great job building a developer experience that is loved and used by more and more developers. The large ecosystem of extensions is unique and provides state-of-the-art tool support for all modern programming languages, frameworks and tools.\n\nWe believe that the assets released as open source should remain readily available to everyone. A vendor-neutral, community-driven marketplace for VS Code extensions is an important first step to make this happen.","metadata":{"source":"https://gitpod.io/blog/open-vsx"}}],["226",{"pageContent":"As of today Gitpod is open source under the AGPL license at github.com/gitpod-io/gitpod. This allows the community to participate in the development of Gitpod, provides more transparency and makes it even easier for developers to use and integrate Gitpod in their workflows.\n\nFor those of you who know us, this probably does not come as a big surprise. Working in open source is in our DNA and everything we‚Äôve created over the past 10 years, including Theia, Xtext, Open VSX and many other projects have been open source. In fact, Gitpod was our only closed-source project and it is a relief to change that going forward.\n\n__SPLIT_HERE__\nOpen-Source Contributions\n\nContributing to Gitpod should be easy and accessible for everyone. All contributions are welcome, including pull requests, issues, documentation as well as updates and tweaks, blog posts, tutoials, and more. Please head over to GitHub to find out about the various ways you can contribute and join our Gitpod Community.\n\nOver the past year, Gitpod has simplified contributions to many open source projects (see contribute.dev for examples). Today, everyone in our team is excited to share our own streamlined development pipeline including Kubernetes preview deployments, an aggressively cached build system, our own slim and fast CI system and of course Gitpod, which continuously beams us into ready-to-code (and debug) dev environments. Chris gave a great talk about this setup earlier this year üëá\n\nyoutube: dFMpXUsJcGM\n\nNaturally, we develop Gitpod in Gitpod. This allows the whole team to spin up fully initialized, remote dev environments on any branch at any time.\n\nIn line with the pets vs. cattle analogy of the cloud-native world, we treat dev environments as automated (yet customizable) resources you can spin up when you need them and close down (and forget about) when you are done with your task. Once you experience the peace of mind of automated, ephemeral dev environments you never want to go back.\n\nSven will run a webinar next week on Thursday, where we will showcase how we use Gitpod internally at Gitpod and how much it improves our workflow. Hope to see you there!\n\nHow Gitpod uses Gitpod\n\n__SPLIT_HERE__\nGitpod Self-Hosted is Now Free\n\nThe SaaS offering of gitpod.io remains the easiest way to streamline your development workflows with continuously prebuilt dev environments.\n\nIn case you want to host Gitpod on your own infrastructure or private cloud, starting today, Gitpod Self-Hosted is free for unlimited users. Organisations using Gitpod Self-Hosted can purchase an enterprise license in order to get additional features like:\n\nSnapshots (share a reproducible workspace with your team)\nLive Share (invite others into your running workspace)\nUnlimited Prebuilds (making ephemeral dev environments possible)\nAdmin Dashboard\n\nOffering a paid plan for enterprises makes it possible for us to keep working towards building a new category in developer tooling, which completes modern DevOps pipelines. In the future we will add additional functionality to both the open source code as well our paid offering.\n\nStart for Free","metadata":{"source":"https://gitpod.io/blog/opensource"}}],["227",{"pageContent":"TL;DR\n\nGitpod introduces open-source project OpenVSCode Server that runs the latest VS Code on a remote machine accessed through a modern web browser.\nThe project is backed by GitLab, VMware, Uber, SAP, Sourcegraph, RStudio, SUSE and many others.\n\nIn retrospect the second half of 2021 will mark an important turning point for remote, cloud-based developer environments. After two years GitHub managed to ship Codespaces (&amp; received a cake üéÇ). With JetBrains‚Äô remote development support developers will be able to choose between IDEs to access Gitpod&#39;s ephemeral, cloud-based developer environments later this year. For those who like the convenience of a browser, we have great news to share today.\n\nWe are excited to announce OpenVSCode Server - an open-source project that makes running VS Code in a browser easily accessible for all developers and organisations. OpenVSCode Server runs upstream VS Code on a remote machine accessed through a modern web browser - from any device, from anywhere.\n\nUnlike other attempts, this project is based on a minimal set of changes and uses the same architecture that powers both Gitpod and GitHub Codespaces at scale.\n\nThe project is officially backed by our partners from GitLab, VMware, Uber, SAP, Sourcegraph, RStudio, SUSE, Tabnine, Render and TypeFox.\n\n__SPLIT_HERE__\nGoals\n\nWe have been approached by individual developers and large organisations asking how we manage to always run the latest VS Code in Gitpod given that Microsoft doesn&#39;t publish the source code they use to enable GitHub Codespaces. Since many developers and organisations want to adopt the approach within their own products and daily workflows with the same low-footprint technique like Gitpod, we decided to share this with everyone.\n\nThe project has the following long-standing objectives:\n\nEnable every developer to run the latest VS Code in the browser based on the same architecture that powers both Gitpod and GitHub Codespaces\nEliminate the need for bad forks of VS Code that introduce unnecessary complexity\nProvide a straightforward upgrade path and low maintenance effort\nDemonstrate that professional software development in the cloud is a reality today\nOffer a browser-based VS Code distribution that is free from the control of Microsoft in addition to the vendor neutral OpenVSX extension registry\n\n__SPLIT_HERE__\nBenefits\n\nWe shared and tested the project with several developers and asked them about the benefits of OpenVSCode Server. Below is a list of the most common responses:\n\nUse the power of the cloud - dependencies, compilation, testing, large data sets can all be run on machines far more powerful than your laptop\nRemote access - you can access those machines from any device such as iPads and Chromebooks via a web browser with the familiar VS Code experience\nSave battery &amp; data - as all CPU and RAM intensive tasks run on the remote machine you will preserve battery life and keep your data plan under control\nKeep your source secure - you keep your dev environment centralized and secure, away from your local machine","metadata":{"source":"https://gitpod.io/blog/openvscode-server-launch"}}],["228",{"pageContent":"Getting started\n\nGetting started is as simple as a one-line docker run command and starting localhost:3000.\n\n```shell\ndocker run -it --init -p 3000:3000 -v \"$(pwd):/home/workspace:cached\" gitpod/openvscode-server\n```\n\nTo run VS Code on the cloud provider of your choice we created guides for AWS, Azure, Digital Ocean, GCP, Railway and Render.\n\nA big thank you to all our engineers involved in making this happen, specifically Anton, Jean Pierre, Filip and Mike!\n\nyoutube: qGR7rgqjdiY\n\nHow is this different to Gitpod?\n\nGitpod is all about removing friction from the developer experience by provisioning and orchestrating automated, ephemeral developer environments for you and your team. An IDE is just one building block of a working cloud based developer environment, in addition to the operating system, databases, compilers and all the other tools you need to be productive. At Gitpod we want to support the IDE or editor you like best, and providing VS Code through the web browser is just one possibility. Alternatively, you can access your Gitpod workspaces through SSH, local VS Code and soon your favorite Jetbrains IDEs.\n\nIf you want one-click, fully automated developer environments that give yourself and your team an unparalleled productivity boost try Gitpod.\n\n\nIf you have a machine somewhere which you would like to access with VS Code through a browser, check out OpenVSCode Server.","metadata":{"source":"https://gitpod.io/blog/openvscode-server-launch"}}],["229",{"pageContent":"We know how important it is for you to customize and perfect your development environment. Of course, you want either your favourite IDE from JetBrains, VS Code as your editor, or even vim. You want your optimal configuration of keyboard shortcuts, spaces vs tabs, editor extensions like Prettier, editor themes like Dracula theme, and fonts like FiraCode.\n\nWith Gitpod, switching to remote development is frictionless üöÄ You can personalize your Gitpod workspaces by configuring your IDE Settings, custom dotfiles and IDE or editor of your choice. Gitpod helps you to get the best of both worlds: ephemeral workspaces and personalization consistent across all Gitpod dev environments.‚ú®\n\nIn this article, we&#39;ll show you three features in Gitpod for personalisation:\n\nHow to configure your IDE and editor\nHow to configure Dotfiles\nHow to configure VS Code settings sync\n\n__SPLIT_HERE__\n1. IDEs &amp; Editor\n\nGitpod currently supports various popular IDEs &amp; Editors üéâ. You can edit code in Gitpod using:\n\nJetBrains IDE‚Äôs via JetBrains Gateway\nVS Code in the browser and VS Code on desktop\nCommand-line-based editors such as Vim\n\nTo configure a specific IDE or editor of your choice for all new workspaces:\n\nYou will need to update your user preferences.\nFor changes to get reflected, you have to restart a workspace. To read more about this in detail, you can refer to the following doc.\n\n__SPLIT_HERE__\n2. Dotfiles\n\nDotfiles are a collective name for a user&#39;s configuration files. As with any configuration file, Dotfiles are used to customize your environment according to personal requirements. For example: customizing your git environment using the .gitconfig file, your bash/ zsh shell using the .bashrc file or .zshrc file, or your vim editor using .vimrc, all these are done using dotfiles. These can also be fully functional scripts.\n\nConfigure Dotfiles in Gitpod Preferences to be loaded on every new workspace.\n\nDotfiles is not to be confused with the .gitpod.yml. Dotfiles are personal to you &amp; they contain all your config settings and preferences that can be consistent and reused across all Gitpod workspaces. Whereas .gitpod.yml is used to prepare the dev environment for your project. The gitpod.yml is a project-specific file that you check into the root of your repository.\n\nNote: You should not necessarily use dotfiles to install heavy applications &amp; libraries and instead use Dockerfiles to leverage the build cache. You can configure custom docker image for your project and can read more about it from here.\n\n__SPLIT_HERE__\nHow Do Dotfiles Work in a Gitpod Workspace?\n\nWhen you create a new Gitpod workspace, the Dotfiles loading process first looks in your preferences to get your dotfiles repository address. If found, the repository is cloned to your new workspace as .dotfiles in the $HOME directory, before searching for executable scripts like install.sh, bootstrap.sh (for the exact script names, see the configure Dotfiles page). The dotfiles are synchronously set up before Gitpod starts to handle the .gitpod.yml start tasks.\n\nThis loading procedure will be repeated each time you create a new Gitpod Workspace. Refer to the configure Dotfiles page in our docs to learn more.\n\n__SPLIT_HERE__\nGetting started with Dotfiles in Gitpod\n\nThe following video shows an example of how to setup Dotfiles, by configuring deno in our Gitpod Workspace.\n\nImportant: Your installation script should be executable. Enter chmod 755 &lt;install-script-name&gt;.sh before committing and pushing it to your dotfiles repository.\n\nAdd the URL of your dotfiles repository in /preferences\nSave the configuration\n\nAll your dotfiles will be configured automatically from the next time you create a new Gitpod Workspace.\n\nYou Can Refer this demo-dotfiles template to Bring your dotfiles to Gitpod.","metadata":{"source":"https://gitpod.io/blog/personalize-your-gitpod-workspace-environment"}}],["230",{"pageContent":"3. VS Code settings sync üîÅ\n\nSettings Sync in VS Code lets you always work with your favorite editor setup by sharing your VS Code configuration such as settings, keybindings, and installed extensions across your machines.\n\nWhile working with Gitpod, you start a new workspace for every task. With Settings Sync, you can avoid resetting your environment for each new workspace üß°\n\nFor VS Code in the browser Gitpod enables Settings Sync by default. Settings Sync keeps polling the backend to ensure your settings are stored, which gets pushed to the Gitpod&#39;s server after the first sync. You can learn more about personalizing your workspace in this video.\n\n__SPLIT_HERE__\nGetting started with Settings Sync in VS Code Desktop\n\nyoutube: wMW2JrCqVA4\n\nInstall and enable the Gitpod extension.\nUsing the Command Palette select: &quot;Settings Sync: Enable signing in with Gitpod&quot;.\nWith this your preferences will be stored in Gitpod‚Äôs server.\nRestart your VS Code Desktop application.Important: You must entirely close VS Code Desktop for changes to take effect.\n\n\nEnable Settings Sync from the Manage gear menu at the bottom of the Activity Bar. Authenticate with Gitpod to enable settings sync.\n\nRead more in the VS Code Setting Sync documentation.\n\n__SPLIT_HERE__\nPower of customization\n\nCustomizing the settings and tools to your preferences and workflows is an important step when using any development environment. Let us know how personalizing your Gitpod workspace environment makes you more productive by joining our community ‚ú®\n\nIf you have any questions, drop by our community Discord server.","metadata":{"source":"https://gitpod.io/blog/personalize-your-gitpod-workspace-environment"}}],["231",{"pageContent":"Once your developer environment is freed from manual setup procedures it can do work even while you are not. We call this continuous development.\n\nA while ago Sven described the idea of developer environment as code. His main point: instead of using outdated README files that describe how to set up our developer environment we should have executable, replicable and version-controlled descriptions thereof. In such a dev-environment as code world, on-boarding new team members/contributors is dead easy, going back to an old branch becomes a breeze (that old setup you had a year ago is now easy to restore) and playing with a new project becomes a joy. All those situations are very much direct use scenarios; you set up a dev-environment using code which you as a developer use straight away.\n\nHowever, a machine-reproducible version of your development setup enables another powerful capability: your dev-environment can already checkout the latest code, download dependencies and build everything. Once you actually open your IDE, everything‚Äôs ready for you. No more siting there and watching paint dry yarn download the internet.\n\nThe number 1 programmer excuse for legitimately slacking off: &#39;My Code is compiling.&#39; - https://xkcd.com/303/\n\n__SPLIT_HERE__\nPaint dries even when you‚Äôre not watching\n\nTurns out we don‚Äôt actually have to be present for those things to happen. What if we had a system that would use our dev-environment description, check out the repo, build everything and then make it available to us?\n\nSounds an awful lot like continuous integration (CI). Except there‚Äôs a subtle difference: CI checks if everything still fits together, i.e. does the code still build and do the tests still pass? The result of continuous integration is a test report and a bunch of built binaries/Docker images/update sites/APK files/you get the point. A CI build does not give you a ready-to-code workspace. But it tells you that the next time you want to build your software things will likely be fine.\n\nContinuous Development means that your code is built before you even open it. Once you open an IDE on your project, everything is ready to go.\n\nThe result of continuous development is a ready-to-code workspace. The second you open your IDE you can start working because all dependencies have been downloaded, indices updated, code generated and compiled, and coffee has been brewed. Your dev environment has done all the things you‚Äôd otherwise do manually, except you didn‚Äôt have to trigger them or watch them finish.","metadata":{"source":"https://gitpod.io/blog/prebuilds"}}],["232",{"pageContent":"How could we build this?\n\nHands with paint on them.Photo by Amaury Salas on Unsplash\n\nTo build a continuous development system we need three things:\n\nA dev-environment-as-code, e.g. based on Docker ‚Äî there are various ways of how this can be achieved.\n\n\nMeans to trigger an action when our code changes. The obvious candidates are webhooks, GitHub actions, or something tied in to your CI system.\n\n\nThe integration bit that upon changes to your code builds the dev-environment, checks out your code, builds it and then serves the resulting ready-to-code environment.\n\nLet‚Äôs sketch out a possible implementation of a such a system. Our dev-environment-as-code is basically a Docker image that contains the tools we need + Eclipse Theia as IDE). Suppose we‚Äôd have this dev-env built as ourprj/dev-env:latest .\n\n```dockerfile\nFROM theiaide/theia:next\n\nUSER root\nRUN apk add go && \\\n    npm install --global yarn\nUSER theia\n```\n\nUsing for example Jenkins or GitHub Actions we can then build a ready-to-code environment using a Dockerfile such as:\n\n```dockerfile\nFROM ourprj/dev-env:latest\n\nWORKDIR /home/project\nCOPY /workspace/ourprj .\n\nRUN yarn install && \\\n    yarn build\n```\n\nOnce we‚Äôre ready to start working on a new feature, or want to review a PR, we just find the previously built Docker image and have everything ready to go. No faffing with git clone, waiting for the code to build or anything of the sorts. We have reduced many minutes of our time to a simple Docker run.\n\nA similar way of implementing this is the way gitpod.io does it (full disclosure: I am one of the folks working on this project). Gitpod comes with a GitHub app that triggers workspace prebuilds which in essence take your dev-environment as code (Dockerfile), execute a set of commands in there and associate the results with the particular commit that triggered it all. When you open a workspace on that commit, you‚Äôll get the results of the prebuild instead of waiting for everything to complete.\n\n__SPLIT_HERE__\nIs this new?\n\nProbably not. The idea has been around in one form or the other. But now, with the advent of machine reproducible dev-environments, Docker &amp; Theia we can finally build this for the real world. I did not find statistics how much time people spend waiting for their stuff to build on any given day. But I know waiting for something that you didn‚Äôt have to wait for is not a good way to spend your time. If anything continuous development helps us developers create more and wait less.","metadata":{"source":"https://gitpod.io/blog/prebuilds"}}],["233",{"pageContent":"Welcome to DevX Digest - the place to hear all about Developer Experience, brought to you by Pauline Narvas (@paulienuh) and Mike Nikles (@mikenikles) from Gitpod. You&#39;re reading another newsletter from us üéâ! In this edition, we deep dive into the psychology behind developer experience. The key question we will be answering today is whether developer experience is not easy because we don&#39;t want it to be?","metadata":{"source":"https://gitpod.io/blog/psychology-of-devx"}}],["234",{"pageContent":"The Psychology of Developer Experience üß†\n\nHave you noticed the language used when describing improved developer experience? Tooling is easier, faster and simpler. Despite these promises, Stripe released a developer coefficient report in 2018, revealing that developers waste a lot of time due to tooling that doesn‚Äôt deliver on its efficiency promises. A waste of time costs money. The question then becomes - why haven‚Äôt things gotten easier?\n\n‚ÄúThe best moments in our lives usually occur if a person‚Äôs body or mind is stretched to its limits in a voluntary effort to accomplish something difficult and worthwhile.‚Äù - Psychologist Mihaly Csikszentimihalyi.\n\nIn other words, the effort put in to accomplish something challenging is a rewarding experience. It feels good being able to do something hard that not everyone can do. Is this why developer experience hasn‚Äôt improved? Because we as developers like the challenge?","metadata":{"source":"https://gitpod.io/blog/psychology-of-devx"}}],["235",{"pageContent":"Think back to the last time you were bored. For example, you have spent so much time doing manual work that could be automated. Automating this task may take a lot longer and is perhaps more difficult to do‚Ä¶ But at the end of it, your brain feels accomplished and as a result, you feel better about the task. You successfully completed the challenge that you set yourself! It was not too easy (boredom) and not too hard. When something is too hard, resistance and anxiety block your brain from ever entering flow. It‚Äôs a balance!\n\nEllen Chisa suggests that perhaps developer experience has been optimising for the wrong thing this whole time? Instead of making things easy, faster, simpler; we should be optimising for the flow we described above. Let‚Äôs delve into this some more using the example of onboarding.\n\nWhen something is too hard üò£","metadata":{"source":"https://gitpod.io/blog/psychology-of-devx"}}],["236",{"pageContent":"When something is too hard üò£\n\nIf onboarding is too hard, you can often hit that wall of frustration and spiralling anxiety that comes with it. So how do we solve this? Leveraging the feeling of familiarity is so important. üéØ\n\nAnchoring familiar onboarding e.g. from the comfort of a CLI tool!\nConnecting the tool to an existing skill\nConnecting to an existing workflow e.g. adding to the toolchain\n\nWhen something is too easy ü•±\n\nOn the other hand, when something is too easy, people can switch off completely. Brains, eh?\n\nThere needs to be enough effort that people feel like they&#39;ve done something meaningful. None of us wants the experience of developing software to just be like copy and paste. The feeling of making some real progress by doing should be embedded into the developer experience as it is what brings people back into the flow. üß†\n\nHow do you solve this? Developers need to be made to feel like something is believably hard.\n\nProgressive disclosure üïπ","metadata":{"source":"https://gitpod.io/blog/psychology-of-devx"}}],["237",{"pageContent":"How do you solve this? Developers need to be made to feel like something is believably hard.\n\nProgressive disclosure üïπ\n\nNow you don‚Äôt want to overwhelm people by providing them with every single bit of information at once.\n\nThis will give you the opposite effect: too much to comprehend and anxiety rises. But if you give too little, folks may feel like they know it all already leading to boredom. The best way to solve this is by sending information over a period of time, this is where progressive disclosure comes in.\n\nIn software, this is done quite well with error messages and documentation. Good error messages can reduce anxiety as users are informed about what is going on and feel empowered to solve it, resulting in flow. Good documentation can also support learning and lead to the feeling of growth.\n\nDifferent learning styles üé≠\n\nDevelopers come from all walks of life, from vast backgrounds and experiences, making awareness of these differences important.","metadata":{"source":"https://gitpod.io/blog/psychology-of-devx"}}],["238",{"pageContent":"Different learning styles üé≠\n\nDevelopers come from all walks of life, from vast backgrounds and experiences, making awareness of these differences important.\n\nFor instance, let‚Äôs take learning styles. Ellen highlighted that developers learn in different ways which contribute to their onboarding experience. Some developers...\n\nRead the documentation üìñ\nStart with a blank canvas and learn by building üíª\nCompletely take apart an application and reverse it to fit their own needs üõ†\n\nIn a similar sentiment, there‚Äôs a saying: the more you know, the more you don‚Äôt know.\n\nEllen experienced this herself when showing darklang to developers with functional programming experience, folks with limited programming experience and those that had internalised imperative models. Interestingly, it was the latter group that struggled the most with onboarding because they had a lot of unlearning to do.\n\nDo your efforts in developer experience account for this diversity?\n\nCustomisation üé®","metadata":{"source":"https://gitpod.io/blog/psychology-of-devx"}}],["239",{"pageContent":"Do your efforts in developer experience account for this diversity?\n\nCustomisation üé®\n\nAnother important part of developer experience is customisation. Ideally, developers will grow with a tool over a couple of years. Giving developers the power to customise their experience will cultivate positive feelings as they improve their expertise in it. This will ultimately lead to users paying it forward, sharing and re-investing in your tool in the long-term, which is great!\n\nThere‚Äôs a reason why people enjoy sharing their CLI tools, colour schemes, remote office set-ups and optimising these things to their needs.\n\nIs developer experience designed not to be easy? üé©","metadata":{"source":"https://gitpod.io/blog/psychology-of-devx"}}],["240",{"pageContent":"There‚Äôs a reason why people enjoy sharing their CLI tools, colour schemes, remote office set-ups and optimising these things to their needs.\n\nIs developer experience designed not to be easy? üé©\n\nWe may need to rethink how we look at developer experience. Instead of promises of tools making our lives easier, better, more efficient, it may be worth honing our focus towards designing balanced experiences that cater for everyone‚Äôs learning styles, improving progressive disclosure and giving more power to the developers to make the experience their own.\n\nAs Ellen ends her DevX Conf talk beautifully:\n\n‚Äúwe don‚Äôt want magic, we want to be magicians.‚Äù ü™Ñ\n\nDevX newsletter is community-driven\n\nAnother thing about Gitpodders is that we&#39;re all driven by community feedback, and this newsletter is no exception! Please send us your thoughts, feedback and help us drive this conversation. We may even feature some of your takes and comments in future newsletters!","metadata":{"source":"https://gitpod.io/blog/psychology-of-devx"}}],["241",{"pageContent":"Come and hang out with us over on our Discord channel.","metadata":{"source":"https://gitpod.io/blog/psychology-of-devx"}}],["242",{"pageContent":"As a developer, how can you increase your velocity to ship? And how can you test what you are about to ship in Production to avoid bad surprises?\n\nThat&#39;s where Gitpod and Qovery come to the rescue:\n\nGitpod will focus on the developer experience, ensuring that individual developers and teams are productive enough and can ship fast.\nWhile Qovery helps developers to be autonomous enough to ship in production and correctly manage their applications.\n\nIn this blog we will learn how can we develop and run applications using Qovery and Gitpod:\n\nWhat is Gitpod\nWhat is Qovery\nHow Gitpod and Qovery Makes Sense Together\nMake a Hotfix with Qovery and Gitpod\nTry a New Feature Before Pushing it to Production\nExample Scenario - Sample application on Qovery x Gitpod\n\n__SPLIT_HERE__\nWhat is Gitpod?\n\nGitpod is an open-source remote development platform for remote development. It provides an automated setup with cloud-based, remote developer environments connected with a developer&#39;s editing experience of choice, making developer experiences better. Gitpod&#39;s Cloud Development Environments (CDEs) help developers to be always ready-to-code from any device, from anywhere.\n\nRather than having a single static environment (like your local machine), Gitpod encourages you to codify your dev environment as code. With your project codified, you&#39;ll be able to spin up a new workspace, start coding and throw away the workspace when you&#39;re done. You can have multiple workspaces with different contexts open at once - one for your feature, one for a bug, or one for your code review directly in Gitpod.\n\n__SPLIT_HERE__\nWhat is Qovery?\n\nQovery is a platform delivering Environments as a Service in your Cloud, where you can build, deploy and test in production-like environments. Qovery turns app deployment and environment provisioning on AWS a breeze. Developers can instantly spin up production-like environments and start shipping in seconds.\n\nQovery introduced the concept of on-demand environments where dev teams can test code changes in isolation by generating Preview environments on every Pull Request.\n\nA preview environment is as good as other deployment environments, e.g., Production, Staging, etc., because it is equipped with everything needed for proper testing in isolation. That includes infrastructure, updated products, integrations, databases, configuration, etc. A preview environment is better than traditional deployment environments because it is super easy to provision and de-provision a preview environment.\n\nPerfectly integrated with the developer&#39;s workflows, the Qovery UI simplifies deployment, debugging, and monitoring from a unified interface. Qovery is pluggable and ready for whatever you may hold. You can grow your stack without re-tooling and disrupting your DevOps team.\n\n__SPLIT_HERE__\nHow Gitpod and Qovery Makes Sense Together\n\nGitpod, integrated into the Qovery console, will work on the developer experience, helping to have a complete cloud development environment for the developers anywhere in no time. On the other side, Qovery will help developer teams be autonomous enough to ship in production and test features in dynamic production-like environments. Let&#39;s see how it works behind the scenes and explore real-life examples.","metadata":{"source":"https://gitpod.io/blog/qovery-and-gitpod"}}],["243",{"pageContent":"The Magic Behind it\n\nQovery is a product that integrates into your working environment, meaning that you can connect it directly to the git account of your choice; it will take the applications from those VCS providers. You can also note that it‚Äôs integrated in the same way with Gitpod as it‚Äôs working on Git, so when you make a change with Gitpod, Qovery detect the change and react to it. You can also integrate your CI/CD, Container Registry if you want to deploy an already build container image. There are several interfaces, such as a web interface, CLI, API and even a Terraform Provider. All the actions you will perform on those interfaces are applied to your Cloud Infrastructure as you connect your Cloud Provider account when registering in just 30 min.\n\n__SPLIT_HERE__\nMake a Hotfix with Qovery and Gitpod\n\nLet&#39;s say you are a developer working in a production environment and need to change quickly because something went wrong! Here are the steps to follow:\n\nThe Gitpod integration on the Qovery console will allow you to make changes by clicking on the &quot;edit code&quot; button in the interface.\n\nBy clicking on this &quot;edit code&quot; button on one of your applications, you will be redirected to Gitpod, which will already be connected to your Git account. Thus, without leaving your browser or any installation needed, you can quickly change on Gitpod with all the correct dependencies loaded and the same complete environment.\n\n\nTo describe your workspace you can configure it through a .gitpod.yml file, located at the root of your project, written in YAML syntax. You can read more about it in Gitpod Documentation.\n\nHere is the example:\n\n```yaml\n# Commands to start on workspace startup\ntasks:\n  - name: Setup & Build\n    before: yarn global add express\n    init: yarn install\n    command: yarn build\n\n# Ports to expose on workspace startup\nports:\n  - port: 3000\n    onOpen: open-preview\n    name: Website\n    description: Website Preview\n```\n\nAfter committing and pushing from Gitpod on your necessary changes, Qovery will automatically re-deploy the new version without any downtime. You can even head to the deployment logs on the Qovery interface to see what happens in real-time such as the rebuild.\n\n__SPLIT_HERE__\nTry a New Feature Before Pushing it to Production\n\nNow let‚Äôs say that you or someone from your team wants to try out a new feature or a change before pushing it into production! Here are the steps to follow:\n\nYou can use the Preview Environment feature from Qovery that you can turn on from your Environment Settings.\n\n\nFor every single pull request that you create for your application, a new environment will be spun up with all the dependencies so you will be able to test that feature. When you close the pull request or merge back, the environment will disappear, so you won‚Äôt pay for resources that you are no longer consuming.\n\n\nOnce the Preview Environment feature is activated, you can follow the same steps as for the first use case, where you click on the ‚Äúedit button‚Äù that will redirect you to Gitpod, but this time, we are just going to create a new branch.\n\n\nOnce your new branch is created on the Gitpod browser interface, make the change wanted on your code, and then you can commit your branch.\n\nGoing back to the Qovery interface, you can find the Git provider button that will redirect your repository, where you can create a merge request (also called a pull request, depending on your Git provider).\n\n\nAfter creating your merge request, you will see that a new environment has been created on Qovery, which is a full-stack environment with Frontend, Backend, API Gateway. So you can test it and change it in a production-like environment without impacting your production or any other environments.","metadata":{"source":"https://gitpod.io/blog/qovery-and-gitpod"}}],["244",{"pageContent":"Example Scenario - Sample application on Qovery x Gitpod\n\nIn this Demo, Nancy (Gitpod) and Romaric (Qovery), will show you how you can easily Develop, Deploy and Run applications on AWS with Gitpod and Qovery!\n\nyoutube: QPXeCmbl2d0\n\nWhether you need to do a hotfix because you messed up something or want to try a new feature before pushing it to production, Gitpod and Qovery are here for you.\nThe power of Gitpod and Qovery combined makes managing the environment and development easy and straightforward. Don‚Äôt wait for one more second and improve your velocity and autonomy today!\n\nIf you have any questions about configuring and running your project, drop by Gitpod‚Äôs community Discord server or Qovery Discord Server. We would love to hear your feedback in the Community.","metadata":{"source":"https://gitpod.io/blog/qovery-and-gitpod"}}],["245",{"pageContent":"The team has been focussing on shipping some major new features, which mark important milestones on our goal to eliminate all friction around maintaining dev environments.\n\nRoot Access üí™\nDocker üê≥\nVS Code and Other IDEs ü•Ç\nConnect to Self-managed GitLab ‚ù§Ô∏è\nNext Steps ‚è©\n\n__SPLIT_HERE__\nRoot Access üí™\n\nGitpod workspaces run as containers which make them incredibly fast and efficient. Compared to VMs, isolating workspace containers from each other is not easy. Due to this difficult isolation, Gitpod operated a fairly restricted set of privileges within its workspaces. This meant you couldn‚Äôt install additional tools using your favourite package manager (think sudo apt-get install ...) or run docker resp. docker-compose. Clearly, this has made some things more difficult than they should be.\n\nAfter investigating different options such as gVisor or virtual machines, we‚Äôve settled on a solution that isolates through user namespaces. Chris, our Chief Architect and author of the isolation mechanics, has explained how it works in detail in this webinar. Long story short, you can now run commands using sudo. So for instance, you can test-install additional packages using apt-get, before adding those commands to your workspace‚Äôs Dockerfile (where setup commands should still go eventually).\n\nyoutube: 5JUfzet1NNg\n\n__SPLIT_HERE__\nDocker üê≥\n\nWith the new privileges you can now also run and build Docker images to start containers within your workspace. Gitpod‚Äôs default image (workspace-full) comes equipped with Docker now, so all you need to do is run sudo docker-up and wait until the service is listening. Now start another terminal and use the Docker CLI as usual. Here is a short screencast showing how to start a simple hello world example.\n\nyoutube: tW9zBHH37Cc\n\nWarning: This is in feature preview for a reason, and there are a few things we still have to sort out. For instance, within Docker containers process ids are not properly mapped which might cause some weird errors. Please provide feedback in the community or the issue tracker.\n\n__SPLIT_HERE__\nVS Code and Other IDEs ü•Ç\n\nAt Gitpod we want to help automate your dev environments, so that you are always ready-to-code. We believe you should not have to compromise in terms of what tools you use. Instead we make sure you get all your favourite tools readily configured and initialised for any project and task. Until today you had no choice but to use Theia, which is a great vendor-neutral IDE that leverages a lot of VS Code‚Äôs tech and provides a very similar UX. Still there are some differences in behaviour and compatibility so many users asked for supporting VS Code (and other IDEs as well).\n\nSince today you can switch between VS Code and Theia in your settings. You can even bring your own web IDE though a Docker image. This enables Gitpod to run other IDEs such as all the Jetbrains IDEs (using projector), Jupyter Notebook, or Jupyter Lab. This feature is however currently still in a private beta, so you need to contact us in order to get access to that.\n\nyoutube: 5hArIRPZuBI\n\nWarning: This is an early preview of the functionality and we haven&#39;t fully implemented all necessary features, yet. For instance, user settings are not persisted among sessions. Also while you can install extensions, they are also not persisted and extension settings from .gitpod.yml are currently ignored. We&#39;ll follow up with these capabilities ASAP.\n\nPlease provide feedback in the community or the issue tracker\n\nWe are also shipping an SSH mode in Q1/21, that will let you connect to Gitpod using your favorite desktop IDE‚Äôs remote mode.","metadata":{"source":"https://gitpod.io/blog/root-docker-and-vscode"}}],["246",{"pageContent":"Connect to Self-managed GitLab ‚ù§Ô∏è\n\nYou can now connect your Self-Hosted GitLab application with gitpod.io. This way you don&#39;t have to host and operate your own Gitpod installation, just to make it work with your GitLab installation. To make this connection, go to the settings and scroll down to the ‚ÄúGit Provider Integrations‚Äù section. Add your instance and follow the instructions.\n\nAfter completing this process, your entire team can open dev environments by prefixing the projects and merge requests URLs on the self-managed instance with gitpod.io# or simply use the Gitpod button provided by GitLab (make sure it is enabled).\n\nGitpod loves GitLab\n\n__SPLIT_HERE__\nNext Steps ‚è©\n\nThere will be a Gitpod Self-Hosted release before Christmas that includes the features listed here as well as many additional enhancements and bugfixes for installing and running Gitpod on different infrastructures.\n\nIn the near future, we will complete the features in preview, work on some important updates around prebuilds, support SSH access to workspaces, and are kicking off a redesign of the dashboard. The future is bright üåÖ.","metadata":{"source":"https://gitpod.io/blog/root-docker-and-vscode"}}],["247",{"pageContent":"When new users try Cloud Development Environments, one of the very first questions they ask is: ‚ÄúHow do you manage access to secrets?‚Äù\n\nDuring local development, the storage and management of secrets is generally an exercise left up to individual developers. Configuration sprawl can eventually occur on each developer‚Äôs laptop, and things like ssh keys, passphrases, AWS configurations, and specific lines in ~/.bash_rc files become untracked dependencies for a project.\n\nOnce the management of secrets has to be a reproducible process for all team members (as in a CDE like Gitpod), the lack of attention secrets hygiene gets on teams can become especially apparent. By using Gitpod Variables and Doppler, teams can consistently enforce secrets management across entire organizations, and rotate keys without a single interaction from developers.\n\n__SPLIT_HERE__\nSecrets Sprawl and Enforced Consistency with Gitpod Variables\n\nAs it stands, developers have a myriad of options when to locally manage secrets and keys. Some prefer to inject environment variables in their ~/.bashrc file, while some tools (like AWS&#39; cli) require secrets within a home sub-directory. Some teams approach the problem of secrets within repositories with .env files, but these approaches inevitably have gaps, or are difficult to update across everyone&#39;s laptops.\n\nWorse still, when secrets management becomes cumbersome, developers can hardcode credentials into their code. This raises the possibility of secrets accidentally being committed to source repositories.\n\nOut of the box, Gitpod offers the ability to set and inject environment variables into workspaces. These environment variables are encrypted when stored on Gitpod, and are injected in the shell environment as plaintext environment variables when running in a Workspace.\n\n(Remember, you can always run env in a workspace bash terminal to see all the environment variables that are set.)\n\nEnvironment variables can be set within Gitpod either by the gp env command, or by setting them in the Variables section of your user account. There they can either be scoped to a single Git repository, or set globally, for things like configuring your shell environment preferences.\n\nWith settable environment variables, users can ensure API keys, passphrases, and certificates are all available within their developer environments, ready for immediate coding.","metadata":{"source":"https://gitpod.io/blog/securely-manage-development-secrets-with-doppler-and-gitpod"}}],["248",{"pageContent":"Doppler and Secrets Management\n\nBut for larger teams, maintaining secrets can become a serious challenge. Distributing access to development keys is hypothetically easy enough, but what about rotating them? And how do you maintain consistency around which secrets are required for which project?\n\nDoppler is a SecretOps platform that allows you to share and sync developer secrets across all environments. Rather than manually setting environment variables via .env files, Doppler allows you to run an executable that injects the latest version of secrets into your binary or configuration files before execution.\n\nLet‚Äôs take a concrete example:\n\nWhen developing an OAuth 2.0 application, developers need to maintain an OAuth Client ID and Secret. Ideally, they‚Äôll also have a static URL for callbacks from the OAuth provider.\n\nIn our case we‚Äôll use ngrok during development to have a static route to our development environment.\n\nDoppler allows you to set up specific instances of your secrets, and have them be injected into your environments, depending on the environment which you‚Äôre running in.\n\nThis is done with a doppler run, right before launching your process. It reads your environment configuration (set either via doppler.yaml or passed via command line arguments), and injects the associated environment variables before running the process.\n\nWith this, we‚Äôre able to do things like share cloud keys, database credentials, certificates, and URLs directly to our executables at execution time.\n\nAs a side effect, using Doppler with Gitpod for development helps ensure we maintain good secret hygiene, by encouraging us to keep secrets consistently stored across all the places we run our software, from development to production. This also ensures our development team always has access to the latest version of secrets, and never has to think about the logistics of rotating keys.\n\n__SPLIT_HERE__\nInjecting Secrets into Configuration Files\n\nBut some secrets don‚Äôt fit well within the environment variable paradigm. These secrets may live deep within yaml files, or custom configuration files in subdirectories not related to our repository. For example, logging and database settings may change from staging to production. For these, Doppler has the --mount command. This behaves as a standard Go template, allowing you to inject your configuration values into a named pipe. (Basically a pipe that behaves as a file but doesn‚Äôt get written to disk.)\n\nFor reference, here‚Äôs how I‚Äôve set up my ngrok account (with a configuration file which must live within my home directory) with Doppler to have a static URL for testing my OAuth 2.0 flow:\n\n```yaml\n# in ngrok.yml\nauthtoken: { { .NGROK_AUTH_TOKEN } }\nregion: us\nversion: 2\ntunnels:\n  fastapi-openid-connect:\n    proto: http\n    hostname: { { .NGROK_DOMAIN } }\n    addr: 127.0.0.1:8000\n```\n\nIn my Doppler development environment, I‚Äôve set the matching variables NGROK_AUTH_TOKEN and NGROK_DOMAIN. To inject these into my Gitpod workspace and run ngrok, I have the following line in my .gitpod.yml:\n\n```bash\ndoppler setup --no-interactive && doppler run --mount /home/gitpod/.config/ngrok/ngrok.yml --mount-template ngrok.yaml -- ngrok start fastapi-openid-connect\n```\n\nWith this, I‚Äôm able to configure my template, and have my secrets get set across both staging and development with the proper values.\n\nNote here that we‚Äôre using named pipes, and not actually writing our template secrets to disk. Doppler offers this as a feature with the --mount and --mount-template options in the doppler run command.","metadata":{"source":"https://gitpod.io/blog/securely-manage-development-secrets-with-doppler-and-gitpod"}}],["249",{"pageContent":"Automating Doppler Secrets Injection on Gitpod\n\nGiven Gitpod‚Äôs ephemeral nature, we ideally want our entire development environment to spin up without any interaction from our part.\n\nTo accomplish this, we first need to create a DOPPLER_TOKEN token environment variable, set to our Doppler token. Again, we can accomplish this via Variables.\n\nIn my case, I‚Äôve scoped my Doppler token to only be injected in my specific repository. This prevents me from opening another Gitpod instance, and injecting my secret where it may not be needed.\n\nOnce this is done, I can then set a project and environment with a doppler.yaml file within my repository. I‚Äôve done the bare minimum in my repository for a compliant Doppler configuration:\n\n```yaml\nsetup:\n  project: fastapi-openid-connect-playground\n  config: dev\n```\n\nWith this, I can then inject environment variables into a command named MY_COMMAND by:\n\n```bash\ndoppler setup --no-interactive && doppler run MY_COMMAND\n```\n\nAlternatively, continuing the example above I can inject my OAuth Client secret, along with my JWKS secret into multiple configuration files with a:\n\n```bash\ndoppler setup --no-interactive && doppler run --mount ../client_secret.json --mount-template oauth2_client_secret.json  -- doppler run --mount-template jwks_secret --mount ../jwks_secret -- doppler run -- uvicorn main:app --reload\n```\n\nAgain, note the -- used to separate our commands between the template mounting and actual execution of our binary. As each of these is written as a separate task within our .gitpod.yaml, we‚Äôll need to again do the doppler setup ‚Äìno-interactive to set our configuration in the user‚Äôs home directory, just in case our task gets executed first.\n\nBecause our secret gets injected at run time, if we need to rotate our secrets, it&#39;s as simple as setting the new value in the Doppler UI.\n\nIn the next post, we‚Äôll cover using Doppler to generate dynamic cloud credentials for ephemeral developer environments. This adds another layer of protection to your secrets, by making them short lived and created on demand to a scoped set of permissions.\n\nSign up for our newsletter below to get notified when we publish it.","metadata":{"source":"https://gitpod.io/blog/securely-manage-development-secrets-with-doppler-and-gitpod"}}],["250",{"pageContent":"Gitpod takes a central position in the software development lifecycle. As such, the security of our product is paramount; not only at runtime, but also as we build and deliver Gitpod. Next to a host of other initiatives (e.g. becoming SOC 2 compliant), we aim to secure our own software supply chain. Today, we are proud to announce that we‚Äôve taken a first step in that direction: Gitpod is now SLSA Level 1 compliant. üéâ\n\nSLSA is an end-to-end framework for ensuring the integrity of software artifacts throughout the software supply chain. It aims for the software to be shipped securely from source to production, and is inspired by Google&#39;s internal &quot;Binary Authorization for Borg&quot;. But what is a software supply chain anyways?\n\n__SPLIT_HERE__\nWhat is a Software Supply Chain?\n\nIn manufacturing, many different components make up an assembly, and many assemblies make up a finished product. Think of a car that consists of multiple parts such as doors, wheels and seats built from raw materials like steel, plastics, aluminium and rubber. Many of these parts and raw materials come from different vendors and suppliers, forming the supply chain.\n\nSoftware engineering is similar. While developing an application, we rely on open source code and external services. We build, test and deploy applications using CI/CD pipelines which have far reaching access to development and production systems. Deep dependency trees without controls (think log4shell), insecure CI/CD pipelines and developer‚Äôs laptops make for attractive attack vectors. Such attacks have been carried out successfully, with SolarWinds and Kaseya it&#39;s not only the Fortune 500 who are at risk, but their suppliers, too. No one wants to become a vehicle for malicious actors and irrevocably destroy the trust that cost so much to build. We must not underestimate the importance of Software Supply Chain Security.\n\nContainers, heavily caching build systems, ever deeper dependency trees (I‚Äôm looking at you, Javascript), require us to up the ante towards supply chain security. Containers famously don‚Äôt offer a security boundary, and this year has seen ample proof of that. Hence, even a minor dependency can put a large part of the infrastructure at risk, without operators even being aware. The log4shell fallout partially was so bad because it took a long time to even find out who was affected.\n\nAs the threat landscape evolves, organizations are looking into mitigation strategies that verify the integrity and security of software artifacts and build systems.","metadata":{"source":"https://gitpod.io/blog/securing-the-software-supply-chain-at-gitpod-with-slsa"}}],["251",{"pageContent":"Building a More Resilient Ecosystem for Supply Chain Security\n\nMany developers and communities are taking initiatives to help mitigate risk and prevent software supply chain attacks ‚ú®\n\nThe Go team, mainly coming from Google, are acutely aware of supply chain issues, and provide a variety of built-in supply chain attack mitigations.\nA significant aspect of preventing software supply chain risks is to keep dependency trees as small as possible. &quot;A little bit of copying is better than a little dependency&quot;. Go contains various functionalities out-of-the-box by copying relevant dependencies code, enabling Go modules with zero dependencies. Our Go code relies on 44% fewer dependencies compared to our TypeScript codebase - at about the same amount of code.\n\nGo offers other features which improve our confidence in the integrity of those components:\n\nGo locks builds by pinning specific versions specified inside the go.mod file. Malicious updates introduced as a new version won&#39;t affect go build automatically\nEven if malicious updates get introduced in the same version as a re-upload, this wouldn&#39;t automatically affect Go builds containing hashes of all dependencies that contribute to a build specified in the go.sum file. An incomplete or incorrect file will cause an error - version content will always remain the same\nGo modules are directly consumed through the version control system without an additional package repository that could get compromised.\n\nIf you want to read more about how Go mitigates supply chain attacks, you can read it here.\n\nBeyond individual languages, there are broader efforts underway in the cloud-native community. The sigstore project is building a comprehensive tool chain to sign and verify software artifacts. Cosign can sign and verify containers from an OCI registry. Fulcio nicely solves the hard key-management problems by issuing short-lived keys tied to an OpenID connect token. In combination with Rekor, all these operations are logged in a tamper proof transparency log for auditability.\n\nRecently, with the release of Version 1.24 &quot;Stargazer&quot;, Kubernetes adapted Sigstore to generate signed provenance enabling the community to verify signatures of software artifacts and review how they have been built.\n\n__SPLIT_HERE__\nSLSA is hot üî•\n\nSupply chain Levels for Software Artifacts, SLSA in short, is a security framework which introduces common terminology, standards and process controls to improve supply chain security. SLSA consists of four different levels of assurance that provide a predefined roadmap to artifact security and allow linear progression between levels. Following this multi-level approach, it‚Äôs particularly easy to get started with. Also, SLSA brings value even if the transitive dependencies of a project have not yet adopted it. This combination predestines SLSA for a lang-and-expand motion in modern software ecologies.\n\nSLSA level 1 focuses on providing transparency and documentation of the build process. The key concept here is provenance, i.e. a record of prior ownership and involvement. Starting with this level, build systems are required to keep a record of their involvement, which sources went into the build process, and which process was used. All this data is recorded using in-toto attestations and published alongside the actual build artifacts.\n\nHaving this provenance offers a number of benefits. For one, it provides traceability for artifacts deployed in production, which greatly helps when debugging issues. It prevents the simplest of supply chain attacks (think cache poisoning) if the provenance requires different permissions to upload. Delivery pipelines can assert qualities about the artifacts they‚Äôre about to deploy, e.g. that the code was built from a clean working copy, hence the entire state is recorded in a version control system.\n\nTo read more about the remaining three levels, head over to the SLSA page.","metadata":{"source":"https://gitpod.io/blog/securing-the-software-supply-chain-at-gitpod-with-slsa"}}],["252",{"pageContent":"Making Gitpod SLSA level 1 compliant\n\nGenerating Provenance\n\nWe use a heavily caching build system called Leeway. Leeway recently gained support for producing SLSA/in-toto provenance during its build, and maintains that provenance as part of its cache. A package build produces an attestation bundle, which contains a number of SLSA attestations (records) that were created during the build; one per package.\n\nFor example, building one of Gitpod‚Äôs component yields entries for each of its dependencies within our source tree:","metadata":{"source":"https://gitpod.io/blog/securing-the-software-supply-chain-at-gitpod-with-slsa"}}],["253",{"pageContent":"```bash\ngitpod /workspace/gitpod (main) $ leeway build --save out.tar.gz components/ws-manager:app\n‚òÅÔ∏è  checking remote cache for past build artifacts\nüì¶  cached  components/common-go:lib               (version 29fc1af63929607ec2f48e5e34095d4f236fcad7)\nüì¶  cached  components/content-service-api/go:lib  (version c349f5dbbaf9f911c3097b38cb715ba10af7c8f4)\nüì¶  cached  components/content-service:lib         (version ec596e8eed59d221f14c1170fddfd21c558c7efb)\nüì¶  cached  components/image-builder-api/go:lib    (version 45286faf29d40a249430d35d6b04119b48a88570)\nüì¶  cached  components/ws-daemon-api/go:lib        (version 2a8a3fb20bb4149baae445f33cc38e0d01d05ff5)\nüì¶  cached  components/ws-manager-api/go:lib       (version 37ca7e9e7117e744722413934ff24684619db42c)\nüîß  build   components/registry-facade-api/go:lib  (version ddddf609debf50fc38c2a107deffb83b15749ae9)\nüîß  build   components/ws-manager:app              (version 91a5fae2f2b869ecbd7f278a17122f283ff9fc83)\nbuild succeded","metadata":{"source":"https://gitpod.io/blog/securing-the-software-supply-chain-at-gitpod-with-slsa"}}],["254",{"pageContent":"üîß  build   components/ws-manager:app              (version 91a5fae2f2b869ecbd7f278a17122f283ff9fc83)\nbuild succeded\nüíæ  saving build result to out.tar.gz","metadata":{"source":"https://gitpod.io/blog/securing-the-software-supply-chain-at-gitpod-with-slsa"}}],["255",{"pageContent":"gitpod /workspace/gitpod (main) $ tar Oxf out.tar.gz ./provenance-bundle.jsonl","metadata":{"source":"https://gitpod.io/blog/securing-the-software-supply-chain-at-gitpod-with-slsa"}}],["256",{"pageContent":"{\"payloadType\":\"application/vnd.in-toto+json\",\"payload\":\"ewogICJfdHlwZSI6ICJodHRwczovL2luLXRvdG8uaW8vU3RhdGVtZW50L3YwLjEiLAogICJwcmVkaWNhdGVUeXBlIjogImh0dHBzOi8vc2xzYS5kZXYvcHJvdmVuYW5jZS92MC4xIiwKICAic3ViamVjdCI6IFsKICAgIHsKICAgICAgIm5hbWUiOiAiL190ZXN0cy91dGlsLnRlc3QiLAogICAgICAiZGlnZXN0IjogewogICAgICAgICJzaGEyNTYiOiAiZjU0ZmFjY2VlMTJhZDMzMmMwNWRiMDdjZmYzYjRkNTFjZmVmZTEwOTJlYTVlYTdlYmU3MTAxMzYzZjFiZDRlYiIKICAgICAgfQogICAgfSwKICAgIHsKICAgICAgIm5hbWUiOiAiL190ZXN0cy9jZ3JvdXBzLnRlc3QiLAogICAgICAiZGlnZXN0IjogewogICAgICAgICJzaGEyNTYiOiAiODAzNDg5NWI5NWNjM2M2M2NjZjAwNjc3MWYwZGRhYjg4OTc3M2JjNzExMGMxYTQyN2VmZTg0OGZhOGIwYjM4ZCIKICAgICAgfQogICAgfSwKICAgIHsKICAgICAgIm5hbWUiOiAiL190ZXN0cy9uYW1lZ2VuLnRlc3QiLAogICAgICAiZGlnZXN0IjogewogICAgICAgICJzaGEyNTYiOiAiN2I0Yzc3MjgxZmYyZjk2ZjkxZTk5YjAxZWZhY2JmMjZlMzJjMjMyMWJhZGUwN2FmMmI1MTg5OGM4MTVmMTVmMiIKICAgICAgfQogICAgfSwKICAgIHsKICAgICAgIm5hbWUiOiAiL190ZXN0cy9iYXNlc2VydmVyLnRlc3QiLAogICAgICAiZGlnZXN0IjogewogICAgICAgICJzaGEyNTYiOiAiZjhmOWU1MTNjMjMzMDk3YWQ1OG","metadata":{"source":"https://gitpod.io/blog/securing-the-software-supply-chain-at-gitpod-with-slsa"}}],["257",{"pageContent":"JjMjMyMWJhZGUwN2FmMmI1MTg5OGM4MTVmMTVmMiIKICAgICAgfQogICAgfSwKICAgIHsKICAgICAgIm5hbWUiOiAiL190ZXN0cy9iYXNlc2VydmVyLnRlc3QiLAogICAgICAiZGlnZXN0IjogewogICAgICAgICJzaGEyNTYiOiAiZjhmOWU1MTNjMjMzMDk3YWQ1OGM4ZDFmYzYwODczMjg4NGMyNjExNWQ1MGM2YTUyMTE1N2MwOTFmNTBjN2VmMiIKICAgICAgfQogICAgfSwKICAgIHsKICAgICAgIm5hbWUiOiAiL190ZXN0cy9sb2cudGVzdCIsCiAgICAgICJkaWdlc3QiOiB7CiAgICAgICAgInNoYTI1NiI6ICIyZTY5MmFiZDViYTEwOTFlYWMyZmMwNzY3M2JjM2E5N2I0OTBkYjA5NGMzYjYwYzNiMWE4OTZkNmM3NWFmOTRhIgogICAgICB9CiAgICB9LAogICAgewogICAgICAibmFtZSI6ICIvX3Rlc3RzL2dycGMudGVzdCIsCiAgICAgICJkaWdlc3QiOiB7CiAgICAgICAgInNoYTI1NiI6ICJiZDYxYjM3ZmI1YmFmMmI5N2E5MDQ2M2U3NmI5ODc4NmQ1ZTgwYWY4ZjdkNTU2ZDhjMGMwZmRjMDNkNmJkZjc2IgogICAgICB9CiAgICB9CiAgXSwKICAicHJlZGljYXRlIjogewogICAgImJ1aWxkZXIiOiB7CiAgICAgICJpZCI6ICJnaXRodWIuY29tL2dpdHBvZC1pby9sZWV3YXk6MC4yLjE3LTNlYmZiMmFAc2hhMjU2OmI5NjI5ZTJkMDQzMmFkZWExYmU3ZGRkYjM2MDNlMzZkOWY2OWIwOWQ4OTg1ZjcyNTI1N2FkYWFkZTUxZDRhNDAiCiAgICB9LAogICAgInJlY2lwZSI6IHsKICAgICAgInR5cGUiOiAiaHR0cHM6Ly9naXRodWIuY","metadata":{"source":"https://gitpod.io/blog/securing-the-software-supply-chain-at-gitpod-with-slsa"}}],["258",{"pageContent":"y9sZWV3YXk6MC4yLjE3LTNlYmZiMmFAc2hhMjU2OmI5NjI5ZTJkMDQzMmFkZWExYmU3ZGRkYjM2MDNlMzZkOWY2OWIwOWQ4OTg1ZjcyNTI1N2FkYWFkZTUxZDRhNDAiCiAgICB9LAogICAgInJlY2lwZSI6IHsKICAgICAgInR5cGUiOiAiaHR0cHM6Ly9naXRodWIuY29tL2dpdHBvZC1pby9sZWV3YXkvYnVpbGRAZ286MiIsCiAgICAgICJkZWZpbmVkSW5NYXRlcmlhbCI6IDAsCiAgICAgICJlbnRyeVBvaW50IjogImNvbXBvbmVudHMvY29tbW9uLWdvOmxpYiIsCiAgICAgICJhcmd1bWVudHMiOiBbCiAgICAgICAgImxlZXdheSIsCiAgICAgICAgImJ1aWxkIiwKICAgICAgICAiLS1zYXZlIiwKICAgICAgICAib3V0LnRhci5neiIsCiAgICAgICAgImNvbXBvbmVudHMvd3MtbWFuYWdlcjphcHAiCiAgICAgIF0sCiAgICAgICJlbnZpcm9ubWVudCI6IHsKICAgICAgICAibWFuaWZlc3QiOiB7CiAgICAgICAgICAiYXJjaCI6ICJhbWQ2NCIsCiAgICAgICAgICAiZ28iOiAiZ28gdmVyc2lvbiBnbzEuMTguMyBsaW51eC9hbWQ2NCIsCiAgICAgICAgICAibm9kZSI6ICJ2MTYuMTUuMCIsCiAgICAgICAgICAib3MiOiAibGludXgiLAogICAgICAgICAgInlhcm4iOiAiMS4yMi4xOSIKICAgICAgICB9CiAgICAgIH0KICAgIH0sCiAgICAibWV0YWRhdGEiOiB7CiAgICAgICJidWlsZFN0YXJ0ZWRPbiI6ICIyMDIyLTA2LTEwVDEzOjIzOjI4LjE4MDk5NTI1WiIsCiAgICAgICJidWlsZEZpbmlzaGVkT24iOiAiMjAyMi0wNi0xMFQxMzoy","metadata":{"source":"https://gitpod.io/blog/securing-the-software-supply-chain-at-gitpod-with-slsa"}}],["259",{"pageContent":"MS4yMi4xOSIKICAgICAgICB9CiAgICAgIH0KICAgIH0sCiAgICAibWV0YWRhdGEiOiB7CiAgICAgICJidWlsZFN0YXJ0ZWRPbiI6ICIyMDIyLTA2LTEwVDEzOjIzOjI4LjE4MDk5NTI1WiIsCiAgICAgICJidWlsZEZpbmlzaGVkT24iOiAiMjAyMi0wNi0xMFQxMzoyMzozNy43MzMyOTA4MTNaIiwKICAgICAgImNvbXBsZXRlbmVzcyI6IHsKICAgICAgICAiYXJndW1lbnRzIjogdHJ1ZSwKICAgICAgICAiZW52aXJvbm1lbnQiOiBmYWxzZSwKICAgICAgICAibWF0ZXJpYWxzIjogdHJ1ZQogICAgICB9LAogICAgICAicmVwcm9kdWNpYmxlIjogZmFsc2UKICAgIH0sCiAgICAibWF0ZXJpYWxzIjogWwogICAgICB7CiAgICAgICAgInVyaSI6ICJnaXQraHR0cHM6Ly9naXRodWIuY29tL2dpdHBvZC1pby9naXRwb2QuZ2l0IiwKICAgICAgICAiZGlnZXN0IjogewogICAgICAgICAgInNoYTI1NiI6ICI1MTc2YTkwOGQ3YTdlYWVjZjQwMjAwNTIwZWFlNmYxYTZlMTk5ZTM1IgogICAgICAgIH0KICAgICAgfQogICAgXQogIH0KfQ==\",\"signatures\":null}","metadata":{"source":"https://gitpod.io/blog/securing-the-software-supply-chain-at-gitpod-with-slsa"}}],["260",{"pageContent":"{\"payloadType\":\"application/vnd.in-toto+json\",\"payload\":\"ewogICJfdHlwZSI6ICJodHRwczovL2luLXRvdG8uaW8vU3RhdGVtZW50L3YwLjEiLAogICJwcmVkaWNhdGVUeXBlIjogImh0dHBzOi8vc2xzYS5kZXYvcHJvdmVuYW5jZS92MC4xIiwKICAic3ViamVjdCI6IFtdLAogICJwcmVkaWNhdGUiOiB7CiAgICAiYnVpbGRlciI6IHsKICAgICAgImlkIjogImdpdGh1Yi5jb20vZ2l0cG9kLWlvL2xlZXdheTowLjIuMTctM2ViZmIyYUBzaGEyNTY6Yjk2MjllMmQwNDMyYWRlYTFiZTdkZGRiMzYwM2UzNmQ5ZjY5YjA5ZDg5ODVmNzI1MjU3YWRhYWRlNTFkNGE0MCIKICAgIH0sCiAgICAicmVjaXBlIjogewogICAgICAidHlwZSI6ICJodHRwczovL2dpdGh1Yi5jb20vZ2l0cG9kLWlvL2xlZXdheS9idWlsZEBnbzoyIiwKICAgICAgImRlZmluZWRJbk1hdGVyaWFsIjogMCwKICAgICAgImVudHJ5UG9pbnQiOiAiY29tcG9uZW50cy9jb250ZW50LXNlcnZpY2UtYXBpL2dvOmxpYiIsCiAgICAgICJhcmd1bWVudHMiOiBbCiAgICAgICAgImxlZXdheSIsCiAgICAgICAgImJ1aWxkIiwKICAgICAgICAiLS1zYXZlIiwKICAgICAgICAib3V0LnRhci5neiIsCiAgICAgICAgImNvbXBvbmVudHMvd3MtbWFuYWdlcjphcHAiCiAgICAgIF0sCiAgICAgICJlbnZpcm9ubWVudCI6IHsKICAgICAgICAibWFuaWZlc3QiOiB7CiAgICAgICAgICAiYXJjaCI6ICJhbWQ2NCIsCiAgICAgICAgICAiZ28iOiAiZ28gdmVyc2lvbiBnbz","metadata":{"source":"https://gitpod.io/blog/securing-the-software-supply-chain-at-gitpod-with-slsa"}}],["261",{"pageContent":"IsCiAgICAgICAgImNvbXBvbmVudHMvd3MtbWFuYWdlcjphcHAiCiAgICAgIF0sCiAgICAgICJlbnZpcm9ubWVudCI6IHsKICAgICAgICAibWFuaWZlc3QiOiB7CiAgICAgICAgICAiYXJjaCI6ICJhbWQ2NCIsCiAgICAgICAgICAiZ28iOiAiZ28gdmVyc2lvbiBnbzEuMTguMyBsaW51eC9hbWQ2NCIsCiAgICAgICAgICAibm9kZSI6ICJ2MTYuMTUuMCIsCiAgICAgICAgICAib3MiOiAibGludXgiLAogICAgICAgICAgInlhcm4iOiAiMS4yMi4xOSIKICAgICAgICB9CiAgICAgIH0KICAgIH0sCiAgICAibWV0YWRhdGEiOiB7CiAgICAgICJidWlsZFN0YXJ0ZWRPbiI6ICIyMDIyLTA2LTEwVDEzOjIzOjQwLjI0NzAwMTk5MloiLAogICAgICAiYnVpbGRGaW5pc2hlZE9uIjogIjIwMjItMDYtMTBUMTM6MjM6NDIuOTU0MTA4MTM1WiIsCiAgICAgICJjb21wbGV0ZW5lc3MiOiB7CiAgICAgICAgImFyZ3VtZW50cyI6IHRydWUsCiAgICAgICAgImVudmlyb25tZW50IjogZmFsc2UsCiAgICAgICAgIm1hdGVyaWFscyI6IHRydWUKICAgICAgfSwKICAgICAgInJlcHJvZHVjaWJsZSI6IGZhbHNlCiAgICB9LAogICAgIm1hdGVyaWFscyI6IFsKICAgICAgewogICAgICAgICJ1cmkiOiAiZ2l0K2h0dHBzOi8vZ2l0aHViLmNvbS9naXRwb2QtaW8vZ2l0cG9kLmdpdCIsCiAgICAgICAgImRpZ2VzdCI6IHsKICAgICAgICAgICJzaGEyNTYiOiAiNTE3NmE5MDhkN2E3ZWFlY2Y0MDIwMDUyMGVhZTZmMWE2ZTE5OWUzNSIKICAgICAgICB9CiAgI","metadata":{"source":"https://gitpod.io/blog/securing-the-software-supply-chain-at-gitpod-with-slsa"}}],["262",{"pageContent":"CJ1cmkiOiAiZ2l0K2h0dHBzOi8vZ2l0aHViLmNvbS9naXRwb2QtaW8vZ2l0cG9kLmdpdCIsCiAgICAgICAgImRpZ2VzdCI6IHsKICAgICAgICAgICJzaGEyNTYiOiAiNTE3NmE5MDhkN2E3ZWFlY2Y0MDIwMDUyMGVhZTZmMWE2ZTE5OWUzNSIKICAgICAgICB9CiAgICAgIH0KICAgIF0KICB9Cn0=\",\"signatures\":null}","metadata":{"source":"https://gitpod.io/blog/securing-the-software-supply-chain-at-gitpod-with-slsa"}}],["263",{"pageContent":"...\n```","metadata":{"source":"https://gitpod.io/blog/securing-the-software-supply-chain-at-gitpod-with-slsa"}}],["264",{"pageContent":"Notice that the built package carries a provenance-bundle.jsonl file. This newline delimited JSON file contains attestations for all dependencies built using leeway. Let‚Äôs look at one of those base64 monsters in more detail.","metadata":{"source":"https://gitpod.io/blog/securing-the-software-supply-chain-at-gitpod-with-slsa"}}],["265",{"pageContent":"```bash\ngitpod /workspace/gitpod (main) $ tar Oxf out.tar.gz ./provenance-bundle.jsonl | jq -r .payload | base64 -d | jq\n{\n  \"_type\": \"https://in-toto.io/Statement/v0.1\",\n  \"predicateType\": \"https://slsa.dev/provenance/v0.1\",\n  \"subject\": [\n    {\n      \"name\": \"/_tests/util.test\",\n      \"digest\": {\n        \"sha256\": \"f54faccee12ad332c05db07cff3b4d51cfefe1092ea5ea7ebe7101363f1bd4eb\"\n      }\n    },\n    {\n      \"name\": \"/_tests/cgroups.test\",\n      \"digest\": {\n        \"sha256\": \"8034895b95cc3c63ccf006771f0ddab889773bc7110c1a427efe848fa8b0b38d\"\n      }\n    },\n    {\n      \"name\": \"/_tests/namegen.test\",\n      \"digest\": {\n        \"sha256\": \"7b4c77281ff2f96f91e99b01efacbf26e32c2321bade07af2b51898c815f15f2\"\n      }\n    },\n    {\n      \"name\": \"/_tests/baseserver.test\",\n      \"digest\": {\n        \"sha256\": \"f8f9e513c233097ad58c8d1fc608732884c26115d50c6a521157c091f50c7ef2\"\n      }\n    },\n    {\n      \"name\": \"/_tests/log.test\",\n      \"digest\": {\n        \"sha256\": \"2e692abd5ba1091eac2fc07673bc3a97b490db094c3b60c3b1a896d6c75af94a\"","metadata":{"source":"https://gitpod.io/blog/securing-the-software-supply-chain-at-gitpod-with-slsa"}}],["266",{"pageContent":"}\n    },\n    {\n      \"name\": \"/_tests/log.test\",\n      \"digest\": {\n        \"sha256\": \"2e692abd5ba1091eac2fc07673bc3a97b490db094c3b60c3b1a896d6c75af94a\"\n      }\n    },\n    {\n      \"name\": \"/_tests/grpc.test\",\n      \"digest\": {\n        \"sha256\": \"bd61b37fb5baf2b97a90463e76b98786d5e80af8f7d556d8c0c0fdc03d6bdf76\"\n      }\n    }\n  ],\n  \"predicate\": {\n    \"builder\": {\n      \"id\": \"github.com/gitpod-io/leeway:0.2.17-3ebfb2a@sha256:b9629e2d0432adea1be7dddb3603e36d9f69b09d8985f725257adaade51d4a40\"\n    },\n    \"recipe\": {\n      \"type\": \"https://github.com/gitpod-io/leeway/build@go:2\",\n      \"definedInMaterial\": 0,\n      \"entryPoint\": \"components/common-go:lib\",\n      \"arguments\": [\n        \"leeway\",\n        \"build\",\n        \"--save\",\n        \"out.tar.gz\",\n        \"components/ws-manager:app\"\n      ],\n      \"environment\": {\n        \"manifest\": {\n          \"arch\": \"amd64\",\n          \"go\": \"go version go1.18.3 linux/amd64\",\n          \"node\": \"v16.15.0\",\n          \"os\": \"linux\",\n          \"yarn\": \"1.22.19\"\n        }\n      }\n    },","metadata":{"source":"https://gitpod.io/blog/securing-the-software-supply-chain-at-gitpod-with-slsa"}}],["267",{"pageContent":"\"manifest\": {\n          \"arch\": \"amd64\",\n          \"go\": \"go version go1.18.3 linux/amd64\",\n          \"node\": \"v16.15.0\",\n          \"os\": \"linux\",\n          \"yarn\": \"1.22.19\"\n        }\n      }\n    },\n    \"metadata\": {\n      \"buildStartedOn\": \"2022-06-10T13:23:28.18099525Z\",\n      \"buildFinishedOn\": \"2022-06-10T13:23:37.733290813Z\",\n      \"completeness\": {\n        \"arguments\": true,\n        \"environment\": false,\n        \"materials\": true\n      },\n      \"reproducible\": false\n    },\n    \"materials\": [\n      {\n        \"uri\": \"git+https://github.com/gitpod-io/gitpod.git\",\n        \"digest\": {\n          \"sha256\": \"5176a908d7a7eaecf40200520eae6f1a6e199e35\"\n        }\n      }\n    ]\n  }\n}\n```","metadata":{"source":"https://gitpod.io/blog/securing-the-software-supply-chain-at-gitpod-with-slsa"}}],["268",{"pageContent":"SLSA attestations have a subject (the build output) and a predicate (the process which produced this output). Each file produced by the build is recorded including its SHA hash.\nThe predicate contains information about the builder; in leeway‚Äôs case that‚Äôs the version number and a hash of the leeway binary itself (the version number is easily tampered with). We record the command line that was used to invoke the build, as well as some environmental data.\nLastly, the materials section describes the inputs to the build. In this example, the build ran from a clean working copy, hence leeway adds a reference to this well-defined state. If the working copy was dirty, leeway would list all sources and their hashes instead.","metadata":{"source":"https://gitpod.io/blog/securing-the-software-supply-chain-at-gitpod-with-slsa"}}],["269",{"pageContent":"Consuming the provenance\n\nWe publish the provenance bundle as part of the versions and installer images. Those files can be extracted using the oci-tool, or using a container runtime. See below for a demo of this process:\n\nIn addition to just printing it and looking at the provenance data manually, you can use leeway to make assertions against this data. For example:\n\n```js\ngitpod /workspace/gitpod (main) $ oci-tool fetch file eu.gcr.io/gitpod-core-dev/build/installer:release-2022.05.0.5 app/provenance-bundle.jsonl\ndownloading sha256:0eae1244a408e28c6d4b8f99765a924a9039c0dd59ca2026bcf2fb292859856e  100% |‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà| (17/17 MB, 36.936 MB/s)\ndownloading sha256:39a08d88448d7592d4dc4fac5b6dba8977d7110c9baf2428fb30534c14c8f170  100% |‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà| (18/18 MB, 40.292 MB/s)\n\ngitpod /workspace/gitpod (main) $ leeway provenance assert file://provenance-bundle.jsonl --git-only  && echo Built from a clean working copy\nBuilt from a clean working copy\n\ngitpod /workspace/gitpod (main) $ leeway provenance assert file://provenance-bundle.jsonl --built-with-leeway  && echo Built exclusively using leeway\nBuilt exclusively using leeway\n\ngitpod /workspace/gitpod (main) $ leeway provenance assert file://provenance-bundle.jsonl --built-with-leeway-version 0.2.17-3ebfb2a@sha256:b9629e2d0432adea1be7dddb3603e36d9f69b09d8985f725257adaade51d4a40  && echo Built using the latest version\nBuilt using the latest version\n\ngitpod /workspace/gitpod (main) $ leeway provenance assert file://provenance-bundle.jsonl --built-with-leeway-version not-an-actual-version\nERRO[0000] install/installer:app failed built-with-leeway-version: was built using leeway version 0.2.17-3ebfb2a@sha256:b9629e2d0432adea1be7dddb3603e36d9f69b09d8985f725257adaade51d4a40\nERRO[0000] components:all-docker failed built-with-leeway-version: was built using leeway version 0.2.17-3ebfb2a@sha256:b9629e2d0432adea1be7dddb3603e36d9f69b09d8985f725257adaade51d4a40\nERRO[0000] dev/version-manifest:app failed built-with-leeway-version: was built using leeway version 0.2.17-3ebfb2a@sha256:b9629e2d0432adea1be7dddb3603e36d9f69b09d8985f725257adaade51d4a40\nERRO[0000] test:docker failed built-with-leeway-version: was built using leeway version 0.2.17-3ebfb2a@sha256:b9629e2d0432adea1be7dddb3603e36d9f69b09d8985f725257adaade51d4a40\nERRO[0000] test:app failed built-with-leeway-version: was built using leeway version 0.2.17-3ebfb2a@sha256:b9629e2d0432adea1be7dddb3603e36d9f69b09d8985f725257adaade51d4a40\nERRO[0000] components/ide-proxy:docker failed built-with-leeway-version: was built using leeway version 0.2.17-3ebfb2a@sha256:b9629e2d0432adea1be7dddb3603e36d9f69b09d8985f725257adaade51d4a40\nERRO[0000] components/ws-proxy:docker failed built-with-leeway-version: was built using leeway version 0.2.17-3ebfb2a@sha256:b9629e2d0432adea1be7dddb3603e36d9f69b09d8985f725257adaade51d4a40\nERRO[0000] components/ws-proxy:app failed built-with-leeway-version: was built using leeway version 0.2.17-3ebfb2a@sha256:b9629e2d0432adea1be7dddb3603e36d9f69b09d8985f725257adaade51d4a40\nERRO[0000] components/ws-manager:docker failed built-with-leeway-version: was built using leeway version 0.2.17-3ebfb2a@sha256:b9629e2d0432adea1be7dddb3603e36d9f69b09d8985f725257adaade51d4a40\nERRO[0000] components/ws-manager:app failed built-with-leeway-version: was built using leeway version 0.2.17-3ebfb2a@sha256:b9629e2d0432adea1be7dddb3603e36d9f69b09d8985f725257adaade51d4a40\nERRO[0000] components/ws-manager-bridge:docker failed built-with-leeway-version: was built using leeway version 0.2.17-3ebfb2a@sha256:b9629e2d0432adea1be7dddb3603e36d9f69b09d8985f725257adaade51d4a40\nERRO[0000] components/ws-manager-bridge:app failed built-with-leeway-version: was built using leeway version 0.2.17-3ebfb2a@sha256:b9629e2d0432adea1be7dddb3603e36d9\n```","metadata":{"source":"https://gitpod.io/blog/securing-the-software-supply-chain-at-gitpod-with-slsa"}}],["270",{"pageContent":"What are we going to do next ‚è≠Ô∏è\n\nWhile SLSA Level 1 is an important first step. It helps security teams gain confidence in the integrity of our product, and increases trust in what we deliver. We also know that it will be difficult for security teams to review the provenance of every software, including its dependencies that are getting consumed to make risk-based decisions.\n\nWe have set our sights on Level 2, with Leeway being able to provide signed provenance already. At the same time, we need to invest into our CI/CD infrastructure to reduce the likelihood of the provenance signing keys being exfiltrated. Fulcrio and Rekor will come in handy here. Once that‚Äôs sorted, expect signed containers (including provenance) coming out of our build pipeline.","metadata":{"source":"https://gitpod.io/blog/securing-the-software-supply-chain-at-gitpod-with-slsa"}}],["271",{"pageContent":"Eighteen months ago we launched the public beta of Gitpod.\nThat date marked the beginning of an amazing journey with plenty of feedback, fixes and improvements.\nIt is exciting to see how far we have come and where that simple idea of instant, ready-to-code workspaces has taken us.\n\nNone of this would have been possible if it weren&#39;t for the troves of developers, hackers, coders and other purveyors of Open-Source who provide ample feedback and use Gitpod as their IDE of choice.\nIf the technical side of Gitpod is fun, the user side of Gitpod is truly amazing.\n\nWe are blown away every day because of the quantity and quality of what you guys do with Gitpod.\n\n__SPLIT_HERE__\nA Public Service is Not Enough\n\nHowever, until now Gitpod has not truly been available for everyone.\nThere are many situations, especially in the enterprise, where working on your source code on a third-party cloud service is out of question.\nMaybe the codebase you work on lives on a GitLab or GitHub Enterprise instance in your company&#39;s network, guarded by a firewall.\nMaybe working on the code requires access to services that are available only inside your company network, such as databases, npm/Docker/Maven registires or a Kubernetes cluster.\n\nWell, why not have Gitpod where you need it?\n\n__SPLIT_HERE__\nIntroducing: Gitpod Self-Hosted\n\nToday we announce the availability of Gitpod Self-Hosted.\nMuch like eighteen months ago, this marks the starting point of a new section of our journey.\n\nTo create Gitpod Self-Hosted, we took our codebase from gitpod.io and made it dramatially easier to configure, install and run.\nAs a result, you&#39;ll find all the features you know from gitpod.io in Gitpod Self-Hosted.\n\nGitpod Self-Hosted runs on Kubernetes and integrates via OAuth with GitHub Enterprise, GitLab CE and GitLab EE.\nThis way no additional user management is required and users get easy access to Git repositories based on the permissions already present in GitLab/GitHub.\n\nWe operate gitpod.io on GCP, hence running Gitpod Self-Hosted on Google Cloud Platform (GCP) is a battle-tested solution.\n\n__SPLIT_HERE__\nInstallation\n\nInstalling Gitpod Self-Hosted on your own infrastructure works much like any other piece of kit running on Kubernetes. We have produced a series of installation guides will work most Kubernetes clusters.\n\n__SPLIT_HERE__\nPricing\n\nGitpod Self-Hosted is free for up to three users. If you&#39;re a small shop that will get you up and running.\n\nIf you need more, there is a free one-month unlimited license available.\n\nIn case you need support running your PoC in-house please email us and we&#39;ll be happy to help.\n\nOur remodeled community will also fill with helpful tips and tricks regarding Gitpod Self-Hosted.\n\nWe are absolutely thrilled to see Gitpod and its community growing.\nSelf-Hosted will enable even more developers to focus more on coding and less on setting up their machine or waiting for builds to finish.","metadata":{"source":"https://gitpod.io/blog/self-host-your-gitpod"}}],["272",{"pageContent":"By default, git makes no attempt to verify or validate the identity of the person making commits. On a fresh installation, git will prompt for an email address and name, but no attempt is made to verify the person making commits actually owns the email address.\n\nGiven this lack of verification, if an attacker compromises access to a source code repository, they can impersonate the person normally creating commits, potentially compromising the downstream binaries.\n\n__SPLIT_HERE__\nSigning Commits to Help Secure the Software Supply Chain\n\nOne way to prevent this sort of an attack is via tools like Sigstore, in-toto, and TUF. Each of these frameworks validates the supply chain integrity leading up to the building of a binary artifact, and, in the case of TUF, the secure distribution of binaries.\n\nA key component of these tools is ensuring developers cryptographically sign their commits.\n\nTo do git commit signing, developers generate and use a cryptographic key pair to add a digital signature to each commit which verifies their identity. Once set up properly, both GitHub and GitLab add a ‚Äúverified‚Äù badge to each commit which has been signed.\n\nIn this blog post, we‚Äôll explore how you can sign your commits while developing on Gitpod Workspaces using 1Password and SSH key signing.\n\n__SPLIT_HERE__\n1Password‚Äôs SSH Agent and SSH Key Management\n\n1Password now allows you to set up and manage SSH keys from within the desktop application. This is useful, as you can be prompted every time an attempt is made to use an SSH key, and authorization can be granted from within the application with biometric confirmation.\n\nAs described in the illustration below, 1Password can handle all SSH authentication between Gitpod Workspaces and Gitpod supported desktop IDEs/editors.\n\nIt accomplishes this via SSH agent forwarding, which lets you authenticate remote SSH requests using local SSH credentials. In practice this means you can run any SSH command in your remote Gitpod workspace, without the SSH private key ever leaving the local 1Password process.\n\nWe can also use these local SSH keys to sign Git commits, as GitHub supports SSH key signing for commits. We can then get the verified badge next to our username, and add a layer of proof showing the code came from us.","metadata":{"source":"https://gitpod.io/blog/signing-git-commits-on-gitpod-with-1-password"}}],["273",{"pageContent":"Signing commits in Gitpod with 1Password\n\nAgain, for now SSH agent forwarding with 1Password only works on desktop applications. This means you won‚Äôt be able to do git signatures in the browser edition of VS Code, and must use a Gitpod compatible desktop IDE for code signing.\n\nSo first, ensure you‚Äôre running a desktop IDE for your workspace. With that, we can then set up 1Password to manage our SSH keys:\n\nInstall 1Password on your machine, and enable the SSH Agent found under Settings -&gt; Developer -&gt; SSH Agent\n\nMake the following changes in your local ~/.ssh/config to add a 1Password agent socket and SSH agent forwarding for Gitpod workspaces. (If the file doesn&#39;t exist, create it.)\n\n```\nHost *\n  IdentityAgent \"~/Library/Group Containers/2BUA8C4S2C.com.1password/t/agent.sock\"\n\nHost *.gitpod.io\n  ForwardAgent yes\n```\n\nThese changes make sure of two things:\n\nSSH authentication is being handled by 1Password&#39;s Agent\n\n\nAgent forwarding is enabled for *.gitpod.io which means all Gitpod workspaces have access to the SSH auth socket. (If you‚Äôre using an instance of Gitpod dedicated, set it to a wildcard of your internally hosted domain.)\n\nNext, we&#39;ll need to generate an SSH Key. You can do this right within the Gitpod SSH keys page if you have the 1Password extension installed:\n\nIf you&#39;d like to use an existing SSH key, you can also import that into 1Password. It&#39;s best if it&#39;s passphrase protected. The command to add a passphrase to an existing key is:\n\n```\n$ ssh-keygen -p -f ~/.ssh/id_rsa\n```\n\nWith this, you can then load your SSH key into 1Password, and save the passphrase you created. Going forward, 1Password will enter your passphrase for you automatically.\n\nFrom there, add your SSH public key to Gitpod to the Gitpod SSH keys. With 1Password 8 and its browser extension (currently supports Chrome, Safari, Brave and more), again, you will get the option to insert the SSH key into the browser. (This should be your public key!) This will allow us to access our Gitpod Workspace via SSH.\n\nNext, add your public SSH key to Gitpod as a user environment variable. We&#39;ll use this environment variable to tell git which key to use for signing. In this case, I‚Äôve named my environment variable SSH_SIGNING_KEY, and I‚Äôve set it as a global variable with a */* scope. (I want every repository I use on Gitpod to use it for signing if possible.)\n\nAdd your SSH public key to Github as both a signing key and an authentication key. The signing key will be used to confirm your identity in git, and the authentication key will be used to authenticate your code pushes with the Github server. (Yes, two different things. You may need to do the authentication key first for the signing key option to show up.)\n\nNote: To verify if your SSH credentials work properly, you can try authenticating with Github over SSH on your local machine. On a fresh local terminal, type:\n\nssh -T git@github.com\n\nThis should first prompt you for biometric confirmation with 1Password, and then return a message saying you have successfully authenticated with Github with your username.","metadata":{"source":"https://gitpod.io/blog/signing-git-commits-on-gitpod-with-1-password"}}],["274",{"pageContent":"Signing your first commit in Gitpod\n\nOpen a project in a Gitpod workspace, and ensure it&#39;s open in VS Code Desktop.\n\nWhen you open a workspace in VS Code Desktop, an SSH connection between VS Code desktop and Gitpod workspace should be established by the 1Password SSH Agent. If everything has been set correctly you should get a biometric prompt to login by touch key when opening the workspace. The 1Password application provides SSH credentials and handles the SSH flow.\n\nNext, we need to open a new shell by clicking the + sign in VS Code, and type the commands to enable git commit signing:\n\n```bash\n$ git config --global gpg.format ssh\n$ git config --global user.signingkey \"$SSH_SIGNING_KEY\"\n```\n\nThis tells git to use SSH as a sigining format, and injects our environment variable as the public key to sign with.\n\nWe can now test a commit by using the following command after changing a file:\n\n```bash\n$\tgit commit -S -am ‚ÄúTesting our signed commits‚Äù\n```\n\nIf we look at Github for our commit, we should now see a verified badge next to the commit:\n\nTo enable git commit signing every time we open our repository, must set our git preferences in .gitpod.yaml as a task, and again, ensure have set an environment variable for our SSH_SIGNING_KEY in our environment variables:\n\n```yaml\ntasks:\n  - name: Local terminal\n    init: git config --global gpg.format ssh && git config --global user.signingkey \"$SSH_SIGNING_KEY\" && git config commit.gpgsign true --global\n    command: bash\n```\n\nWe should now have biometric prompts from 1Password for signing our git commits, and have helped to secure our source code.\n\nBut what if we want all of our repositories to have commit signing enabled by default in Gitpod?\n\n__SPLIT_HERE__\nAutomatic Commit Signing in Every Repository with Dotfiles\n\nFor that, Gitpod has Dotfiles, which allow us to run a bit of bash on each of the Gitpod workspaces we spin up. In my case, I created a git repository named gitpod-dotfiles, and linked it to my user settings:\n\nIn my Dotfile repository, I‚Äôve created a file with the name install.sh (and run chmod +x install.sh afterwards), and have pasted in the same commands we used in the above task:\n\n```bash\ngit config --global gpg.format ssh && git config --global user.signingkey \"$SSH_SIGNING_KEY\" && git config commit.gpgsign true --global\n```\n\nIf you like, you can fork my dotfiles, or create your own, and set them in your account preferences to have git commit signing everywhere when using a Desktop IDE and Gitpod.\n\n__SPLIT_HERE__\nReferences\n\nCommunity office hours with 1Password:\n\nyoutube: u2aCOtMqtc4\n\nSSH &amp; Git - Get Started https://developer.1password.com/docs/ssh/get-started\n1Password Developer Documentation https://developer.1password.com/\n\nIf you have any questions about setting this up, drop by Gitpod‚Äôs community Discord server or 1Password‚Äôs Developer Slack Community. We would love to hear your feedback in the Community.","metadata":{"source":"https://gitpod.io/blog/signing-git-commits-on-gitpod-with-1-password"}}],["275",{"pageContent":"This story is about how Gitpod enabled an 18-year-old student from Dhaka with a broken laptop to continue developing software on an Android phone seamlessly. From learning to code in Rust to developing Optimus Discord Bot, which is now powering the Gitpod Community Discord server, I learned a lot! ü•≥\n\nWith Gitpod, developing software is easier, accessible and more productive than with a local development environment. How so? Gitpod is a complete dev environment running in the cloud, turning my android phone into a powerful dev machine. Put in different words, I get hold of data center hardware in my palm that is fine tuned for developing software.\n\nI am known as AXON in the Gitpod Community. I‚Äôll be sharing my story of how Gitpod quite literally changed my life and enabled me to continue my journey into software development. Today, I‚Äôm a Community Engineer intern at Gitpod. Being an active community member and solving my development pains with Gitpod led me here!\n\nA few years ago, I got into software development while exploring the Android-x86 space. As a user, I wanted to play android games with it, but I ended up getting involved in its development. One day, my laptop broke because of all the overload I had put into it over the years. The only other device that I had on me was my Android phone. Luckily, this was around the same time I discovered Gitpod! I hoped that I would be able to recreate a functioning developer environment in the cloud, just using my phone and Gitpod. I used Techno Spark 7 Pro (128/6GB) with a Bluetooth mouse and keyboard combo, which I also connected with the TV for a larger screen. With this new setup, I could start working on almost any project. I also had a native Linux environment within my phone where I could chroot into with my phone&#39;s superuser privileges. Still, it wasn&#39;t suitable for software development, given the hardware and software limitations and all the other hassles. Using Gitpod, my Android phone effectively turned into a thin client with an interface to write code. Gitpod provisioned a developer environment in a Linux container in the cloud and was doing the brunt of computing work, and my phone was resting in peace ü§£\n\n__SPLIT_HERE__\nGetting started with Gitpod on Android\n\nMy android phone with a bluetooth keyboard and mouse\n\nGetting started with Gitpod on Android is quite easy. If you are interested in setting up Gitpod on Android, you can check out the detailed guide.\n\nyoutube: Aepvv_OqRYU\n\nStep 1: Install Kiwi browser ü•ù\nStep 2: Install the Gitpod extension in Kiwi browser üçä\nStep 3: Open a Git repository in Gitpod ‚ö°Ô∏è\nStep 4: Code, Develop, Ship it üöÄ\n\n__SPLIT_HERE__\nThings I built/maintained with Gitpod on my Android phone\n\nHere are some fun things I did:\n\nOptimus Discord Bot - This hackathon project is now powering our Gitpod Community Discord server üéâ I had started developing the first version of it for https://aopc.dev/ discord server but the compile times were unbearable until I found Gitpod.\nGearLock - Maintaining a bootable custom-recovery and package manager for Android-x86.\nTuxdroid - This script manages my Linux GUI and the terminal environment on my phone, and an interesting fact - I programmed it on my phone to use it for my phone üòÜ. I can run VS Code inside my phone with the help of this, which also enables me to connect to a Gitpod workspace via Remote-SSH and more!\nBashbox - A bash compiler that helps me create modular and maintainable bash projects. I also used it for creating Tuxdroid above in a very short time!\nDarkMatter - Maintaining a customized Android-x86 distro.\nmultitux-gp - Attempt to parse Gitpod workspace-images Dockerfiles and generate them for different distros. It&#39;s still a work in progress!","metadata":{"source":"https://gitpod.io/blog/software-development-from-my-android-phone-at-datacenter-speeds"}}],["276",{"pageContent":"How I got an Internship at Gitpod\n\nI had applied for the Professional Open Source plan after running out of free hours. Surprisingly, I was found eligible for it!\n\nThat really inspired me! All my tiny little projects weren&#39;t worthless afterall. Since then, I have strongly wanted to give something back to the Gitpod Community. I started hanging out with the Gitpod community and helping others whenever possible. It made me feel happy. I consider this as a method of learning things as you get presented with new challenges everyday.\n\nAround that time Gitpod also launched the Community Heroes program - an initiative that recognises the most active community members that go above and beyond to contribute to community üçäü¶∏. I was recognised for my consistent efforts and was a member of the first cohort üòé\n\nLater, I had applied for an internship at Gitpod. It was kind of an unexpected event for me: I got the internship, and officially, I became a Gitpodder üçä\n\nMission passed: RESPECT üòù\n\n__SPLIT_HERE__\nUnlocking the power of Gitpod\n\nCan you believe it? All the contributions and projects have been made from my phone, using the power of Gitpod! Gitpod is powerful, and I believe with Gitpod, anyone can learn to code and develop software without any hurdles.\n\nDrop by our community Discord server if you find this interesting and want to develop software on your phone. We have the #mobile-and-tablets channel where fellow mobile-dev enthusiasts hang out! Feel free to share your tips and tricks on software engineering in a more unconventional but accessible way.","metadata":{"source":"https://gitpod.io/blog/software-development-from-my-android-phone-at-datacenter-speeds"}}],["277",{"pageContent":"SSH (secure shell) is a critical protocol for remote development.\n\nBoth JetBrains IDEs and the VS Code editor use SSH as their remote development foundation. So, a big focus at Gitpod has been on improving performance and usability for connecting using SSH.\n\nWhich is why today we&#39;re excited to announce that in Gitpod you can now upload your own public keys to access your workspace. In addition, we&#39;ve also removed the requirement for a mandatory public key to be available when access Gitpod using SSH with an Access Token.\n\nWith SSH public key upload you can now:\n\nRe-connect to workspaces without needing to go back to the Gitpod dashboard.\nBenefit from improved security when accessing your workspace with a private key.\n\nBut, why? Use-cases for SSH key upload","metadata":{"source":"https://gitpod.io/blog/ssh-key-upload"}}],["278",{"pageContent":"Re-connect to workspaces without needing to go back to the Gitpod dashboard.\nBenefit from improved security when accessing your workspace with a private key.\n\nBut, why? Use-cases for SSH key upload\n\nIf you&#39;ve been happily working away on Gitpod until now, you might be wondering why we&#39;re so excited about users being able to upload their SSH keys for Gitpod? The SSH protocol is flexible, so there are many use-cases, but to give you an idea, here are some different use-cases:\n\nStatic connection strings - The access token method of copy/paste SSH generates a new workspace access token for each workspace start, meaning users had to go to the Gitpod dashboard to retrieve their SSH command on every workspace timeout or restart. Using an uploaded SSH key allows you can restart the workspace without needing to update your SSH connection details.","metadata":{"source":"https://gitpod.io/blog/ssh-key-upload"}}],["279",{"pageContent":"Note: The workspace cluster version e.g. .ws-eu54.gitpod.io is currently included in the SSH connection host. On workspace update, you&#39;ll still be required to update the SSH string. This is an area of improvement that we will investigate for the future.\n\nDesktop client access - SSH is used as the protocol for many desktop tools, notably users who like to use local command line access for editing, connecting to headless testing tools (which connect to processes running in the workspace) and database clients. Not having to jump back and forth to the Gitpod dashboard eliminates some friction for these workflows.\n\n\nPort-forwarding - Whilst, both the VS Code and JetBrains IDEs have support for port-forwarding, some of our users want to script / automate their port forwarding. Using regular SSH means you can more easily leverage the -L and -R flags of your SSH client for for port-forwarding without having to go back and forth to the dashboard to copy/paste the SSH string.","metadata":{"source":"https://gitpod.io/blog/ssh-key-upload"}}],["280",{"pageContent":"In addition to some of these more visual improvements, SSH key upload also will give our users more stable, performant and secure connections. Improvements to the SSH connection experience also enables Gitpod to build new workflows and features around the SSH protocol, such as:\n\nFurther reducing steps and friction when opening desktop editors like VS Code Desktop\nInvestigating a fully desktop-based workspace opening and managing experience in future\n\nSo, watch this space for future announcements!\n\nGetting started with SSH key access\n\nNavigate to the keys page in your Gitpod preferences\n\nSSH page of the Gitpod dashboard\nSSH page of the Gitpod dashboard\n\nUpload a public SSH key (See: SSH documentation)\n\nAdding an SSH Key to Gitpod\nAdding an SSH Key to Gitpod\n\nGo to your workspace list and copy the SSH command\n\nCopy SSH key from modal\nCopy SSH key from modal\n\nOr, get the SSH connection from the workspace start page (when using a Desktop IDE or editor)","metadata":{"source":"https://gitpod.io/blog/ssh-key-upload"}}],["281",{"pageContent":"Go to your workspace list and copy the SSH command\n\nCopy SSH key from modal\nCopy SSH key from modal\n\nOr, get the SSH connection from the workspace start page (when using a Desktop IDE or editor)\n\nSSH to a workspace via the workspace splash page\nSSH to a workspace via the workspace splash page\n\nFor more information, see the configuring SSH documentation, and using Gitpod with command-line access. And for any feedback see the related GitHub issue, or raise a new one.\n\nWhat&#39;s next for SSH in Gitpod?","metadata":{"source":"https://gitpod.io/blog/ssh-key-upload"}}],["282",{"pageContent":"What&#39;s next for SSH in Gitpod?\n\nEasier copying of SSH credentials - We want to make it easier for you to access your SSH credentials, either through direct IDE or editor integration, or via the gp CLI.\nIntegration with third-parties - We&#39;re investigating integration with other 3rd party services which hold users public keys, such as GitHub, to avoid duplicate upload of SSH keys.\nImprovement to desktop editing experiences - For users who prefer desktop for editing, either in VS Code Desktop or JetBrains‚Äîas opposed to editing in-browser‚Äîwe will continue to investigate ways to improve the experience, for example with desktop-first editing experiences.\n\nWe hope you enjoy the new, easier SSH access in Gitpod, and we&#39;d love to hear your feedback in the Gitpod community.\n\nLastly, a very special thanks to William and Sarah for their valuable input and thoughts as community heroes on this blog post!","metadata":{"source":"https://gitpod.io/blog/ssh-key-upload"}}],["283",{"pageContent":"Gitpod experienced a series of incidents [1, 2, 3, 4] between April 11th and 22nd, which led to workspace performance degradation in all regions, and in some cases, users were unable to start workspaces and experienced data loss.\n\n__SPLIT_HERE__\nSummary\n\nGitpod workspaces are meant to ‚Äúfeel‚Äù like your own machine, except in the cloud. Performance and reliability of workspaces are hallmark features of Gitpod. And, just like your own machine, the pain is very real when workspaces do not perform as you need or expect.\n\nOn April 9th at 7:30 UTC (all times will be in 24 hour-format UTC), we finished shipping a new generation of workspace clusters (ws39). This included a variety of features to reduce workspace startup times, as well as make more CPU accessible to users at runtime.\n\nHowever, between April 11th and 22nd, Gitpod experienced a series of incidents resulting in sustained performance degradation for workspaces. Additionally, some users were unable to start workspaces at times and experienced data loss.\n\nIn this post, we‚Äôll cover:\n\nWhat happened: a complete timeline.\nContributing factors: the cause of the outage.\nHow we‚Äôll do better","metadata":{"source":"https://gitpod.io/blog/sustained-performance-degradation"}}],["284",{"pageContent":"What happened: a complete timeline\n\nApril 8th\n\n20:08 UTC - ws39 is released for all regional clusters, excluding XL clusters. This included a variety of changes to significantly reduce workspace startup times, and provided a new generation of CPUs with better performance characteristics.\n\nApril 9th\n\n17:45 UTC - The release for ws39 is extended to XL clusters too, concluding the release. All traffic at this point will use ws39 to start workspaces.\n\nApril 11th\n\n13:17 UTC - We received reports from customers and Gitpodders at 13:17 that workspaces were intermittently becoming unresponsive. We opened an incident in Slack via our incident.io integration and began investigating.\n\n13:58 UTC - When we inspected the CPU usage for nodes and pods, it was normal, nothing was maxed out, and signs did not indicate our CPU limiting had failed or that there were noisy neighbors. At 13:58, we realized workspaces were getting IO bound, rather than CPU bound.","metadata":{"source":"https://gitpod.io/blog/sustained-performance-degradation"}}],["285",{"pageContent":"At the time, we lacked IO limiting capabilities, so we decided to shift traffic for workspace starts back to our prior set of clusters (ws38), which did not have this performance issue. This was completed at 15:37.\n\n21:29 UTC - While stable on the prior generation (ws38), we planned short and long term action items to move forward with the release. For the short term: build a new set of clusters (ws39a) running faster machine types (t2d‚Üíc2d) with quicker disks (local SSDs). For the long term, prepare a new VM image and environment so that we can design a IO limiting feature.\n\nIn other words, short term, we decided to alleviate the IO bandwidth issues by using faster disks. The reasoning was that we would avoid maxing out the read and write capabilities of disks, hence avoid workspaces being IO bound. We planned to run like this for 2-3 days, while researching, building, and testing an IO limiting solution.\n\nThe deploy of ws39a did not go smoothly.","metadata":{"source":"https://gitpod.io/blog/sustained-performance-degradation"}}],["286",{"pageContent":"The deploy of ws39a did not go smoothly.\n\nThe new c2d machine type was not available in all zones that we typically use, so we had to deploy to a new region. However, the region lacked sufficient quota for CPU and storage, and when we tried to increase, GCP‚Äôs quota approval process was too slow, albeit within SLA.\nOnce we were able to deploy to GCP, we were unexpectedly rate limited by Let‚Äôs Encrypt! As a result, we could not provision TLS certificates for new sub-domains, which is why some clusters had old sub-domains. Why? A customer requested TLS certs, exhausting the limit for gitpod.io! We eventually resolved the rate limiting issue. Additionally, we requested a limit increase from Let‚Äôs Encrypt.\n\nThe traffic shift from ws38 to ws39a was completed by 21:29, and the incident was closed. Additionally, we held onto ws38, just in-case we have to fall-back to it, again.\n\nApril 12th","metadata":{"source":"https://gitpod.io/blog/sustained-performance-degradation"}}],["287",{"pageContent":"The traffic shift from ws38 to ws39a was completed by 21:29, and the incident was closed. Additionally, we held onto ws38, just in-case we have to fall-back to it, again.\n\nApril 12th\n\n11:53 UTC - Customers and Gitpodders reported that workspaces were experiencing performance issues. After troubleshooting, we created a new incident, and confirmed workspaces were becoming IO bound, again.\n\nAt this point, it was apparent we needed an IO limiting solution for the new workspace cluster release. In the meantime, we had successfully built a cgroups-based IO limiter for Gitpod, and it worked well in our dev/test environment!","metadata":{"source":"https://gitpod.io/blog/sustained-performance-degradation"}}],["288",{"pageContent":"Unfortunately, the new IO limiter did not behave similarly in production, and crashed our ws-eu39xl cluster. The XL cluster contained workspaces for unleashed customers and Gitpodders, who both experienced data loss. The ws-daemon rollout on those clusters broke the CPU limiter which lead to the nodes becoming unresponsive. All of the cores for each node became consumed, the services on the those nodes ceased to function, and we couldn‚Äôt connect to them to recover via ssh or kubectl.\n\n13:49 UTC - At roughly 13:49, we shifted EU XL traffic back to ws-eu38xl. We did not realize, however, until 14:21 that it was not receiving traffic! We promptly opened another incident because EU XL users were unable to start workspaces.","metadata":{"source":"https://gitpod.io/blog/sustained-performance-degradation"}}],["289",{"pageContent":"In the meantime, a breaking API change had been deployed to our control plane, rendering the ws38 clusters incompatible. At 15:28, we temporarily routed traffic to the regional EU cluster, to start workspaces again. All the while, we built a new XL cluster, (ws-eu39bxl) to replace the one we burned down (ws-eu39xl).\n\nAt this time, we had too many active clusters, and had to increase quotas (approval was delayed) to continue to meet demand and scale. This additional incident and the replacement XL cluster were resolved by 17:09.\n\n18:32 UTC - We decided to prepare yet another set of clusters to accomplish two things:\n\nRollback from the c2d to n2d machine type, which is what ws38 had been using.\nShare a new set of clusters with the EU team to develop a fix for the IO limiting.\n\nApril 13th","metadata":{"source":"https://gitpod.io/blog/sustained-performance-degradation"}}],["290",{"pageContent":"Rollback from the c2d to n2d machine type, which is what ws38 had been using.\nShare a new set of clusters with the EU team to develop a fix for the IO limiting.\n\nApril 13th\n\n02:00 UTC - While building the next set of clusters we bumped into a blocker: a Git CVE had been discovered and fixed, requiring a configuration change. Without this change, our tests were failing and we could not continue work on the IO limiter. One PR later we could focus on the IO bandwidth issue again.\n\n07:30 UTC - The APAC team handed off the new set of clusters to the EU team at 07:30. The EU team at this point pursued a couple things:\n\nClean-up workspaces stuck in a stopping state, so that users could start them again.\nFix the CPU limiter and build the IO limiter, to help return Gitpod to reliable performance.","metadata":{"source":"https://gitpod.io/blog/sustained-performance-degradation"}}],["291",{"pageContent":"Clean-up workspaces stuck in a stopping state, so that users could start them again.\nFix the CPU limiter and build the IO limiter, to help return Gitpod to reliable performance.\n\nWhile improving limiters, a problem was found with workspace networking. Networking had been improved as part of the April 8th release to grant faster network speeds and more CPU to users. However, it was also causing workspaces to be sluggish in production! This was hard to identify and resolve [1] because of a lack in parity between our development and production environments (production has IP forwarding disabled, development has it enabled).","metadata":{"source":"https://gitpod.io/blog/sustained-performance-degradation"}}],["292",{"pageContent":"16:00 UTC - As a next step, at 16:00 we decided to clean-up unneeded clusters. The clean-up for old clusters helped us avoid GCP quota limits, reduce cost, and made it easier to manage the active clusters. While monitoring operations overall, it was important for us to inspect customer workloads that were still getting IO bound to learn how we need to improve our own monitoring capabilities.\n\nApril 14th\n\n02:00 UTC - We started the release of ws40. It included nodes with 1TB boot disks, which is what we had prior to the April 8th release. The intent for this new generation was the same as the previous day: restore reliable performance. In this case, we were pursuing two results:\n\nGet more IO bandwidth from the disks, to have a larger pool of IO for workspaces to consume\nHave a working IO limiter, to fairly distribute disk resources","metadata":{"source":"https://gitpod.io/blog/sustained-performance-degradation"}}],["293",{"pageContent":"Get more IO bandwidth from the disks, to have a larger pool of IO for workspaces to consume\nHave a working IO limiter, to fairly distribute disk resources\n\n10:10 UTC - In a night-shift we had rewritten the IO limiter, deployed it and began shifting traffic to ws40. At 13:12 we observed that the IO limiter was still not working as expected. However, we decided to continue with the shift of traffic to ws40 because it was making more IO available overall to our users.\n\n16:31 UTC - The traffic shift was at 50% at 16:31, and 100% by 17:49. We continued to monitor for a couple hours after the traffic shift, and observed that there were in fact still spikes, where nodes were IO saturated, meaning some workspaces would still get IO bound. Regardless, we finally closed the incident, because we believed the additional IO bandwidth would resolve the issue.\n\nApril 17th","metadata":{"source":"https://gitpod.io/blog/sustained-performance-degradation"}}],["294",{"pageContent":"April 17th\n\n5:18 UTC - We noticed increased CPU load on the workspace nodes and triggered an internal incident. In ws40 our defence mechanism against crypto-currency miners was broken. This lead to a proliferation of crypto-mining, rendering many of the workspace nodes uninhabitable. We proceeded to manually inspect node workloads using our monitoring systems, identified workspaces which consumed excessive CPU time and removed them from the system. Our internal rate limits prevented these workloads from spreading to new nodes.\n\n8:47 UTC - Our investigation of the users who had caused this excessive CPU use revealed that the vast majority of them were auto-generated GitHub accounts, produced for the sole purpose of gaining compute from Gitpod workspaces.\n\nApril 18th","metadata":{"source":"https://gitpod.io/blog/sustained-performance-degradation"}}],["295",{"pageContent":"April 18th\n\n12:36 UTC - We saw the same increase in CPU load on workspace clusters as the day before - and responded in kind. Through manual combing through the nodes (in combination with our miner detection system), we identified fraudulent users and blocked their use of Gitpod.\n\n19:38 UTC - Throughout the day we had been fending off illicit use of Gitpod‚Äôs resources. At the same time part of the team attempted to fix the issue with our automatic crypto-miner defenses.\n\n23:35 UTC - We have found the main issue with our dynamic CPU limiting mechanism.\n\nEssentially, our CPU limiting wasn‚Äôt working correctly, more workspaces were being given CPU time than we intended.\n\nThe solution was to rollback a change to our ws-daemon which was not present in our ws38 generation of clusters, making CPU limiting stable again.\n\nApril 19th","metadata":{"source":"https://gitpod.io/blog/sustained-performance-degradation"}}],["296",{"pageContent":"The solution was to rollback a change to our ws-daemon which was not present in our ws38 generation of clusters, making CPU limiting stable again.\n\nApril 19th\n\n03:31 UTC - ws34 is ready for rollout (we had to use an old name due to the rate limiting issue with Let‚Äôs Encrypt, which was preventing us from registering new TLS certificates). Those clusters carry the fix for the recent CPU limiting issues which should curtail crypto-mining. Not wanting to risk doing more harm than good we start with a conservative roll-out scheme. This deployment also blocks ACME HTTP requests to workspace ports, to prevent running into LetsEncrypt rate limits again.\n\n10:59 UTC - We have not observed adverse effects from the ws34 changes, and continue to shift 50% of the traffic ws34.\n\n16:34 UTC - Throughout the day we have observed that the ws34 change is effective and provides an improvement in service. By this time the rollout is complete and we retire the ws40 clusters.\n\nApril 20th","metadata":{"source":"https://gitpod.io/blog/sustained-performance-degradation"}}],["297",{"pageContent":"April 20th\n\n13:45 UTC - We create this incident, as multiple customers were still having performance issues, resulting in unreliable workspaces for workloads that were behaving normally prior to the April 8th release.\n\nAs a first step, we decide to prepare a rollback for the breaking API change, just in case we need to use ws38, which was the original cluster prior to the April 8th release.\n\nNext we socialized alternatives for implementing IO limiting. It was determined through many experiments that the best path forward is to use this library to limit IO.\n\n20:49 UTC - We get IO limits partially working! Our nodes have a few disks, and the limiting was having trouble detecting the proper devices to limit. In other words, we wanted to make sure we can fairly marshal workspace IO for /workspace and / .","metadata":{"source":"https://gitpod.io/blog/sustained-performance-degradation"}}],["298",{"pageContent":"23:48 UTC - After many experiments,, via ws41xl, we‚Äôve produced a cluster that fairly distributes disk IO between workspaces. The initial shift of traffic was conservative at first, just 25%, so that we can check specifically with the customers who were reporting that workspaces were continuing to suffer from being IO bound.\n\nApril 21th\n\n10:58 UTC - IO behavior in the ws41xl cluster had shown significant improvement over their predecessors. Additionally we had confirmation from impacted customers that workspaces started on the new cluster felt normal again. With that news, we shifted traffic to 50%.\n\n14:00 UTC - Next, we started building the standard, regional clusters for ws41, and started traffic shift for them at 14:00. We opted to be conservative here, because the nodes in these clusters run twice the density as our XL clusters. Seeing as the IO limiting was new, we wanted to make sure that we applied load gradually, so that we could monitor and react, if needed.","metadata":{"source":"https://gitpod.io/blog/sustained-performance-degradation"}}],["299",{"pageContent":"18:46 UTC - Confident that the IO limiting worked as expected, we set the XL clusters to 100%, and standard regional clusters to 50%. The standard regional cluster were pushed to 75% at 22:00, and to 100% by April 22nd 02:00.","metadata":{"source":"https://gitpod.io/blog/sustained-performance-degradation"}}],["300",{"pageContent":"Contributing factors: the cause of the outage\n\nBeforehand\n\nThe April 8th changeset lacked sufficient risk assessment and was released too quickly.\n\nPrior to the release, test results should have informed us that the release was a no-go. Essentially acting as a firewall. We continue to invest in our test automation to help prevent similar incidents in the future. [1][2]\n\nExecution of the release, especially due to its size and proximity to the prior release (3.5 weeks), was too aggressive. ws38 was replaced by ws39 starting on April 8th and finished by April 9th. For the future, the time interval used to control how quickly we shift percentages of traffic to new clusters will vary. Larger releases will have more time in-between traffic percentage shifts to ‚Äúlimit the blast radius‚Äù.\n\nInitial incident\n\nThe following changes from the April 8th release caused the first incident.\n\nWe split a 1TB disk to many smaller RAID0 disks. This was done to isolate IO for image pulls and workspaces from one another, as well as increase performance. However, we later realized, the IOps a disk can achieve decrease with disk size.\n\nAn enhancement to our CPU limiting feature included a bug which reduced its corresponding effectiveness. This allowed for too many noisy neighbors. Further, the effect a noisy neighbor could have was magnified by workspaces generally having more CPU available. This was due to a couple factors:\n\nWe upgraded to faster machine types, for the same cost, to provide better multi-core performance.\nWe removed slirp4netns from workspace networking, freeing up user-space for customer workloads.\n\nImprovements to workspace networking unfortunately introduced a couple tricky defects. [1][2] These caused sluggish performance for network processes, including containerized workloads.\n\nTo summarize: degraded workspace performance was caused by a myriad of factors that were interconnected and reinforced each other. disk IO was slower than anticipated, and CPU was more accessible while not governed as expected. This was further compounded by a lack of ability to limit disk IO and latency in workspace networking.\n\nSubsequent incidents\n\nIt would have been best if we had committed to rolling back on April 11th. However, we did not, and continued to build and ship fixes which resulted in pain for customers and Gitpodders.\n\nCustomers were exposed to degraded performance for a period of time longer than necessary. Some even experienced data loss, both of which are extremely frustrating. Gitpodders accumulated stress over many days while troubleshooting the series of incidents.\n\nThe best we can do is acknowledge our mistakes, reflect on them, and plan related improvements. Let‚Äôs talk about how.","metadata":{"source":"https://gitpod.io/blog/sustained-performance-degradation"}}],["301",{"pageContent":"How we&#39;ll do better\n\nWe have seen a lot of things fail during this series of incidents, and take away a host of areas where we will improve. Most changes are organisational or touch on process, and roughly fall into three categories: preventing incidents, reacting quicker, and improving communication.\n\nWe continuously strive to reduce the ‚Äúbatch size‚Äù and increase deployment frequency. With ws39 we failed to follow up on this intent. For future workspace cluster rollouts, we shall introduce a risk assessment stage (which we aim to automate), which‚Äôll govern changeset size and rollout speed (rate at which we make a change available to users).\n\nIn addition, we‚Äôve seen cross-team dependencies limiting our ability to roll back. We continue to reduce the impact teams have on each other, and establish additional review criteria to uncover backwards incompatible changes prior to merging pull requests (PRs). Such PRs will then need to be split up to avoid scenarios where we struggle to roll back a deployment.\n\nCoupled with an improved capability to roll back changes, we have updated our procedures to recommend rollback as a primary means of mitigation. Discussions are underway how such a process could be automated.\n\nDuring the incident we failed to hold up one of our core values: transparency helps build a community of trust. Our external communication was not up to our own standards. Although we provided status page updates, they were not frequent enough. Further the workspace service on that page did not properly indicate that we were down (with an orange or red color). This has since been corrected, and our playbooks updated accordingly.\n\nOur internal communication was spread across too many channels. This made it difficult at times to effectively coordinate. The team fixed this by consolidating communication in a single Slack channel and Google Meet starting April 20th. This made reviewing the history easier and gave us a better overview of all things in flight. We have updated our incident procedures accordingly.\n\nLastly, we have redesigned our on-call process. Starting May 9th, 10% of our engineering staff will be part of the on-call rotation at any given time. We will use this engineering time to improve our observability, alerting and overall stability of the system. The mission of the folks who are on-call (other than monitoring and responding to abnormal events) is to make next week‚Äôs on-call shift less eventful than last week.\n\n__SPLIT_HERE__\nConclusion\n\nWe‚Äôve shared a detailed timeline for the events leading up to and during the performance degradation. Our intent is for you to understand what, was happening when, and why certain outcomes manifested. Frankly, we want to earn back your trust, and being open about what happened is paramount. It‚Äôs also in our DNA - we build in the open.\n\nThe contributing factors leading to sustained performance degradation were partially preventable. However, hindsight is 20/20 and failure free operations require experience with failure.\n\nMoving forward, we are actively experimenting with process changes and automation to help mitigate similar issues in the future. This will help us gain the feedback and leverage we need to confidently assess risk, while also allowing teams to be independent and ship continuously.\n\nWant to help build Gitpod? Checkout our careers.","metadata":{"source":"https://gitpod.io/blog/sustained-performance-degradation"}}],["302",{"pageContent":"I&#39;m super stoked to share with all of you that I have stepped down from my former CEO role in order to get back to working more directly on our beloved product. I actually made this transition already two months ago, and this has turned out to be one of the best decisions I&#39;ve made.\n\nI&#39;m still on the board of directors and also help our leadership team with strategic decisions (I&#39;m writing these lines from our annual leadership offsite in San Francisco). But I have completely moved out of any management responsibilities and my weekly meeting schedule has slimmed down significantly. This allows me to focus entirely on making Gitpod better.üòç\n\nI&#39;m learning so much every day and have been super pumped since the first day. I can&#39;t overstate how much I love my new role!\n\nHere&#39;s the letter I shared internally with my colleagues when I first announced this in August üëá\n\nDear Gitpodders,\n\nI‚Äôm super excited to share with you that I‚Äôll be transitioning from my current Co-CEO position to an engineering individual contributor role. You might not too surprised about this step if you know me a bit better, but I would like non-the-less to give some background on why this is so exciting for both Gitpod and me.\n\nI‚Äôve spent my entire career building developer tools (e.g. [oAW, Xtext, Xtend, Theia]). Because these were often successful and inspired others to work with me, I reluctantly moved into management roles. I‚Äôve learned a lot about leadership and management in the past years. In particular, that I naturally lead through my conviction and that I don‚Äôt enjoy ‚Äúmanaging‚Äù people. Also I always felt like owning formal management titles harms my ability to show up as my true natural self and connect with people.\n\nWhen you start a company, many things need to be done, which can move you away from building the actual product and having deep technical conversations. These are my superpowers and why I initiate things like Gitpod. To focus on this, I have always teamed up with amazing people that would own anything non-product building. I co-founded TypeFox with Jan and Mo for this reason and later teamed up with Johannes for Gitpod because of this. You all know and have seen how well Johannes grew into the CEO role.\n\nSince the Co-CEO announcement, I could do a bit more coding again, which helped remind me that this is what I love and where I can have the most significant impact. Chris and Johannes are doing fantastic work in their roles as CTO resp. CEO and with Mike joining as our new Head of Product, we have a great team lined up to lead the company and the product engineering organization into the next phase.\n\nStarting in September, I‚Äôll work as a full-time IC joining the WebApp team but will move to other product teams if needed. As Gitpod‚Äôs first Technical Fellow, I‚Äôll work directly on one team. Still, I can coordinate efforts that span multiple teams, own and flesh-out architectural decisions, help the product team with discovery work, and learn from and advise other engineers. I‚Äôll also engage with our users and customers and keep spreading the word through conference talks and meet-ups.\n\nI‚Äôll also stay on the board of Gitpod and bring my IC perspective to it. I‚Äôll no longer be part of the executive and the leadership team but maintain regular check-ins with Johannes and Mike. I will report to and work closely with Chris.\n\nI can‚Äôt state enough how excited I am for this transition and how much I‚Äôm looking forward to making Gitpod a bit better every day in a more direct way again with all of you and, in particular our fantastic engineering team.","metadata":{"source":"https://gitpod.io/blog/svens-new-role"}}],["303",{"pageContent":"TL;DR\n\nTabnine and Gitpod partner to remove friction from developers&#39; workflows\nTabnine built a first-class VS Code extension via the OpenVSX marketplace running on browser-based VS Code\n\nEverything we do at Gitpod centers around the premise of improving the day-to-day developer experience with automated, ephemeral developer environments. Developer experience is part of our core company attributes and our guiding product design principle.\n\nWe are building Gitpod to reduce friction and help developers to automate and speed up their workflows so they can get into that magical state of flow that makes software engineering joyful.\n\n__SPLIT_HERE__\nIntegrate, don&#39;t dictate üëê\n\nThat focus on putting developers‚Äô interest first means to be transparent, open and flexible in product design and as a company. To offer choice, embrace our community &amp; ecosystem and give every developer out there the option to work with the tools that fit their workflow. We integrate, don‚Äôt dictate - and are not alone in this.\n\n__SPLIT_HERE__\nTabnine and Gitpod\n\nTabnine allows you to code faster with a pluggable code completion assistant that is trained on your specific development style &amp; taste. Their compliant and privacy-first approach to training data means that their models never share your code with others. With their simple plug-in model they support all popular languages, libraries and work on all IDEs.\n\nWe joined forces to use both of our products together in harmony bringing the best of AI code completion and ephemeral developer environments together. This means that a Gitpod workspace removes the friction from setting up and maintaining brittle dev environments, while adding Tabnine to your workspace makes you faster and more efficient when writing code.\n\nIn line with our orthogonal product design Tabnine‚Äôs pluggable code completion assist can be installed as part of a polished VS Code extension that is available for everybody and pre-installed on a repository level for our Tabnine example templates.\n\n__SPLIT_HERE__\nGetting started\n\nTry out Gitpod &amp; Tabnine yourself by opening one of these different templates. It is as simple as pressing the open in Gitpod button:\n\nJS/TypeScript\nPython\nGo\n\nIf you want to add Tabnine to your own Gitpod project, go ahead and install it in with a single click.","metadata":{"source":"https://gitpod.io/blog/tabnine"}}],["304",{"pageContent":"TL;DR\n\nTailscale and Gitpod partner to enable secure, professional software development from anywhere\n\nWe mentioned this already a couple of times: in retrospect the second half of 2021 will mark the tipping point for remote, cloud-based development.\n\nWith VS Code remote and Jetbrains&#39; remote development support, more than 80% of developers will use an IDE with built-in functionality to connect to developer environments running in the cloud.\n\nStackoverflow Survey 2021\n\nGitpod provisions and orchestrates remote developer environments enabling you to develop from anywhere (even from an iPad traversing Australia üèï). Today, all of this gets even more connected &amp; secure. We are excited to announce a partnership with our friends at Tailscale. Secure, ephemeral developer environments as part of your private network.\n\nTailscale is built on top of the point-to-point open-source WireGuard protocol which powers an encrypted mesh network or &#39;tailnet&#39; that directly connects your developer environment to your resources as well as your colleagues&#39; developer environments. We have been big fans of the product for quite some time.\n\n__SPLIT_HERE__\nRemote development at its finest\n\nYou can now automatically and securely connect your Gitpod workspace to other development resources, whether in the cloud or on prem, such as a production database behind your company&#39;s firewall. You can also spin up several Gitpod workspaces that can talk to each other.\n\nTo connect any new dev environment, spin up a workspace in Gitpod and authenticate to Tailscale with an auth key. We recommend setting an ephemeral auth key as an environment variable so you do not pollute your list of Tailscale nodes once you experienced the magic of ephemeral dev environments ü™Ñ. You‚Äôll also need to add a task to start up Tailscale as well as set a network variable as part of your .gitpod.yml configuration file.\n\nCheck out our docs and/or the Tailscale repo for a sample .gitpod.Dockerfile and .gitpod.yml to get started.\n\nWith Gitpod and Tailscale you can:\n\nSecurely access a cloud or on-prem resource, like a production database\nSpin up a fleet of connected Gitpod workspaces\nShare a staged resource with a colleague, as part of a review\nAccess a package registry\nComplete a coding interview\n\nWhat Big Tech such as Google, Facebook or Shopify has been doing for years is now accessible for the rest of the world: secure remote development in the cloud.\n\n__SPLIT_HERE__\nSecuring your software supply chain in a distributed world\n\nIn a distributed world remote development is an important lever to counter the increasing threat of source integrity and supply chain attacks for your project &amp; team. Our partnership with Tailscale marks the first step of a series of articles that will raise awareness around that topic.\n\nSoftware development without sandboxes is a security risk. For approximately 4 hours last week, a widely utilized NPM package, ua-parser-js, was embedded with a malicious script intended to install a coinminer, harvest user/credential information and to compromise developer endpoints.\n\nWith Gitpod, no packages or dependencies are downloaded to users&#39; devices which contain security incidents and inhibits malicious actors pivoting towards completely compromising developer endpoints. Gitpod workspaces are short-lived sandboxes and protect your local machine from arbitrary code execution coming from a dependency in your code‚Äîso that you can run only what you trust locally.\n\nTo test that we encourage you to run rm -rf in a Gitpod workspace as many times as you want! If the destructive joy is diminishing in utility you can revert to playing Doom inside Gitpod üî´.","metadata":{"source":"https://gitpod.io/blog/tailscale"}}],["305",{"pageContent":"Our mission here at Gitpod has always been about removing friction from the lives of developers.\n\nToday, we&#39;re excited to share with you the next big step in this journey‚ÄîTeams and Projects.\n\n__SPLIT_HERE__\nWait, what?\n\nSo, Gitpod provides your team with consistent, standardized and fully-automated dev environments. When you use Gitpod, you can launch new workspaces in a flash, for any project and any context, and then throw them away again when the job is done.\n\nDisposable workspaces feel like inbox-zero üßò‚Äç‚ôÄÔ∏è\n\nBut before you and your team can get there, there have always been a few caveats, a few obstacles standing annoyingly between you and that frictionless dev experience:\n\nIt&#39;s complicated to describe your project&#39;s setup in the .gitpod.yml syntax\nIt&#39;s complicated to enable Prebuilds for your project‚Äîyou never know if they&#39;re running, or when they fail, and you can&#39;t get the build logs anywhere\nIt&#39;s complicated to create a Team in Gitpod and to invite your team members\n\nAll this changes today.\n\n__SPLIT_HERE__\nIntroducing: Teams and Projects ‚ú®\n\nOur goal with this latest update is to resolve the three pain points listed above, specifically by:\n\nProviding a nicer experience for teams\nMaking it easier than ever to configure Gitpod for your project\nMaking Prebuilds a first-class feature that is easy to set up, easy to observe and easy to troubleshoot\n\n‚ÑπÔ∏è Teams and Projects are currently in Beta and the UI is still evolving. Please send feedback.\n\n__SPLIT_HERE__\nTeams\n\nTeams\n\nWe&#39;re making it easy to create and to manage your Teams.\n\nCreate a new Team in a few clicks and give it a recognizable name (teams are free and you can create as many as you want)\nInvite your colleagues, collaborators or students with a simple (revokable) invite link\nChoose who is a Member or an Owner‚Äîyou can even have multiple Owners\nAdd GitHub or GitLab repositories to your Team in order to create Projects\n\n‚ÑπÔ∏è For now, this new Teams feature is totally independent of Gitpod‚Äôs pre-existing Team plans. If you‚Äôre currently managing a Team Plan, or you‚Äôre a member of a Team Plan, this will remain unchanged, regardless of what new Teams you create using this new feature or how many Members you invite (the Members lists are also independent).\n\n__SPLIT_HERE__\nProjects\n\nWe are also making it easy to automate your Projects with Gitpod.\n\nAdd a new Project or directly visit gitpod.io/new\nSelect which repository to import into Gitpod\nGitpod will auto-detect your Project&#39;s configuration, based on the files present in your repository\nView and edit your Project&#39;s configuration\nFinally, trigger your first Prebuild to test your new configuration\n\nRunning your first Gitpod Prebuild\n\nVoil√†. From now on, Gitpod will automatically detect changes in your repository, and start new Prebuilds to speed up your workspaces continuously. From here on out, waiting for builds really is a thing of the past!\n\nWe hope you&#39;ll enjoy having instant precompiled workspaces at your fingertips and being always ready-to-code. ‚ö°","metadata":{"source":"https://gitpod.io/blog/teams-and-projects"}}],["306",{"pageContent":"Welcome to DevX Digest - the place to hear all about Developer Experience, brought to you by Pauline Narvas (@paulienuh) and Mike Nikles (@mikenikles) from Gitpod. You‚Äôre reading the first ever newsletter from us üéâ!\n\n__SPLIT_HERE__\nWhat is DevX?\n\nWhen we‚Äôve asked folks what they think developer experience (DevX) is, the answers vastly differ. For some, it‚Äôs good documentation; it‚Äôs a language, it‚Äôs the best framework, it‚Äôs how quickly you can go from idea to execution with minimal headaches‚Ä¶\n\nNo matter how you define developer experience, it is crucial to get it right; a good (or bad) experience could be the make or break relationship developers have with a tool. On top of that, the industry is saturated with choice on which tool is best to use - it is so overwhelming. How can we pick the right one?\n\nIt‚Äôs strange how even though we recognise how important developer experience is, it‚Äôs still an area that just isn‚Äôt talked about often. Redmonk gave this a name, ‚Äúdeveloper experience gap‚Äù:\n\n‚Äú...developers are forced to borrow time from writing code and redirect it towards managing the issues associated with highly complex, multi-factor developer toolchains held together in places by duct tape and baling wire.‚Äù\n\n__SPLIT_HERE__\nDevX in the IDE world\n\nTo illustrate how DevX has evolved to become a more seamless, joyful, efficient experience, let‚Äôs talk about the integrated developer environment (IDE).\n\nA few years ago there were two approaches for devs, either use a fully-integrated developer environment (IDE) that would be a fat application equipped with everything a developer could possibly need. Examples of this are Eclipse, Jetbrains‚Äô IDEs or Apple‚Äôs Xcode. On the other end of the spectrum we would find developers who find all this tooling too heavy weight and slow. Those devs would cheer for the lightness and flexibility of command lines paired with text editors, such as sublime but also vi or Emacs.\n\nHas this changed? Yes, that is the short answer to that. You can see that another IDE, namely Visual Studio Code, has since taken over.","metadata":{"source":"https://gitpod.io/blog/the-evolution-of-devx"}}],["307",{"pageContent":"VS Code takes over - Why is that?\n\nClassic heavy-weight IDEs, such as Eclipse, were the trailblazers that paved the way for many important DevX improvements. What made it a fantastic experience for developers was how they could vastly customise environments using their extensible plugin system. But they often went a bit too far, by adding tools and abstractions that slowed down the overall experience and ignoring powerful tools like CLIs that were contributed by the various language communities.\n\nSven Efftinge and Erich Gamma recently talked about this very topic during DevX Conf (YouTube video). Erich led the original development of the Eclipse IDE. He co-authored the book ‚ÄúDesign Patterns: Elements of Reusable Object-Oriented Software‚Äù and currently works at Microsoft, where he is the VS Code Dev Lead. Their conversation gave an interesting insight on the history of these IDEs, design decisions made at the time and how that has changed over time influenced by developer experience.\n\nOne thing we know that is certain is that things change.\n\nEclipse was designed to run extensions on the same process as the core. At the time, this single process architecture made sense. In the spirit of moving fast, this was the quickest way to integrate extensions to the core.\n\nSource: Stackoverflow Surveys 2015-2019 (professional developers)\nSource: Stackoverflow Surveys 2015-2019 (professional developers)\n\nHowever, the more Eclipse grew, including its extensions, the downsides became more apparent. This complex architecture‚Äôs side effects often led to slow start-up times, a bloated IDE and extensions depending on specific versions. The mindset of loading everything in the same process implied that every extension had to be written in Java, but what about other languages?\n\nOver time slow and bloated software can leave folks wondering if there are alternatives - something that could relieve the pain of those downsides!\n\nAnd then... VS Code enters the chat.\n\nJSON-RPC, the Language Server Protocol (LSP), API-driven, a multi-process architecture (extensions not part of the ‚Äòcore‚Äô) leading to faster start-up times, less bloat and leaner. The pain points and limitations developers had experienced from Eclipse, VS Code was developed to reduce. It is no wonder that today, VS Code is the most used IDE.\n\n__SPLIT_HERE__\nLess is better\n\nFor those extreme power users, upon the first inspection, the VS Code extension model may seem limited in some way in comparison to the one from Eclipse, but that can be a good thing. What‚Äôs the saying again? Simplicity is better! This simplicity is deliberate, of course. Often, it is the simpler designs that extend the lifespan of software for years to come.\n\nIt‚Äôs interesting how the mindset from Eclipse to VS Code has shifted, which has massively been led by the experience of developers.\n\n__SPLIT_HERE__\nLet‚Äôs look at challenges developers face today\n\nWith this in mind, the next question is, what are some pain points developers have today? And what is next to help with those pain points?\n\nSpeaking personally, despite massive leaps to VS Code, I still think of roaring loud fans, a burning hot laptop, especially if you were like me -- hanging on to dear life to old tech. Sound familiar? My six-year-old Macbook Pro fits this description.\n\nVS Code with all my extensions ran slow despite it being relatively light compared to other IDEs; my laptop couldn‚Äôt handle it. I wasn‚Äôt able to start writing code immediately when the creative juices started flowing! Don‚Äôt even get me started on the uphill battle of getting the correct developer environment setup (e.g. cloning, installing dependencies on an old, bloated piece of hardware)... At that point, it just wasn‚Äôt worth it. So what is the solution?","metadata":{"source":"https://gitpod.io/blog/the-evolution-of-devx"}}],["308",{"pageContent":"What‚Äôs next for developer experience?\n\nTech has constantly been talking about the power of the cloud in recent years. As Chris Aniszczyk describes in his post, &quot;Cloud Native predictions for 2021 and beyond.&quot;:\n\n‚ÄúThe future will hold that the development lifecycle (code, build, debug) will happen mostly in the cloud versus your local Emacs or VSCode setup. You will end up getting a full dev environment setup for every pull request, pre-configured and connected to their deployment to aid your development and debugging needs.‚Äù\n\nSounds like a dream, huh? The next generation of IDEs is already here! You can do this right now with Gitpod and GitHub Codespaces beta. The constant innovation excites me the most about tech in general; it‚Äôs truly magical to see how developer experience will continue to shape our tool kit as developers. As long as we can imagine it, it is possible and isn‚Äôt that exciting?\n\n__SPLIT_HERE__\nJoin us for the ride!\n\nWe hope to highlight DevX further and bring to you curated content about what truly makes for great developer experiences! Over the next few months, we‚Äôll be sharing best practices and frameworks that continue to spark dialogue across four different areas:\n\nDevelop\nCollaborate\nTest, build &amp; deploy\nRun\n\n__SPLIT_HERE__\nDevX newsletter is community-driven\n\nAnother thing about Gitpodders is that we‚Äôre all driven by community feedback, and this newsletter is no exception! Please send us your thoughts, feedback and help us drive this conversation. We may even feature some of your takes and comments in future newsletters!\n\nCome and hang out with us over on our Discord channel.","metadata":{"source":"https://gitpod.io/blog/the-evolution-of-devx"}}],["309",{"pageContent":"Welcome to DevX Digest - the place to hear all about Developer Experience, brought to you by Pauline Narvas (@paulienuh) and Mike Nikles (@mikenikles) from Gitpod. You&#39;re reading another newsletter from us üéâ! In this edition, we talk about developer experience in cloud-based,ephemeral dev environments.\n\nLast week on DevXPod, we sat down with Shawn Wang (aka Swyx) to hear his thoughts on what makes developer experience. For those that have not heard of Shawn before, he‚Äôs currently the Head of Developer Experience at Temporal and is well known for the learning in public movement and for speaking about React and Severless.","metadata":{"source":"https://gitpod.io/blog/the-radiating-circle-of-devx"}}],["310",{"pageContent":"As usual, in today‚Äôs newsletter, we‚Äôll be sharing some of our key takeaways from the podcast episode. If you‚Äôd like to listen to the full episode, head over to your favourite podcast platform and search for DevXPod. Don‚Äôt forget to subscribe and leave us a rating ‚≠êÔ∏èAlternatively, if you‚Äôd prefer to read a transcript of our conversation head over to our Buzzsprout site!\n\nPodcast\n\nDevX Pod is available wherever you get your podcasts!\n\nKey Takeaways\n\nDeveloper Experience is like a radiating circle out from the core product. ‚≠ïÔ∏è Shawn describes it as:","metadata":{"source":"https://gitpod.io/blog/the-radiating-circle-of-devx"}}],["311",{"pageContent":"Podcast\n\nDevX Pod is available wherever you get your podcasts!\n\nKey Takeaways\n\nDeveloper Experience is like a radiating circle out from the core product. ‚≠ïÔ∏è Shawn describes it as:\n\n&quot;You start with the core product, you make sure that API design solid. Then you radiate out into the docs. And then you go from the first party content, which is your blog posts and talks. Then community, which is going from one to many communication to many, to many communication. Having a place where your users talk to other users and help each other out. And then the final tier is enabling third-party content, which is users writing blog posts and books, workshops, courses and tutorials about you, even posting jobs with your tool or your technology in the job description on anything like this, where it&#39;s very user initiated.&quot;","metadata":{"source":"https://gitpod.io/blog/the-radiating-circle-of-devx"}}],["312",{"pageContent":"Keeping developers engaged from the beginning with a ‚Äúwow‚Äù moment is also part of this, if your end-to-end experience helps keep developers curious and in flow, they are as a result much more productive.\n\nIt‚Äôs clear that developer experience covers more than just your core product. Experiences around it are also equally as important. The radiating circle analogy is spot on! We‚Äôll certainly be using this from now. üéØ\n\nIn the DevX world, we often talk about the happy paths i.e. how fast something is and how much it‚Äôs improved their workflow. However, ‚Äú_Developer Exceptions_‚Äù is as equally as important. What do we do when things go wrong? Thinking about this is just as vital for a good developer experience. This covers more of the ‚Äúboring‚Äù things for example, work on observability, clear deprecation support policies, etc. üëÄ","metadata":{"source":"https://gitpod.io/blog/the-radiating-circle-of-devx"}}],["313",{"pageContent":"When it comes to the importance of developer experience, accessibility for folks getting into the space was once again front and centre. Shawn shared that he thinks it‚Äôs important especially as a career switcher into tech himself.\n\nShawn‚Äôs pick in favourite developer experience is anything that makes cycles faster, reduced feedback loops and with lots of customisation options.\n\nThe future of developer experience is looking bright! ‚ú® Video format was mentioned again in this episode, especially with the rise of short-form videos like TikTok. There are challenges that come with video format (e.g. outdated very quickly) but it‚Äôs still a space that will only continue to grow. üìπ\n\nShawn shared some of his thoughts on where he thought it is going, building on the radiating circle analogy.","metadata":{"source":"https://gitpod.io/blog/the-radiating-circle-of-devx"}}],["314",{"pageContent":"Shawn shared some of his thoughts on where he thought it is going, building on the radiating circle analogy.\n\n&quot;In line with the model that we&#39;ve been developing, either you integrate forward or integrate backwards. In other words,typically developer experience is very tied to developer relations and a lot of first party content creation. So you integrate forward, meaning that talk a little bit more with community, you take on more community management roles or you encourage more, third party content by holding workshops and stuff like that. Or you integrate backwards, which is you get more involved with products. So I think that&#39;s an interesting way to think about this in terms of the radiating circles, but the other way to think about it as well is what&#39;s the shift within the content creation meta game, which I think about a lot as well.&quot;\n\nDevX Digest is community-driven ü§ù","metadata":{"source":"https://gitpod.io/blog/the-radiating-circle-of-devx"}}],["315",{"pageContent":"DevX Digest is community-driven ü§ù\n\nAnother thing about Gitpodders is that we‚Äôre all driven by community feedback, and this newsletter is no exception! Please send us your thoughts, feedback and help us navigate this conversation. We may even feature some of your takes and comments in future newsletters!\n\nCome and hang out with us over on our Discord. üëãüèº","metadata":{"source":"https://gitpod.io/blog/the-radiating-circle-of-devx"}}],["316",{"pageContent":"At Gitpod, we have operated unofficially with two CEOs for the past 1.5 years. Today, we make our dual leadership around Sven and Johannes official.\n\nWhether a Co-CEO setup is good or not has been a matter of contention throughout the years. While still a little uncommon, we see more and more very successful companies such as Atlassian, Salesforce, and Netflix operating with two CEOs (we are working hard to add Gitpod to that list „ÉÑ). We believe this is superior to having a single CEO if done right. Below, we dive into the advantages of a modern dual leadership setup, discuss typical preconceptions, and share what we believe makes the structure successful for Gitpod.","metadata":{"source":"https://gitpod.io/blog/two-ceos-are-better-than-one"}}],["317",{"pageContent":"Benefits of running a company with two CEOs\n\nWhen it comes to the people you work with, quality matters more than quantity. Hence, one great CEO is better than two mediocre ones. Conversely, if both CEOs think too similarly and care about the same parts of the business, you don&#39;t get many of the benefits below. But if you run your company with two CEOs who operate with high trust and full transparency, are aligned in terms of direction and culture, and have complementary skill sets, your company will see a lot of benefits:\n\nFewer skill gaps. Let&#39;s face it, we all have our strengths and weaknesses. We are motivated differently and are more or less passionate about the various responsibilities of a CEO. With two complementary CEOs, you can cover much more ground effectively.\n\n\nDefer the entire C-Suite. As a company grows, you need to build out its structures, so that information flows efficiently and effectively. Director, VP, and C-Level layers are the standard answer to scaling companies. But adding such a layer comes at a cost (longer information flow). As a single CEO, you&#39;ll feel the need to delegate to a CFO, COO, etc., much earlier. With two CEOs, you can defer adding that layer because you cover more ground (fewer skill gaps). With Chris as our CTO, our executive team consists of three people that are highly aligned while adding different perspectives to the conversations.\n\n\nGrounded Decisions. A common preconception is that decision-making would be less efficient with two CEOs. The contrary is the case if you do it right. For one, if you have two CEOs, each needs to have clear Areas of Responsibilities (AORs). It becomes straightforward for everyone who makes the call. There are, however, some shared AORs as well. For those critical areas, you get more grounded decisions. When we reach out with a significant change, the whole team knows we&#39;ve at least run this by the two of us (of course, we consult with others in the decision process).\n\n\nTeam over individual. Company culture is essential for a modern tech startup. Not only to attract the best talent but to make sure everyone is having a great time building a superb product for your users. Our culture at Gitpod is based on openness, humbleness, empathy, and generally an egoless team spirit. A dual leadership embraces and emphasizes these values, while a single CEO model quickly leads to throne building.\n\n\nReduced Burnout. Running and building a company can be stressful. As a single CEO, you are not only responsible for everything that happens and goes wrong, but you also need to look after and be on top of so many things. Hiring, Fundraising, Company Building, Operations, Finance, and then you also need to make sure the product gets better and provides more value. Doing this alone isn&#39;t great for many reasons and can amplify the stress level. You should get help from coaches, friends, and advisors but nothing beats having a partner in crime with whom you can share everything.\n\n\nMinimize bus factor. A single CEO also means a single point of failure. It doesn&#39;t need to be the bus or the prevalent burnout, but it can be something as simple and straightforward as taking two weeks off to recharge and spend time with your family.\n\nSo are there only advantages to this? Almost. One disadvantage is that there are many preconceptions about such a co-leadership setup, especially in venture capital. Let&#39;s discuss why some of them dislike running a startup with two CEOs.","metadata":{"source":"https://gitpod.io/blog/two-ceos-are-better-than-one"}}],["318",{"pageContent":"Typical Preconceptions about Two CEOs\n\nIf you search the web for opinions on running a company with two CEOs, you&#39;ll find a few articles. Christoph Janz has recently written down his take where he lists three reasons why a single CEO is better. Sorry, Christoph, your article was just the most recent one üôÉ\n\nFaster Decision Making. &quot;If you need two people to make a decision, ‚Ä¶&quot;\nThat would be very inefficient indeed. But you don&#39;t need two people. With two CEOs, you need trust so either one can make many of the calls themselves without mutual approval. This works great as long as you align in vision and direction. If there is not complete trust between CEOs, this will not work. Actually, the same is true for every high-performing team.\n\n\nClear Responsibilities. &quot;Another side effect of having two CEOs is that it&#39;s less clear who does what.&quot;\nThat is not a side-effect of having two CEOs, but unclarity arises when you are not explicit about clarifying AORs. You need to clarify responsibilities with clear decision-making guidelines - again, this must exist between CEOs and the entire organization.\n\n\nA Co-CEO setup makes it harder to attract top VPs. &quot;They might wonder if you let your ego stand in the way of doing what&#39;s best for the company and if you&#39;re able to make tough decisions.&quot;\nAs we hope has been clarified by now, we do not run Gitpod with two CEOs because both CEOs have too big an ego and couldn&#39;t sort it out. Quite the contrary: Sven used to be the single CEO and decided that there is a better setup for Gitpod, so he asked Johannes to help. Ego is the enemy.\n\nChristoph is looking at this topic from a certain angle: many co-founders avoid having difficult conversations to clarify who is leading the company. In those setups, dual leadership is not a conscious decision but rather a legacy arrangement due to large egos. If you don&#39;t talk candidly about why two CEOs are suitable for your company at the current state, you are also likely to not set it up for success in the first place. In the end, your job in any venture-backed company is to maximize long-term shareholder value and not to work on your hubris.","metadata":{"source":"https://gitpod.io/blog/two-ceos-are-better-than-one"}}],["319",{"pageContent":"When you do it, do it right.\n\nAt Gitpod, we naturally grew into the co-leadership setup over time and have successfully practiced it for some time. There are a couple of reasons why this worked so well for us:\n\nComplementary Skill Set - Sven built development tools, programming languages and grew open source communities for the last 15 years. His passion, strength, and energy source are around building Gitpod, the product. Johannes deeply understands the developer tooling market and worked in venture capital before Gitpod. He excels at building Gitpod, the company, and runs everything from go-to-market, fundraising, operations, to finance.\n\n\nHigh Trust - over the last 1.5y we became friends and partners. Without complete trust and psychological safety, co-leadership does not work, and you can not leverage the respective strengths of each person. We always help each other out, can speak up, and trust in the other person&#39;s decision-making. If there are problems, we confront those issues quickly, get relevant input, and find practical solutions.\n\n\nFull transparency - the human mind is excellent at fooling itself by painting an unwanted reality in comfortable ways. We openly share everything and constantly give positive and constructive feedback to stay true to reality. No information is held back.\n\n\nClear AORs - when several people share responsibility for an action or process, often that action doesn&#39;t get done well or at all. We prevent this from happening with Areas of Responsibility - a routing layer that ensures nothing falls through the cracks.\n\n\nClear Goal Setting - We follow a quarterly goal-setting process that creates alignment, focus, accountability, and aspiration to set direction and drive our business forward ‚Äî both between executives and the whole organization.\n\nLeadership decisions are distinctive and specific to the company you are building. That said, we believe many of the reasons to embrace a dual leadership model apply to other companies, too.\n\nRead our 7-part blog series about the Gitpod Company Operating System\n\nThis article was the first in a series in which we share how we are building the Gitpod company operating system. We will walk through the tactical resources we are putting in place to create a fully distributed company. The title of the next article in this series is Set Direction (Purpose, Product Vision, Brand). If you want to stay in the loop drop your email address below and we will reach out once the next article launches.\n\n&amp;nbsp","metadata":{"source":"https://gitpod.io/blog/two-ceos-are-better-than-one"}}],["320",{"pageContent":"Ho ho ho! Christmas came early!\nWe‚Äôve just released a bunch of exciting new features and I&#39;m not talking about Gitpod Enterprise which was announced last week or the GitLab support we&#39;ve shipped the week before.\n\nüîìTry with Your Private Repositories For Free\nüõ†Get Your Projects Setup with an Assistant\nü§óNew, Cheaper Plans with More Features\nüåìLight and Dark Theme\n‚ôªAutomatic Garbage Collection\nüí¨New Community Forum\n\n__SPLIT_HERE__\nüîì Private Project Trial\n\nUsers can now try Gitpod on their private GitHub and GitLab projects for one month for free without providing payment information or automatic subscription start afterward.\n\nTo get started, simply prefix your private repository‚Äôs GitHub or GitLab URL with gitpod.io/# and go through the OAuth flow. To fully get the hang of Gitpod, you need to configure your project accordingly. You can either schedule a call with an engineer, study the documentation, or use the new and shiny setup assistant.\n\n__SPLIT_HERE__\nüõ† Setup Assistant\n\nAlthough setting up a project for Gitpod is usually a one-off effort, it can be a little involving depending on the complexity of the project&#39;s structure. With the arrival of a new setup assistant configuring Gitpod has become a whole lot easier now.\n\nThe assistant informs you through a small notification when your project lacks a .gitpod.yml and guides you through a 5 step process to create, test and propose a proper Gitpod configuration.\n\nYou can of course try it out on an arbitrary open-source project, too. We want the assistant to become really smart over time and understand all kinds of languages and build tools. So please share ideas and other kinds of feedback.\n\nyoutube: IRzCR0r7DSE\n\n__SPLIT_HERE__\nü§ó New Plans\n\nWe have reworked the plans and added a bunch of features to them as well.\n\nFree for Open Source ‚ù§Ô∏è\n\nSo far Gitpod has been free to use on public repositories for up to 100hours/month. We analyzed how people have been using Gitpod and found out that while a lot of people use it regularly for open-source work and reach the 100 hours limit, there are others using the free plan to run their expensive processes and builds (miners and the like are automatically killed, btw, and are violating our terms) which is not what we had in mind when offering a generous open-source plan.\n\nTo protect us from such miss-use and at the same time better support open-source work, we made the following two changes:\n\nAdd a free, unlimited hours for professional open-source developers.\nReduce the free plan to 50h/month, which is still plenty for part-time contributors and trying Gitpod.\n\nPlease apply for the unlimited open-source plan, once you ran against the 50 hours limit. We&#39;ll check your track record and get you going within one business day.\n\nPersonal Plan\n\nThe Personal Plan got a change in that it can now be used commercially as well. This hasn‚Äôt changed the price of ‚Ç¨8 / $9.\n\nProfessional Plan üÜï\n\nWe added a plan in the middle that offers unlimited usage hours for ‚Ç¨23 / $25.\n\nUnlimited Plan\n\nThe Unlimited plan got a couple of cool upgrades.\n\nMost importantly, Unlimited users enjoy a 60min timeout with an additional 3 hours booster. For regular users the timeout is strict 30 minutes. The additional booster can be triggered from within a workspace. Simply press the hourglass sign in the status bar (only visible if you are an unlimited users)\n\nTimeout Booster\n\nFurthermore, with Unlimited you can start up 16 workspaces in parallel.\n\nCheckout the pricing page for an overview.\n\n__SPLIT_HERE__\nüåìLight &amp; Dark Theme\n\nGitpod comes with a dark theme by default. You can now switch to light and the styles will be applied on all your workspaces and the dashboard pages. Full support for VS Code themes is already landing in Theia, the open-source IDE we are developing for Gitpod, and will be shipped in January.\n\nyoutube: CcTI9X9na8A","metadata":{"source":"https://gitpod.io/blog/update-december-2019"}}],["321",{"pageContent":"‚ôª Garbage Collection\n\nWith prebuilt, disposable workspaces, Gitpod encourages to start fresh workspaces for every task. Whenever I need to code, do a review or just want to try something, I simply spin up a fresh workspace, do my thing and forget about it afterward.\n\nBut what happens to all those old workspaces?\n\nWell, in order to really be able to forget about it, we have implemented an automatic garbage collection. It automatically deletes old workspaces after an inactivity of 30 days. You can exclude workspace from being garbage collected by manually pinning them in the workspaces list on the dashboard (see belows screenshot).\n\nGarbage collection starts on January 20th.\n\nPin Workspaces\n\n__SPLIT_HERE__\nü•ÇHave a Great Holiday Season!\n\nThat&#39;s all for now. I hope you have a great time with your families and friends. Many thanks to everyone supporting us in our quest to simplify and streamline developer&#39;s daily live.\n\nSee you online &amp; happy coding!","metadata":{"source":"https://gitpod.io/blog/update-december-2019"}}],["322",{"pageContent":"With Visual Studio Online (VSO) Microsoft is entering the space of cloud-based developer environments. So, what are the differences? Glad you asked:\n\n__SPLIT_HERE__\nNext Generation Cloud IDE\n\nCloud IDEs are not exactly a new thing. Platforms like Cloud9 or Eclipse Che have been around for quite some time. However, these days we see the advent of a new generation of cloud IDEs, which are either based on VS Code, like VSO, or on the vendor-neutral alternative Eclipse Theia, such as Gitpod.\n\nMake no mistake, the ‚ÄúEclipse‚Äù in Eclipse Theia doesn‚Äôt mean it is based on the classic Eclipse IDE, but that it is governed by the Eclipse Foundation rather than controlled by a single company. The Eclipse Foundation is a not-for-profit Open-Source Foundation.\n\nThis is open-source at its best, as it means others can innovate on top of a stable platform without risking the project is making unexpected turns.\n\nTheia has not even seen a 1.0 release, yet, but is already adopted by many companies, such as Google, ARM, Arduino, RedHat, IBM, SAP, Ericsson and yes, Gitpod. We actually started the project together with Ericsson and are still among the most active contributors.\n\nWith regards to features neither VS Code nor Theia has a significant competitive advantage over the other as both support VS Code extensions and the UI is almost identical. Theia is more flexible when it comes to extending the core IDE, though, as you can build all kinds of modern cloud and desktop IDEs based on it. But as an end user of Gitpod this doesn&#39;t really make a difference as we are embracing the look and feel of VS Code.\n\nLong story short, from the user‚Äôs perspective the IDE itself is a common good and therefore not a real differentiator, so we need to dig a little deeper to discover the real differences.\n\n__SPLIT_HERE__\nContinuous Dev Environments\n\nContinuous Dev Environments are at the core of Gitpod.\n\nWe believe that the way to go are short-lived dev environments that are easy and fast to create from any Git branch.\n\nFor that we eliminated any ‚Äòcreate environment‚Äô-wizards and dashboards standing between you and your dev environment. With Gitpod you just go to your Git project and start coding. GitHub or GitLab is your dashboard.\n\nIn the launch post for VSO disposable dev environments are mentioned, which is an important part of our vision, but unfortunately VSO doesn‚Äôt embrace it in the actual product. After getting through the account creation of VSO, you land on a dashboard and create a dev environment through a form based configuration dialog. Due to the lack of prebuilds, creating fresh dev environments all the time is tedious, as you need to wait for the build, downloading dependencies and running tests. This dashboard-centric approach encourages people to reuse their workspaces instead of relying on a well-working, automated setup continuously.\n\nGitpod, on the other hand, builds your branches similar to a CI build before you open a dev environment. This way you are really ready-to-code whenever you open a workspace. Disposable dev environments really need such a feature as you‚Äôd otherwise waste your time on watching your build.\n\n__SPLIT_HERE__\nSelf Hosting\n\nGitpod can be installed on any Kubernetes cluster and deeply integrates with your existing tool chain. Whether you use GitHub, GitLab or Bitbucket a deep integration is possible, providing a frictionless dev experience. We also support custom OAuth and styling/re-branding so you could even use our technology in the context of your branded service or product.\n\nOn VSO there is something called ‚Äòself-hosted‚Äô but that doesn‚Äôt mean you can self host VSO itself. Instead, you can only point it to hardware running elsewhere and start dev environments there. You are still stuck in Microsoft / Azure land.","metadata":{"source":"https://gitpod.io/blog/visual-studio-online-vs-gitpod"}}],["323",{"pageContent":"DX\n\nA list of checkboxes doesn‚Äôt make a good product, although in terms of features Gitpod definitely is ahead of VSO, as it supports capabilities like snapshots, prebuilds, the deep integration with GitHub and GitLab or all the advanced automation possibilities the configuration allows.\n\nThat said, VSO is still in beta and they have features on their agenda that are also not yet supported on Gitpod, such as starting Windows VMs.\n\nAnyhow, the Gitpod team is not striving for an ever growing feature list. Instead,\n\nwe are focussing on a coherent developer experience (DX) that doesn‚Äôt get into your way, but lets you focus on coding.\n\n__SPLIT_HERE__\nMicrosoft Monopoly?\n\nNot really related to product functionality, but I‚Äôm honestly a little concerned about the massive control MS has gained over the developer world in the last few years. They have hired awesome talent and allow them to create crazy good developer products such as TypeScript and VS Code. Acquiring GitHub was another huge cornerstone and I wonder if the other big tech companies don‚Äôt realize this or whether they already have given up on this.\n\nFor GitHub, GitLab seems to be the only real competitor and Azure DevOps is trying to take over the CI tools space. VS Code has surpassed 50% market share which I believe is the highest number for an IDE/Editor in history. The stuff MS has created is amazing and the people behind them are great and friendly engineers, but for the rest of the industry is definitely not healthy to have everything under control of a single vendor as it hinders competition and with that diversity and inventions.\n\n__SPLIT_HERE__\nConclusion\n\nIn this post I covered the most important differences between Gitpod and Visual Studio Online. In a nutshell:\non the IDE feature level there are not many differences, but\n\nregarding how dev environments are provisioned, Gitpod‚Äôs approach is clearly leading the pack.\nSelf-hosting is not really supported by VSO and\nMicrosoft is growing a little too dominant in the developer world these days.\n\nPlease let us know if you have further questions.","metadata":{"source":"https://gitpod.io/blog/visual-studio-online-vs-gitpod"}}],["324",{"pageContent":"You might have seen we recently announced SSH public key upload for Gitpod, and in the announcement, we mentioned: &quot;SSH key upload also gives our users more stable, performant and secure connections&quot; which might have left you wondering what this statement means in practice.\n\nA lot of the changes we made to our SSH approach applies to our VS Code Desktop users. In this article we will take a deeper look at: how SSH connections work with VS Code Desktop, the pros/cons of the different approaches, and cover some common gotchas and questions.\n\n__SPLIT_HERE__\nTL;DR; benefits of SSH improvements for VS Code Desktop\n\nIf you&#39;re short of time, here are the improvements:\n\nConnection has improved stability, with fewer disconnections\nApproach doesn&#39;t overwrite the remote.SSH.configFile\nNo additional binary downloads required or background processes\nFewer requests from VS Code to accept the SSH fingerprint\nImproved operating system support via OpenSSH\n\nHowever, if you&#39;re eager to learn more about the details about what has changed with VS Code Desktop and SSH Gateway, read on.\n\n__SPLIT_HERE__\nThe Different Approaches to SSH access in Gitpod\n\nAll our desktop clients, direct SSH access, VS Code Desktop and JetBrains clients share similar methods of connecting to a workspace via the SSH protocol.\n\nThe SSH methods with Gitpod are:\n\nSSH Gateway - By uploading your SSH public key to Gitpod (recommended)\nSSH Gateway - Using your workspace owner token (a username/password type approach)\nLocal Companion - The legacy approach, using Local Companion under the hood.\n\nWe&#39;ll go through all of these approaches in more detail below.\n\n__SPLIT_HERE__\nUnderstanding SSH Gateway\n\nYou may notice above the mention of the SSH Gateway component. SSH Gateway is an intermediary service within Gitpod that proxies incoming SSH requests to the appropriate running workspaces.\n\nSSH Gateway for SaaS should be mostly transparent / invisible to the Gitpod experience. However, it is worth noting that SSH Gateway has non-functional benefits for performance and security.\n\nSSH Gateway architecture in Gitpod\nSSH Gateway architecture in Gitpod\nCaption: SSH Gateway architecture in Gitpod","metadata":{"source":"https://gitpod.io/blog/vscode-desktop-ssh-updates"}}],["325",{"pageContent":"VS Code Desktop for connecting via SSH Gateway\n\nThe two main methods for using SSH Gateway with VS Code Desktop are:\n\nSSH Gateway access an uploaded public key (recommended)\nSSH Gateway access using the owner token\n\nImportant: You must first ensure that gitpod.remote.useLocalApp is set to false in your VS Code user preferences for Gitpod to connect via the two SSH Gateway methods.\n\nVS Code Gitpod use Local App setting\nVS Code Gitpod use Local App setting\nThe VS Code Desktop Gitpod extension &quot;useLocalApp&quot; setting\n\nSSH Gateway access using an uploaded public key (recommended)\n\nFirst, VS Code Desktop will check if you have already added a public SSH key to Gitpod and that the associated private key is available on your device.\n\nIf you haven&#39;t set up an SSH key with Gitpod, you can go to gitpod.io/keys to upload a public key. Alternatively, you can continue using the owner token approach detailed below.\n\nYou must have at least one public key uploaded to Gitpod, and a matching private key locally on your device to avoid this prompt. VS Code Desktop will look to find private keys in the following named files within the .ssh directory listed under your home directory.\n\nid_dsa\nid_dsa\nid_ecdsa\nid_rsa\nid_ed25519\nid_xmss\nid_ecdsa_sk\nid_ed25519_sk\n\nSSH Gateway access using the owner token\n\nIf you cannot upload a public key to Gitpod (for whatever reason) selecting Copy will allow you to proceed to access your Gitpod workspace using the owner token approach. Selecting Copy will copy the necessary password to your clipboard to be pasted in the subsequent password prompt.\n\nVS Code prompting for a password. This message is shown when the public key warning notice is dismissed on the previous page by selecting Copy\nVS Code prompting for a password. This message is shown when the public key warning notice is dismissed on the previous page by selecting Copy\nCaption: VS Code prompting for a password. This message is shown when the public key warning notice is dismissed on the previous page by selecting Copy.\n\nNote: Gitpod previously required a local private SSH key to be stored in the default SSH directory, otherwise Gitpod would prompt for a &quot;password&quot;. This limitation is no longer required. If not using an SSH uploaded key, you may be prompted for a password (the owner token), or asked for the passphrase associated with your SSH key.\n\n__SPLIT_HERE__\nVS Code Desktop for connecting via Local Companion (Legacy)\n\nIf VS Code Desktop cannot connect directly via the SSH Gateway methods described above, the Local Companion approach is used as a fallback to tunnel your SSH connection. Gitpod via the VS Code Desktop plugin will download and start the Local Companion process on your behalf.\n\nThis approach is not recommended because:\n\nIt overwrites your remote.SSH.configFile VS Code setting, which will break users who have configured the VS Code remote development plugins to access other locations than Gitpod.\nDownloads and starts Local Companion in a non-transparent way.\nIs less performant than the SSH Gateway approach.\n\nIf required, you manually can force VS Code Desktop to always fallback to the Local Companion by setting the property gitpod.remote.useLocalApp in your user preferences to true.\n\nDeprecation Notice: The fallback SSH connection using Local Companion for VS Code Desktop will be deprecated in a future release of Gitpod. If you cannot connect to your workspaces directly via SSH, for example, because your firewall is blocking the SSH connection, please contact support with troubleshooting logs.","metadata":{"source":"https://gitpod.io/blog/vscode-desktop-ssh-updates"}}],["326",{"pageContent":"Diagnosing / Fixing common SSH connection issues\n\nIf you experience issues with any of the above described methods of accessing your workspace using VS Code Desktop and SSH there are some common things to check when troubleshooting.\n\nThe owner token wasn&#39;t copied to my clipboard, where can I find it?\n\nIf, for some reason you are being prompted for the owner token password, but cannot copy to clipboard, you can find the password on the Gitpod workspaces page under &quot;connect via SSH&quot;.\n\nThe password prompt in VS Code Desktop for the owner token\nThe password prompt in VS Code Desktop for the owner token\nCaption: The password prompt in VS Code Desktop for the owner token\n\nAccessing the owner token string manually from the Gitpod dashboard\nAccessing the owner token string manually from the Gitpod dashboard\nCaption: Accessing the owner token string manually from the Gitpod dashboard\n\nNote: The pattern of the owner token string is: workspaceid#ownertoken@host\n\nHow do I know whether I&#39;m connecting via Local Companion or SSH Gateway?\n\nIf you&#39;re unsure which connection method you&#39;re using to connect (SSH Gateway or Local Companion), you can work it out from the host name shown in the bottom left of VS Code Desktop. The format of the host will indicate which connection method you are using.\n\nSSH Gateway - SSH: workspaceid.ssh.*.gitpod.io\nLocal Companion: workspaceid (no domain)\n\nThe SSH host information shown in the bottom left of VS Code Desktop\nThe SSH host information shown in the bottom left of VS Code Desktop\nCaption: The SSH host information shown in the bottom left of VS Code Desktop\n\nI&#39;m prompted for a password/passphrase but I still cannot access my workspace?\n\nThe owner token prompt and passphrase prompt in VS Code can look similar, however require different inputs. If you&#39;re seeing a failure to connect, it could be that you are using the incorrect authentication method, e.g. pasting an owner token for a passphrase, or vice versa.\n\nOwner token - If the password prompt in VS Code Desktop asks Enter password for workspace@\\*.gitpod.io, this prompt is for the owner token of the workspace, not the passphrase associated with your SSH key.\n\nPassword prompt from VS Code requiring the workspace owner token\nPassword prompt from VS Code requiring the workspace owner token\nCaption: Password prompt from VS Code requiring the workspace owner token.\n\nThe SSH owner token shown in the Gitpod dashboard\nThe SSH owner token shown in the Gitpod dashboard\nCaption: The SSH owner token shown in the Gitpod dashboard\n\nSSH key Passphrase - If your SSH key has a &quot;passphrase&quot; associated with the SSH key (it is not required for SSH keys), you&#39;ll need to enter your passphrase. If your public key has no passphrase, you should not see the passphrase prompt.\n\nPassphrase prompt from VS Code requiring the SSH key passphrase\nCaption: Passphrase prompt from VS Code requiring the SSH key passphrase.\n\nThere is no way to recover passphrases with Gitpod. If you cannot remember your passphrase, consider creating a new SSH key and uploading that new key to Gitpod.\n\nSee configuring SSH for details on creating and uploading SSH keys.\n\nWhat if I&#39;m still having issues with SSH connections?\n\nCheck that your Gitpod VS Code Desktop extension version is using the latest stable version (0.40 or above).\nAttempt to directly connect via SSH using the -v to show verbose SSH logs. For example: ssh -v workspacename@hostname. You can find the ssh command in the workspace list on your Gitpod dashboard, see the command-line docs for more.\nIf you&#39;re a self-hosted customer, ensure SSH Gateway is configured correctly.\n\nIf you are still experiencing issues using VS Code Desktop and Gitpod, please contact support with any related troubleshooting logs\n\nFor more details on VS Code Destkop and SSH setup with Gitpod, see:\n\nConfiguring SSH with Gitpod\nWorking with VS Code Desktop and Gitpod","metadata":{"source":"https://gitpod.io/blog/vscode-desktop-ssh-updates"}}],["327",{"pageContent":"Today, we are excited to announce the start of our public beta phase for VS Code extensions in Gitpod, the next generation cloud IDE.\n\nSo far Gitpod supported the mainstream languages like JavaScript, Java, Python, Ruby, Rust, C++ and Go, but many others weren&#39;t covered yet. With today&#39;s release, we have added support for installing any of the 10K+ existing extensions for VS Code. Finally, Scala, Swift and F# developers will feel at home in Gitpod, too.\n\n__SPLIT_HERE__\nPart of Your Project‚Äôs Configuration\n\nGitpod automatically creates fresh, disposable dev environments on demand. Unlike traditional dev environments which you setup once and then have to maintain over time, you get a fresh one for every task. Therefore any installed extensions would normally be gone when discarding the workspace.\n\nThat‚Äôs because a Gitpod dev environment is tailored and optimized for the project at hand. I might work on multiple different projects, e.g. a Scala project as well as some Node.js projects. Why should I need to have the Scala extension in all my projects?\n\nTraditionally you would maintain one bloated editor for all your projects or alternatively maintain multiple per project.\n\nGitpod solves this problem for you by providing a small configuration that is part of your Git history. This includes information about dependencies, start up tasks and now also lists the extensions needed for the project at that point in time (version).\n\nHere is how it works:\n\n__SPLIT_HERE__\nInstalling an Extension\n\nInstalling extensions is a matter of dragging and dropping a *.vsix file into the extension view. Gitpod will automatically install and activate the new extension, and add an entry to the .gitpod.yml file. You can now test the experience and if you are happy with it share this new experience with your team by pushing the change to your remote Git repository.\nHere‚Äôs a small screencast:\n\nyoutube: hEqmXM62cjo\n\n__SPLIT_HERE__\nWhere Do I Find Extensions?\n\nMicrosoft prohibits the direct use of the Visual Studio Marketplace for any other software but their own. Although most extensions are open-source and not even developed or maintained by MS, the access to the Marketplace is restricted.\nHowever, if you have the .vsix file available, you can upload the extension yourself. .vsix files are not only available from the Visual Studio Marketplace but can be found on GitHub as well, e.g. prettier-vscode.\n\nAn extension only needs to be uploaded once and is available for you and your teammates afterwards. Please make sure you comply with the licenses of those extensions.\nAdditionally, of course, you can develop and upload your own extensions. They won‚Äôt be listed anywhere publicly except in your own .gitpod.yml file.\n\n__SPLIT_HERE__\nYour extension doesn&#39;t work as expected?\n\nCovering the full API surface of VS Code extension is a huge task and the Theia community has been working hard on that for over a year now.\n\nAs we are approaching 100% coverage of the implementation it is time to expose this feature to more users. Which is why we decided to make it available as a beta feature to the Gitpod community.\n\nSo if you want to help us hardening this exciting new feature, please try your favorite extensions and submit issues on the Theia project for anything that you think needs improving.\n\nHappy coding!","metadata":{"source":"https://gitpod.io/blog/vscode-extension-in-online-ide"}}],["328",{"pageContent":"TL;DR\n\nAfter Gitpod launched OpenVSCode Server in September, Microsoft now open-sourced the server code powering VS Code remote development and GitHub Codespaces\nWithin a few days we switched Gitpod VS Code and OpenVSCode Server Insiders builds to the upstream implementation\nToday, we release Gitpod VS Code and OpenVSCode Server with these changes\n\nWhen we launched our history of the last four years of Cloud IDEs on Oct 20, we spoke about the road ahead:\n\nAs VS Code and cloud-based, remote development continues to grow in popularity, we hope to see the server-side implementation powering GitHub Codespaces being open-sourced in the upstream repository by Microsoft.\n\nA month after we released OpenVSCode Server, we are excited to see that Microsoft open-sourced their server implementation for running VS Code in the browser‚Äîthe release happened faster than we anticipated üöÄ ! First and foremost we want to say thank you to the excellent VS Code team. The community deserves that the most popular developer tool of the planet keeps its open nature.\n\nWhile we won‚Äôt send them a cake this time üéÇ, we wanted to share our take on the release, our nightly sync jobs that enable us to run the latest VS Code in Gitpod and the future of OpenVSCode Server.\n\n__SPLIT_HERE__\nWhy OpenVSCode Server in the first place?\n\nIn September we announced OpenVSCode Server, an open-source project that runs upstream VS Code on a remote machine accessed through a modern web browser. The OpenVSCode Server project is officially backed by our partners from GitLab, VMware, Uber, SAP, Sourcegraph, RStudio, SUSE, Tabnine, Render and TypeFox.\n\nPublishing OpenVSCode Server was motivated by the fact that Microsoft hadn‚Äôt at the time published any source code for their own implementation of a server that was able to run Visual Studio Code, which Microsoft uses to power GitHub Codespaces and their remote extensions. Since many developers and organisations wanted to run VS Code as a full web application in their daily workflows with the same low-footprint technique used by Gitpod and Codespaces, we decided to share our own server implementation with everyone.\n\n__SPLIT_HERE__\nHow We Keep Up To Date With VS Code\n\nAs you may know, we provide Insiders builds for Gitpod VS Code and OpenVSCode Server. This process is possible thanks to a couple of GitHub actions we‚Äôve set up. We noticed the VS Code Server changes immediately and started working on integrating them. By now, we have been running the latest builds in production for more than a week and today we are releasing the builds for everybody.\n\nThese GitHub actions run daily to update OpenVSCode Server with the latest upstream changes, run integration and smoke tests, and make a GitHub pre-release along with publishing the updated docker image to Docker Hub under the Insiders tag.\n\nThis release process allows OpenVSCode Server to get the latest updates from the upstream VS Code code and make new stable releases on the same day as VS Code. We also use the same release process with our VS Code Insiders version that we use inside Gitpod, which enables Gitpod users to go into their gitpod settings and swap their IDE configuration for the VSCode Insiders with the latest features and fixes from VSCode.","metadata":{"source":"https://gitpod.io/blog/vscode-server"}}],["329",{"pageContent":"The Future of OpenVSCode Server\n\nUnfortunately, the changes from Microsoft don&#39;t give us a full standalone implementation for VS Code Server yet, while the server source code is now also open-sourced and you can build VS Code yourself, you cannot use the extensions marketplace as it is restricted to only be used by Microsoft products.\n\nSo OpenVSCode Server adds some much-needed, yet minimal changes on top of VS Code to:\n\nenable the marketplace using Open VSX\nenable HTTPS and WebSocket Secure (wss) by default\n\nTry the new 1.62 OpenVSCode Server or the Insiders version and don‚Äôt forget to leave feedback and file any GitHub issues if you need!\n\nYou can also quickly explore the latest version of VS Code from within Gitpod, all you have to do is prefix a GitHub URL with gitpod.io/#https://github.com/example-org/your-repo (or install the browser extension) to get started.\n\nAnd why not, because Gitpod is free for up to 50 hours a month.","metadata":{"source":"https://gitpod.io/blog/vscode-server"}}],["330",{"pageContent":"Today, we continue to expand support for JetBrains IDEs with Gitpod as part of our official partnership and general üíï love and admiration for Jetbrains. At Gitpod we have a value Integrate, don&#39;t dictate which means we believe in the power of your choice. WebStorm and RubyMine users rejoice! You may now choose to use WebStorm and RubyMine with Gitpod üéâ.\n\nHere&#39;s a screencast to see exactly how working with JetBrains IDE and Gitpod looks.\n\nyoutube: 8djaRYT2FAY\n\n__SPLIT_HERE__\nGetting Started\n\nHere&#39;s how you can get started with a JetBrains IDE in Gitpod today:\n\nInstall JetBrains Gateway - With the JetBrains Gateway and Gitpod plugin you can create and manage your latest 20 Gitpod workspaces.\nInstall the Gitpod plugin - Open JetBrains Gateway and you&#39;ll see the Gitpod logo on the main page. Click &quot;install&quot; to install the Gitpod plugin for JetBrains Gateway.\nUpdate your Gitpod preferences - Select RubyMine or WebStorm on the Gitpod preferences page which will set RubyMine or WebStorm as your default IDE for future workspace starts.\nStart (or restart) your workspace - Either start a workspace directly from within the JetBrains Gateway via the Gitpod plugin OR open a new workspace directly in Gitpod where on workspace start you will be prompted to open RubyMine or WebStorm for that workspace.\n\n__SPLIT_HERE__\nLearn more about WebStorm and RubyMine in Gitpod\n\nRubyMine\nWebStorm\nJetBrains Gateway","metadata":{"source":"https://gitpod.io/blog/webstorm-rubymine-now-in-beta"}}],["331",{"pageContent":"__SPLIT_HERE__\nCommunity is at the heart of everything we do at Gitpod üß°\n\nOur small community team is made up of me, Pauline and AXON - you may have seen us floating around answering questions and hanging out in our community Discord server.\n\nOur Gitpod community has grown from 500 to 5000 in just under a year! In this blog post, we‚Äôll share some of our behind-the-scenes learnings of scaling the community and how we‚Äôre maintaining a positive and collaborative culture that reflects our core values.\n\n__SPLIT_HERE__\nHumble beginnings ü§≤\n\nBack in July 2021, our community was scattered across different platforms with no central place where Gitpod users and champions could exist. There was no consistent place to not only ask questions about our product but to also connect with other professional developers who also saw the future of remote, developer environments. üí≠\n\nOther challenges we faced in the early days was that we just didn‚Äôt have a dedicated community team that ensured community queries were answered in a timely manner and that community felt seen, heard and cared for. üß° Before this team existed, our engineers jumped in when they could but it was unsustainable and came at the expense of preventing them from getting into flow state.\n\nAs the first community hire, it was my goal to address these challenges! In my first six months, I streamlined the community process both externally and internally.\n\nFrom an external standpoint, we created the first official ‚Äúhome‚Äù for community on Discord. Our community could still interact with us in various ways in addition to this new home. However, instead of just opening a tab for every platform, we introduced an internal tool (Front) that improved the visibility of the chatter.\n\nAdditionally, we created the internal ‚ÄúCommunity Captains‚Äù process üßë‚Äç‚úàÔ∏è that gave Gitpod engineers an opportunity to stay connected with our community in rotations. This is important because our community is the beating heart of Gitpod and we want to make sure everyone in the company continues to have a touchpoint with them. üíØ\n\nBeing trusted with the community from day one was nerve-wracking, especially as this was my first time in this type of community/developer relations role. Previously, I‚Äôd built several communities as a side ‚Äúhobby‚Äù, but never saw it as a career path. üí° I‚Äôm glad I‚Äôve had the opportunity to grow into this role at Gitpod and make it my own - an opportunity that I find is quite rare psst‚Ä¶ we‚Äôre hiring!\n\nFurthering my professional growth in parallel to our flourishing community, we hired AXON in January 2022 which was another pivotal moment for us! Expanding the community team upped our game to another level especially as our community also grew in parallel. üî•","metadata":{"source":"https://gitpod.io/blog/what-we-learned-growing-a-community-from-500-5000"}}],["332",{"pageContent":"Our top three learnings\n\nBuilding out and scaling the Gitpod community is an ongoing learning journey, but it‚Äôs a challenge that gets me up in the morning! ‚òïÔ∏è These are our top three learnings from the past year of building the community.\n\n1. Building community takes intentionality üíú\n\nWithout actively managing your community, it can be easy to let it run wild for better or for worse. üèÉüèª‚Äç‚ôÄÔ∏è Most of the time though no moderation causes more issues! It is also much more difficult to go back and fix a bad community culture than it is building a positive one.\n\nTo join our Gitpod community, users must agree to our Code of Conduct. In addition, we have quite the moderator team that is made up of Gitpodders and Gitpod Heroes alike who are all actively shaping the community culture that reflects our core values.\n\n2. Being part of a community should be an experience ‚ú®\n\nThere is a danger of communities being seen as ‚Äú_yet another Discord server or Slack workspace_‚Äù. If our platform were to disappear one day, I‚Äôm confident our community would still be active simply because a community is a group of connected people, not a platform. üíú\n\nWith that said, we have been intentional about organising our community platform with our number one goal of being valuable to everyone that takes part in it.\n\nA few months ago, we started our ‚Äú_Community Experience 2.0_‚Äù project which aimed to completely overhaul our Discord server. The aim was to reduce mental overload, improve overall structure that encouraged organic conversations and help our folks be successful using Gitpod as quickly as possible.\n\nJust to highlight some of these changes:\n\nWe introduced Optimus, a bot that helps level up this community experience. To help reduce overwhelm, our new onboarding flow allows new users to pick and choose what channels they‚Äôd like to have access to. For example, some users are solely in our community to learn from others using the self-hosted version of Gitpod in which they have access only to the relevant channels.\n\nOnboarding experience on Discord\n\nIn our busiest channel (#questions), we‚Äôve enforced the use of Discord Threads to keep context in those threads and therefore reducing mental overload.\nWithin those threads, we have a suggestion system that fetches related GitHub issues, documentation, and previous Discord thread conversations for whenever someone asks a question in our community.\n\nDiscord bot suggestions\n\nIt‚Äôs important to us that the server is safe from any harm caused by bad actors. Optimus protects our community by filtering out bot accounts during the onboarding process! We have WickBot that prevents common bot spam too.\n\n3. Recognise your superfans - they are core to the community üéØ\n\nEven in the early days, Gitpod had a group of core members who loved the product, who wanted us to succeed and recognised the bright future in remote, developer environments.\n\nLast October, we launched the Community Heroes program ü¶∏ This aimed to recognise the wonderful contributions of our superfans and gave them an opportunity to help us shape Gitpod even more by keeping them closer. Together with our Community Heroes, we want to push our mission of empowering developers to make software engineering collaborative and joyful again.\n\nJulien Lengrand on Twitter\n\nOur Heroes play a huge role in the success of Gitpod by shaping our community culture, supporting our growing user base and being the advocates for the future of ephemeral dev environments worldwide.\n\nBottom line is I truly believe that we wouldn&#39;t be where we are without their daily Gitpod love! üß°\n\nYou can find a list of our Heroes on Twitter here.\n\nyoutube: yrMNOWZkc1A","metadata":{"source":"https://gitpod.io/blog/what-we-learned-growing-a-community-from-500-5000"}}],["333",{"pageContent":"What‚Äôs next ü¶©\n\nWe want to continue to empower our community to lead initiatives. Our plans are ambitious!\n\nThink: events, conferences and local communities that creates a large interconnected network of Gitpod members across the world. üåé Additionally, we want to improve our contribution processes across the board allowing our community to continue to build Gitpod with us.\n\nThere is no stopping this community rocket ship! üöÄ We‚Äôre excited to continue growing and building the community with our community.\n\nWant to join in? Come and hang out with us over on our Discord server.","metadata":{"source":"https://gitpod.io/blog/what-we-learned-growing-a-community-from-500-5000"}}],["334",{"pageContent":"Learn how to streamline your code review experience.\n\nCode reviews are one of the best things you can do to keep your codebase clean. They improve code quality, reduce code ownership and let you learn a lot from your teammates.\n\nMuch has been said about the advantages of code reviews for individuals, teams and codebases. Research has found that projects that do proper code reviews identify ‚Äú‚Ä¶ more than half of the defects in code reviews‚Äù.\n\nAssuming you understood the importance of it, I want to discuss the tools, the process and how you can improve your code review experience using Gitpod and new app for GitHub that lets you do deep code reviews.\n\n__SPLIT_HERE__\nContext Switches &amp; Shallow Reviews\n\nCode reviews are super valuable but they add friction to our daily tasks. Without reviews you would probably write code all day, maybe have a discussion here and there. But you would would mostly working on a single task or at least one after the other.\n\nTherefore, changing our local dev environment between different branches is something we want to avoid. Especially if setup times (rebuilding, etc.) are long. So instead of doing our colleague a favor and providing a proper code review, we too often take the shortcut and just glimpse over the code online in a code review tool. Be it GitHub, GitLab, Bitbucket, or Gerrit they all just present syntax coloured diffs. These tools allow us to glimpse over the changes, but we cannot run the code, navigate around (and use the smart editing features for that) or even add code (e.g. tests).\n\nAs a result, many bugs are not spotted and potentially wrong assumptions are not identified during such shallow code reviews.\n\n__SPLIT_HERE__\nDeep Code Reviews\n\nInstead of glimpsing over the changes on GitHub, we should check out the branch in a real developer environment. So we can read, run, and test them.\n\nYes, it messes up our local development context and might even take a bit of time to set up. And, yes, we have to go back to the online code review tool to add our comments. It‚Äôs all a bit cumbersome so ‚Ä¶ maybe for this little change I could just go with a quick LGTM?\n\nI feel your pain, but you should not take that shortcut. It will fire back eventually. Instead, let‚Äôs improve our workflows, streamline the context switches and get rid of unnecessary overhead.\n\n__SPLIT_HERE__\nEnter Gitpod\n\nGitpod gives you a full developer environment with a single click for any pull request on GitHub. You don‚Äôt have to manually setup or even change anything on your local developer environment. Just click a button and you have the best of both worlds:\n\na full developer environment (similar to VS Code)\n\n\na great code review experience (similar to GitHub)\n\n__SPLIT_HERE__\nCode Review in Gitpod\n\nWhen you start a Gitpod workspace from a pull request, it will automatically open with the list of changes on the left. You can now use either the cursor keys or the mouse to go through the changes one by one.\n\nGitpod Diff Editor\n\nThe opened diff editors are full-fledged code editors, so you can navigate to inspect references and easily check out alternative code. You can even comment right within those editors.\n\nDiff Editor an example review comment\n\nThe build starts automatically, so you can already spot any issues coming up from there, while you are reviewing.\n\nLaunching the tests or even running and trying the application is something that is part of a good code review as well.\n\nThe last thing you do is to submit your review and close the browser tab.\n\nGitpod submit review tab","metadata":{"source":"https://gitpod.io/blog/when-code-reviews-lgtm"}}],["335",{"pageContent":"TL;DR\n\nWhile we cannot get rid of context switches completely when doing code reviews, we can streamline and automate those switches so that they are less time consuming and distracting.\n\nGitpod integrates the review features of GitHub in an online IDE and provides an automated experience with a single click. All you need is a browser, and once you are done with the review, you just close the window and don‚Äôt need to look back.\n\nGitpod is free and you can use it now. Just go to any pull request on GitHub and prefix the URL with. gitpod.io/#, e.g.\nhttps://gitpod.io/#https://github.com/theia-ide/theia/pull/1204","metadata":{"source":"https://gitpod.io/blog/when-code-reviews-lgtm"}}],["336",{"pageContent":"Gitpod workspaces are Kubernetes pods. Each Kubernetes pod maintains its own network namespace - similar to how a regular container would. Network namespaces (netns) provide isolation of the system resources associated with networking.\n\nContainer runtimes (e.g. Docker) or VPNs (e.g. Tailscale) both require control over these system resources associated with networking. If we wanted to provide workspaces with control over the network namespace of their pod, that would require CAP_NET_ADMIN on the node - clearly not a good idea.\n\n__SPLIT_HERE__\nEnabling rootless Docker in workspaces\n\nMore than a year ago we enabled &quot;$lib/components/workspacekit).\n\nDocker-specific network setup\n\nYou&#39;ll have noticed that a network namespace was not part of additions we make to what Kubernetes provides. Docker however, requires the control a network namespace would afford.\n\nIn a Gitpod workspace, we don&#39;t just start a Docker daemon, but instead call docker-up. This custom piece of code produces a network namespace using slirp4netns, and starts the docker daemon in there. The combination of the user namespace we provide using workspace, and this newly created network namespace, enables docker to create the networking devices and iptables entries it requires.\n\nWait, what&#39;s slirp4netns, and why do we need this?\n\nCreating a network namespace is the easy part and does not require a lot of permissions (capabilities). You can easily try that for yourself using unshare -n bash. You&#39;ll quickly find that it isolates a little too well, and that you don&#39;t have any connection to the world outside of the namespace you&#39;ve just created.\n\nIf you have enough capabilities/permissions outside of the network namespace, you can just create a veth pair that effectively tunnels traffic from within the netns to outside of the netns. However, we&#39;re creating the netns because we don&#39;t have those permissions in the first place.\n\nSlirp4netns solves this problem using TAP/TUN, by turning itself into a user-space packet forwarder. Running outside the netns (hence it has access to the network of the &quot;outside world&quot;), it creates a tun device inside the network namespace. All packets to and from this tunnel network device are forwarded through user-space now.\n\nBiggest benefit: works without elevated capabilities. Biggest drawback: forwards all traffic through user-space, which incurs a significant performance cost.\n\n__SPLIT_HERE__\nCAP_NET_ADMIN for everyone those who configure it\n\nWe&#39;ve been living with the setup described above (netns only for the Docker daemon) for more than eight months. Mainly driven by performance considerations, but also because we saw no use-case which would warrant a change.\n\nOne day, we were approached by the awesome folks from Tailscale. They were working on how to make Tailscale available in Gitpod workspaces. The underlying issue: creating a TAP/TUN device and setting up routes to make use of it, all within a regular Gitpod workspace.\n\nworkspace-wide network namespace\n\nWe had solved this problem already for one specific use-case: the Docker daemon. Within a single day, we wrapped the entire workspace in a network namespace, if the workspace had a new experimentalNetwork: true config flag set.\n\nWhy make this optional behind a flag? Because this is a considerable change of the workspace networking setup, and we are careful not to break the existing experience. Also, the slirp4netns solution comes with a performance penalty (see above).\n\nHowever, with this change, we no longer needed to special case Docker, and Tailscale works out of the box.","metadata":{"source":"https://gitpod.io/blog/workspace-networking"}}],["337",{"pageContent":"CAP_NET_ADMIN for everyone\n\nAfter observing the behaviour of this new networking setup in the wild, and with our recent move to k3s, we felt comfortable enough to make this behaviour standard. On the 9th December, we rolled out a change which enabled this network namespace addition for all workspaces. We&#39;ve also seen this change fixing other networking related issues, providing even more reasons to move ahead.\n\nToday, when you start a workspace, sudo tailscaled will just run, and your Docker daemon will share the same network setup as the rest of the processes in your workspace. You can even do the networking equivalent of rm -rf / and break your workspace by running sudo ip link set tap0 down (you&#39;ll have to stop your workspace from the dashboard, or let it time out).\n\nThere&#39;s still the performance cost of slirp4netns we have to deal with. Now that we run on more recent Linux versions, we can integrate a seccomp-addfd approach and follow what bypass4netns implements.\n\n__SPLIT_HERE__\nExciting times\n\nIt&#39;s super exciting to see how quickly these changes have come together, and the use-cases they enable. We&#39;re nowhere near the end of what we can do in this space, but are just getting started. If you want to join the fun, please head over to gitpod.io/careers and see what floats your boat.","metadata":{"source":"https://gitpod.io/blog/workspace-networking"}}],["338",{"pageContent":"TL;DR\n\nRunning workshops is easier and more productive with Gitpod.\nThere is an entire class of problems that attendees and educators continue to put up with when they shouldn‚Äôt need to because these concerns can be removed through automation.\nPeople attend workshops because they want to learn about what is being taught and what device they are using, or how the device configured should not matter.\nHosting a workshop on Gitpod is as simple as supplying a Dockerfile and then specifying the commands to execute in a Git repository hosted on either GitHub, GitLab or BitBucket.\nDataStax have integrated their cloud-native database-as-a-service product offering with Gitpod.\nPulumi run their workshops with Gitpod, and we would love to work with you to integrate your workshop.","metadata":{"source":"https://gitpod.io/blog/workshops-as-code"}}],["339",{"pageContent":"Folks in technical education, I have a hot-tip for you - Running workshops is easier and more productive with Gitpod. That‚Äôs a bold statement, and by the end of this tale, I hope you‚Äôll be nodding your head but until then, mash this button to launch the Nix Operating System in your browser:\n\nOpen in Gitpod\n\nYup, that‚Äôs right, running an operating system in your browser is now possible in 2021. In 2019, which now seems like an eternity thanks COVID19, I was invited to deliver a workshop at Compose on NixOS.\n\nCredit: Javier Candeira\nPhoto Credit: Javier Candeira\n\nNixOS is an exciting up-and-coming in the DevOps space because it provides declarative and reproducible environments supported by powerful testing primitives. One may say NixOS is ‚Äúan overnight success that is 18 years in the making‚Äù as many industry leaders are switching.","metadata":{"source":"https://gitpod.io/blog/workshops-as-code"}}],["340",{"pageContent":"Anyway, I was in complete shock when circa 50 people registered to attend the workshop. So let‚Äôs glance past the entire topic of building workshop courseware for a moment and instead focus on the logistics of running a workshop.\n\nOne of the biggest challenges of running a workshop is ensuring attendees do all the prerequisite activities before turning up. For the NixOS workshop at Compose the steps were:\n\nDownloading upwards of 4Gb of software from the internet (ie. 200gb of data).\nDownloading and installing Virtual Box\nDownloading and installing the Virtual Box Extension Pack.\nCreating a virtual machine.\n\nIt‚Äôs important to remember that the reason people attend workshops is that they want to learn about what is being taught. People are willing to do prerequisite activities and put up with waiting for that half of the class that didn‚Äôt do the prerequisites to pass around that USB stick but already from the get go your workshop is off to a bad start and precious time is slipping.","metadata":{"source":"https://gitpod.io/blog/workshops-as-code"}}],["341",{"pageContent":"Credit: SpongeBob SquarePants\nCredit: SpongeBob SquarePants\n\nSuppose you were to once again peek at the prerequisite activities of the NixOS workshop. In that case, you‚Äôll notice a line item - ‚ÄúCreate a virtual machine‚Äù. At the time, the step appeared to be a simple request, but it wasn‚Äôt. People turned up with Chromebooks and laptops running macOS, Linux and shudder windows devices enrolled under group policy with admin rights disabled.\n\nFortunately, with some support from the lovely folks from the QFPL who ran around and helped reconfigure peoples devices (where possible), the workshop was able to start and was successful.\n\nAfterwards, feedback was collected, and one item stuck out - what device attendees are using or how the device is configured should not matter . People should be able to rock up to your workshop and do it on an iPad Pro or from a forest with marginal 4G internet connectivity.\n\nCredit: Geoffrey Huntley\nCredit: Geoffrey Huntley","metadata":{"source":"https://gitpod.io/blog/workshops-as-code"}}],["342",{"pageContent":"Credit: Geoffrey Huntley\nCredit: Geoffrey Huntley\n\nNow granted, not every workshop requires people to install or configure virtual machines, but in the CNCF space, I often see people asking attendees to create a Kubernetes cluster as a prerequisite to learning. I‚Äôll be frank here - there is an entire class of problems that attendees and educators continue to put up with when they shouldn‚Äôt need to because these concerns can be removed through automation.\n\nBy taking lessons learned from the infrastructure-as-code movement and converting workshops to Docker images, workshops become repeatable and reproducible. By utilising products such as Gitpod to consume, build and execute your Dockerfile then attendees no longer need to download or configure your software. All they need is a browser.\n\nA Gitpod workspace gives you the same capabilities (yes, even root, Docker &amp; qemu) as a Linux machine that is already pre-built, works on any device from anywhere and that launches in seconds.","metadata":{"source":"https://gitpod.io/blog/workshops-as-code"}}],["343",{"pageContent":"A Gitpod workspace gives you the same capabilities (yes, even root, Docker &amp; qemu) as a Linux machine that is already pre-built, works on any device from anywhere and that launches in seconds.\n\nDocker Compose Configuration\n\nHosting a workshop on Gitpod is as simple as supplying a Dockerfile and then specifying the commands to execute in a Git repository that is hosted on either GitHub, GitLab or BitBucket.\n\nLaunching a workshop on Gitpod is as easy as prefixing any Git URL with gitpod.io/#. Thus if the workshop was hosted at https://github.com/gitpod-io/template-nixos then https://gitpod.io/#https://github.com/gitpod-io/template-nixos is the link that would be shared with attendees.\n\nAlternatively, you could embed this button into the README of your workshop materials:\n\nOpen in Gitpod\n\nHowever, if you want to take it to 11, maybe you‚Äôll consider embedding Gitpod?","metadata":{"source":"https://gitpod.io/blog/workshops-as-code"}}],["344",{"pageContent":"Alternatively, you could embed this button into the README of your workshop materials:\n\nOpen in Gitpod\n\nHowever, if you want to take it to 11, maybe you‚Äôll consider embedding Gitpod?\n\nMy mind is blown (ü§Ø). C√©drick Lunven just showed me Gitpod with a full demo configured and ready to run. 2021 is a great time to be running workshops online!\n\nJonathan Ellis (co-founder and CTO of DataStax)\n\nFor the last couple of months, Gitpod has been working with DataStax who has integrated their cloud-native database-as-a-service product offering with Gitpod.\n\nDatastax Astra DB is a cloud-native database-as-a-service built on Apache Cassandra that is designed to simplify cloud-native application development\n\nLet‚Äôs peek under the hood how the integration works from top to bottom:","metadata":{"source":"https://gitpod.io/blog/workshops-as-code"}}],["345",{"pageContent":"Let‚Äôs peek under the hood how the integration works from top to bottom:\n\nDataStax have created self-paced workshops which are hosted on GitHub.\nThese workshops are listed within Astra DB (which is DataStax‚Äôs DBaaS offering)\nOn each workshop, there is a button to launch the workshop on Gitpod.\nDataStax prompts the user to select which managed database the workshop should use, and non-sensitive information is passed through to Gitpod as environment variables via the URL:\n\nhttps://gitpod.io/#ASTRA_DB_ID=6677d1aa-2a69-4739-ba5d-26fdef15d8ae,ASTRA_DB_KEYSPACE=Workshop,ASTRA_DB_REGION=us-east1,ASTRA_DB_USERNAME=/https://github.com/DataStax-Examples/todo-astra-jamstack-netlify\n\nChris Coyier recently sat down and pair-programmed with David Jones-Gilardi of DataStax and Chris‚Äôs mind was also blown. In the video below, David doesn‚Äôt even use any local software other than a web browser. All code editing was done in Gitpod.\n\nyoutube: sPnBN-RhzQQ","metadata":{"source":"https://gitpod.io/blog/workshops-as-code"}}],["346",{"pageContent":"youtube: sPnBN-RhzQQ\n\nThe Infrastructure as Software company Pulumi has also been using Gitpod as an option for attendees taking part in their instructor-led workshops because Gitpod enables them to spend less time configuring prerequisites and enables people to focus on what matters: the educational content.\n\nStuff like gitpod makes doing workshops so much easier I can‚Äôt believe how we used to do this stuff before - Matty Stratton\nhttps://twitter.com/mattstratton/status/1426213495826096131?s=20\n\nüéâ Thanks for reading! Hopefully, you‚Äôre convinced and can see the benefits of defining your workshops as code by now. As recently announced, Gitpod is available to everyone, and our free tier is open to every developer with a GitLab, GitHub, and/or Bitbucket account.","metadata":{"source":"https://gitpod.io/blog/workshops-as-code"}}],["347",{"pageContent":"Whenever you want to share a reproducible example on StackOverflow or an issue report, providing real code that can be quickly tried, executed and explored is the best you can do. Online code playgrounds, such as CodePen or JSFiddle, are an excellent way to do that, as they are very accessible for both the creator and the readers. Unfortunately, they are not available for every programming platform, language and often don‚Äôt work for larger projects or examples.\n\nIn this post I‚Äôd like to introduce you to a new feature in Gitpod, that lets you create reproducible examples for any programming environment and any size of project.\n\n__SPLIT_HERE__\nNew in Gitpod: Snapshots\n\nNo matter what state your Gitpod workspace is in, taking a Snapshot captures everything and provides you a link to share anywhere: on issues, forums (StackOverflow), emails and blogs. Anybody who clicks on a snapshot link instantly gets an exact copy of that workspace, including any uncommitted file changes and the UI layout.\n\nLet‚Äôs go through an example.\n\nSpring Boot Example\n\nI went over to spring-boot and picked the first issue in the list:\n\n\nBean overriding in spring boot 2.1 ¬∑ Issue #15326 ¬∑ spring-projects/spring-boot\n\nI have an issue with bean overriding with spring boot 2.1.0 I have a main application class that we use in‚Ä¶github.com\n\n\nThe issue has a detailed description on how to reproduce the problem. It even has a link to a GitHub repository containing the code! So the author did a lot to make it easy for the maintainers to reproduce the issue and figure out what‚Äôs wrong.\n\nHowever, instead of laying out the steps in prose, an automated solution would be much better. A snapshot would have reduced this to a single click for the maintainers, and the author wouldn‚Äôt have to write a lengthy explanation.\n\nTake a Snapshot\n\nBefore we are taking the snapshot, we want to make sure everything is in the state we want it to be. So the maintainers get pointed to the culprit immediately. For this example I made sure\n\nthe build ran through,\n\n\nthe right editors are opened\n(I choose to open the two files mentioned in the issue in split mode),\n\n\nthe sample application is started automatically\n\nTaking care of the first two items is easy. For the third, you need to add a .gitpod.yml to the root of the project containing the tasks you want to start.\n\nIn the case of this project I added a task to start the failing Java process:\n\n```yaml\ntasks:\n    - command: >\n    mvn -q exec:exec\n        -Dexec.executable=java \\\n        -Dexec.args=\"-cp %classpath com.example.beanoverriding.EmbeddedApplication\" \\\n        -Dexec.classpathScope=\"test\"\n```\n\nBtw. to figure out how to start that damn thing using Maven, I had to ask the community on StackOverflow. Of course, by providing a Gitpod Snapshot :-)\nRun main from test scope in Maven: ‚ÄúThe parameters ‚ÄòmainClass‚Äô for goal‚Ä¶ &gt; Thanks for contributing an answer to Stack Overflow! Some of your past answers have not been well-received, and you‚Äôre‚Ä¶stackoverflow.com\n\nWith the **.gitpod.yml **configured and the editors and views laid out as needed, we are ready to take a snapshot. Simply click on the avatar on the top right:\n\nGitpod menu share workspace snapshot\n\nPick ‚ÄúShare Workspace Snapshot‚Äù and copy and share the link or one of the snippets in the opened dialog:\n\nGitpod workspace snapshot prompt\n\nHere‚Äôs the snapshot link for you to try:\nhttps://gitpod.io/#snapshot/f7f5954a-250b-4113-909c-aae88b64321c","metadata":{"source":"https://gitpod.io/blog/workspace-snapshots"}}],["348",{"pageContent":"Summary\n\nGitpod Snapshots are a very convenient way to create and consume large and small examples for any programming language and platform. Make sure to check out the documentation, which goes into more detail on the options available.\n\nWe think snapshots are not only great for reproducing issues or showing solutions and examples, but very useful in other situations. Preparing workshops and tutorials should be super convenient with snapshots, as it will free your audience from any tedious setup procedures. We are looking forward to learning about all the creative ways you will put this feature to use. Please let us know and have fun!","metadata":{"source":"https://gitpod.io/blog/workspace-snapshots"}}],["349",{"pageContent":"&lt;OpenGraph\ndata={{\n    description:\n      &quot;From in-house remote development to unlocking a collaboration culture. Saving each engineer 5 to 10 hours a month. Freeing the DevOps team to focus on production as Factorial grows from 45 developers to 120.&quot;,\n    title: &quot;Factorial case study: From in-house remote development to unlocking a collaboration culture&quot;,\n    keywords: &quot;DevX, velocity, growth, onboarding, factorial&quot;,\n  }}\n/&gt;\n\n&lt;CustomerHero\ntitle=&quot;From in-house to Gitpod: unlocking a collaboration culture&quot;\ntext=&quot;Factorial embraced a collaboration culture by switching from their in-house dev environments to Gitpod. It saved each engineer 5 to 10 hours a month and freed the DevOps team to focus on production as they scaled from 45 developers to 120.&quot;\ncard={{\n        image: &quot;/images/customers/factorial/teaser.png&quot;,\n        details:{\n            industry: &quot;Human Resources&quot;,\n            plan: &quot;Organization, SaaS&quot;,\n            people: {\n                title: &quot;Engineers&quot;,\n                text: &quot;120+&quot;\n            },\n            website: {\n                href: &quot;https://factorialhr.com/&quot;,\n                text: &quot;Factorial&quot;,\n            }\n        }\n    }}\n/&gt;\n\n&lt;CompanyBenefits\nbenefits={[\n{\ntitle: &quot;50%&quot;,\ntext: &quot;DevOps capacity saved&quot;,\n},\n{\ntitle: &quot;5-10hrs&quot;,\ntext: &quot;saved per engineer / month&quot;,\n},\n{\ntitle: &quot;65+&quot;,\ntext: &quot;new developers hired&quot;,\n}]}\n/&gt;\n\nFactorial is a software company building an all-in-one human resources management application that handles document management, payroll, time tracking, and more.\n\nDirector of Developer Experience Josep Jaume has spent the last 8 months improving the way developers at Factorial work. Since then, the company has grown from 45 developers to 120, and Gitpod has become a core part of their developer experience.\n\nJosep tells us the story of Factorial&#39;s growth and what led the company to embrace Gitpod for all their development.","metadata":{"source":"https://gitpod.io/customers/factorial"}}],["350",{"pageContent":"Achieving parity between development and production\n\nBuilding their application as a large monolith with Ruby on Rails and React helps Factorial rapidly iterate over major changes. As they serve companies in a wide variety of sectors, they need to be agile enough to change the shape of the application quickly. That level of flexibility in the macro-scale comes at the expense of micro-scale changes.\n\nDue to the nature of a monolith, even a small change to the application can affect the totality of the application. Engineers need to be confident that their code reflects reality without having to wait for a deployment cycle to complete, so Factorial uses queues and job workers to fully replicate the production environment during development time.\n\nThey saw the need for cloud developer environments early on. Simulating production during development required 10-12GB of RAM and was difficult to run on local machines. It was clear that remote development was the only realistic approach to developing software at this scale.\n\nAs Factorial moved away from local development, each developer workstation turned into another cloud application to maintain.\n\nTheir DevOps team was 5 people, and maintaining these dev environments became a significant part of the job. A large amount of time went into setting up new environments, onboarding new engineers, and reallocating keys; creating new machines, and then restarting them when things broke.\n\nIt took time to provision each new machine but there were greater issues at scale. &quot;Applying changes via Terraform is easy at 10 machines, but fails in entirely different ways with 100 machines.&quot; Josep says. &quot;And then you need to ramp up the DevOps team.&quot;\n\nLast February, the collaboration between Factorial and Gitpod began, and before long the DevOps team was freed to focus on the production environment where they can provide the most value to the business.\n\n&quot;The DevOps team is the happiest in the whole company because they don&#39;t have to deal with the old dev containers anymore.&quot;\n\n__SPLIT_HERE__\nRethinking the development infrastructure\n\nThe learning curve with Gitpod is significantly lower than their previous dev environments, which required deep knowledge of Terraform and Docker in order to restart containers or spin up tasks. Each repository has a configuration file and an image, and then developers can spin up workspaces at the click of a button.\n\nInstead of having to maintain persistent developer environments for each engineer, they became something that was just &quot;there&quot; the moment a developer needed one. They could simply connect to it, like a thin client, and do their work.\n\nJosep explained how several of their developers had been running the IDE locally and rsyncing against the server. It worked for files, but a lot of the common IDE tooling plugins like ESLint and Prettier don&#39;t work that way.\n\n&quot;Individual devs were frustrated at the inability to use the proper tooling.&quot;\n\nInstead of getting immediate feedback in the IDE, they had to manually run scripts, which resulted in many issues only being noticed when it was time to deploy.\n\nOther issues relating to the local environment differing from the production environment often meant that the developer would push to CI and have to wait until it completes before finding out what the next broken thing was.\n\nWith Gitpod, the IDE is backed by a remote development server that lives inside the workspace container, so there are significantly fewer layers between the developer and their code. Linters and formatters &quot;just work&quot; and engineers can fix issues as they code, instead of pushing and waiting to see what fails and so they can fix it later.","metadata":{"source":"https://gitpod.io/customers/factorial"}}],["351",{"pageContent":"Adopting Gitpod across the organization team by team\n\nFactorial&#39;s first days with Gitpod were met with some internal hesitation, but Josep was well prepared to avoid it. &quot;You can&#39;t force people to use particular technology. At the slightest moment of uncertainty, people will say &quot;this is too new&quot; and go back to their old habits,&quot; he explains. Developers need visibility into the system, so when something goes wrong they can see the real root cause and know how to fix it.\n\nJosep went through the company team-by-team. The product and engineering managers came first, because they worked in different ways than the developers.\n\nUnlike the engineers, who tend to work on fewer tasks for longer times, managers and team leads have to switch contexts frequently. As they used Gitpod for more and more of these tasks, they could feel an immediate improvement in collaboration. &quot;They can jump from feature to feature, spin up new environments, test things, comment on them, improve on them, and without having to worry about rebasing and resetting the database,&quot; he describes. &quot;Context switching is way easier now. People have noticed that, and they&#39;re using it.&quot;\n\nThe engineers started seeing similar benefits.\n\n&quot;They now have a way to share URLs and work on a feature with that workspace open and have someone from the product team check it out while working on another workspace.&quot;\n\nFactorial&#39;s previous code review system involved 12 available staging environments, which developers needed to reserve and provision with their code in order for the QA team to review it.\n\nWith so few available, and so many developers who needed them, they often had difficulties finding one to use. And when a developer actually managed to reserve one, it was rarely in a ready-to-go state. The burden of these staging environments fell on the DevOps team to maintain.\n\nRather than mandating that developers do their work with Gitpod, Josep focused on learning more about the problems they were facing, and highlighting how Gitpod solves them.\n\nThey shared a lot about their development process and had frequent pair sessions. Every time they found a pain point, they fixed it, and unlike the old dev environments that were unique to each developer, these fixes improved the developer experience for everyone. Changes to formatting or lint rules became part of the code that every new workspace would build from.\n\nGitpod also transformed the way Factorial onboarded new hires. From November to July, Factorial grew from 45 developers to 120, and they all needed to be trained on Factorial&#39;s development process. With no experience using the old system, Gitpod was a much easier entry point. &quot;You can either spend 3 days of your life setting them up, teaching them to use tmux, or you can just give them a button and say &#39;click here&#39;.&quot;","metadata":{"source":"https://gitpod.io/customers/factorial"}}],["352",{"pageContent":"Discovering a new collaborative way to work\n\nCollaboration is an indispensable part of Factorial&#39;s culture, but it was hard work. Changing tracks to work with someone else meant pushing work to branches for both front-end and back-end repositories, stashing changes, reinstalling dependencies and possibly even re-seeding the database.\n\nGitpod enabled developers to work in parallel, with multiple workspaces that were easily shareable and readily accessible.\n\n&quot;I&#39;d estimate each engineer saves 5 to 10 hours a month on dev environment issues that just don&#39;t exist with Gitpod.&quot;\n\nJosep adds that junior developers usually have the hardest time with such issues.\n\nOnce a developer hits the &quot;I can do that?&quot; moment, they start seeing the work of software development in a different way. &quot;There was a tipping point where they just started talking to each other.&quot;\n\nEventually the messages started coming in.\n\nThe tide had turned. 4 months after Factorial began transitioning to Gitpod, the engineers embraced the new way of working and committed to it‚Äîfrom varying degrees of skepticism and engagement to passionate advocates for a modern developer experience.\n\nOne evening in May, Josep was playing a show with his band, where a group from the Factorial team came to see him. They stood in the audience and raised Gitpod signs high above the crowd as he played his guitar on stage.\n\nA gitpod sign in the crowd with Josep playing guitar in the background\n\nGitpod is now the standard way to develop software at Factorial. Not mandated by company policy, but the result of developers who are empowered to develop in any way they want, and who chose Gitpod anyway. We are extremely appreciative of the Factorial team, and for Josep Jaume&#39;s time to do this interview with us.","metadata":{"source":"https://gitpod.io/customers/factorial"}}],["353",{"pageContent":"&lt;OpenGraph\ndata={{\n    description:\n      &quot;Quizlet started using Gitpod due to CPU compatibility issues. Six months in, Quizlet improved internal developer satisfaction by 45 percentage points reporting reduced incidents with broken development environments and improved collaboration.&quot;,\n    title: &quot;Quizlet increased developer satisfaction by 45 percentage points using Gitpod&quot;,\n    keywords: &quot;CDE, cloud dev environment, DevX, velocity, growth, education, quizlet&quot;,\n  }}\n/&gt;\n\n&lt;CustomerHero\ntitle=&quot;Quizlet increased developer satisfaction by 45 percentage points using Gitpod&quot;\ntext=&quot;Quizlet started using Gitpod due to CPU compatibility issues. Six months in, Quizlet improved internal developer satisfaction by 45 percentage points reporting reduced incidents with broken development environments and improved collaboration.&quot;\ncard={{\n        image: &quot;/images/customers/quizlet/teaser.png&quot;,\n        details:{\n            industry: &quot;Education&quot;,\n            plan: &quot;Enterprise&quot;,\n            people: {\n                title: &quot;Engineers&quot;,\n                text: &quot;85&quot;\n            },\n            website: {\n                href: &quot;https://quizlet.com/&quot;,\n                text: &quot;Quizlet&quot;,\n            }\n        }\n    }}\n/&gt;\n\n&lt;CompanyBenefits\nbenefits={[\n{\ntitle: &quot;45pt&quot;,\ntext: &quot;increase in internal development satisfaction&quot;,\n},\n{\ntitle: &quot;60%&quot;,\ntext: &quot;reduction in incidents with dev environments&quot;,\n},\n{\ntitle: &quot;&lt;10 min&quot;,\ntext: &quot;onboarding time for new engineers&quot;,\n}]}\n/&gt;\n\nIn less than two quarters, the platform engineering team at Quizlet achieved a drastic improvement in developer productivity and developer satisfaction across the company by introducing cloud development environments (CDEs).\n\nQuizlet is an online learning tool that makes big subjects easier to digest with flashcards and practice tests. Its users depend on it as a way to improve their test scores and so being a reliable, scalable solution is extremely important to the Quizlet development team. Quizlet was founded in 2005 in San Francisco and serves users in more than 130 countries across the globe.\n\nNew engineers at Quizlet had struggled with compatibility issues after the ARM-based M1 MacBook was introduced. At the time, it took days to onboard new developers and hours to troubleshoot development environments. After a POC with Gitpod, the platform engineering team around Senior Staff Engineer Roger Goldfinger and Staff Platform Engineer Cooper Benson rolled out Gitpod CDEs to the entire engineering team of 85 in summer of 2022:\n\nTheir key objectives:\n\nReduce onboarding time to make new hires productive, faster\nReduce time to troubleshoot broken development environments\nIncrease security of development environments\n\nGitpod‚Äôs cloud development environments (CDEs) are high-powered, automated development environments in the cloud. With a single click, developers can spin up a perfectly configured workspace in a container in the cloud - independent of the device, operating system, or IDE they use.\n\n__SPLIT_HERE__\nReducing onboarding time from days to minutes\n\nQuizlet solved their onboarding problems right away. In Gitpod, configuration of development environments is handled on a project level, removing complexity of managing configuration and varying installations of local machines. A one-line config change by a platform engineer is instantly available to every team member who opens a new workspace in Gitpod.\n\n&quot;Developers are experiencing far less productivity issues onboarding. Now it takes an hour at most, with training, and developers are coding.&quot; - Cooper Benson, Staff Platform Engineer at Quizlet","metadata":{"source":"https://gitpod.io/customers/quizlet"}}],["354",{"pageContent":"Higher security with ephemeral CDEs\n\nQuizlet saw the benefit of doing cloud-based development on ephemeral containers over virtual machines.\n\n&quot;Because Gitpod provides ephemeral environments and allows software to run on each running workspace, we‚Äôre able to reduce exfiltration risks as well as outside actors from accessing our development environments.&quot; - Roger Goldfinger, Senior Staff Software Engineer at Quizlet\n\nGitpod keeps source code off the local machine and is ephemeral and isolated from other work which reduces the potential impact of software supply chain attacks.\n\n__SPLIT_HERE__\nFewer broken developer environments\n\nBeyond solving their onboarding problem, the team at Quizlet observed reduced developer toil, increased team collaboration across different roles and massively improved developer satisfaction.\n\nGitpod eliminates configuration drift and ensures every developer is always working on the latest configuration. Because Gitpod‚Äôs workspaces are short-lived, it is super easy to restart or create a new workspace. Before Gitpod, 90% of developers had a broken environment at least 1 and up to 4 days a month with 100% of the team reporting they experienced issues or delays working with their codebase. Since the introduction of Gitpod, the latter number already decreased by 60 percentage points.\n\n&quot;Trying to SSH into a VM to diagnose one of a million running processes is infinitely worse than just creating a workspace in Gitpod.&quot; - Cooper Benson, Staff Platform Engineer at Quizlet\n\nWith Gitpod, Quizlet has been able to take debugging from what was once a two hour job, to less than thirty seconds with the fix of a new workspace, with now 40% of developers reporting they experience no issues or delays with coding.\n\n__SPLIT_HERE__\nEnhanced collaboration with designers and product managers\n\n&quot;Sharing a change that spanned the front end and back end was really difficult before. Now they can just share a workspace URL with their product manager.&quot; - Roger Goldfinger, Senior Staff Software Engineer at Quizlet\n\nQuizlet developers have been able to spin up development environments on demand, share port URLs to enable faster collaboration and debugging and get new members of their teams onboarded quickly.\n\nNon-engineering team members benefit from the introduction of CDEs as well. At Quizlet, Gitpod is used by designers to review front end changes and product managers to easily jump from workspace to workspace.\n\n__SPLIT_HERE__\nThe bottom line: massively improved developer satisfaction\n\nGitpod offers a compelling developer experience, and reduces our developer downtime to nearly zero. Running in the cloud enabled new ways of working together that weren‚Äôt possible before. We were able to modernize our development environment and increase internal developer satisfaction by 45%‚Äù - Roger Goldfinger, Senior Staff Software Engineer at Quizlet\n\nThe Quizlet team initially deployed Gitpod on their largest repo. Engineers at Quizlet can choose whether to use Gitpod or their local development environment.\n\nSix months in, over 75% of their developers are using Gitpod. The team is now deploying Gitpod across additional repositories to make it available to even more engineers at Quizlet.\n\n&quot;We&#39;ve solved dev. Now we&#39;re focused on delivering value to users.&quot; - Roger Goldfinger, Senior Staff Software Engineer at Quizlet","metadata":{"source":"https://gitpod.io/customers/quizlet"}}],["355",{"pageContent":"&lt;OpenGraph\ndata={{\n    description:\n      &quot;RedwoodJS was founded by Tom Preston-Werner, the Founder and former CEO of GitHub. Gitpod removed the friction of contributing to RedwoodJS, growing the community.&quot;,\n    title: &quot;RedwoodJS case study: Building a community by removing friction&quot;,\n    keywords: &quot;open-source, community, redwoodJS, OSS&quot;,\n  }}\n/&gt;\n\n&lt;CustomerHero\ntitle=&quot;Increasing Redwood&#39;s development velocity by removing the friction to&nbsp;contribute&quot;\ntext=&quot;RedwoodJS is the latest open source project of Tom Preston-Werner, the Founder and former CEO of GitHub. Gitpod removed the friction of building on and contributing to Redwood, helping them to build an engaging community.&quot;\ntextMaxWClass=&quot;max-w-4xl&quot;\nlogo={{\n        src: &quot;/images/customers/redwoodjs/logo.png&quot;,\n        alt: &quot;customer.io&quot;\n    }}\ncard={{\n        image: &quot;/images/customers/redwoodjs/teaser.png&quot;,\n        details:{\n            industry: &quot;Open Source Software&quot;,\n            plan: &quot;Professional Open Source, SaaS&quot;,\n            people: {\n                title: &quot;Contributors&quot;,\n                text: &quot;190+&quot;\n            },\n            website: {\n                href: &quot;https://redwoodjs.com/&quot;,\n                text: &quot;redwoodjs.com&quot;,\n            }\n        }\n    }}\n/&gt;\n\n&lt;CompanyBenefits\nbenefits={[\n{\ntitle: &quot;275+&quot;,\ntext: &quot;Contributors to RedwoodJS&quot;,\n},\n{\ntitle: &quot;+11k&quot;,\ntext: &quot;Stars on GitHub&quot;,\n},\n{\ntitle: &quot;1 click&quot;,\ntext: &quot;To spin up a fully functional test project&quot;,\n}]}\n/&gt;\n\nSimilar to developer experience, Open Source is part of Gitpod‚Äôs DNA. Not only is Gitpod an open source company, but our product is positioned to remove one of the biggest hurdles before developers can contribute to open source: setting up the developer environment.\n\n__SPLIT_HERE__\nA match made in OSS heaven\n\nRedwood is the latest open source project initiated by Tom Preston-Werner, co-founder and former CEO of GitHub. RedwoodJS is an opinionated, full-stack, serverless-ready web application framework that will allow you to build and deploy with ease.\n\nAs with any new open source project, the team around Tom Preston-Werner wanted to build RedwoodJS with the help of a growing community of engaged developers.\n\n‚ÄúFrom the very beginning, our goal was to build an engaging, dynamic open source community and we‚Äôre optimising for collaboration by design.‚Äù\n\nOften the problem with building a community of contributors is the project setup friction. And since RedwoodJS is a framework, it required tedious manual steps when setting up the developer environment like linking the framework to a development application to explore changes made to the code.\n\nTo solve that and enable developers to contribute to the project with a single click, the RedwoodJS core team turned to Gitpod. Convinced by the idea, they described their configuration and startup tasks in a .gitpod.yml file which is available to everyone publicly as it‚Äôs versioned in the Git repo along with the source code.","metadata":{"source":"https://gitpod.io/customers/redwoodjs"}}],["356",{"pageContent":"Making it easy for the community to use RedwoodJS and contribute to it\n\nAs the configuration is on the repo level, it allows the community to spin up functional test projects with the click of a button that have been prebuilt ahead of time. Making it so much easier for the community to contribute and use the framework, RedwoodJS has over 11.000 stars and 190+ contributors to the project, at the time of writing.\n\n‚ÄúWe‚Äôre obsessed with developer experience. Gitpod allowed RedwoodJS to be accessible to contributors and the core team without any friction and made everyone more productive.‚Äù\n\nAt Gitpod we also created contribute.dev, an initiative to discover open source projects like Redwood‚Äôs that describe their dev environment as code using Gitpod. This way users know that they can focus on core contributions rather than sacrificing time on developer environment configurations.\n\nRedwood also integrated the ‚ÄúOpen in Gitpod‚Äù button in their contributing.md and recorded a 3min Gitpod + RedwoodJS walk-through video to help contributors understand the alternative to a tedious setup on their local machine.\n\nThe team also frequently hosts workshops for anyone interested to contribute to the project. Having workshop participants start their developer environment in Gitpod makes sure the time is best used for explaining how to actually contribute rather than troubleshooting everyone‚Äôs setup.\n\n‚ÄúIt‚Äôs just brilliant and so simple to use.‚Äù\n\nWith more and more contributions coming in as Pull Requests, the maintainers of Redwood benefit from efficient multitrack development every day. Being able to open a fully prebuilt and context aware workspace for reviewing a PR in parallel, allows them to continue with their work instantly after approving the PR. It also helps unblocking others greatly and speeds up developer velocity.\n\nReviewing pull requests is delightful because they are prebuilt and ready for review!‚Äù\n\nThe team at Gitpod is proud to support the open source community and projects through our product. We‚Äôre doing everything we can to streamline the experience for contributors to develop open source projects. We launched Gitpod for Open Source to let open source contributors use Gitpod without usage limits on any public repository. We‚Äôve also launched an Open Source Sustainability Fund [1] with an initial investment of USD 30.000 and give our employees the chance to donate $1.500USD to open source projects of their choice for successful referrals of new hires.\n\nWe‚Äôre thankful for the collaboration with Redwood and the interview with Tom Preston-Werner and team that led to this case study.","metadata":{"source":"https://gitpod.io/customers/redwoodjs"}}],["357",{"pageContent":"&lt;OpenGraph\ndata={{\n    description:\n      &quot;Scaling from 3 to 45 engineers in 5 months on the back of Gitpod. Cutting onboarding times to 10 minutes. Saving half a day per engineer / week.&quot;,\n    title: &quot;Shares.io case study: Scaling from 3 to 45 engineers&quot;,\n    keywords: &quot;DevX, velocity, growth, onboarding, shares.io&quot;,\n  }}\n/&gt;\n\n&lt;CustomerHero\ntitle=&quot;Scaling from 3 to 45 engineers in 5 months on the back of Gitpod&quot;\ntext=&quot;Gitpod helped engineers at Shares.io become more productive and focused. It removed any friction in the onboarding process, dev environment management and the day to day collaboration.&quot;\nlogo={{\n        src: &quot;/svg/customers/shares-io.svg&quot;,\n        alt: &quot;shares.io&quot;\n    }}\ncard={{\n        image: &quot;/images/customers/shares-io/teaser.png&quot;,\n        details:{\n            industry: &quot;Finance&quot;,\n            plan: &quot;Organization, SaaS&quot;,\n            people: {\n                title: &quot;Engineers&quot;,\n                text: &quot;45+&quot;\n            },\n            website: {\n                href: &quot;https://shares.io/&quot;,\n                text: &quot;shares.io&quot;,\n            }\n        }\n    }}\n/&gt;\n\n&lt;CompanyBenefits\nbenefits={[\n{\ntitle: &quot;10min&quot;,\ntext: &quot;Onboarding time for new hires&quot;,\n},\n{\ntitle: &quot;0.5 days&quot;,\ntext: &quot;saved per engineer / week&quot;,\n},\n{\ntitle: &quot;100%&quot;,\ntext: &quot;of engineers develop w/ Gitpod&quot;,\n}]}\n/&gt;\n\nShares App is a community-powered investment platform where investors come to make trades, discuss opportunities with friends, discover new communities and get digestible investing insights while building long-term financial health ‚Äì together.\n\nLast year, the team around CTO and co-founder Fran√ßois Ruty raised $10m from world famous investors like Peter Thiel. Fran√ßois was looking to set up an engineering org with great developer experience and velocity to attract the best talent, onboard them quickly and build a stellar product. The team was only three engineers when Gitpod was introduced, and in less than a year, they grew to 45 engineers with plans to reach 80 engineers in 2022. The whole engineering team is using Gitpod as their only solution to develop.\n\n__SPLIT_HERE__\nThe Challenge: Inconsistencies and too much friction\n\nA local dev environment was never an option, given the drive for efficiency. Fran√ßois also knew that the company needed to hire many engineers quickly to build the product. Onboarding of new hires needs to be as frictionless as possible, and setting up developer environments should not stand in the way. ‚ÄúI was always aware of the importance of standardizing dev environments as much as possible. So we started out with Docker Compose, but it quickly turned out not to be sufficient for us‚Äù.\nThe setup was not frictionless, as engineers needed to understand how to spin up the containers and get an understanding of how they work to do so.\n\nOn top of that, engineers were often blocked by peculiarities introduced by operating system differences. One issue led the hot reload in Typescript to take up to 1 minute until changes were reflected. ‚ÄúYou‚Äôre out of the cognitive loop and simply can‚Äôt work effectively‚Äù. These turning points led Fran√ßois to explore cloud based development environments and to take a look at Gitpod.\n\n‚ÄúGitpod is so easy to use, I didn‚Äôt need to talk to a representative; I just went to the website, clicked ‚Äúget started‚Äù and knew immediately that was what we needed.‚Äù","metadata":{"source":"https://gitpod.io/customers/shares-io"}}],["358",{"pageContent":"Standardized, ephemeral developer environments for the whole team\n\nThe main goal of Shares.io was to create an engineering org that can focus on core product development as much as possible without distractions. For Shares.io, the key arguments for Gitpod were that you can spin up pre-configured, automated dev environments that are versioned along with the code in Git and the concept of Ephemerality. Fran√ßois describes it as changes to the developer environments of the whole team only being one pull request away.\n\n‚ÄúThis is how software development should be done. I shouldn‚Äôt even spend one minute of my day investigating my dev environment.‚Äù\n\nThe concept of Ephemerality immediately clicked with him as it prevents configuration drift through stateful dev environments. Each time a new workspace is started, it has the tools it needs and the latest code from the default branch already checked out.\n\n‚ÄúConfiguration drift is a plague, you think you‚Äôre cleaning up behind you, but you‚Äôre not. You work on some tasks, you check out some branches and catastrophe is bound to happen at some point.‚Äú\n\nRather than frequent, very individual problems with local dev environment configurations that are hard to pin down, any problem connected to the dev environments with Gitpod is more systematic and\nthus easy to identify. As the whole team is kind of incentivized to fix it, there is no way that a problem with the dev environment can last longer than 15 minutes, says Fran√ßois Ruty.\n\n‚ÄúNobody likes to debug a dev environment; it just doesn‚Äôt create any&nbsp;value.‚Äù\n\n__SPLIT_HERE__\nOnboarding new engineers in 10 minutes rather than a full day\n\nThe way Gitpod works allowed Shares.io to have very lean and fast onboarding processes for new hires. Rather than having to understand and set up all components upfront, engineers can launch a production-like environment with a single click and explore the different parts of the system at their own pace. ‚ÄúIt turns onboarding into an interactive discovery where engineers can look at the code, the running processes, the terminals and ask questions based on that. It decreased the time to get new hires up and running from one full day to only 10 minutes.‚Äù\n\n‚ÄúGitpod has been instrumental to our ability to scale so&nbsp;quickly.‚Äú\n\nOn the back of Gitpod, Shares.io has scaled from three engineers to more than 45 in less than 5 months. Their goal is to grow to 80 engineers within 2022 quickly.\n\n__SPLIT_HERE__\nOngoing productivity gains are the true magic\n\nFran√ßois points out that it‚Äôs not just the time savings from the dev environment set up during onboarding, but rather the day to day efficiency gains through using an ephemeral remote development solution that makes the real difference.\n\n‚ÄúGitpod easily saves every engineer half a day per week. The amount of productivity we gain is&nbsp;staggering.‚Äù\n\nFran√ßois explains that the ability to spin up new workspaces in different contexts allows them to parallelize development. This helps to unblock each other, review PRs and move on with their tasks swiftly. All that while they stay focused, without making changes to the configurations. This greatly increases the development velocity and also the ability to rapidly deploy a production hotfix by spinning up a dev environment out of a release branch. Prebuilds accelerate all this and ‚Äúput a lot of grease in the wheels‚Äù as the wait time is reduced since dependencies have been installed and builds ran even before a workspace in a new context is started.\n\nAll engineers at Shares.io are using Gitpod as a default way of development, and every future hire will embark on the same journey. We‚Äôre thankful for the collaboration with Shares and for the interview with Fran√ßois Ruty that led to this case study.","metadata":{"source":"https://gitpod.io/customers/shares-io"}}],["359",{"pageContent":"&lt;OpenGraph\ndata={{\n    description:\n      &quot;By moving their whole development to the cloud, Vizlib reduced onboarding time for new hires from 2d to 1h. 20% fewer hotfixes after release through Gitpod.&quot;,\n    title: &quot;Vizlib case study: 20% fewer hotfixes with Gitpod&quot;,\n    keywords: &quot;vizlib, astrato, data visualisation, hackathon&quot;,\n  }}\n/&gt;\n\n&lt;CustomerHero\ntitle=&quot;An internal hackathon as catalyst to 20% fewer hotfixes with Gitpod&quot;\ntext=&quot;Vizlib used Gitpod to circumvent challenges with local development at an internal hackathon for their new cloud-native product, Astrato. They eventually moved their whole development to the cloud. This reduced the onboarding time for new hires from two days to one hour and resulted in 20% fewer hotfixes after release.&quot;\nlogo={{\n        src: &quot;/svg/customers/astrato.svg&quot;,\n        alt: &quot;Astrato&quot;\n    }}\ncard={{\n        image: &quot;/images/customers/vizlib/teaser.png&quot;,\n        details:{\n            industry: &quot;Data Analytics&quot;,\n            plan: &quot;Organization, SaaS&quot;,\n            people: {\n                title: &quot;Engineers&quot;,\n                text: &quot;80+&quot;\n            },\n            website: {\n                href: &quot;https://astrato.io&quot;,\n                text: &quot;astrato.io&quot;,\n            }\n        }\n    }}\n/&gt;\n\n&lt;CompanyBenefits\nbenefits={[\n{\ntitle: &quot;1 hour&quot;,\ntext: &quot;Onboarding instead of 2 days&quot;,\n},\n{\ntitle: &quot;20%&quot;,\ntext: &quot;Fewer hotfixes after release&quot;,\n},\n{\ntitle: &quot;100‚Ç¨&quot;,\ntext: &quot;Cloud cost saved per dev/month&quot;,\n}]}\n/&gt;\n\nVizlib builds powerful value-added products for Qlik Sense. Customers go beyond native Qlik Sense to supercharge their analytics. They are growing quickly on the back of their five value-added products, used by 1.000+ enterprise customers, and are now expanding into cloud-native BI with their new product, Astrato.\n\nThe engineering team under CTO Konrad Mattheis came to appreciate the benefits of Gitpod during a hackathon.","metadata":{"source":"https://gitpod.io/customers/vizlib"}}],["360",{"pageContent":"Gitpod as an unexpected outcome from a Hackathon\n\nEngineers want to focus on being creative and writing code. For hackathons, this is even more true. In the case of Vizlib, a five-day hackathon was held to focus the team on the rapid development of new features and improvements for their new product, Astrato‚Äì a modern fully managed Cloud BI solution.\n\nNaturally, the last thing the team wanted was to waste time on dealing with configuration, setup tasks and making changes to their developer environment. But that was the exact challenge ‚Äì since engineers from various areas with different dev stacks came together to collaborate towards the same goal and product. Making changes to running local developer environments was not an option to avoid breaking them for when they return to their regular work. Plus, compatibility issues with the Astrato workflow on Windows added another layer of complexity.\n\n‚ÄúWe needed a fast way to make everyone ready to code in just one hour without touching the local environments.‚Äù\n\nThe CTO, Konrad Mattheis, explored cloud developer environments as an option to solve these challenges and started evaluating Gitpod.\n\nUsing remote development would firstly ensure that local developer environments remained untouched. And since Gitpod provisions powerful Linux containers under the hood, the OS compatibility wouldn‚Äôt be an issue either. Having a standardized configuration to provide everyone with the right set and versions of tools at the click of a button ensured consistency with no ‚Äúbut it works on my machine‚Äù surprises.\n\n‚ÄúGitpod checked all the boxes, so all 72 participants used it throughout the hackathon week.‚Äù\n\nKonrad Mattheis explained that the deep focus on development allowed for much higher productivity. Given the collaborative nature of hackathons, Gitpod‚Äôs features such as sharing running workspaces for pair programming or sharing snapshots of workspaces let the teams collaborate much closer and more efficiently. The hackathon was a huge success and resulted in 10 new features or improvements to Astrato, more than initially expected. Read more in their Astrato blog post.\n\nAn unintended outcome of the hackathon was the improvement of the development workflow at Vizlib: inspired by the efficiency of remote development with Gitpod, the team decided to move their whole developer environments to the cloud altogether. CTO Konrad Mattheis noted that the hackathon acted as a catalyst, making it more obvious that the aforementioned challenges are not exclusive to hackathons but significantly impact the day-to-day work of their engineering organization. Vizlib develops on a dockerized Kubernetes Stack with only full-stack engineers that use a variety of machines with different operating systems. This led to inconsistent, error-prone dev environments due to configuration drift.\n\n‚ÄúNearly every week, a few developers complained that they couldn‚Äôt work because the system couldn‚Äôt be built due to changes they were unaware of.‚Äù","metadata":{"source":"https://gitpod.io/customers/vizlib"}}],["361",{"pageContent":"A smoother development process with improved collaboration and onboarding\n\nVizlib operates in squads consisting of engineers, QA testers, product managers and designers. Konrad shares that one of the biggest advantages of moving to Gitpod are the efficiency gains they get from better collaboration within and across squads. The ability to work on multiple issues, bugs or PRs and spin up workspaces that are fully prebuilt by the time they are started, resulted in massive time savings. Vizlib estimates that every engineer saves a minimum of two hours per week, purely by not having to fix their developer environments anymore. Excluding efficiency gains through increased flow state and more efficient collaboration.\n\nIt also made the development process more robust by having fewer differences across the developer and production environments and allowing for better testing. Gitpod improved the accessibility to QA engineers and designers, which lifted development velocity and quality.\n\n‚ÄúThe ability for QAs to easily test a branch resulted in 20% fewer hotfixes after releases.‚Äù\n\nHaving newly hired engineers use automated developer environments in the cloud significantly reduces friction, onboarding time and allows them to contribute from the get-go. In the past, it took two days for an engineer to set up their dev environment, while it now only takes around an hour to get started.\n\nTo support the rapid business growth, Vizlib plans to hire five additional product squads with 10 FTE each during 2022 (see Vizlib‚Äôs career page for current opportunities), where these efficiency gains will have a massive impact. On top of that, CAPEX expenditures can be reduced as there is no need for overpowered machines anymore. Even without that, Vizlib estimates the cost savings to be more than $100 per month per engineer.\n\n‚ÄúGitpod will become the default way of developing. Local development is just not an option anymore.‚Äù\n\nWe‚Äôre thankful for the collaboration with Vizlib and the interview with Konrad Mattheis that led to this case study.","metadata":{"source":"https://gitpod.io/customers/vizlib"}}],["362",{"pageContent":"Note\nPlease think about updating the /events page when adding a new event.\n\nThe contents for it live in lib/contents/events.ts\n\nThank you :) !!","metadata":{"source":"https://gitpod.io/events/_note"}}],["363",{"pageContent":"Note\nPlease think about updating the /events page when adding a new webinar\n\nThe contents for it live in lib/contents/events.ts\n\nThank you :) !!","metadata":{"source":"https://gitpod.io/webinars/_note"}}],["364",{"pageContent":"__SPLIT_HERE__\nConfigure Gitpod\n\nYou can open any repository in Gitpod by prefixing the full repository URL with gitpod.io/#.\n\nFor example: https://gitpod.io/#https://github.com/nodejs/node\n\nNote: For Self-Hosted, substitute gitpod.io for the domain of your installation.\n\nTo get the most out of Gitpod, commit a .gitpod.yml to the root of your project to give instructions to Gitpod about what packages to install, which process to start, and much more.\n\n__SPLIT_HERE__\nWorkspaces\n\nWorkspaces are the developer environments where you code in Gitpod.\n\nWorkspaces can be created on their own, or as part of a Project.\n\nWorkspace Image\nTasks\nPorts\nCollaboration\nMulti-repo\nWorkspace Classes\n\n__SPLIT_HERE__\nUser Settings\n\nUser settings allow you to customize your own personal Gitpod experience.\n\nBrowser Extension\nBrowser Settings\nBrowser Bookmarklet\nDotfiles\nSSH\nAccess Tokens\n\n__SPLIT_HERE__\nProjects\n\nProjects are the connection between Gitpod and one or more git repositories and allow you to manage Prebuilds. Projects can be associated with your personal account, or associated with Organizations.\n\nPrebuilds\nIncremental Prebuilds\nLast Successful Prebuild\nEnvironment Variables\n\n__SPLIT_HERE__\nOrganizations\n\nOrganizations in Gitpod allow you to share projects and their settings amongst many organization individuals.\n\n__SPLIT_HERE__\nAuthentication\n\nGitLab\nGitHub\nBitBucket\nGitHub Enterprise\nBitbucket Server","metadata":{"source":"https://gitpod.io/docs/configure/index"}}],["365",{"pageContent":"__SPLIT_HERE__\nHelp\n\nBuilding Gitpod\nTroubleshooting","metadata":{"source":"https://gitpod.io/docs/help/index"}}],["366",{"pageContent":"__SPLIT_HERE__\nTroubleshooting\n\nIf you cannot find your issue here or in the documentation, please contact Gitpod via our Support page.\n\n__SPLIT_HERE__\nGitpod logs in VS Code Browser and Desktop\n\nThese logs contain information about the workspace, the session, and the Visual Studio Code environment. They are useful for diagnosing connection issues and other unexpected behavior.\n\nOpen the Visual Studio Code Command Palette (CtrlCmd + Shift + P) and type Export logs, select Gitpod: Export all logs from the list to download a zip file containing all of the logs.\n\nImportant: The content of these logs should NOT be shared publicly as they could contain sensitive information about your workspace. Instead, send them to &#116;&#114;&#111;&#x75;&#98;&#108;&#x65;&#115;&#x68;&#111;&#111;&#116;&#x69;&#x6e;&#103;&#x40;&#x67;&#x69;&#x74;&#x70;&#x6f;&#x64;&#46;&#x69;&#x6f; along with a link to a corresponding GitHub issue if needed.\n\n__SPLIT_HERE__\nGitpod logs in JetBrains Gateway\n\nThese logs contain information about the workspace, the session, and the JetBrains Gateway. They are useful for diagnosing issues when connecting to a workspace, issues from Gateway Plugins and issues preventing the JetBrains Client to open.\n\nOpen the Help menu and select Collect Logs and Diagnostic Data option. After a few seconds, the file manager window will show up, revealing the location where the zip file containing all the logs has been saved.\n\nImportant: The content of these logs should NOT be shared publicly as they could contain sensitive information about your workspace. Instead, send them to &#116;&#x72;&#x6f;&#117;&#98;&#108;&#101;&#115;&#x68;&#111;&#111;&#116;&#x69;&#110;&#103;&#64;&#x67;&#105;&#x74;&#112;&#111;&#100;&#46;&#105;&#x6f; along with a link to a corresponding GitHub issue if needed.\n\nNote: Ensure you are using the latest version of JetBrains Gateway and Gitpod JetBrains Gateway plugin, as issues from older versions might have already been fixed.\n\n__SPLIT_HERE__\nGitpod logs in JetBrains Client\n\nThese logs contain information about the workspace, the session, and the JetBrains IDE. They are useful for diagnosing connection issues, issues from IDE Plugins, and any unexpected behavior from the client and the server.\n\nOpen the Help menu and select Collect Host and Client logs option. After a few seconds, the file manager window will show up, revealing the location where the zip file containing all the logs has been saved.\n\nImportant: The content of these logs should NOT be shared publicly as they could contain sensitive information about your workspace. Instead, send them to &#116;&#x72;&#111;&#117;&#98;&#108;&#x65;&#x73;&#104;&#111;&#111;&#x74;&#105;&#110;&#x67;&#x40;&#x67;&#105;&#116;&#112;&#x6f;&#100;&#46;&#105;&#111; along with a link to a corresponding GitHub issue if needed.\n\nNote: Ensure you are using the latest version of both JetBrains Gateway and Gitpod JetBrains Gateway plugin, as issues from older versions might have already been fixed.\n\n__SPLIT_HERE__\nWhy doesn&#39;t the &quot;ClearURLs&quot; browser extension work with Gitpod?\n\nThe ClearURLs browser extension for Google Chrome and Mozilla Firefox inhibits Gitpod workspaces from initialising and the problem manifests with the following symptoms:\n\nThe dark theme doesn&#39;t load\nThe bottom left Gitpod button is missing\nThe VS Code Marketplace does not load\nSettings Sync does not work\n\nThis issue can be resolved by disabling &quot;ETag filtering&quot; in ClearURLs‚Äô settings. An issue has been created that requests to whitelist Gitpod by default and we would appreciate your upvotes on the issue.\n\n__SPLIT_HERE__\nWhat should I do if JetBrains Gateway and Gitpod aren&#39;t working?\n\nEnsure you are using the latest version of JetBrains Gateway\nEnsure you are using the latest version of the Gitpod JetBrains Gateway plugin","metadata":{"source":"https://gitpod.io/docs/help/troubleshooting"}}],["367",{"pageContent":"What can I do if I have unsynced data inside a workspace but it&#39;s not starting?\n\nWhile this is a very critical issue, our workspace-team would eventually look into why it&#39;s happening but on the other hand you might not be able to wait while things get fixed. As an user you can try and get your workspace data yourself:\n\nGo to the Gitpod Dashboard\nFind your workspace from the list\nDownload your workspace like so:\nDownload a workspace\nYou can now either try opening a new workspace or use your local machine for a while.\nThe downloaded workspace is a tar file which can be extracted with tar -xf &lt;your-workspace-filename-here&gt; command on a new Gitpod workspace or in your Linux/MacOS machine. You can use 7-zip to extract if you&#39;re on windows and don&#39;t have tar.","metadata":{"source":"https://gitpod.io/docs/help/troubleshooting"}}],["368",{"pageContent":"__SPLIT_HERE__\nIntegrations\n\nTailscale\nJetBrains Gateway","metadata":{"source":"https://gitpod.io/docs/integrations/index"}}],["369",{"pageContent":"__SPLIT_HERE__\nJetBrains Gateway\n\n{title} is currently in Beta ¬∑ Send feedback.\n\nJetBrains Gateway is your single entry point to all remote development environments when using JetBrains IDE&#39;s. JetBrains Gateway is a compact desktop app that allows you to work remotely with a JetBrains IDE without downloading the full IDE. Gitpod works with JetBrains Gateway via a custom Gitpod JetBrains Gateway plugin.\n\nUsing JetBrains Gateway on Desktop with Gitpod, allows you to:\n\nCreate a new Gitpod workspace\nView and open your 20 latest Gitpod workspaces\n\nAll without leaving needing to leave your desktop.\n\n__SPLIT_HERE__\nJetBrains IDE support\n\nJetBrains Gateway is the underlying technology which enables the Gitpod integration. Support for JetBrains IDEs will be rolled out incrementally. The JetBrains Gateway plugin is a standalone feature, so its release cycle is independent individual JetBrains IDE support.\n\nIntelliJ\nGoLand\nPhpStorm\nPyCharm\nRubyMine\nWebStorm\nRider\nCLion\n\n__SPLIT_HERE__\nGetting started\n\nyoutube: 8djaRYT2FAY\n\nInstall JetBrains Gateway - With the JetBrains Gateway and Gitpod plugin you can create and manage your latest 20 Gitpod workspaces.\nInstall the Gitpod plugin - Open JetBrains Gateway and you&#39;ll see the Gitpod logo on the main page. Click &quot;install&quot; to install the Gitpod plugin for JetBrains Gateway.\nUpdate your Gitpod preferences - Select your preferred JetBrains IDE on the Gitpod preferences page which will set your default IDE for future workspace starts.\nStart (or restart) your workspace - Either start a workspace directly from within the JetBrains Gateway via the Gitpod plugin OR open a new workspace directly in Gitpod where on workspace start you will be prompted to open your preferred JetBrains IDE for that workspace.\n\nHow does JetBrains and Gitpod work?\n\nOn Gitpod workspace start, a JetBrains IDE is loaded into your workspace according to your preferences. When you start a workspace the JetBrains Gateway application downloads a thin client which then connects to your Gitpod workspace.\n\nSince JetBrains Gateway downloads the thin client for you, you do not need to download, open or modify your JetBrains IDE directly. JetBrains licensing still applies, but is applied to the connecting thin client, not the backend running in your Gitpod workspace.\n\nSetting a JetBrains IDE as a preference\n\nTo start a workspace using JetBrains from your browser, you need to first set your preferred JetBrains IDE as your user preference.\n\nOpening a JetBrains IDE from Gitpod\n\nWhen starting a new workspace from Gitpod in the browser (with a JetBrains IDE set as your preference) you will see a prompt to open JetBrains Gateway. Clicking the prompt will immediately launch JetBrains Gateway and begin downloading the IDE thin client. The downloaded thin client will exactly match the IDE running in your Gitpod workspace.\n\nUpdating the Gitpod plugin in JetBrains Gateway\n\nSince Gitpod and JetBrains works via JetBrains Gateway, you do not need to download a JetBrains IDE. Also, you do not need to alter your plugin settings in your JetBrains IDE. All setup and configuration for Gitpod and JetBrains is completed within JetBrains Gateway.\n\nOpening a JetBrains IDE from JetBrains Gateway\n\nYou can also start, and connect to Gitpod workspaces directly from JetBrains Gateway. Click Gitpod in the left-hand side of JetBrains Gateway, and paste a source control context URL directly to start a new workspace, or click connect on a running or stopped workspace.\n\n__SPLIT_HERE__\nConfiguring the JetBrains Gateway Host\n\nBy default the JetBrains Gateway Gitpod plugin points to gitpod.io as the default host for listing, opening and managing Gitpod workspaces.\n\nIf you&#39;re using Gitpod Self-Hosted, to update the host:\n\nOpen JetBrains Gateway\nNavigate to &quot;preferences&quot; (OSX) or &quot;settings&quot; (Windows/Linux)\nSearch for &quot;Gitpod&quot; (or find it under &quot;tools&quot;)\nModify the Gitpod Host field","metadata":{"source":"https://gitpod.io/docs/integrations/jetbrains-gateway"}}],["370",{"pageContent":"Configuring JetBrains Gateway Networking\n\nThe following diagram details how the JetBrains Gateway client connects and communicates with Gitpod workspaces, for situations such as configuring corporate networking requirements.\n\nJetBrains.com - The JetBrains IDE thin client images are downloaded dynamically from JetBrains Gateway to match the exact IDE that is running in Gitpod. Access to jetbrains.com must be granted for an air-gapped Gitpod installation with JetBrains Gateway configuration to work.\nJetBrains Gateway - The JetBrains Gateway client is the component which fetches information about Gitpod workspaces, pulled from the Gitpod API via HTTPS.\nJetBrains Thin Client - The thin client connects to the Gitpod workspace via SSH, routed via the workspace proxy (&quot;ws-proxy&quot;). The SSH server (SSH Gateway) runs in the workspace proxy, not in the workspace directly.\n\nJetBrains networking setup\nJetBrains networking setup\n\n__SPLIT_HERE__\nTroubleshooting\n\nWhat should I do if JetBrains Gateway and Gitpod aren‚Äôt working?\nGitpod logs in JetBrains Gateway\nGitpod logs in JetBrains Client","metadata":{"source":"https://gitpod.io/docs/integrations/jetbrains-gateway"}}],["371",{"pageContent":"__SPLIT_HERE__\nTailscale\n\nWith Tailscale you can automatically and securely connect your Gitpod workspace to other development resources, whether in the cloud or on prem, such as a production database behind your company‚Äôs firewall. You can also spin up several Gitpod workspaces that can talk to each other.\n\nTailscale is built on top of the point-to-point open-source WireGuard protocol which powers an encrypted mesh network or tailnet. At Gitpod we are big fans of their product and recently announced an official partnership with them.\n\n__SPLIT_HERE__\nIntegration\n\nNote: Using Tailscale ssh to a workspace is not supported right now and from requires Tailscale 1.32 or later. If your workspace image was created before 1.32 was available you can force a rebuild without having to update your .gitpod.Dockerfile.\n\nIf you‚Äôre already using Tailscale, the following steps need to be done (see https://github.com/gitpod-io/demo-tailscale-with-gitpod for a working example):\n\nInstall tailscale through a custom .gitpod.Dockerfile by adding the following layer to it.\n\n```Dockerfile\nUSER root\n\n# Install jq (if not done already). Required for the .gitpod.yml tasks below.\n\nRUN curl -fsSL https://pkgs.tailscale.com/stable/ubuntu/focal.gpg | sudo apt-key add - \\\n     && curl -fsSL https://pkgs.tailscale.com/stable/ubuntu/focal.list | sudo tee /etc/apt/sources.list.d/tailscale.list \\\n     && apt-get update \\\n     && apt-get install -y tailscale jq \\\n     && update-alternatives --set ip6tables /usr/sbin/ip6tables-nft\n```\n\nStart tailscale on workspace start and maintain the machine state across workspaces by adding the following tasks to your .gitpod.yml.\n\n```yaml\ntasks:\n  - name: tailscaled\n    command: |\n      if [ -n \"${TAILSCALE_STATE_MYPROJECT}\" ]; then\n        # restore the tailscale state from gitpod user's env vars\n        sudo mkdir -p /var/lib/tailscale\n        echo \"${TAILSCALE_STATE_MYPROJECT}\" | sudo tee /var/lib/tailscale/tailscaled.state > /dev/null\n      fi\n      sudo tailscaled\n  - name: tailscale\n    command: |\n      if [ -n \"${TAILSCALE_STATE_MYPROJECT}\" ]; then\n        sudo -E tailscale up\n      else\n        sudo -E tailscale up --hostname \"gitpod-${GITPOD_GIT_USER_NAME// /-}-$(echo ${GITPOD_WORKSPACE_CONTEXT} | jq -r .repository.name)\"\n        # store the tailscale state into gitpod user\n        gp env TAILSCALE_STATE_MYPROJECT=\"$(sudo cat /var/lib/tailscale/tailscaled.state)\"\n      fi\n```\n\nThis configuration will register a Tailscale node based on the following name scheme: gitpod-{user-name}-{repo-name}. On first workspace start you will get asked to login through the terminal. When this was successful a Tailscale machine state will be stored in your Gitpod&#39;s account. On subsequent starts of workspaces on this project this machine state will be restored.\n\nIF you enable Tailscale&#39;s Magic DNS you get a stable domain for your project&#39;s services that you can reach from any other Tailscale node (e.g. another workspace or your local machine).\n\nWarning: Be aware that starting and connecting multiple workspaces for the same project in parallel results in unreliable network connections.","metadata":{"source":"https://gitpod.io/docs/integrations/tailscale"}}],["372",{"pageContent":"&lt;OpenGraph\ndata={{\n    description:\n      &quot;Explore our docs to learn how to set up and configure your cloud developer environment. Quickstart. Getting started. Configure. Develop. IDEs. Editors. Integrations. Self-Hosted. Supply Chain Security.&quot;,\n    title: &quot;Gitpod Documentation - Educate, Configure, Develop&quot;,\n    keywords: &quot;documentation, how to, education, learn&quot;,\n  }}\n/&gt;\n\n__SPLIT_HERE__\nLatest updates\n\nTo see all updates view our changelog","metadata":{"source":"https://gitpod.io/docs/introduction/index"}}],["373",{"pageContent":"__SPLIT_HERE__\nCompatibility\n\n‚ö†Ô∏è Self-hosted as a product is no longer supported\n\nThe last official update of this product is the November 2022 self-hosted release. We no longer sell commercial self-hosted licenses. If you want to self-host Gitpod, you can still request our free community license. However, we no longer offer support or updates for it. If you are interested in an isolated, private installation of Gitpod, take a look at Gitpod Dedicated.\nRead our blog on Gitpod Dedicated to learn why we made the decision to discontinue self-hosted.\n\nThis page shows you what components and services Gitpod is and is not compatible with. It is aimed at both individual developers that use Gitpod as well as admins that install and maintain a Gitpod Self-Hosted instance. You can filter the table to show only what is relevant to you.\n\nNote: It is required to have at least one of each category. SaaS users can ignore the self-hosted specific categories (see filter)","metadata":{"source":"https://gitpod.io/docs/references/compatibility"}}],["374",{"pageContent":"__SPLIT_HERE__\nGitpod CLI\n\nGitpod supports a command line interface that is available in each workspace terminal called gp:\n\n```text\nCommand line interface for Gitpod\n\nUsage:\n  gp [command]\n\nAvailable Commands:\n  docs                Open Gitpod Documentation in default browser\n  env                 Controls user-defined, persistent environment variables.\n  help                Help about any command\n  info                Display workspace info, such as its ID, class, etc.\n  init                Create a Gitpod configuration for this project.\n  open                Opens a file in Gitpod\n  ports               Interact with workspace ports.\n  preview             Opens a URL in the IDE's preview\n  rebuild             Re-builds the workspace image (useful to debug a workspace custom image)\n  snapshot            Take a snapshot of the current workspace\n  stop                Stop current workspace\n  sync-await          Awaits an event triggered using gp sync-done\n  sync-done           Notifies the corresponding gp sync-await calls that this event has happened\n  tasks               Interact with workspace tasks\n  timeout             Interact with workspace timeout configuration\n  top                 Display workspace resource (CPU and memory usage)\n  url                 Prints the URL of this workspace\n  version             Prints the version of the CLI\n\nFlags:\n  -h, --help   help for gp\n\nUse \"gp [command] --help\" for more information about a command.\n```\n\n__SPLIT_HERE__\ninit\n\nGitpod workspaces can be configured - see Configuring Workspaces for more details. gp init generates a default .gitpod.yml file. You can customize it to match your requirements.\n\nAlternatively, gp init -i is an interactive guide which helps create the .gitpod.yml configuration file based on a few questions you answer.\n\nExample to start a interactive guide of .gitpod.yml configuration file:\n\n```sh\ngp init -i\n```\n\n__SPLIT_HERE__\nopen\n\nModern editors/IDE&#39;s support command line tooling to open a file (e.g. VS Code code foo.txt). In Gitpod, this can be done using gp open &lt;filename&gt;.\nWe also added common aliases for gp open: code and open.\n\nExample to open the README.md file in the current directory:\n\n```sh\ngp open README.md\n```\n\n__SPLIT_HERE__\npreview\n\ngp preview opens a URL. The default is to show the URL in a preview pane within the editor or IDE directly. Alternatively, you can show the preview a new tab with the --external flag.\n\nMake sure you provide a valid URL, i.e. including the protocol. For example, http://localhost:8080.\n\nYou can also use gp preview &lt;url&gt; --external to open the URL in a new browser tab.\n\nExample opening a gitpod workspace port 3000 as a tab using gp url and gp preview:\n\n```sh\ngp preview $(gp url 3000) --external\n```\n\n__SPLIT_HERE__\nurl\n\nGitpod workspaces can expose services to the internet. gp url provides the URL which points to a service served from a Gitpod workspace. For example gp url 8080 prints the URL which points to the service listening on port 8080 in this current workspace.\n\nYou can combine the preview and the url command to open a certain path instead of the default URL.\n\nFor instance:\n\n```sh\ngp preview $(gp url 3000)/my/path/index.html\n```\n\nIf you put this into the .gitpod.yml to open the a certain page on startup, make sure you ignore the default action when the port opens.\n\n__SPLIT_HERE__\nenv\n\nWith gp env API_ENDPOINT=https://api.example.com you can set an API_ENDPOINT environment variable that is accessible for this project, even if you stop the workspace and start a new one.\n\nTo delete or unset an environment variable, you use gp env -u API_ENDPOINT.\n\nPlease refer to the help output provided by gp env --help for more use cases of the gp env command.\n\nFor instance, you can use following to get your all Gitpod environment variables:\n\n```sh\ngp env\n```","metadata":{"source":"https://gitpod.io/docs/references/gitpod-cli"}}],["375",{"pageContent":"sync-await\n\nIn situations where you work with multiple terminals and one depends on a task in another terminal to complete, gp sync-await &lt;name&gt; waits until you call gp sync-done &lt;name&gt; in another terminal.\n\nSee Start Tasks for a real-world example.\n\n__SPLIT_HERE__\nsync-done\n\nTo notify a gp sync-await &lt;name&gt; call (see previous chapter), you can call gp sync-done &lt;name&gt;.\n\nA common use case is the following where we have three terminals:\n\nTerminal 1: A build process takes several minutes to complete. At the end, you call gp sync-done build.\nTerminal 2: You use gp sync-await build &amp;&amp; npm run start-database to wait for the build to complete before you start a database\nTerminal 3: You use gp sync-await build &amp;&amp; npm run dev to wait for the build to complete before you start the dev server.\n\nSee Start Tasks for a real-world example.\n\n__SPLIT_HERE__\nsnapshot\n\nFor sharing a complete clone of a workspace with others, gp snapshot is basically the CLI method for getting a snapshot URL. To learn more about snapshots, see Collaboration &amp; Sharing of Workspaces\n\n```sh\ngp snapshot\n```\n\n__SPLIT_HERE__\nstop\n\ngp stop is the CLI method of stopping a workspace.\n\nExample to stop the current gitpod workspace using gitpod CLI:\n\n```sh\ngp stop\n```\n\n__SPLIT_HERE__\ntasks\n\nProgrammatically view and interact with workspace tasks as defined in the project&#39;s .gitpod.yml. Useful when using the command line, such as ssh&#39;ing into a workspace or after accidentally losing view of a terminal and it&#39;s output.\n\nlist\n\nReturns a table-formatted list of tasks, their name, state and the ID of the terminal in which the task is executed.\n\nTip: You can see the task you are currently attached to highlighted in green.\n\n```sh\ngp tasks list\n```\n\nUse gp tasks list --no-color to disable colors for the output. It also respects the NO_COLOR &amp; GP_NO_COLOR environment variable.\n\nattach\n\nCreates a connection from a user terminal to a given workspace&#39;s task terminal. The session is interactive. Once attached, both stdin and stdout are streamed between the user and the remote terminal. Allowing the user to run commands directly in the task terminal.\n\nRun without arguments to get a selection prompt. When only one task is running, attach will skip the prompt and automatically connect.\n\n```sh\ngp tasks attach\n```\n\nAlternatively, specify the Terminal ID that you can see with gp tasks list:\n\n```sh\ngp tasks attach <id>\n```\n\nstop\n\nInterrupts one or more running tasks and automatically closes their terminals. Useful when you don&#39;t need a certain task anymore, when authoring the .gitpod.yml file or when you start a workspace for projects with several tasks but you don&#39;t need them and want to save time and resources.\n\nRun without arguments to get a selection prompt. Only running tasks will be offered as a choice.\n\n```sh\ngp tasks stop\n```\n\nSpecify the Terminal ID that you can see with gp tasks list.\n\n```sh\ngp tasks stop <id>\n```\n\nRun with the --all flag to stop all running tasks.\n\n```sh\ngp tasks stop --all\n```\n\n__SPLIT_HERE__\ntimeout\n\nInteract with workspace timeout configuration. You can learn more in Life of a Workspace.\n\n```sh\ngp timeout show\n```\n\nNote: You can only have one workspace with extended timeout at a time.\n\nThe default timeout, and the ability to extend a workspace timeout depends on your billing configuration.\n\nset\n\nSets the current workspace&#39;s timeout to the given value. The value must be a positive integer followed by a unit of time. The unit of time can be one of m, h for minutes and hours, respectively. The maximum workspace timeout is 24 hours.\n\n```sh\ngp timeout set 300m\n```\n\nshow\n\nShows the current workspace&#39;s timeout.\n\n```sh\ngp timeout show\n```\n\nextend\n\nExtends the current workspace timeout from the default, or currently set value to 180 minutes.\n\n```sh\ngp timeout extend\n```","metadata":{"source":"https://gitpod.io/docs/references/gitpod-cli"}}],["376",{"pageContent":"info\n\nDisplays information about the current workspace (such as the workspace ID and URL) and also the workspace class.\n\n```sh\ngp info\n```\n\nUse gp info --json to get the output in JSON format for programmatic use in (e.g. in shell scripts).\n\n__SPLIT_HERE__\nports\n\nProvides a way to manage a workspace&#39;s ports. Applies to both: ports defined in .gitpod.yml and ports that are undeclared but are opened during the lifetime of the workspace.\n\nlist\n\nOutputs a table-formatted list of ports along with their status, URL, name and description.\n\n```sh\ngp ports list\n```\n\nUse gp ports list --no-color to disable colors for the output. It also respects the NO_COLOR &amp; GP_NO_COLOR environment variable.\n\nexpose\n\nIn Gitpod, services/servers running on a port need to be exposed before they become accessible from the internet. This process only works with services listening on 0.0.0.0 and not just localhost.\nSometimes it is not possible to make a server listen on 0.0.0.0, e.g. because it is not your code and there are simply no means of configuration.\n\nIn that case, gp ports expose &lt;port&gt; can be used to forward all traffic form a socket listing on all network interfaces to your process listening on localhost only.\n\n```sh\ngp ports expose <port>\n```\n\nawait\n\nWhen writing tasks to be executed on workspace start, one sometimes wants to wait for an http service to be available. gp ports await does that.\n\nHere&#39;s an example that will open a certain path once a service is a available:\n\n```sh\ngp ports await 3000 && gp preview $(gp url 3000)/my/path/index.html\n```\n\nvisibility\n\nYou can change a port&#39;s visibility to make it only available for users with workspace access (private) or everyone who knows the port&#39;s URL (public). A port&#39;s default visibility is always private, unless configured differently from within .gitpod.yml.\n\nHere&#39;s an example which will make port 3000 public:\n\n```sh\ngp ports visibility 3000:public\n```\n\nHere&#39;s an example which will make port 3000 private:\n\n```sh\ngp ports visibility 3000:private\n```\n\n__SPLIT_HERE__\ntop\n\nDisplays the current workspace&#39;s class info along with the used and available CPU and memory.\n\n```sh\ngp top\n```\n\nUse gp top --json to get the output in JSON format for programmatic use in (e.g. in shell scripts).\n\n\nUse gp top --no-color to disable colors for the output. It also respects the NO_COLOR &amp; GP_NO_COLOR environment variable.\n\n__SPLIT_HERE__\ndocs\n\nOpens the Gitpod documentation in a new browser tab.\n\n```sh\ngp docs\n```\n\n__SPLIT_HERE__\nrebuild\n\ngp rebuild is currently in Beta ¬∑ Send feedback.\n\nRuns a debug workspace inside an existing Gitpod workspace. You can use this to quickly iterate on/debug your .gitpod.yml properties such as tasks or a custom workspace image.\n\n```sh\ngp rebuild\n```","metadata":{"source":"https://gitpod.io/docs/references/gitpod-cli"}}],["377",{"pageContent":"__SPLIT_HERE__\nGitpod public API\n\nAccess Tokens are currently in Alpha ¬∑ Send feedback.\n\nThe Gitpod Public API grants direct access to Gitpod data for use cases such as integration into other 3rd party applications.\n\n__SPLIT_HERE__\nAuthentication\n\nTo authenticate requests, the Gitpod API utilises Access Token. In the Gitpod Settings, you can view and manage your PAT Tokens (Private Beta).\n\nKeep in mind that your access tokens have a lot of power, so protect them carefully! Avoid disclosing your private Access Tokens in areas that are open to the public, such as GitHub, client-side code, and so forth.\n\nTo Authenticate you will need to pass an Access Token as an Authorization request header bearer token in the format Bearer &lt;YOUR_ACCESS_TOKEN&gt;.\n\nExample cURL command:\n\n```bash title=\"cURL\"\ncurl 'https://api.gitpod.io/gitpod.experimental.v1.TeamsService/ListTeams' \\\n  -H 'content-type: application/json' \\\n  -H 'Authorization: Bearer <YOUR_ACCESS_TOKEN>' \\\n  --data '{}'\n```\n\n__SPLIT_HERE__\nAPI Reference","metadata":{"source":"https://gitpod.io/docs/references/gitpod-public-api"}}],["378",{"pageContent":"Resource: Workspaces\n\nList all workspaces\n\nLists all the workspaces belongs to the authenticated user. Currently, it returns only the first page of the results.\n\n```bash title=\"cURL\"\ncurl 'https://api.gitpod.io/gitpod.experimental.v1.WorkspacesService/ListWorkspaces' \\\n  -H 'content-type: application/json' \\\n  -H 'Authorization: Bearer <YOUR_ACCESS_TOKEN>' \\\n  --data '{}'\n```\n\n```go\nfunc ExampleListWorkspaces() {\n    token := \"<YOUR_ACCESS_TOKEN>\"\n\n    gitpod, err := client.New(client.WithCredentials(token))\n    if err != nil {\n        fmt.Fprintf(os.Stderr, \"Failed to construct gitpod client %v\", err)\n        return\n    }\n\n    response, err := gitpod.Workspaces.ListWorkspaces(context.Background(), connect.NewRequest(&v1.ListWorkspacesRequest{}))\n    if err != nil {\n        fmt.Fprintf(os.Stderr, \"Failed to list workspaces %v\", err)\n        return\n    }\n\n    fmt.Fprintf(os.Stdout, \"Retrieved workspaces %v\", response.Msg.GetResult())\n}\n```","metadata":{"source":"https://gitpod.io/docs/references/gitpod-public-api"}}],["379",{"pageContent":"fmt.Fprintf(os.Stdout, \"Retrieved workspaces %v\", response.Msg.GetResult())\n}\n```\n\n```json\n{\n  \"result\": [\n    {\n      \"workspaceId\": \"<WORKSPACE_ID>\",\n      \"ownerId\": \"<USER_ID>\",\n      \"context\": {\n        \"contextUrl\": \"https://github.com/gitpod-io/empty\",\n        \"git\": {\n          \"normalizedContextUrl\": \"https://github.com/gitpod-io/empty\"\n        }\n      },\n      \"description\": \"gitpod-io/empty \",\n      \"status\": {\n        \"instance\": {\n          \"instanceId\": \"<INSTANCE_ID>\",\n          \"workspaceId\": \"<WORKSPACE_ID>\",\n          \"createdAt\": \"2022-12-19T08:36:47.254Z\",\n          \"status\": {\n            \"statusVersion\": \"<STATUS_VERSION>\",\n            \"phase\": \"PHASE_STOPPED\",\n            \"conditions\": {},\n            \"url\": \"https://<WORKSPACE_ID>.ws-us79.gitpod.io\",\n            \"admission\": \"ADMISSION_LEVEL_OWNER_ONLY\"\n          }\n        }\n      }\n    }\n  ]\n}\n```\n\nRequest Parameters:","metadata":{"source":"https://gitpod.io/docs/references/gitpod-public-api"}}],["380",{"pageContent":"Request Parameters:\n\nParameter Description Type Required\npageSize (Coming Soon) It is maximum number of results we expect Int32 false\n\nResponse Parameters:\n\nParameter Description Type\nnextPageToken Next Page Token string\nworkspaceId Workspace Id string\nownerId User Id string\nprojectId Project Id string\ncontext contextUrl with details of git or prebuild or snapshot string\nstatus will return Instance Id if currently assigned Instance Id to this workspace. Empty when there is no Instance Id assigned string\n\nGet a workspace\n\nReturns a single workspace.\n\n```bash title=\"cURL\"\ncurl 'https://api.gitpod.io/gitpod.experimental.v1.WorkspacesService/GetWorkspace' \\\n  -H 'content-type: application/json' \\\n  -H 'Authorization: Bearer <YOUR_ACCESS_TOKEN>' \\\n  --data '{\"workspaceId\":\"<WORKSPACE_ID>\"}'\n```\n\n```go\nfunc ExampleGetWorkspace() {\n    token := \"<YOUR_ACCESS_TOKEN>\"","metadata":{"source":"https://gitpod.io/docs/references/gitpod-public-api"}}],["381",{"pageContent":"```go\nfunc ExampleGetWorkspace() {\n    token := \"<YOUR_ACCESS_TOKEN>\"\n\n    gitpod, err := client.New(client.WithCredentials(token))\n    if err != nil {\n        fmt.Fprintf(os.Stderr, \"Failed to construct gitpod client %v\", err)\n        return\n    }\n\n    response, err := gitpod.Workspaces.GetWorkspace(context.Background(), connect.NewRequest(&v1.GetWorkspaceRequest{\n        WorkspaceId: \"<WORKSPACE_ID>\",\n    }))\n    if err != nil {\n        fmt.Fprintf(os.Stderr, \"Failed to get workspace %v\", err)\n        return\n    }\n\n    fmt.Fprintf(os.Stdout, \"Retrieved workspace %v\", response.Msg.GetResult())\n}\n```","metadata":{"source":"https://gitpod.io/docs/references/gitpod-public-api"}}],["382",{"pageContent":"fmt.Fprintf(os.Stdout, \"Retrieved workspace %v\", response.Msg.GetResult())\n}\n```\n\n```json\n{\n  \"result\": {\n    \"workspaceId\": \"<WORKSPACE_ID>\",\n    \"ownerId\": \"<USER_ID>\",\n    \"context\": {\n      \"contextUrl\": \"https://github.com/gitpod-io/empty\",\n      \"git\": {\n        \"normalizedContextUrl\": \"https://github.com/gitpod-io/empty\"\n      }\n    },\n    \"description\": \"gitpod-io/empty \",\n    \"status\": {\n      \"instance\": {\n        \"instanceId\": \"<INSTANCE_ID>\",\n        \"workspaceId\": \"<WORKSPACE_ID>\",\n        \"createdAt\": \"2022-12-22T07:43:16.152Z\",\n        \"status\": {\n          \"statusVersion\": \"<STATUS_VERSION>\",\n          \"phase\": \"PHASE_RUNNING\",\n          \"conditions\": {\n            \"firstUserActivity\": \"2022-12-22T07:43:21.732Z\"\n          },\n          \"url\": \"https://<WORKSPACE_ID>.ws-us80.gitpod.io\",\n          \"admission\": \"ADMISSION_LEVEL_OWNER_ONLY\"\n        }\n      }\n    }\n  }\n}\n```\n\nRequest Parameters:\n\nParameter Description Type Required\nworkspaceId Workspace Id string true","metadata":{"source":"https://gitpod.io/docs/references/gitpod-public-api"}}],["383",{"pageContent":"Request Parameters:\n\nParameter Description Type Required\nworkspaceId Workspace Id string true\n\nResponse Parameters:\n\nParameter Description Type\nworkspaceId Workspace Id string\nownerId User Id string\nprojectId Project Id string\ncontext contextUrl with details of git or prebuild or snapshot string\nstatus will return Instance Id if currently assigned Instance Id to this workspace. Empty when there is no Instance Id assigned string\n\nCreate Workspace (Coming Soon)\n\nCreates a new workspace from any context URL (Repository, Issues, Pull Requests, Files, etc.)\n\nStart workspace (Coming Soon)\n\nStarts an older workspace (instance).\n\nUsage: StartWorkspace()\n\nRequest Parameters:\n\nParameter Description Type Required\nworkspaceId Workspace Id that needs to be stopped string true\n\nResponse Parameters:\n\nParameter Description Type\ninstanceId Instance Id string\nworkspaceUrl URL of the started workspace string\n\nStop workspace\n\nStops a running workspace (instance).","metadata":{"source":"https://gitpod.io/docs/references/gitpod-public-api"}}],["384",{"pageContent":"Response Parameters:\n\nParameter Description Type\ninstanceId Instance Id string\nworkspaceUrl URL of the started workspace string\n\nStop workspace\n\nStops a running workspace (instance).\n\n```bash title=\"cURL\"\ncurl 'https://api.gitpod.io/gitpod.experimental.v1.WorkspacesService/StopWorkspace' \\\n  -H 'content-type: application/json' \\\n  -H 'Authorization: Bearer <YOUR_ACCESS_TOKEN>' \\\n  --data '{\"workspaceId\":\"<WORKSPACE_ID>\"}'\n```\n\nRequest Parameters:\n\nParameter Description Type Required\nworkspaceId Workspace Id that needs to be stopped string true\n\nResponse: It stops the requested workspace.\n\nDelete workspace\n\nIt deletes the workspace &amp; also stops the workspace if it is running.\n\n```bash title=\"cURL\"\ncurl 'https://api.gitpod.io/gitpod.experimental.v1.WorkspacesService/DeleteWorkspace' \\\n  -H 'content-type: application/json' \\\n  -H 'Authorization: Bearer <YOUR_ACCESS_TOKEN>' \\\n  --data '{\"workspaceId\":\"<WORKSPACE_ID>\"}'\n```\n\nRequest Parameters:","metadata":{"source":"https://gitpod.io/docs/references/gitpod-public-api"}}],["385",{"pageContent":"Request Parameters:\n\nParameter Description Type Required\nworkspaceId Workspace Id that needs to be deleted string true\n\nResponse: It deletes the requested workspace.","metadata":{"source":"https://gitpod.io/docs/references/gitpod-public-api"}}],["386",{"pageContent":"Resource: Teams\n\nCreate a team\n\nCreates a team.\n\n```bash title=\"cURL\"\ncurl 'https://api.gitpod.io/gitpod.experimental.v1.TeamsService/CreateTeam' \\\n  -H 'content-type: application/json' \\\n  -H 'Authorization: Bearer <YOUR_ACCESS_TOKEN>' \\\n  --data '{\"name\":\"<TEAM_NAME>\"}'\n```\n\n```json\n{\n  \"team\": {\n    \"id\": \"<TEAM_ID>\",\n    \"name\": \"<TEAM_NAME>\",\n    \"members\": [\n      {\n        \"userId\": \"<USER_ID>\",\n        \"role\": \"TEAM_ROLE_OWNER\",\n        \"memberSince\": \"2022-12-22T07:53:52.210Z\",\n        \"avatarUrl\": \"<USER_AVATAR_URL>\",\n        \"fullName\": \"<USER_FULL_NAME>\",\n        \"primaryEmail\": \"<USER_EMAIL>\"\n      }\n    ],\n    \"teamInvitation\": { \"id\": \"<TEAM_INVITATION_ID>\" }\n  }\n}\n```\n\nRequest Parameters:\n\nParameter Description Type Required\nname Team name string true\n\nResponse Parameters:\n\nParameter Description Type\nid UUID of Team string\nname Name of team string\ncreationTime Creation time of team string\nmembers List of members in a team array\n\nGet a team\n\nReturns a single team.","metadata":{"source":"https://gitpod.io/docs/references/gitpod-public-api"}}],["387",{"pageContent":"Parameter Description Type\nid UUID of Team string\nname Name of team string\ncreationTime Creation time of team string\nmembers List of members in a team array\n\nGet a team\n\nReturns a single team.\n\n```bash title=\"cURL\"\ncurl 'https://api.gitpod.io/gitpod.experimental.v1.TeamsService/GetTeam' \\\n  -H 'content-type: application/json' \\\n  -H 'Authorization: Bearer <YOUR_ACCESS_TOKEN>' \\\n  --data '{\"teamId\":\"<TEAM_ID>\"}'\n```\n\n```go\nfunc ExampleGetTeam() {\n    token := \"<YOUR_ACCESS_TOKEN>\"\n\n    gitpod, err := client.New(client.WithCredentials(token))\n    if err != nil {\n        fmt.Fprintf(os.Stderr, \"Failed to construct gitpod client %v\", err)\n        return\n    }\n\n    response, err := gitpod.Teams.GetTeam(context.Background(), connect.NewRequest(&v1.GetTeamRequest{\n        TeamId: \"<TEAM_ID>\",\n    }))\n    if err != nil {\n        fmt.Fprintf(os.Stderr, \"Failed to get team %v\", err)\n        return\n    }\n\n    fmt.Fprintf(os.Stdout, \"Retrieved team %v\", response.Msg.GetTeam())\n}\n```","metadata":{"source":"https://gitpod.io/docs/references/gitpod-public-api"}}],["388",{"pageContent":"fmt.Fprintf(os.Stdout, \"Retrieved team %v\", response.Msg.GetTeam())\n}\n```\n\n```json\n{\n  \"team\": {\n    \"id\": \"<TEAM_ID>\",\n    \"name\": \"<TEAM_NAME>\",\n    \"members\": [\n      {\n        \"userId\": \"<USER_ID>\",\n        \"role\": \"TEAM_ROLE_MEMBER\",\n        \"memberSince\": \"2022-12-22T08:05:20.465Z\",\n        \"avatarUrl\": \"<USER_AVATAR_URL>\",\n        \"fullName\": \"<USER_FULL_NAME>'s Bot\",\n        \"primaryEmail\": \"<USER_EMAIL>\"\n      },\n      {\n        \"userId\": \"<USER_ID>\",\n        \"role\": \"TEAM_ROLE_OWNER\",\n        \"memberSince\": \"2022-12-22T07:53:52.210Z\",\n        \"avatarUrl\": \"<USER_AVATAR_URL>\",\n        \"fullName\": \"<USER_FULL_NAME>\",\n        \"primaryEmail\": \"<USER_EMAIL>\"\n      }\n    ],\n    \"teamInvitation\": { \"id\": \"<TEAM_INVITATION_ID>\" }\n  }\n}\n```\n\nRequest Parameters:\n\nParameter Description Type Required\nteamId Team Id string true\n\nResponse Parameters:","metadata":{"source":"https://gitpod.io/docs/references/gitpod-public-api"}}],["389",{"pageContent":"Request Parameters:\n\nParameter Description Type Required\nteamId Team Id string true\n\nResponse Parameters:\n\nParameter Description Type\nid UUID of Team string\nname Name of team string\ncreationTime Creation time of team string\nmembers List of members in a team array\n\nList all teams\n\nLists all the teams belongs to the authenticated user.\n\n```bash title=\"cURL\"\ncurl 'https://api.gitpod.io/gitpod.experimental.v1.TeamsService/ListTeams' \\\n  -H 'content-type: application/json' \\\n  -H 'Authorization: Bearer <YOUR_ACCESS_TOKEN>' \\\n  --data '{}'\n```","metadata":{"source":"https://gitpod.io/docs/references/gitpod-public-api"}}],["390",{"pageContent":"```go\nfunc ExampleListTeams() {\n    token := \"<YOUR_ACCESS_TOKEN>\"\n    gitpod, err := client.New(client.WithCredentials(token))\n    if err != nil {\n        fmt.Fprintf(os.Stderr, \"Failed to construct gitpod client %v\", err)\n        return\n    }\n    ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)\n    defer cancel()\n    response, err := gitpod.Teams.ListTeams(ctx, connect.NewRequest(&v1.ListTeamsRequest{}))\n    if err != nil {\n        fmt.Fprintf(os.Stderr, \"Failed to list teams %v\", err)\n        return\n    }\n\n    fmt.Fprintf(os.Stdout, \"Retrieved teams %v\", response.Msg.GetTeams())\n}\n```","metadata":{"source":"https://gitpod.io/docs/references/gitpod-public-api"}}],["391",{"pageContent":"fmt.Fprintf(os.Stdout, \"Retrieved teams %v\", response.Msg.GetTeams())\n}\n```\n\n```json\n{\n  \"teams\": [\n    {\n      \"id\": \"<TEAM_ID>\",\n      \"name\": \"<TEAM_NAME>\",\n      \"members\": [\n        {\n          \"userId\": \"<USER_ID>\",\n          \"role\": \"TEAM_ROLE_OWNER\",\n          \"memberSince\": \"2022-09-26T04:33:17.557Z\",\n          \"avatarUrl\": \"<USER_AVATAR_URL>\",\n          \"fullName\": \"<USER_FULL_NAME>\",\n          \"primaryEmail\": \"<USER_EMAIL>\"\n        }\n      ],\n      \"teamInvitation\": { \"id\": \"<TEAM_INVITATION_ID>\" }\n    },\n    {\n      \"id\": \"<TEAM_ID>\",\n      \"name\": \"<TEAM_NAME>\",\n      \"members\": [\n        {\n          \"userId\": \"<USER_ID>\",\n          \"role\": \"TEAM_ROLE_OWNER\",\n          \"memberSince\": \"2022-09-25T15:41:41.352Z\",\n          \"avatarUrl\": \"<USER_AVATAR_URL>\",\n          \"fullName\": \"<USER_FULL_NAME>\",\n          \"primaryEmail\": \"<USER_EMAIL>\"\n        }\n      ],\n      \"teamInvitation\": { \"id\": \"<TEAM_INVITATION_ID>\" }\n    }\n  ]\n}\n```\n\nRequest Parameters:","metadata":{"source":"https://gitpod.io/docs/references/gitpod-public-api"}}],["392",{"pageContent":"Request Parameters:\n\nParameter Description Type Required\npageSize It is maximum number of results we expect Int32 false\n\nResponse Parameters:\n\nParameter Description Type\nteams List of teams of a user array\n\nJoin a team\n\nJoins a team.\n\n```bash title=\"cURL\"\ncurl 'https://api.gitpod.io/gitpod.experimental.v1.TeamsService/JoinTeam' \\\n  -H 'content-type: application/json' \\\n  -H 'Authorization: Bearer <YOUR_ACCESS_TOKEN>' \\\n  --data '{\"invitationId\":\"<TEAM_INVITATION_ID>\"}'\n```\n\n```json\n{\n  \"team\": {\n    \"id\": \"<TEAM_ID>\",\n    \"name\": \"<TEAM_NAME>\",\n    \"members\": [\n      {\n        \"userId\": \"<USER_ID>\",\n        \"role\": \"TEAM_ROLE_OWNER\",\n        \"memberSince\": \"2022-12-22T07:53:52.210Z\",\n        \"avatarUrl\": \"<USER_AVATAR_URL>\",\n        \"fullName\": \"<USER_FULL_NAME>\",\n        \"primaryEmail\": \"<USER_EMAIL>\"\n      }\n    ],\n    \"teamInvitation\": { \"id\": \"<TEAM_INVITATION_ID>\" }\n  }\n}\n```\n\nRequest Parameters:\n\nParameter Description Type Required\ninvitationId Team Invitation ID string true\n\nResponse Parameters:","metadata":{"source":"https://gitpod.io/docs/references/gitpod-public-api"}}],["393",{"pageContent":"Request Parameters:\n\nParameter Description Type Required\ninvitationId Team Invitation ID string true\n\nResponse Parameters:\n\nParameter Description Type\nid UUID of Team string\nname Name of team string\ncreationTime Creation time of team string\nmembers List of members in a team array\n\nReset team invitation\n\nResets the team invitation.\n\n```bash title=\"cURL\"\ncurl 'https://api.gitpod.io/gitpod.experimental.v1.TeamsService/ResetTeamInvitation' \\\n  -H 'content-type: application/json' \\\n  -H 'Authorization: Bearer <YOUR_ACCESS_TOKEN>' \\\n  --data '{\"teamId\":\"<TEAM_ID>\"}'\n```\n\n```json\n{\n  \"teamInvitation\": {\n    \"id\": \"<TEAM_INVITATION_ID>\"\n  }\n}\n```\n\nRequest Parameters:\n\nParameter Description Type Required\nteamId Team Invitation ID string true\n\nResponse Parameters:\n\nParameter Description Type\ninvitationId new Invitation Id of Team string\n\nUpdate a team member role\n\nUpdates a team member role","metadata":{"source":"https://gitpod.io/docs/references/gitpod-public-api"}}],["394",{"pageContent":"Response Parameters:\n\nParameter Description Type\ninvitationId new Invitation Id of Team string\n\nUpdate a team member role\n\nUpdates a team member role\n\n```bash title=\"cURL\"\ncurl 'https://api.gitpod.io/gitpod.experimental.v1.TeamsService/UpdateTeamMember' \\\n  -H 'content-type: application/json' \\\n  -H 'Authorization: Bearer <YOUR_ACCESS_TOKEN>' \\\n  --data '{\"teamId\":\"<TEAM_ID>\", \"teamMember\": {\"userId\":\"<USER_ID>\", \"role\":\"TEAM_ROLE_OWNER\"}}'\n```\n\n```json\n{\n  \"teamMember\": {\n    \"userId\": \"<USER_ID>\",\n    \"role\": \"TEAM_ROLE_OWNER\"\n  }\n}\n```\n\nRequest Parameters:\n\nParameter Description Type Required\nteamId Team name string true\nuserId User ID of a team member being updated string true\nrole Role of a team member: TEAM_ROLE_OWNER or TEAM_ROLE_MEMBER string true\n\nResponse Parameters:\n\nParameter Description Type\nuserId User ID of team member string\nrole New role of team string\n\nDelete team member\n\nDeletes a team member.","metadata":{"source":"https://gitpod.io/docs/references/gitpod-public-api"}}],["395",{"pageContent":"Response Parameters:\n\nParameter Description Type\nuserId User ID of team member string\nrole New role of team string\n\nDelete team member\n\nDeletes a team member.\n\n```bash title=\"cURL\"\ncurl 'https://api.gitpod.io/gitpod.experimental.v1.TeamsService/DeleteTeamMember' \\\n  -H 'content-type: application/json' \\\n  -H 'Authorization: Bearer <YOUR_ACCESS_TOKEN>' \\\n  --data '{\"teamId\":\"<TEAM_ID>\", \"teamMemberId\": \"<USER_ID>\"}'\n```\n\nRequest Parameters:\n\nParameter Description Type Required\nteamId Team name string true\nteamMemberId Id of team member being updated string true\n\nResponse: It deletes the team member from the team.\n\nDelete a team\n\nDeletes a team.\n\n```bash title=\"cURL\"\ncurl 'https://api.gitpod.io/gitpod.experimental.v1.TeamsService/DeleteTeam' \\\n  -H 'content-type: application/json' \\\n  -H 'Authorization: Bearer <YOUR_ACCESS_TOKEN>' \\\n  --data '{\"teamId\":\"<TEAM_ID>\"}'\n```\n\nRequest Parameters:\n\nParameter Description Type Required\nteamId Team name string true\n\nResponse: It deletes the requested team.","metadata":{"source":"https://gitpod.io/docs/references/gitpod-public-api"}}],["396",{"pageContent":"API language clients\n\nGo\n\nThe following is an example of how to use the Go client library with the Public API for retrieving teams data. Replace the environment variable PERSONAL_PAT with your own personal access token, for example: export PERSONAL_PAT=&lt;your-personal-pat&gt;\n\n```go\n// Download the helper library using go get -u github.com/gitpod-io/gitpod/components/public-api/go\npackage main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"os\"\n\n    \"github.com/bufbuild/connect-go\"\n    \"github.com/gitpod-io/gitpod/components/public-api/go/client\"\n    v1 \"github.com/gitpod-io/gitpod/components/public-api/go/experimental/v1\"\n)\n\nfunc main() {\n    token := \"<YOUR_ACCESS_TOKEN>\"\n\n    gitpod, err := client.New(client.WithCredentials(token))\n    if err != nil {\n        fmt.Fprintf(os.Stderr, \"Failed to construct gitpod client %v\", err)\n        return\n    }\n\n    response, err := gitpod.Teams.ListTeams(context.Background(), connect.NewRequest(&v1.ListTeamsRequest{}))\n    if err != nil {\n        fmt.Fprintf(os.Stderr, \"Failed to list teams %v\", err)\n        return\n    }\n\n    fmt.Fprintf(os.Stdout, \"Retrieved teams %v\", response.Msg.GetTeams())\n}\n```\n\nTypeScript\n\nüöß Under development","metadata":{"source":"https://gitpod.io/docs/references/gitpod-public-api"}}],["397",{"pageContent":"__SPLIT_HERE__\n.gitpod.yml\n\nThe .gitpod.yml file at the root of your project is where you tell Gitpod how to prepare &amp; build your project, start development servers and configure continuous prebuilds for GitHub.\n\nBelow is a full reference of all available properties. To see the underlying schema, please refer to gitpod-io/gitpod in the gitpod-io/gitpod repository.\n\n.gitpod.ymladditionalRepositories\ncheckoutLocation\ncoreDump\ngitConfig\ngithubprebuilds.addBadge\nprebuilds.addCheck\nprebuilds.addComment\nprebuilds.addLabel\nprebuilds.branches\nprebuilds.master\nprebuilds.pullRequests\nprebuilds.pullRequestsFromForks\n\n\nimageimage.file\nimage.context\n\n\njetbrainsjetbrains.plugins\njetbrains.[product]\njetbrains.[product].plugins\njetbrains.[product].prebuilds\njetbrains.[product].vmoptions\n\n\nportsports[n].name\nports[n].description\nports[n].onOpen\nports[n].port\nports[n].visibility\n\n\ntaskstasks[n].before\ntasks[n].command\ntasks[n].env\ntasks[n].init\ntasks[n].name\ntasks[n].openIn\ntasks[n].openMode\ntasks[n].prebuild\n\n\nmainConfiguration\nvscodevscode.extensions\n\n\nworkspaceLocation\n\n__SPLIT_HERE__\nadditionalRepositories\n\nadditionalRepositories is currently in Beta. Send feedback.\n\nDefines additional source control repositories to clone and where the repository is cloned under /workspaces\n\nType Default\nobject &lt;empty&gt;\n\nDemo\n\n\n\nExample\n\n```yaml\nadditionalRepositories:\n  - url: https://github.com/gitpod-io/demo-multi-repo-backend\n    # checkoutLocation is optional and relative to /workspaces.\n    # by default the location defaults to the repository name.\n    checkoutLocation: backend\n```\n\nWhen the above configuration is defined then the following additional steps happen when Gitpod workspace is started:\n\nIf you open a workspace on a branch, Gitpod will clone the same-named branch in all repositories. If such a branch doesn‚Äôt exist Gitpod checks out the default branch.\nThe contents of the branch is cloned under /workspaces/\nThe contents of https://github.com/gitpod-io/demo-multi-repo-backend is cloned to /workspaces/backend\n\nAfter all of the source control repositories have been cloned then the before, init and command tasks are executed as per normal.\n\nIf you need to run commands (such as package installation or compilation) on the source control repositories which have been cloned then change your working directory to the use configured or default checkoutLocation location using the before task.\n\nExample\n\n```yaml\n# example .gitpod.yml from https://github.com/gitpod-io/demo-multi-repo-frontend\nadditionalRepositories:\n  - url: https://github.com/gitpod-io/demo-multi-repo-backend\n    # checkoutLocation is optional and relative to /workspaces.\n    # by default the location defaults to the repository name.\n    checkoutLocation: backend\n\ntasks:\n  - name: backend\n    # change working directory as per configured in `checkoutLocation`\n    # which is configured above as `/workspaces/backend`\n    before: |\n      cd ../backend\n    init: |\n      echo npm install\n    command: |\n      echo npm run dev\n\n    # changing of working directory is not required as these tasks will\n    # by default by executed in `/workspaces/demo-multi-repo-frontend`\n  - name: frontend\n    init: |\n      echo npm install\n      echo npm run build\n    command: |\n      echo npm run dev\n```\n\n__SPLIT_HERE__\ncheckoutLocation\n\nDefine where Gitpod checks out the project&#39;s code, relative to /workspace.\n\nIn most cases, this is not needed. If you work on an older Go project, please see the Go Language Page for more details.\n\nType Default\nstring /workspace\n\nExample\n\n```yaml\ncheckoutLocation: \"go/src/github.com/demo-apps/go-gin-app\"\n```","metadata":{"source":"https://gitpod.io/docs/references/gitpod-yml"}}],["398",{"pageContent":"coreDump\n\nDefine workspace core dump behavior.\n\nFor most cases, setting the coreDump property is not required. However, it can be a valuable feature to debug C++, or when debugging add-ons in Rust, Python, or node.js.\n\nType Default\nobject &lt;empty&gt;\n\nExample\n\n```yaml\ncoreDump:\n  enabled: true\n```\n\nYou can also set custom size values for the generated core files using the softLimit and hardLimit values (see example below). The setting softLimit configures the upper limit on the size of the core dump file that will be produced if a process receives a core dump signal, while hardLimit allows setting a hard limit to act as a ceiling for the soft limit.\n\n```yaml\ncoreDump:\n  enabled: true\n  softLimit: <bytes>\n  hardLimit: <bytes>\n```\n\nFor more details, please see the Linux man page for getrlimit\n\n__SPLIT_HERE__\ngitConfig\n\nDefine a workspace&#39;s git configuration as key-value pairs.\n\nPlease refer to https://git-scm.com/docs/git-config#_values for a list of accepted values.\n\nType Default\nobject &lt;empty&gt;\n\nExample\n\n```yaml\ngitConfig:\n  alias.st: status\n  core.autocrlf: input\n```\n\n__SPLIT_HERE__\ngithub\n\nConfigure the GitHub Gitpod app. At this time, the following configuration is used to configure continuous prebuilds for GitHub repositories.\n\nType Default\nobject &lt;empty&gt;\n\nExample\n\n```yaml\ngithub:\n  prebuilds:\n    master: true\n    branches: true\n    pullRequests: true\n    pullRequestsFromForks: true\n    addCheck: false\n    addComment: false\n    addBadge: true\n```\n\nprebuilds.addBadge\n\nGitpod can modify the description of a pull request to add an ‚ÄúOpen in Gitpod‚Äù button. This approach produces fewer GitHub notifications than adding a comment, but can also create a concurrent editing conflict when the bot and a user try to edit the description of a pull request at the same time.\n\nAn Open in Gitpod badge in a PR description\n\nType Default\nboolean false\n\nprebuilds.addCheck\n\nConfigure whether Gitpod registers itself as a status check to pull requests - much like a continuous integration system would do. By default a failing prebuild would not make the check fail. Set prevent-merge-on-error to block PR merging when prebuilds failed.\n\nTo learn more about status checks, please see the GitHub documentation about status checks.\n\nGitpod status check in a pull request\n\nType Default Values\nstring prevent-merge-on-error true, false, prevent-merge-on-error\n\nprebuilds.addComment\n\nGitpod can add a comment with an ‚ÄúOpen in Gitpod‚Äù button to your pull requests. Alternatively, you could add a badge to the pull request&#39;s description.\n\nAn Open in Gitpod badge in a PR comment\n\nType Default\nboolean false\n\nprebuilds.addLabel\n\nDeprecated.\n\nprebuilds.branches\n\nDefine whether Gitpod creates prebuilds for all branches.\n\nType Default\nboolean false\n\nprebuilds.master\n\nDefine whether Gitpod creates prebuilds for the default branch.\n\nType Default\nboolean true\n\nprebuilds.pullRequests\n\nDefine whether Gitpod creates prebuilds for pull requests from the original repository.\n\nType Default\nboolean true\n\nprebuilds.pullRequestsFromForks\n\nDefine whether Gitpod creates prebuilds for pull requests from forks.\n\nType Default\nboolean false","metadata":{"source":"https://gitpod.io/docs/references/gitpod-yml"}}],["399",{"pageContent":"image\n\nDefine a custom Docker image to be used for workspaces. To learn more, please review Custom Docker Image.\n\nPublic images are hosted on Docker Hub and can be referenced by their name, e.g. ubuntu:latest.\n\nTo see a list of Gitpod-provided images, please see gitpod-io/workspace-images.\n\nType Default\nobject or string gitpod/workspace-full\n\nExamples\n\nWith a public image\n\n```yaml\nimage: ubuntu:latest\n```\n\nWith a custom image\n\n```yaml\nimage:\n  file: .gitpod.Dockerfile\n```\n\nWith an optional context\n\n```yaml\nimage:\n  file: .gitpod.Dockerfile\n  context: ./docker-content\n```\n\nimage.file\n\nTo define a custom Docker image, you can use the following configuration:\n\nFor a list of examples, please see https://github.com/gitpod-io/workspace-images.\n\nType Default\nstring &lt;empty&gt;\n\nimage.context\n\nOptionally, you can set the image.context. This is useful when you want to copy files into the Docker image. The Docker docs describe this in more detail.\n\nType Default\nstring &lt;empty&gt;\n\n__SPLIT_HERE__\njetbrains\n\nJetBrains is currently in Beta ¬∑ Send feedback.\n\nDefine the integration between Gitpod and JetBrains IDEs.\n\nType Default\nobject &lt;empty&gt;\n\njetbrains.plugins\n\nJetBrains plugin support (via gitpod.yml) is currently in Beta ¬∑ Send feedback.\n\nDefine a list of plugins which should be installed for all compatible JetBrains IDEs when starting a workspace. To find the plugin identifier, from the JetBrains Marketplace, find the desired plugin, open the &#39;Versions&#39; tab, select any version and copy the &#39;Plugin ID&#39; (like ${publisher}.${name}).\n\nType Default\narray &lt;empty&gt;\n\njetbrains.[product]\n\nJetBrains is currently in Beta ¬∑ Send feedback.\n\nDefine the integration between Gitpod and a specific JetBrains IDE. Install plugins and configure prebuilds to speed up the IDE indexing.\n\nSpecify the &#39;product&#39; with one of the following values:\n\nintellij\ngoland\npycharm\nphpstorm\n\nType Default\nobject &lt;empty&gt;\n\njetbrains.[product].plugins\n\nJetBrains plugin support (via gitpod.yml) is currently in Beta ¬∑ Send feedback.\n\nDefine a list of plugins which should be installed for the given JetBrains IDE when starting a workspace. To find the plugin identifier, from the JetBrains Marketplace, find the desired plugin, open the &#39;Versions&#39; tab, select any version and copy the &#39;Plugin ID&#39; (like ${publisher}.${name}).\n\nType Default\narray &lt;empty&gt;\n\nExample\n\n```yaml\njetbrains:\n  intellij:\n    plugins:\n      - zielu.gittoolbox\n      - izhangzhihao.rainbow.brackets\n```\n\njetbrains.[product].prebuilds\n\nJetBrains prebuilds support (via gitpod.yml) is currently in Alpha ¬∑ Send feedback.\n\nDefine whether Gitpod enables prebuilds for a specific JetBrains IDE.\n\nType Default\nobject &lt;empty&gt;\n\nExample\n\n```yaml\njetbrains:\n  intellij:\n    prebuilds:\n      version: stable\n```\n\nThe version is defined as follows:\n\nType Default Values\nstring stable stable, latest, both\n\njetbrains.[product].vmoptions\n\nConfiguration of JVM options (via gitpod.yml) is currently in Alpha ¬∑ Send feedback.\n\nConfigure JVM options for a specific JetBrains IDE.\n\nType Default\nstring &lt;empty&gt;\n\nExample\n\n```yaml\njetbrains:\n  intellij:\n    vmoptions: \"-Xmx4g\"\n```","metadata":{"source":"https://gitpod.io/docs/references/gitpod-yml"}}],["400",{"pageContent":"ports\n\nConfigure how Gitpod treats various ports your application may listen on. You can learn more about this in the Exposing Ports documentation.\n\nType Default\narray &lt;empty&gt;\n\nExample\n\n```yaml\nports:\n  - name: Website\n    port: 3000\n    onOpen: open-preview\n  - name: VNC\n    description: full GUI Virtual Desktop\n    port: 6080\n    onOpen: open-browser\n  - name: Server\n    port: 10000\n    onOpen: ignore\n```\n\nports[n].name\n\nDefine a name for the port, which will be shown as a column in the output of gp ports list and in the Port column inside of the ports list in VS Code Browser and Desktop.\n\nMore detail\n\nType Default\nstring &lt;empty&gt;\n\nports[n].description\n\nAdds a description to the port, which will be shown as a column in the output of gp ports list.\n\nYou can find the port&#39;s description in the ports view table column, following the Address field (the same description can be found in the Remote Explorer as a tooltip [on hover] of the port).\n\nType Default\nstring &lt;empty&gt;\n\nports[n].onOpen\n\nDefine what to do when Gitpod detects a given port is being listened on.\n\nType Default Values\nstring &lt;empty&gt; open-browser,open-preview,notify,ignore\n\nPlease note: For JetBrains IDEs connected to Gitpod via JetBrains Gateway open-preview will behave exactly the same as open-browser, as there is no functionality for a web preview in the JetBrains IDE.\n\nports[n].port\n\nDefine a single port or a range of ports, e.g. 3000-3100.\n\nType Default\nnumber or string &lt;empty&gt;\n\nports[n].visibility\n\nDefine whether to expose the port publicly or keep it private.\n\nA public port allows you to share a URL for a given port with team members, for example if you want to get their feedback on a new feature you develop.\n\nType Default Values\nstring private private,public\n\n__SPLIT_HERE__\ntasks\n\nDefine how Gitpod prepares &amp; builds your project and how it can start the project&#39;s development server(s). To learn more, please visit Start Tasks. Each array element opens in its own terminal.\n\nType Default\narray &lt;empty&gt;\n\nExample\n\n```yaml\ntasks:\n  - before: sh ./scripts/setup.sh\n    init: npm install\n    command: npm run dev\n  - name: Database\n    init: sh ./scripts/seed-database.sh\n    command: npm start-db\n    env:\n      DB_HOST: localhost:3306\n      DB_USER: readOnlyUser\n```\n\ntasks[n].before\n\nA shell command to run before init and the main command. This command is executed on every start and is expected to terminate. If it fails, the following commands will not be executed.\n\nLearn more about Start Tasks in the docs.\n\nType Default\nstring &lt;empty&gt;\n\ntasks[n].command\n\nThe main shell command to run after before and init. This command is executed last on every start and doesn&#39;t have to terminate.\n\nLearn more about Start Tasks in the docs.\n\nType Default\nstring &lt;empty&gt;\n\ntasks[n].env\n\nDefine environment variables that will be available in the workspace.\n\nLearn more about Environment Variables in the docs.\n\nType Default\nobject &lt;empty&gt;\n\ntasks[n].init\n\nA shell command to run between before and the main command.\n\nThis task is executed only once. When you start a workspace that does not have a prebuild, init is executed at workspace start. When you start a workspace that has a prebuild, init executes as part of the prebuild, but does NOT execute again at workspace start.\n\nThis task is expected to terminate. If it fails, the command property will not be executed.\n\nLearn more about Start Tasks in the docs.\n\nType Default\nstring &lt;empty&gt;\n\ntasks[n].name\n\nA name for the task, also shown on the terminal tab.\n\nType Default\nstring &lt;empty&gt;\n\ntasks[n].openIn\n\nDeprecated. This does not have an impact in VS Code.\n\ntasks[n].openMode\n\nConfigure how the terminal should be opened relative to the previous task.\n\nType Default Values\nstring &lt;empty&gt; tab-after,tab-before,split-right,split-left\n\nNote: split-top and split-bottom are deprecated values.\n\ntasks[n].prebuild\n\nDeprecated. Please use the init task instead.","metadata":{"source":"https://gitpod.io/docs/references/gitpod-yml"}}],["401",{"pageContent":"mainConfiguration\n\nmainConfiguration is currently in Beta. Send feedback.\n\nDefines the repository with the main .gitpod.yml file and makes it possible to open the same workspace from any issue, branch or other context URL from any repository defined in a multi repository configuration.\n\nType Default\nstring &lt;empty&gt;\n\nDemo\n\n\n\nExample\n\n```yaml\nmainConfiguration: https://github.com/gitpod-io/demo-multi-repo-frontend\n```\n\n__SPLIT_HERE__\nvscode\n\nConfigure the VS Code editor.\n\nType Default\nobject &lt;empty&gt;\n\nvscode.extensions\n\nDefine a list of extensions which should be installed for users of this workspace. The identifier of an extension is always ${publisher}.${name}. For example: &#39;vscodevim.vim&#39;.\n\nPlease note, Gitpod uses the Open VSX registry to find extensions. If you cannot find an extension you know exists in your local VS Code, please get in touch with us or open a new PR in the open-vsx/publish-extensions repository to add the extension to Open VSX üôè.\n\nType Default\nobject &lt;empty&gt;\n\nBy default, extensions will use the latest available version unless you use a specific version number. The version number must use semantic versioning rules. If you are interested in importing an extension that is not published on the Open VSX registry you can directly use the full URL.\n\nExample\n\n```yaml\nvscode:\n  extensions:\n    - svelte.svelte-vscode\n    - bradlc.vscode-tailwindcss@0.6.11\n    - https://example.com/abc/releases/extension-0.26.0.vsix\n```\n\n__SPLIT_HERE__\nworkspaceLocation\n\nDefine which path Gitpod considers the project&#39;s workspace directory, relative to /workspace.\n\nIn most cases, this is not needed. If you work on an older Go project, please see the Go Languages page for more details.\n\nType Default\nstring /workspace\n\nExample\n\n```yaml\nworkspaceLocation: \".\"\n```","metadata":{"source":"https://gitpod.io/docs/references/gitpod-yml"}}],["402",{"pageContent":"__SPLIT_HERE__\nReferences\n\nBelow are links to Gitpod reference material you may find helpful:\n\nProduct Compatibility Matrix\n.gitpod.yml\nCommand Line Interface\nRoadmap\nGitpod Releases\nSecurity FAQ","metadata":{"source":"https://gitpod.io/docs/references/index"}}],["403",{"pageContent":"&lt;OpenGraph\ndata={{\n    description: &quot;Building a learning platform on Gitpod that allows instructors to teach, evaluate, and grade code lessons. They have taught over 4000 students in 6 countries and have received over $15 million USD in educational grants.&quot;,\n    title: &quot;4Geeks Academy case study: Building a learning platform on Gitpod&quot;,\n    keywords: &quot;education, funding, workshops, 4Geeks&quot;,\n  }}\n/&gt;\n\n&lt;CustomerHero\ntitle=&quot;Building a learning platform on Gitpod&quot;\ntext=&quot;4Geeks built LearnPack ‚Äì an educational platform that runs in Gitpod on VS Code and allows instructors to teach, evaluate, and grade code lessons. Using LearnPack and Gitpod, they have taught over 4000 students in 6 countries and have received over $15 million USD in educational grants.&quot;\ncard={{\n        image: &quot;/images/education/4geeks/teaser.png&quot;,\n        details:{\n            industry: &quot;Education&quot;,\n            plan: &quot;Organization, SaaS&quot;,\n            people: {\n                title: &quot;Students&quot;,\n                text: &quot;over 4000&quot;\n            },\n            website: {\n                href: &quot;https://4geeksacademy.com/&quot;,\n                text: &quot;4Geeks Academy&quot;,\n            }\n        }\n    }}\n/&gt;\n\n&lt;CompanyBenefits\nbenefits={[\n{\ntitle: &quot;$15M USD&quot;,\ntext: &quot;in educational grants&quot;,\n},\n{\ntitle: &quot;6 countries&quot;,\ntext: &quot;teaching students&quot;,\n},\n{\ntitle: &quot;4000+&quot;,\ntext: &quot;students taught w/ Gitpod&quot;,\n}]}\n/&gt;\n\n4Geeks Academy is an international code school operating bootcamps in the United States, Latin America, and Europe. Teaching full stack development, computer science, and machine learning, the academy has taught over 4000 students with a high job placement rate.\n\nAs possibly the largest institution using Gitpod as a tool to teach, we reached out to the academy&#39;s cofounder Alejandro to better understand how Gitpod fits into their business.\n\nAlejandro explains that 4Geeks Academy used to run on Replit Classrooms: an educational platform that allowed students to submit code exercises for grading, amongst other things. In January of 2021, the service was shut down and replaced with an expensive, paid alternative. All their courses and exercises, which they had set up in Classrooms, no longer worked.\n\nRather than rely on another hosted education offering, for which there was no guarantee they wouldn&#39;t end up in the same situation, they chose to build their own, and that&#39;s where LearnPack started.\n\n__SPLIT_HERE__\nBuilding an educational platform on Gitpod\n\nLearnPack is an interactive course framework that runs inside VS Code using Gitpod.\n\nWhen a student opens a repository in Gitpod, LearnPack uses Start Tasks to initialize the lesson and display both the course instruction and the lesson material at once. Youtube videos from the instructors are embedded directly into the application for a fully integrated learning experience.\n\nAlejandro expands on some of the advantages of using Gitpod in this way.\n\n&quot;Competitors require high-end MacBooks to do their courses, but with Gitpod, you can do it in a Chromebook. A single mom with a kid can be online doing exercises.&quot;\n\nBuilding the experience into Gitpod allows students to learn on any device with a browser. While universities often don&#39;t have large budgets for high-end development machines, affordable Android tablets are easier to procure.\n\nUniversities, Alejandro says, aren&#39;t interested in spending time developing their own educational tools. &quot;They just want a vendor who handles everything. In continuing education, it&#39;s all about vendors and teaching through content partners.&quot; With LearnPack, 4Geeks aims to be the ideal vendor.","metadata":{"source":"https://gitpod.io/for/education/4geeks"}}],["404",{"pageContent":"Going above and beyond the status quo\n\nEducators looking to take advantage of Gitpod often use it to run code repositories that accompany workshops and courses. Sometimes these are as simple as empty workspaces, providing a clean terminal and IDE with developer tools pre-installed.\n\nMore complex learning material usually involves application code and may require provisioning databases or infrastructure.\n\nLearnPack runs alongside such applications as a framework that allows instructors to evaluate and grade structured lessons.\n\n&quot;Gitpod&#39;s killer feature is that workspaces can be created while passing environment variables through the URL.&quot;\n\nLearnPack reads a user ID from the URL to report telemetry to the instructor. Keeping the instructors updated with how many hours their students spend training, when they open exercises, and even transmitting application logs allows them to curate their instruction to exactly where the learner is.\n\n__SPLIT_HERE__\nTaking the learning experience to the next level\n\nEvery new thing is a new layer of complexity, and students (and many teachers) have difficulty rationalizing their way around that. They often blame the wrong layer if they hit a bug in their code. It takes time and experience to build mental models of the boundaries between different pieces of tech.\n\nThe more LearnPack can appear to be a single cohesive layer, the better the learning experience is.\n\n&quot;One feature we&#39;re really looking forward to is the ability to list workspaces for a user,&quot; he adds. At the moment, students have to go to their Gitpod dashboard to see their workspaces, but when Gitpod&#39;s public API is released, viewing, starting, and stopping workspaces could become an integrated part of LearnPack.\n\n4Geeks has received over $15M in educational funding, including $10M from Lyft, $1.5M from United Way, and several large government grants. They have also partnered with Miami Dade College‚Äîthe largest university in the US‚Äîand other prominent schools in Mexico, Venezuela, Uruguay, and Spain, to run their coding courses.\n\nBeyond their work with the academy, 4Geeks is launching a free platform to the general public where anyone will be able to learn with Gitpod.\n\nGitpod appreciates the work Alejandro and the 4Geeks team have put into building an excellent platform, and we thank them for the interview that led to this case study.","metadata":{"source":"https://gitpod.io/for/education/4geeks"}}],["405",{"pageContent":"&lt;OpenGraph\ndata={{\n    description:\n      &quot;Teaching thousands of students using Gitpod. Saving 20 minutes every workshop. Learn how Bruno uses Gitpod to teach Python.&quot;,\n    title: &quot;Bruno Rocha case study: Teaching python with Gitpod&quot;,\n    keywords: &quot;education, python, rust, workshops, Bruno Rocha&quot;,\n  }}\n/&gt;\n\n&lt;CustomerHero\ntitle=&quot;Teaching thousands of students using Gitpod&quot;\ntext=&quot;Gitpod helped Bruno Rocha teach students Python and Rust reducing the amount of in-person support each student needed and allowing students to learn on any device.&quot;\ncard={{\n        image: &quot;/images/education/bruno-rocha/teaser.png&quot;,\n        details:{\n            industry: &quot;Education&quot;,\n            plan: &quot;Organization, SaaS&quot;,\n            people: {\n                title: &quot;Students&quot;,\n                text: &quot;over 1000&quot;\n            },\n            website: {\n                href: &quot;https://twitter.com/rochacbruno&quot;,\n                text: &quot;@rochacbruno&quot;,\n            }\n        }\n    }}\n/&gt;\n\n&lt;CompanyBenefits\nbenefits={[\n{\ntitle: &quot;12&quot;,\ntext: &quot;years teaching&quot;,\n},\n{\ntitle: &quot;20min&quot;,\ntext: &quot;saved per workshop&quot;,\n},\n{\ntitle: &quot;1000&#39;s&quot;,\ntext: &quot;of students taught w/ Gitpod&quot;,\n}]}\n/&gt;\n\nBruno Rocha is an engineer at RedHat and for the past 12 years he&#39;s been an online educator. He runs workshops teaching students to code using python and rust.\n\nBruno&#39;s workshops cater to students using many different operating systems, with some on Mac, on Windows, on Linux, some tablets, and even some mobile environments.\n\n__SPLIT_HERE__\nFighting setup issues for each student\n\nFor each repository, he would write specific sections in the documentation to walk students through setting up any of the possible operating systems.\n\nBut there was a lot of variance within operating systems too. Two Linux users could be using entirely different shells and have different versions of python installed. Writing bash scripts that perform consistently across environments is not trivial. Having students change their python version for a course, especially if they have other projects that rely on a different version, is also challenging.\n\nAt the time, those workshops were all in-person events. Bruno had the opportunity to help his students one-on-one. As each student was getting set up for the lesson, Bruno could go directly into their machine to configure their environment and make sure everything was ready to go.\n\nBut after switching to online workshops, that physical access stopped being possible, and Bruno needed to find a new solution.","metadata":{"source":"https://gitpod.io/for/education/bruno-rocha"}}],["406",{"pageContent":"Eliminating problems with Gitpod\n\n&quot;I tested other alternatives, and when I found Gitpod it was perfectly what I wanted. Just give them a single link&quot;, Bruno says. &quot;They can click and enter a ready-to-use environment.&quot;\n\nBruno started using Gitpod in his classes last year.\n\nWithin a Gitpod workspace, dependencies can be pre-installed at specific versions, so students are guaranteed to get an identical experience no matter how their local machine is configured.\n\nProblems with differences between Mac, Windows, and Linux went away immediately. With Gitpod, every student was on the same environment, entirely eliminating the setup issues that used to require personal attention.\n\n&quot;When they have problems, I can just send some Gitpod documentation links, which saves me a lot of time.&quot;\n\nBruno explains that the code repositories were configured to start terminals automatically. From the moment a student opens a workspace, the application is running and the student is ready to follow along.\n\nBruno&#39;s students still had their own preferences about which tools to use. While most would use VS Code in the web editor, some would work in vim or neovim; sometimes in the integrated terminal, sometimes connecting remotely over SSH. Gitpod allows developers to use their preferred IDE rather than prescribing a one-size-fits-all solution. &quot;So I think it&#39;s very flexible,&quot; Bruno says. &quot;There&#39;s no way that any training or workshop won&#39;t work on a Gitpod environment.&quot;\n\nIn April, Bruno hosted a workshop event called Python Week with over 2000 live viewers. During the 5 days of Python Week, students were provided with a GitHub repository pre-configured for Gitpod. Students were able to get started immediately with the learning materials and follow along within the codebase over the course of the workshop.","metadata":{"source":"https://gitpod.io/for/education/bruno-rocha"}}],["407",{"pageContent":"Working with Docker gives developers the ability to develop and deploy applications of all types locally without adding dependencies and binaries to their local development environment. Using Docker is used throughout the development lifecycle for fast, easy, and portable application development.\n\nAppwrite uses Docker to make spinning up multiple services as quickly as possible in a self-hosted environment, but we‚Äôre always looking at ways to give developers who are less familiar with Docker ways to try Appwrite. This is where Gitpod comes in. Gitpod is one way to combine the power of Docker and Appwrite together to get started quickly. This post shows you how to use Appwrite and Gitpod together to spin up a REST API with database access, authentication, storage, and more without installing anything on your local computer.\n\nGitpod is a platform that helps you spin up fresh, automated developer environments for each task, in the cloud, in seconds. The vision of Gitpod is to remove all friction from the developer experience &amp; bring back joy and speed to developers&#39; workflows.\n\nThe goal of Appwrite is to make getting started and scaling with application development as quickly as possible. Traditionally, you would need to install Docker on your local machine to run Appwrite. Now with Appwrite and Gitpod, you can spin up Appwrite instances for multiple projects with a couple of steps!\n\nWe‚Äôve set up a template repo with Gitpod and Appwrite together. You can start a new developer environment with this button:\n\nOpen in Gitpod\n\nYou can also check out our demo application built with Gitpod, Appwrite, and Svelte: https://github.com/appwrite/demo-todo-with-svelte\n\nJust click the ‚ÄúOpen in Gitpod‚Äù button, log in to GitHub and you‚Äôll be up and running! You can also fork the repo and customize it even further! üëè\n\nWe look forward to integrating more with Gitpod in the future! Check out the Gitpod homepage for more information and new development environment templates. Follow @appwrite and @gitpod on Twitter for more updates!\n\nLearn More\n\nüöÄ Getting started Tutorial\nüöÄ Appwrite GitHub\nüìú Appwrite Docs\nüí¨ Discord Community","metadata":{"source":"https://gitpod.io/guides/appwrite-and-gitpod/index"}}],["408",{"pageContent":"Working with ephemeral developer environments has many advantages. When every new workspace starts from a clean slate, you never have to worry about uncommitted changes causing problems.\n\nBut sometimes you want uncommitted changes. Some things (configuration, secrets, etc) just shouldn&#39;t enter source control.\n\nIn a long-lived development environment, you can leave a .env file on the file system and it will survive the length of your project. When you integrate with a new service, you add their API keys to the file and be done with it.\n\nWith Gitpod, creating a .env file works wonderfully for precisely one workspace. You can close and reopen that workspace as many times as you want and your .env file will still be there, but those who embrace ephemeral development wholeheartedly and want a new workspace for each task will quickly notice they need to set everything up again.\n\nSo how do you persist a file between workspaces without committing it to source control? You store it securely in a database.\n\nThe most convenient database to use is Gitpod&#39;s workspace environment variable storage. You can encode your .env file as a base64 string, and use the gp tool to store it in a Gitpod environment variable. You can then automate restoring from the environment variable to keep the .env persisted between workspaces.\n\nThe Gitpod CLI is built-in: simply run gp env DOTENV=value and you will be able to read $DOTENV in every workspace. If you&#39;re ready to start persisting files, follow the instructions below.\n\nNote: The maximum length of an environment variable value is 32k, so if you have exceptionally large files to persist, consider an alternative solution, like an enterprise secrets manager.\n\n__SPLIT_HERE__\nSaving the .env file after changes\n\nBase64 outputs text with a standard character set and no whitespace, so it&#39;s a good place to start. It does add line breaks though, which the tr text replacement utility can delete.\n\n```sh\n$ base64 .env\n\nOVRMQVNfVVJEEE1vbmdvZGIrc3sJ2Oi8vbXJnZGV2OlRMfaSnl0T1dFUVNpefFKVmZ\ndnVapdGkubW9uZ29hYi5uZXDvQdWRtaXQxdX2Rldj9ydZCDeVdyaQRlcz10cnVlJnc\nCk5FWFRfUFVCTElDX0dPT0dMvRV9QTEEGNfQVBJPUFJemFTeddfgURVREdaSll2WmV\n\n# Remove line breaks\n$ base64 .env | tr -d '\\\\n'\n\nOVRMQVNfVVJEEE1vbmdvZGIrc3sJ2Oi8vbXJnZGV2OlRMfaSnl0T1dFUVNpefFKVmZdnVapdGkubW9uZ29hYi5uZXDvQdWRtaXQxdX2Rldj9ydZCDeVdyaQRlcz10cnVlJncCk5FWFRfUFVCTElDX0dPT0dMvRV9QTEEGNfQVBJPUFJemFTeddfgURVREdaSll2WmV\n```\n\nGitpod&#39;s gp command line interface provides a quick way to get and set environment variables for the workspace.\n\nEvery time you make changes to the .env file, run this script to persist it across your Gitpod workspaces.\n\n```sh\n$ gp env -e DOTENV=\"$(base64 .env | tr -d '\\\\n')\"\n```\n\nSee how this script works at ExplainShell\n\n__SPLIT_HERE__\nRestoring your .env in new workspaces\n\nGitpod will create a terminal for each command in each task in the .gitpod.yml file, and those shells will have access to the environment variables set for your Gitpod account.\n\nNote: this only applies to command scripts. The init and before scripts by default do not load user-specific environment variables for security reasons.\n\nDecoding the $DOTENV variable and writing to a file is all that&#39;s required to restore it and have a populated .env waiting for you by the time your new workspace has loaded.\n\n```sh\necho \"${DOTENV}\" | base64 -d > .env\n```","metadata":{"source":"https://gitpod.io/guides/automate-env-files-with-gitpod-environment-variables/index"}}],["409",{"pageContent":"Improving the developer experience\n\nThe real power of Gitpod is in fully automating your developer environment, so while you can manually store and retrieve your .env file, you can achieve an even better developer experience by using Gitpod&#39;s Start Tasks to run the scripts for common user flows automatically.\n\nWhen a new developer is onboarding to your repository, they won&#39;t have a $DOTENV saved from a previous workspace. You can commit a .env.example file into the codebase that provides reasonable defaults for new developers. As part of the startup task, copy that example file into a real .env file to save the developer from having to do it manually.\n\nAnother concern is that if a developer makes local changes to their .env but hasn&#39;t persisted it yet, a workspace restart (like after a timeout) shouldn&#39;t erase their changes. If there is already a .env file when a workspace starts, don&#39;t try to override it at all.\n\nYou can copy the following Gitpod Task directly into your .gitpod.yml. For more information, check out the documentation for Start Tasks on Gitpod\n\n```yml\ntasks:\n  - name: Restore .env file\n    command: |\n      if [ -f .env ]; then\n        # If this workspace already has a .env, don't override it\n        # Local changes survive a workspace being opened and closed\n        # but they will not persist between separate workspaces for the same repo\n        echo \"Found .env in workspace\"\n      else\n        if [ -z \"${DOTENV}\" ]; then\n          # There is no $DOTENV from a previous workspace\n          # Default to the example .env\n          echo \"Setting example .env\"\n          cp .env.example .env\n        else\n          # After making changes to .env, run this line to persist it to $DOTENV\n          #   gp env DOTENV=\"$(base64 .env | tr -d '\\n')\"\n          #\n          # Environment variables set this way are shared between all your workspaces for this repo\n          # The lines below will read $DOTENV and print a .env file\n          echo \"Restoring .env from Gitpod\"\n          echo \"${DOTENV}\" | base64 -d > .env\n        fi\n      fi\n```","metadata":{"source":"https://gitpod.io/guides/automate-env-files-with-gitpod-environment-variables/index"}}],["410",{"pageContent":"So, you are working on multiple services that need to talk to each other. Each part of your application lives in a different repository, or you might be collaborating on an integration project involving more than one product from different teams. With Gitpod, you set up secure and isolated cloud workspaces for your git repositories.\n\nBut how do we make workspaces talk to each other securely?\n\nWe have teamed up with our friends at Tailscale to bring an easy way to solve this problem using their simple zero-config VPN, which comes pre-installed in Gitpod workspaces.\nTailscale&#39;s secure mesh technology based on WireGuard can connect machines securely across the internet, such as your Gitpod workspaces or a cloud or on-prem resource, like a database, frictionlessly. ‚ú®\n\nThis guide will show how easy it is to connect Gitpod workspaces over a secure tunnel provided by Tailscale. Let&#39;s get started üöÄ\n\n__SPLIT_HERE__\nA case for working with multiple repositories at a time\n\nA typical architecture these days is server-side rendering (SSR). You generate the view by calling backend services on the frontend server instead of calling your API from client devices. If you develop on your local machine, two repositories will be open in two IDE windows. Every service can communicate with each other as they are all running on the same machine.\n\nIn Gitpod, each workspace runs in a secure sandbox. You can expose ports so that only your browser can access them. However, the workspaces cannot communicate with one another.\n\nAs long as only the browser interacts with the API, this will work with Gitpod without any changes. If you develop single-page applications and static sites where every network request is a client-side fetch, you don&#39;t need Tailscale.\n\nBut if your application has a server-side that needs to fetch data from another workspace, it becomes a networking problem. The application server requires a secure network tunnel between them to send a request outside of its workspace and into the API workspace.\n\nThis is what Tailscale is made for ‚ú®\n\n__SPLIT_HERE__\nConnecting multiple workspaces together with Tailscale\n\nWe can run Tailscale in each of our Gitpod workspaces, which will make them part of your &quot;tailnet&quot;, a secure VPN consisting of your machines that can access each other. Traffic over your &quot;tailnet&quot; is fully end-to-end encrypted, with each workspace having its private key, so anyone, not even Tailscale, is capable of reading the traffic.\n\nIn Gitpod, each workspace can log into Tailscale and receive a list of secure IP addresses of other workspaces connected to your &quot;tailnet&quot;. It is only possible to connect to these IPs from machines running Tailscale, which can be your workspaces or your local machines.\n\nTailscale comes pre-installed with gitpod/workspace-full, Gitpod&#39;s base image for workspaces. So if you are using the default image or a custom docker image based on workspace-full, you are ready to go üöÄ; else, you will need to add instructions to install Tailscale into your workspace.","metadata":{"source":"https://gitpod.io/guides/connect-multiple-repositories-using-tailscale/index"}}],["411",{"pageContent":"1. Add Tailscale to your .gitpod.yml tasks\n\nScroll to the bottom of this page for an example .gitpod.yml file, or follow these steps to set it up for yourself.\n\nThe ‚ÄúConnect to Tailscale‚Äù task will prompt you to log in. We only need to do this once. Next time, we fetch the token from Gitpod‚Äôs environment variables to skip the login.\n\nThe ‚ÄúRestore Tailscale daemon‚Äù task launches Tailscale and puts it in the background. It connects the workspace to your ‚Äútailnet‚Äù using your previously saved Tailscale token.\n\n```yaml\ntasks:\n  - name: Restore Tailscale daemon\n    command: |\n      if [ -n \"${TS_STATE_TAILSCALE_EXAMPLE}\" ]; then\n        # restore the tailscale state from gitpod user's env vars\n        sudo mkdir -p /var/lib/tailscale\n        echo \"${TS_STATE_TAILSCALE_EXAMPLE}\" | sudo tee /var/lib/tailscale/tailscaled.state > /dev/null\n      fi\n      sudo tailscaled\n  - name: Connect to Tailscale\n    command: |\n      if [ -n \"${TS_STATE_TAILSCALE_EXAMPLE}\" ]; then\n        sudo -E tailscale up\n      else\n        sudo -E tailscale up --hostname \"gitpod-${GITPOD_GIT_USER_NAME// /-}-$(echo ${GITPOD_WORKSPACE_CONTEXT} | jq -r .repository.name)\"\n        # store the tailscale state into gitpod user\n        gp env TS_STATE_TAILSCALE_EXAMPLE=\"$(sudo cat /var/lib/tailscale/tailscaled.state)\"\n      fi\n      exit\n```\n\n__SPLIT_HERE__\n2. Open a workspace for each repository\n\nCommit the .gitpod.yml to your repository.\n\nNext time when you launch your workspace, your Gitpod terminal will give you a login link with a unique token. Once you‚Äôve logged in, it will connect your workspace to your Tailscale account.\n\nTailscale allows you to log in via GitHub, Google, Microsoft, or email. As long as you are logged in to the same organization in each of your repositories, your Gitpod workspaces will be able to send requests to each other.\n\n__SPLIT_HERE__\n3. View your connected workspaces\n\nRun tailscale status to see the private IP addresses for your other workspaces. These are only accessible to other Tailscale nodes. Your workspaces can communicate with each other, but neither your browser nor anyone else will be able to access them.\n\n```\n$ tailscale status\n100.11.166.123  main-backend-service username@  linux   -\n100.11.201.28   main-application username@  linux   -\n```\n\nGitpod is all about giving you a great developer experience. So if you have to look up IP addresses every time you make a workspace, it isn‚Äôt great.\n\nWe can use a .gitpod.yml task to search Tailscale and create environment variables for each connected service.\n\nLet‚Äôs say backend-service is the name of the repository you want to connect. You can find its IP address by running the following command:\n\n```\n$ tailscale status | grep backend-service | cut -d \" \" -f 1\n100.11.166.123\n```\n\nYou can set the result as an environment variable so that your application can use it later.\n\nIn this example, this task looks for backend-service and sets an environment variable named API_URL pointing to it before launching the application.\n\n```yaml\n- name: Start application\n  init: npm install\n  command: |\n    REPO_NAME=backend-service\n    API_IP=$(tailscale status | grep $REPO_NAME | cut -d \" \" -f 1)\n    if [ \"${API_IP}\" ]; then\n      echo \"üê≥ Connected to $REPO_NAME through Tailscale\"\n      API_URL=\"http://$API_IP:5000/api\" npm run dev\n    else\n      echo \"üê≥ Failed to connect to $REPO_NAME. Make sure a $REPO_NAME workspace is active and logged into Tailscale.\"\n      npm run dev\n    fi\n  env:\n    PORT: 3000\n    NODE_ENV: development\n```\n\nTo try this out, add this task to the tasks list in your .gitpod.yml file, commit it, and try it out with a new workspace. Your workspaces should be able to send requests to each other through their secure Tailscale IP addresses. Now you are fully set up for multi-repo development on Gitpod. ‚ú®","metadata":{"source":"https://gitpod.io/guides/connect-multiple-repositories-using-tailscale/index"}}],["412",{"pageContent":"Sample .gitpod.yml\n\n```yaml\nimage: gitpod:workspace/full\nports:\n  - port: 3000\n    onOpen: ignore\ntasks:\n  - name: Restore Tailscale daemon\n    command: |\n      if [ -n \"${TS_STATE_TAILSCALE_EXAMPLE}\" ]; then\n        # restore the tailscale state from gitpod user's env vars\n        sudo mkdir -p /var/lib/tailscale\n        echo \"${TS_STATE_TAILSCALE_EXAMPLE}\" | sudo tee /var/lib/tailscale/tailscaled.state > /dev/null\n      fi\n      sudo tailscaled\n  - name: Start application\n    init: |\n      eval $(gp env -e)\n      npm install\n    command: |\n      REPO_NAME=backend-service\n      API_IP=$(tailscale status | grep $REPO_NAME | cut -d \" \" -f 1)\n      if [ \"${API_IP}\" ]; then\n        echo \"üê≥ Connected to $REPO_NAME through Tailscale\"\n        API_URL=\"http://$API_IP:5000/api\" npm run dev\n      else\n        echo \"üê≥ Failed to connect to $REPO_NAME. Make sure a $REPO_NAME workspace is active and logged into Tailscale.\"\n\n        npm run dev\n      fi\n    env:\n      PORT: 3000\n      NODE_ENV: development\n  - name: Connect to Tailscale\n    command: |\n      if [ -n \"${TS_STATE_TAILSCALE_EXAMPLE}\" ]; then\n        sudo -E tailscale up\n      else\n        sudo -E tailscale up --hostname \"gitpod-${GITPOD_GIT_USER_NAME// /-}-$(echo ${GITPOD_WORKSPACE_CONTEXT} | jq -r .repository.name)\"\n        # store the tailscale state into gitpod user\n        gp env TS_STATE_TAILSCALE_EXAMPLE=\"$(sudo cat /var/lib/tailscale/tailscaled.state)\"\n      fi\n      exit\n```","metadata":{"source":"https://gitpod.io/guides/connect-multiple-repositories-using-tailscale/index"}}],["413",{"pageContent":"The default Gitpod workspace-full image comes with preinstalled Java development tools like SDKMan, Maven and Gradle.\n\nWhen you execute java --version in the terminal, you&#39;ll find out that the current Java version is Java 11 (at the time of writing this blog post).\n\nSince SDKMan is installed, you can easily switch to a different Java version with:\n\n```bash\nsdk install java 17.0.4.1-tem\n```\n\nBut this change will be reflected only in your current workspace. If someone else opens the Gitpod workspace for the same Gitpod repository or if you recreate the workspace, Java will be back to 11, and the version you installed with SDKMan will be gone.\n\nThere are at least two ways to configure the Java version for each new Gitpod workspace.\n\n__SPLIT_HERE__\nSet Java version with .gitpod.yml\n\nGitpod workspaces can be configured with .gitpod.yml. We can specify startup task(s) that will execute shell commands for us:\n\n```yaml\ntasks:\n  - before: sdk install java 17.0.4.1-tem\n```\n\nThis is almost good. The problem is that sdk install prompts the user to set the installed version as a default. There&#39;s no flag to run the command in non-interactive mode, but there is a hacky workaround:\n\n```yaml\ntasks:\n  - before: sdk install java 17.0.4.1-tem < /dev/null\n```\n\nThe drawback is that this command takes some time to run and is executed every time the workspace is created.\n\nInstead, we can create a custom workspace image that will be built only once.\n\n__SPLIT_HERE__\nSet Java version with workspace image\n\nGitpod gives an option to use a custom Docker image on which the workspace runs. Let&#39;s create one that uses Java 17 by default:\n\nRemove the before task from .gitpod.yml and instead set the image.file property to .gitpod.Dockerfile.\n\n```yaml\nimage:\n  file: .gitpod.Dockerfile\n```\n\nNext, create a file .gitpod.Dockerfile. If you are happy with the default Gitpod workspace image, you can use it as a base.\n\n```dockerfile\nFROM gitpod/workspace-full:2022-10-25-06-57-58\n\nSHELL [\"/bin/bash\", \"-c\"]\nRUN source \"/home/gitpod/.sdkman/bin/sdkman-init.sh\"  \\\n    && sdk install java 17.0.4.1-tem < /dev/null\n```\n\nLet&#39;s break it down:\n\nIt is recommended to use a specific Docker image tag for a base image. Go to https://hub.docker.com/r/gitpod/workspace-full and look for the latest tag, then use it in FROM command in the Dockerfile.\nChange shell to bash, source SDKMan init so that sdk command becomes available, and run sdk install like we previously did in the .gitpod.yml:\n\nThen, when you create a new repository with these files, only on the first run, Gitpod builds an image:\n\nbuild-image\n\n.. and once the workspace is ready:\n\n```bash\njava --version\n```\n\nExample output:\n\n```bash\nPicked up JAVA_TOOL_OPTIONS:  -Xmx3489m\nopenjdk 17.0.4.1 2022-08-12\nOpenJDK Runtime Environment Temurin-17.0.4.1+1 (build 17.0.4.1+1)\nOpenJDK 64-Bit Server VM Temurin-17.0.4.1+1 (build 17.0.4.1+1, mixed mode, sharing)\n```","metadata":{"source":"https://gitpod.io/guides/custom-java-distribution-on-gitpod/index"}}],["414",{"pageContent":"Use a JDK that is unavailable in SDKman\n\nWhat if the JDK we want to use is not available in SDKMan? Since we are using a Dockerfile, we can write shell scripts.\n\nAs an example, let&#39;s use JetBrains distribution of the OpenJDK.\nUse the following .gitpod.Dockerfile contents:\n\n```dockerfile\nFROM gitpod/workspace-full:2022-10-25-06-57-58\nSHELL [\"/bin/bash\", \"-c\"]\nRUN wget https://cache-redirector.jetbrains.com/intellij-jbr/jbr-17.0.4.1-linux-x64-b653.1.tar.gz\nRUN sudo tar zxf jbr-17.0.4.1-linux-x64-b653.1.tar.gz --directory /opt/\nRUN echo 'export JAVA_HOME=/opt/jbr-17.0.4.1-linux-x64-b653.1/' >> /home/gitpod/.bashrc \\\n    && echo 'export PATH=/opt/jbr-17.0.4.1-linux-x64-b653.1/bin:$PATH' >> /home/gitpod/.bashrc\n```\n\nLet&#39;s break it down:\n\nDownload JetBrains Runtime release from https://github.com/JetBrains/JetBrainsRuntime/releases/\nUnpack it and move to /opt/\n\nNow, two important points:\n\nexport JAVA_HOME is effectively overwriting the one set by SDKMan\nAdd JDK bin directory to $PATH. It is important to put it before what&#39;s already been there so that the new JDK bin is before the SDKMan path.\n\nFinally, use .gitpod.Dockerfile from your .gitpod.yml:\n\n```yaml\nimage:\n  file: .gitpod.Dockerfile\n```\n\nAnd follow see it in action!\n\nOnce you recreate the workspace, and the new image is built:\n\n```bash\njava --version\n```\n\nExample output:\n\n```bash\nPicked up JAVA_TOOL_OPTIONS:  -Xmx3489m\nopenjdk 17.0.4.1 2022-08-12\nOpenJDK Runtime Environment JBR-17.0.4.1+1-653.1-nomod (build 17.0.4.1+1-b653.1)\nOpenJDK 64-Bit Server VM JBR-17.0.4.1+1-653.1-nomod (build 17.0.4.1+1-b653.1, mixed mode)\n```\n\nThat&#39;s all folks!","metadata":{"source":"https://gitpod.io/guides/custom-java-distribution-on-gitpod/index"}}],["415",{"pageContent":"Yes! You can learn to code and build software with Gitpod on Android! Gitpod is a complete dev environment running in the cloud, which turns any android phone into a powerful dev machine. I have been developing software on my phone using Gitpod for a long time! It is powerful, and I believe with Gitpod, anyone can learn to code and build software without any hurdles.\n\nGitpod changed my life and enabled me to continue my journey into software development. I have talked more about it here. In this guide, I have discussed how Gitpod is fully usable from an Android phone. I will be sharing how I set up Gitpod on my Android phone. If you&#39;re curious, follow along üöÄ\n\n__SPLIT_HERE__\nBrowser\n\nTo get started, all you need is a browser. I use the Kiwi browser on Android. It brings you almost a full-blown desktop-like chromium experience but on mobile! That means you get chrome-devtools, extensions support, keyboard shortcuts and many more.\n\nImportant notes about using Gitpod on Kiwi:\n\nThere is a chromium bug with mouse cursor hover. If you face this bug, you must toggle off your installed accessibility services while using Kiwi.\nI recommend toggling off ‚ÄúPrefer native applications‚Äù on Kiwi from its Settings &gt; Accessibility.\n\nconversation 1\n\nSome shortcuts like Windows/Meta + Key, Control + Space and etc. will not work on Gitpod as Android captures them for its internal shortcuts. Unfortunately, you can not disable or remap them easily. To workaround, you will have to remap some of your conflicting IDE shortcuts from the VS Code Browser settings.\n\nKiwi tips:\n\nTry pressing ‚ÄúWindows/Meta key‚Äù + ‚Äú**/**‚Äù on the Kiwi browser to see all browser and Android-system shortcuts.\nMy favourite shortcuts are Alt + Tab for quick application switching and Ctrl + T for quickly creating a new Kiwi tab.\nInstall the Gitpod extension on Kiwi to make your life easier.\nI also use the Vimium extension on Kiwi for swiftly navigating through websites without using my mouse.\n\n__SPLIT_HERE__\nHardware keyboard and mouse\n\nNext, you need a way to control your phone as you would with a PC. There are two easy things you can do:\n\nYou can get a Bluetooth keyboard and mouse combo (this is the most convenient choice)\nOr you can get a USB hub for your Android device and use a wired keyboard and mouse (this is the most responsive)\n\nI&#39;ve gone through both routes and ended up sticking with Bluetooth devices for convenience!","metadata":{"source":"https://gitpod.io/guides/getting-started-with-gitpod-in-android/index"}}],["416",{"pageContent":"Display\n\nAs phone displays are so small, it can get tricky coding from such a small screen. There&#39;s no easy solution for this problem if you&#39;ve got some entry-level or mid-range Android phone like me. Nowadays, even entry-level Android devices are powerful enough to serve you well and run a complete Linux GUI environment with virtually no lag unless you&#39;re a hardcore mobile gamer.\n\nNote: If you got a tablet or a high-end Android phone with USB-C 3.0, you probably don&#39;t need to care about the particular issue I will discuss in detail. You can skip it!\n\nCheap phones won&#39;t likely come with USB-C 3.0, so you won&#39;t be able to get direct VIDEO output from your phone to an external monitor/TV. Some third-party products utilize ADB, and a mini-CPU on the HDMI end to stream your Android display over a cable.\n\nexternal monitor\n\nIn my case, I use a Chinese HDMI adapter for my microUSB phone to connect with this external screen. You can take &quot;Renkchip&quot; for reference if you want one too. But, you have to consider a few things first:\n\nIf you&#39;re planning to buy it to connect with a TV, ensure that its input lag isn&#39;t more than 15ms. Otherwise, your experience will be terrible combined with the adapter input lag. You can use the incredible Rtings.com TV input lag list for reference.\nAvoid unbranded adapters if you buy online since most of those use a weak CPU for processing the VIDEO data on the HDMI end.\nconversation 2\n\nWe can also utilize some software-based things; these can be helpful whether you&#39;re using an external screen or not. For instance:\n\nPress the F11 key on a Gitpod workspace to make VS CODE full screen on the Kiwi browser.\n\n\nIncrease the Smallest/Minimal Weight on your phone&#39;s Developer options. It can be also referred as DPI. It will make things take less space on your tiny screen when the value is increased. Please remember that it can brick some devices when increased too much, so don&#39;t go too far.\n\n__SPLIT_HERE__\nExtra Tips &amp; tricks\n\nYou can use an app called Rotation Control to force landscape/auto-rotate mode for every app on Android (including your Home launcher!)\nI&#39;m using a $2 phone stand, it&#39;s called &quot;Retractable L7 Phone Stand&quot;, sharing the name for reference in case you want to find something similar in your local market or online. Or you can put your phone against a book as well üòÜ\n\nCongratulations üéâ. Now you have set up the browser and display and connected the hardware keyboard and mouse with your Android phone. You can now code, build and learn seamlessly using Gitpod ‚ö°Ô∏è. To get started, you can refer to the following documentation.\n\nIf you have more questions, drop by our community Discord server. We have the #mobile-and-tablets channel where fellow mobile-dev enthusiasts hang out!","metadata":{"source":"https://gitpod.io/guides/getting-started-with-gitpod-in-android/index"}}],["417",{"pageContent":"I recently stumbled upon a new project on GitHub that piqued my interest. It proposed a new type of database that I was dying to try out. So I cloned their repository, and looked at their README for a way to build their code.\n\nAfter activating a Python 3.7 virtual env and running pip install -v -e . as suggested, I was soon faced with a rather cryptic build output. Investigating a bit revealed that some build command was failing due to a missing package: zlib1g-dev. I figured out the right incantation to install it on my machine, then tried again. Next it was libreadline6-dev that was missing. After a few similar iterations, I guessed that the project probably needed all PostgreSQL build dependencies, so I went ahead and installed all that. Yet somehow the project still wouldn&#39;t build, showing yet another error, but by then I was out of free time and had to call it a day. Sadly, I hadn&#39;t been able to run this project even once.\n\nIf you&#39;re a developer, this scenario probably sounds familiar. In fact, that repository&#39;s setup instructions were already pretty helpful, but still we frequently face these kinds of setup problems ‚Äî you probably have similar stories of your own. In the software industry, we collectively lose too much time and energy setting up many projects, on countless systems, often in half-broken ways.\n\nWhat if there was a better way to do this? Maybe one day we can all just forget about troubleshooting build dependencies, and simply focus on the projects&#39; code itself? I have good news: Developer environments can be automated, in the form of scripts and Dockerfiles in your repository, in a way that allows anyone interested in your project to get a ready-to-code environment for free in seconds, without having to worry about dependencies ever again. How does it work? I&#39;m glad you asked!\n\n&nbsp; The idea in brief\n&nbsp;&nbsp;The problem Figuring out which dependencies, tools, and language versions to install to properly configure a dev environment takes a lot of time and energy, and has to be repeated from scratch every time you use a different computer, and for every new project.\n&nbsp;&nbsp;The cause Most setup instructions are written in a format that is not executable or reproducible, like plain text in Markdown files.\n&nbsp;&nbsp;The solution To solve this problem for every developer of your project, setup instructions should be written in a format that is executable, like scripts and Dockerfiles, and ideally versioned and shipped with your code. Gitpod was invented to make this easy.","metadata":{"source":"https://gitpod.io/guides/gitpodify/index"}}],["418",{"pageContent":"Introducing Gitpod\n\nSo you&#39;re ready to fully automate your GitHub project&#39;s development setup? That&#39;s great! I&#39;m here to help you achieve this. üëç\n\nIn this guide, I will be using Gitpod, a free developer service that makes it easy for maintainers to automate any non-executable setup instructions as code. If you follow it, you will end up with a button that launches pre-configured containers for your project, thus allowing everyone to check out your repository and run your code in a single click.\n\nThe first thing you&#39;ll probably want to do is try opening your repository in Gitpod. You can do this by navigating to your GitHub project root, and then typing gitpod.io/# before the URL. It should look a bit like this:\n\n```bash\ngitpod.io/#https://github.com/gitpod-io/website\n```\n\nWhen you see the IDE and Terminal, just try building and running your project as usual. Maybe it will just work out of the box, but maybe you&#39;ll notice that something is missing or broken, and you can iterate on your Gitpod setup to fix it (see table of contents below).\n\nOnce you&#39;re happy with your automated setup, a cool way to guide your contributors toward it is to add a Gitpod badge to your README. Here is a Markdown snippet you can use (just replace the ... with your repo):\n\n```markdown\n[![Open in Gitpod](https://gitpod.io/button/open-in-gitpod.svg)](https://gitpod.io/#https://github.com/...)\n```\n\nOpen in Gitpod\n\nHappy with your onboarding experience? Great! You&#39;re all set. üéâ\n\nDo you wish Gitpod would do more for your project? Then please read on. üëá\n\n__SPLIT_HERE__\nTable of contents\n\nIntroducing Gitpod\nTable of contents\nRunning init scripts\nAccelerating startup with prebuilt workspaces\nInstalling missing packages\nInstalling databasesPostgreSQL\nMySQL\nRedis\nMongoDB\n\n\nGetting a Virtual Desktop\nOpening previews\nSolving common preview problemsInvalid Host Header\nCSP errors\nUnreachable localhost URLs\nNo usable sandbox\n\n\nSetting env variables\n\n__SPLIT_HERE__\nRunning init scripts\n\nAdding a .gitpod.yml file at the root of your repository allows customizing Gitpod for your project. A useful thing it can do is running scripts on start-up (or sometimes even before start-up: the Gitpod app can watch your repo and start pre-building the init step for every commit, see the next section for more info):\n\n```yml\ntasks:\n  - init: npm install\n    command: npm start\n```\n\n(Please note the single - symbol: init and command should run in the same Terminal, one after each other.)\n\nTo open multiple Terminals on startup, just add more - entries under tasks:\n\n```yml\ntasks:\n  - init: npm install\n    command: npm run server\n  - command: npm run client\n```\n\nBut this example probably won&#39;t work, because npm run client likely also needs dependencies from npm install, so you might get an error like this in your second Terminal:\n\nError: Cannot find module &#39;lib&#39;\n\nIn order to make a Terminal wait for another Terminal to finish some task (e.g. installing dependencies), you can use the gp sync-done and gp sync-await commands like so:\n\n```yml\ntasks:\n  - init: |\n      npm install\n      gp sync-done installation\n    command: npm run server\n  - init: gp sync-await installation\n    command: npm run client\n```\n\nTo learn more about configuring Terminals, please visit the docs.","metadata":{"source":"https://gitpod.io/guides/gitpodify/index"}}],["419",{"pageContent":"Accelerating startup with prebuilt workspaces\n\nWith medium-to-large GitHub projects, your init step might take a long time to complete, especially if you need to compile code. To avoid that you and your contributors wait forever, you can make Gitpod auto-build your repository on every push, and start building workspaces even before Gitpod is opened. This will shave up to several minutes off your workspace loading times, and make your developers very happy.\n\nTo enable prebuilt workspaces, simply install the Gitpod app for your GitHub repository, and Gitpod will start auto-building all your branches and Pull Requests continuously in the background.\n\nOptionally, you can then customize the app&#39;s behavior for your project by editing your .gitpod.yml like so:\n\n```yml\ngithub:\n  prebuilds:\n    # enable for the master/default branch (defaults to true)\n    master: true\n    # enable for all branches in this repo (defaults to false)\n    branches: false\n    # enable for pull requests coming from this repo (defaults to true)\n    pullRequests: true\n    # add a check to pull requests (defaults to true)\n    addCheck: true\n    # add a \"Review in Gitpod\" button as a comment to pull requests (defaults to false)\n    addComment: false\n```\n\nTo see all configuration options for the Gitpod app, please visit the docs.\n\n__SPLIT_HERE__\nInstalling missing packages\n\nThe default Docker image for all Gitpod workspaces (gitpod/workspace-full) already comes with many common developer tools. But sometimes you may see an error like this one:\n\nbash: tool: command not found\n\nAnd if you try to install it locally using sudo, you might see an error like this:\n\nsudo: effective uid is not 0\n\nThe solution is to write a small Dockerfile for your project. If a particular tool is missing in your Gitpod workspace, simply add this at the top of your .gitpod.yml:\n\n```yml\nimage:\n  file: .gitpod.dockerfile\n```\n\nThen add a new file called .gitpod.dockerfile at the root of your repository, containing:\n\n```dockerfile\nFROM gitpod/workspace-full\n\nRUN sudo apt-get update \\\n && sudo apt-get install -y \\\n    tool \\\n && sudo rm -rf /var/lib/apt/lists/*\n```\n\nFrom now on, every new Gitpod workspace that will be opened for your repository will come with tool pre-installed. Cool right?","metadata":{"source":"https://gitpod.io/guides/gitpodify/index"}}],["420",{"pageContent":"Installing databases\n\nMany projects need a database to work properly. Here is how to install the most common databases in Gitpod ‚Äî take your pick! (If yours is missing please let us know, we&#39;d love to help you.)\n\nPostgreSQL\n\nTo get PostgreSQL for your project, you can use our dedicated PostgreSQL image.\n\nSimply put the following line to your .gitpod.yml file:\n\n```yaml\nimage: gitpod/workspace-postgres\n```\n\nThis will give you an auto-starting PostgreSQL server (it should auto-start every time you open a new Terminal), plus a few utility scripts that you can run in a Terminal or in a .gitpod.yml command:\n\npg_start: start the PostgreSQL service\npg_stop: stop the PostgreSQL service\npg_ctl status: check if the PostgreSQL service is running\n\nOnce the PostgreSQL server is running, you can use the psql CLI as usual:\n\n```bash\n$ psql -h localhost -d postgres\npsql (10.8 (Ubuntu 10.8-0ubuntu0.18.10.1))\nType \"help\" for help.\n\npostgres=#\n```\n\nMySQL\n\nIf your project needs MySQL to work, we also have a dedicated MySQL image. Simply base your .gitpod.dockerfile on:\n\n```dockerfile\nFROM gitpod/workspace-mysql\n```\n\nThen you&#39;ll get an auto-starting MySQL server, and you can use the mysql CLI like so:\n\n```bash\nmysql -e \"show databases;\"\n```\n\nRedis\n\nTo install Redis for your project, simply add these instructions to your .gitpod.dockerfile:\n\n```dockerfile\nFROM gitpod/workspace-full\n\n# Install Redis.\nRUN sudo apt-get update \\\n && sudo apt-get install -y \\\n  redis-server \\\n && sudo rm -rf /var/lib/apt/lists/*\n```\n\nThen, you&#39;ll be able to start the Redis server by running this in a Terminal or in a .gitpod.yml command:\n\n```bash\nredis-server\n```\n\nMongoDB\n\nTo get MongoDB for your project, you can use our dedicated MongoDB image built on top of gitpod/workspace-base.\n\nSimply base your .gitpod.dockerfile on:\n\n```dockerfile\nFROM gitpod/workspace-mongodb\n```\n\nThen start the MongoDB server by running this in a Terminal or in a .gitpod.yml command:\n\n```bash\nmkdir -p /workspace/data && mongod --dbpath /workspace/data\n```\n\nNote: Storing MongoDB&#39;s data inside /workspace ensures that it will get backed up and restored properly when you stop and restart a workspace, or share a snapshot.\n\n__SPLIT_HERE__\nGetting a Virtual Desktop\n\nIf your application needs to run a graphical UI, you might see an error like this:\n\nGtk: cannot open display: :0\n\nThat&#39;s because by default, Gitpod workspaces don&#39;t have a graphical environment at all. Luckily, we have a dedicated noVNC image built on top of gitpod/workspace-full that comes with a Virtual Desktop.\n\nSimply base your .gitpod.dockerfile on:\n\n```dockerfile\nFROM gitpod/workspace-full-vnc\n```\n\nThis will give you a virtual X server and a Remote Desktop client running on port 6080:\n\nVirtual X server and Remote Desktop client running on port 6080\n\nThis can be useful for example to run Electron apps graphically. For that, you&#39;ll just need a few extra dependencies in your .gitpod.dockerfile:\n\n```dockerfile\nFROM gitpod/workspace-full-vnc\n\n# Install Electron dependencies.\nRUN sudo apt-get update \\\n && sudo apt-get install -y \\\n  libasound2-dev \\\n  libgtk-3-dev \\\n  libnss3-dev \\\n && sudo rm -rf /var/lib/apt/lists/*\n```\n\nTo learn more, please see our dedicated post on Developing native UI applications in Gitpod.\n\nOr check out this fun Windows 95 in Electron example (see the Gitpod demo, .gitpod.yml, and Dockerfile).","metadata":{"source":"https://gitpod.io/guides/gitpodify/index"}}],["421",{"pageContent":"Opening previews\n\nGitpod will automatically detect when processes like web servers start listening on a port, and display a notification that allows you to open a web preview:\n\nPort notification\n\nIf you want to suppress these notifications, or pre-configure a specific behavior, you can do this in your .gitpod.yml file:\n\n```yml\nports:\n  - port: 8080\n    onOpen: open-preview\n  - port: 9000-9999\n    onOpen: ignore\n```\n\nAnother way to open web previews is to run gp preview &lt;url&gt; in a Terminal or in your .gitpod.yml commands. This can be used in combination with gp url &lt;port&gt; to open a web preview for a given port, like so:\n\n```yml\ntasks:\n  - command: python3 -m http.server 8080\n  - command: gp preview $(gp url 8080)\n```\n\nHowever, if the preview opens too soon, you might see an error like this:\n\nPort 8080 didn&#39;t respond\n\nIf you&#39;d like a task to run only when a given port becomes active, you can use gp ports await &lt;port&gt; like so:\n\n```yml\ntasks:\n  - init: npm install\n    command: npm run server 3000\n  - command: gp ports await 3000 && gp preview $(gp url 3000)\n```\n\nIf the Port X didn&#39;t respond error persists, please double-check in the Terminal output that your server is actually running on that port, then refresh the Preview pane. (Or, if it&#39;s a Browser tab, please close it and re-open it from the IDE&#39;s &quot;Open Ports&quot; view ‚Äî refresh isn&#39;t currently supported for Browser preview tabs).","metadata":{"source":"https://gitpod.io/guides/gitpodify/index"}}],["422",{"pageContent":"Solving common preview problems\n\nSometimes web servers like to negotiate a little before accepting to serve your precious content. Here is how to troubleshoot the most common issues.\n\nInvalid Host Header\n\nSince we&#39;re running in a cloud workspace, URLs like localhost:3000 should be converted to something like 3000-abc-123.ws-eu0.gitpod.io. You can get the exact preview URL for a port by running gp url &lt;port&gt;, or by checking the &quot;Open Ports&quot; IDE view.\n\nThis custom hostname may annoy servers like webpack-dev-server, because they usually only accept requests on localhost. So you might see an error like this one:\n\nInvalid Host Header\n\nTo make your server accept non-localhost requests, you can use the following CLI parameters (e.g. with webpack-dev-server or ng serve):\n\n--host 0.0.0.0 --disable-host-check\n\nOr you can edit your webpack.config.js, or vue.config.js, like so:\n\n```js\ndevServer: {\n  host: '0.0.0.0',\n  disableHostCheck: true,\n},\n```","metadata":{"source":"https://gitpod.io/guides/gitpodify/index"}}],["423",{"pageContent":"--host 0.0.0.0 --disable-host-check\n\nOr you can edit your webpack.config.js, or vue.config.js, like so:\n\n```js\ndevServer: {\n  host: '0.0.0.0',\n  disableHostCheck: true,\n},\n```\n\nAlternatively, if you don&#39;t want to use disableHostCheck, you can also add &#39;.gitpod.io&#39; to your allowedHosts, like so:\n\n```js\ndevServer: {\n  host: '0.0.0.0',\n  allowedHosts: ['localhost', '.gitpod.io'],\n},\n```\n\nSee all webpack-dev-server configuration options here.\n\nIf you don&#39;t have direct access to the dev server configuration, e.g. when using frameworks like Create React App, you might want to look in the framework&#39;s docs for a similar option, like CRA&#39;s environment variable DANGEROUSLY_DISABLE_HOST_CHECK:\n\n```yml\ntasks:\n  - before: export DANGEROUSLY_DISABLE_HOST_CHECK=true\n    init: yarn install\n    command: yarn start\n```\n\nCSP errors","metadata":{"source":"https://gitpod.io/guides/gitpodify/index"}}],["424",{"pageContent":"```yml\ntasks:\n  - before: export DANGEROUSLY_DISABLE_HOST_CHECK=true\n    init: yarn install\n    command: yarn start\n```\n\nCSP errors\n\nIf the Preview pane still refuses to display your web app, please open the Browser Console (e.g. by typing F12 or by exploring your Browser menus). In there, you might see errors mentioning things like:\n\nX-Frame-Options\n\nOr:\n\nCSP frame-src\n\nThese mean that your web app refuses to be opened inside an &lt;iframe&gt;, for security reasons (that&#39;s what the Preview pane uses to display web apps). In that case, please open previews in an external Browser tab instead, e.g. by going to the &quot;Open Ports&quot; IDE view and clicking the Open Browser button.\n\nUnreachable localhost URLs\n\nIf your web app starts to show up in a preview, but it doesn&#39;t work well, the Browser Console might reveal failing requests to localhost URLs like:\n\n```bash\nhttp://localhost:9000/api/v1/\n```","metadata":{"source":"https://gitpod.io/guides/gitpodify/index"}}],["425",{"pageContent":"If your web app starts to show up in a preview, but it doesn&#39;t work well, the Browser Console might reveal failing requests to localhost URLs like:\n\n```bash\nhttp://localhost:9000/api/v1/\n```\n\nThis happens for example with some Angular apps, that like to run a web client on a port like 3000, and an API backend on a different port like 9000.\n\nIf that&#39;s your case, you can try two things:\n\nReplace all references to localhost:9000 in your web client with the result of the gp port 9000 command (should be something like 9000-abc-123.ws-eu0.gitpod.io)\nConfigure your port 3000 server to proxy certain requests (e.g. starting with /api) to localhost:9000 on the server-side\n\nYou can sometimes do 1. with a simple configuration change, and here is how you can achieve 2. in an Angular app using the Angular CLI:\n\nCreate a new file called proxy.config.json, that includes a proxy route like:\n\n```json\n{\n  \"/api\": {\n    \"target\": \"http://localhost:9000\",\n    \"secure\": false\n  }\n}\n```","metadata":{"source":"https://gitpod.io/guides/gitpodify/index"}}],["426",{"pageContent":"Create a new file called proxy.config.json, that includes a proxy route like:\n\n```json\n{\n  \"/api\": {\n    \"target\": \"http://localhost:9000\",\n    \"secure\": false\n  }\n}\n```\n\nAnd then point ng serve to that file using the --proxy-config parameter:\n\n```bash\nng serve --proxy-config proxy.config.json --host 0.0.0.0 --disable-host-check --port 3000\n```\n\nFor a complete example using PostgreSQL, Angular CLI, disableHostCheck, and a backend proxy, please check out the PeerTube project (.gitpod.yml, Dockerfile, proxy.config.json, ng serve command).\n\nNo usable sandbox\n\nOk this is not really a preview problem, but I thought I&#39;d mention it here anyway since we&#39;re already troubleshooting.\n\nMore and more projects are using headless Chrome as a dependency (e.g. via Puppeteer), and when running it in Gitpod, you might see an error that looks like:\n\nError: Failed to launch chrome!\nNo usable sandbox!","metadata":{"source":"https://gitpod.io/guides/gitpodify/index"}}],["427",{"pageContent":"Error: Failed to launch chrome!\nNo usable sandbox!\n\nIn this case, you&#39;ll want to use Chrome&#39;s --no-sandbox and/or --disable-setuid-sandbox flags. With Puppeteer, it may look like this:\n\n```js\nconst browser = await puppeteer.launch({\n  args: [\"--no-sandbox\", \"--disable-setuid-sandbox\"],\n});\n```","metadata":{"source":"https://gitpod.io/guides/gitpodify/index"}}],["428",{"pageContent":"Setting env variables\n\nSometimes, your project needs some extra information that is either a secret, or it&#39;s different for each developer. A good example is tokens or credentials that are used to interact with external APIs or services. A good way to give these values to your project setup is via environment variables.\n\nTo ensure that a required env variable called TOKEN is defined, you can do something like this in your .gitpod.yml:\n\n```yml\ntasks:\n  - command: >\n      while [ -z \"$TOKEN\" ] ; do\n        printf \"\\n‚ùó The TOKEN environment variable is required. Please enter its value.\\n\" &&\n        read -s -p \"TOKEN: \" TOKEN ;\n      done ; gp env TOKEN=$TOKEN && printf \"\\nThanks\\n\"\n      # Now you can use $TOKEN\n```\n\nThis will check the value of $TOKEN, and if it&#39;s empty, it will ask the user to manually type its value into the Terminal, and then save that value for future workspaces with gp env.\n\nIf you need to have these values inside a file, you can add something like this to your .gitpod.yml commands:\n\n```yml\ntasks:\n  - command: echo \"$SSH_PRIVATE_KEY\" > ~/.ssh/id_rsa\n```\n\nAnother (unsafe) way to pass an env variable to a single workspace is to add it in the Gitpod context URL, like so:\n\n```bash\nhttps://gitpod.io/#TOKEN=value/https://github.com/gitpod-io/website\n```\n\n(But please don&#39;t use this for security-sensitive data like passwords and private keys, because URLs can easily be intercepted. Also, note that values should be URL-encoded.)\n\nFinally, users can also manage env variables for all their workspaces by visiting gitpod.io/environment-variables. You can learn more about managing Gitpod env variables in the docs.\n\nFor a complete example of a project that requires env variables (saved in .yml config files), please see the dev.to project&#39;s .gitpod.yml.\n\nPhew... that&#39;s about it! I hope you enjoyed reading through this guide and that it helped you in some way. If you still have questions or suggestions, please let us know. I&#39;d love to help you and make this guide more useful.","metadata":{"source":"https://gitpod.io/guides/gitpodify/index"}}],["429",{"pageContent":"Gitpod is a remote development platform. Gitpod workspaces are ephemeral and only live for as long as you work on a task. While ephemeral workspaces are a very powerful feature, they&#39;re also likely new to you, which is why you&#39;re here. In this guide, we&#39;ll walk you through what ephemerality means for a development environment in the cloud and how Gitpod enables you to work in this totally new way of working. Welcome to the future!\n\nFirst up, what is ephemerality? Rather than having a single static environment (like your local machine), Gitpod users are encouraged to codify their dev environment as code (more on how to do this later!). With your project codified, you&#39;ll be able to spin up a new workspace, start coding and throw away the workspace when you&#39;re done.\n\nLet me give you a few examples where ephemerality shines :\n\nAlways start from a clean slate - If you break something in your environment, rather than waste time trying to figure out exactly which environment variable or configuration you accidentally updated, throw away the workspace and start a new working workspace.\nWork on many workspaces at once - Let&#39;s say you&#39;re working on a feature while simultaneously supporting reviewing a colleague&#39;s code. Rather than having to update your local environment to swap between, you can create a new parallel workspace and code in two (or more!) workspaces simultaneously.\n\nGitpod ensures when you open a new workspace, all the correct tools &amp; packages are in place, any servers or processes are running, and more. We will also dig into neat features of Gitpod, such as &#39;Prebuilds&#39;, which install dependencies ahead of time so that when you open a new workspace, you don&#39;t have to wait for anything to install.\n\nThis guide will focus on topics and concepts that can help you set up an ephemeral dev environment on Gitpod:\n\nConfiguring your dev environment with code\nFaster startup by enabling prebuilds\nPersisting environment variables and files\n\nSound good? Let&#39;s dive in and learn how to configure your development environment with Gitpod.\n\n__SPLIT_HERE__\nConfiguring your dev environment with code\n\nTo start any project, you typically need to install the dependencies and tools required to run the project. This setup process can become tedious and error-prone if you repeatedly set up your dev environment. If you&#39;re working on ephemeral environments, you want to be able to throw away an environment and start a new one, so you don&#39;t want to have a single barrier to simply creating a new workspace.\n\nIn Gitpod, you can configure your dev environment as code with .gitpod.yml and an optional .gitpod.Dockerfile file. Gitpod can be configured to install all the tools and dependencies you need to start your project. Since both these configuration files are committed to version control, you get all of the benefits of source control, such as viewing the history and authors of files. With this configuration, your dev environment remains consistent throughout the organization.","metadata":{"source":"https://gitpod.io/guides/guide-ephemeral-dev-environment-on-gitpod/index"}}],["430",{"pageContent":"Configuring your project with a .gitpod.yml\n\nThe .gitpod.yml file prepares your dev environment by automating setup like dependency installation and specifying which application ports to open on workspace start. Every time you open your project or a repository in a new workspace, all the configured tasks are executed. The .gitpod.yml file lives at the root of your project. For example:\n\n```yml\n# Commands to start on workspace startup\ntasks:\n  - init: yarn install\n    command: yarn build\n# Ports to expose on workspace startup\nports:\n  - port: 8000\n    onOpen: open-preview\n```\n\nYou can read more about .gitpod.yml in docs: config gitpod file\n\nSetting up your first .gitpod.yml ‚ö°Ô∏è\n\nyoutube: E95oV_iqUtI \n\nOpen your repo in a new Gitpod workspace. The simplest way is by appending the entire repo URL (including the protocol) to gitpod.io/#, e.g. gitpod.io/#https://github.com/gitpod-io/gitpod\nCreate a .gitpod.yml in the root directory of your project, e.g. touch .gitpod.ymlTip: Instead of manually creating the gitpod.yml, type gp init in the terminal of your Gitpod workspace. (gp is a CLI for Gitpod included in all Gitpod workspaces)\n\n\nFor Gitpod to detect configuration changes, push and commit your gitpod.yml.\nNow open your project in a new workspace by prefixing your repo URL with gitpod.io/#{your-repository-url} or using the Gitpod extension.\n\nYou can read more about .gitpod.yml in the configure documentation. For information about the .gitpod.yml file properties, see the .gitpod.yml reference documentation.\n\n__SPLIT_HERE__\nConfigure your developer environment based on a Dockerfile\n\nIn addition to supplying commands via the .gitpod.yml, you can also configure a Dockerfile. Using Docker can be helpful if you already have a Dockerfile for your application, are familiar with the format, or want to leverage the many benefits of the Dockerfile format, such as improved caching and performance. Gitpod workspaces, by default, start with an image called workspace-full (more on this soon), or you can configure a custom Dockerfile.\n\nGitpod default Docker image\n\nBy default, Gitpod uses workspace-full for Gitpod workspaces. workspace-full comes pre-installed with Docker, Nix, Go, Java, Node.js, C/C++, Python, Ruby, Rust, and PHP, as well as tools such as Homebrew, Tailscale, Nginx, and several more.\n\nGitpod provides some premade and optimized workspace images for various programming languages and tools. You can select an image by adding it to your .gitpod.yml file.\n\nFor example, if you want to use Java 17, specify the following in your .gitpod.yml file.\n\n```yml\nimage: gitpod/workspace-java-17\n```\n\nNote: To avoid unexpected breaking changes, we suggest that you explicitly pin your workspace image. For Gitpod images, we recommend using a time-stamped image tag for maximum reproducibility. For example, image: gitpod/workspace-full:2022-08-17-18-37-55 (taken from the tags panel on this dockerhub page)\n\nBring your own Dockerfile\n\nSuppose one of the premade workspace images doesn&#39;t fit your needs, or you want to extend an image with additional configuration, such as a specific service or programming language. In that case, you can bring your own (Docker) image to Gitpod.\n\nYou can configure a custom Dockerfile by adding a reference to the Dockerfile location to use in your .gitpod.yml. We recommend the .gitpod.Dockerfile naming convention.\n\n```yml\nimage:\n  file: .gitpod.Dockerfile\n```\n\nNext, create a .gitpod.Dockerfile file at the root of your project.\nYou can start using the lightweight base image gitpod/workspace-base for your custom Docker image. The workspace-base image has some default tooling, whereas gitpod/workspace-full already has a lot of pre-installed installed tools.\nStart adding the commands you need for your dev environment.\n\nRead more about how to configure a custom Dockerfile.","metadata":{"source":"https://gitpod.io/guides/guide-ephemeral-dev-environment-on-gitpod/index"}}],["431",{"pageContent":"Faster startup by enabling prebuilds\n\nWhen working on your local machine, you typically have a single environment to configure and work on simultaneously. You manually install dependencies and system configurations when switching branches or projects. With Gitpod, you can have many concurrent workspaces. Rather than doing tasks like dependency installation when you swap the branch, you can start a new workspace based on your latest development environment image.\n\nEvery time you create a new ephemeral workspace, a lot of time can be saved by using a Prebuild. Prebuilds allow you to configure asynchronous builds of your workspace image when it&#39;s updated or changed. This is a very similar approach to how Continuous Integration tools work. When collaborating with peers and working on the same branch, configuring a Prebuild can be helpful as Gitpod triggers it whenever there is a commit to the repository.\n\nFor example, the .gitpod.yml saves 41 minutes of installation and building time for the Node.js repo that would otherwise have to be run on your machine. In Gitpod, the workspace image is prebuilt, so all you have to do is start a new workspace.\n\nHow to get started with Prebuilds\n\nPrebuilds work for GitHub, Gitlab and Bitbucket repositories (see our Prebuilds documentation for more). To give you a real example, though, let&#39;s take a look at how you can enable Prebuilds for GitHub:\n\nTo enable Gitpod Prebuilds for a repository, you must install the Gitpod GitHub App for your repository.\nClick &#39;Configure&#39; and choose the repository where you wish to install the Gitpod App.\nThe GitHub app will create the prebuild for every merged commit (on the particular branch), or you can configure it for every PR, and Gitpod will store the prebuilt image. With Prebuilds, whenever a new workspace is created, Gitpod will load the previously built image.\n\nBy default, Gitpod prepares prebuilt workspaces for all changes on the default branch and pull/merge requests from the same repository. Here is an example where Dropwizard has enabled the Prebuilds. The GitHub prebuilds section in the .gitpod.yml file configures the specific conditions when prebuilds should be run.\n\n```yml\nGitHub:\n  prebuilds:\n    # enable for the default branch\n    master: true\n    # enable for all branches in this repo\n    branches: true\n    # enable for pull requests coming from this repo\n    pullRequests: true\n    # enable for pull requests coming from forks\n    pullRequestsFromForks: true\n    # add a check to pull requests\n    addCheck: true\n    # add a \"Review in Gitpod\" button as a comment to pull requests\n    addComment: false\n    # add a \"Review in Gitpod\" button to the pull request's description\n    addBadge: false\n```\n\nImportant: Prebuilds only save the workspace directory. Any file changes made outside of /workspace file hierarchy from init tasks will be lost on workspace start when prebuilds are enabled.\n\nYou can read more about prebuilds in the following doc.\n\n__SPLIT_HERE__\nPersisting environment variables and files\n\nEvery time you start a project, you require API keys, secrets like database passwords or sensitive information that can&#39;t be committed to the version control system. These are usually added as environment variables that are used to configure a value in your code. When working with an ephemeral workspace, you will have to set up everything again for each new task. We will discuss a few ways with which we can persist these environment variables across Gitpod workspaces.","metadata":{"source":"https://gitpod.io/guides/guide-ephemeral-dev-environment-on-gitpod/index"}}],["432",{"pageContent":"Configure environment variables in Gitpod\n\nYou can configure persistent environment variables in your Gitpod Account settings.\n\nThe scope of each variable determines in what workspaces it will be available. Scope patterns follow the owner/repository pattern:\n\nYou can use a wildcard (denoted with a *) to match either the owner or repo, for example:\n\nSingle organizations - Setting dropwizard/* would make an environment variable available in all repositories owned by the organization dropwizard.\nSingle repository - */dropwizard would make an environment variable available on all repositories called dropwizard; this is especially useful for forks.\nAll organizations or repositories - Using */* would make an environment variable available in every repository for any organization for that given user.\n\nYou can read more about environment variables in Environment Variables on Gitpod.\n\nPersisting files between workspace restarts\n\nFor those of you who are looking to persist personal configurations with non-sensitive data, such as bash or zsh configs, you can use dotfiles. For sensitive information, an option (outside of introducing your secret store, such as vault) is to leverage: environment variables and consider encoding, e.g. with base64. See blog posts[1] [2] .\n\nThere would be some use cases where we would want to persist some files between workspace starts. For example, .bash_history refers to previously used history commands.\n\nHere we would like to persist the .bash_history file under the $HOME directory. For this, we will create a folder .persist inside the /workspace folder.\n\nInside your workspace, Open the terminal &amp; run the following steps:\n\nStep 1: mkdir -p /workspace/.persist\nStep 2: cp $HOME/.bash_history /workspace/.persist\nStep 3: Add the following task inside .gitpod.yml:\n\n```yaml\ntasks:\n  - name: Restore persist\n    before: |\n      cp /workspace/.persist/.bash_history $HOME;\n      # Copy more files as necessary below\n      exit;\n```\n\nStep 4: See it in action\n\nNote: This is just a temporary solution. The issue for this is still open Issue URL\n\n__SPLIT_HERE__\nRecommended Reading\n\nDocs: Config Dotfiles\nGitHub Repository: Bring your own Dotfiles to Gitpod | dotfiles on Gitpod\nGitHub Repository: AWS Single Sign-On (SSO) and Amazon Elastic Container Registry (ECR) with Gitpod\nGuide: Gitpodifying ‚Äî The Ultimate Guide\nBlog: Personalize your Gitpod Workspace Environments\n\n\n__SPLIT_HERE__\nReady to code üöÄ\n\nYay! You are now ready to get started with an ephemeral Dev Environment on Gitpod.\n\nIf you have questions about configuring your project, drop by our community Discord server. We would love to hear your feedback in the Gitpod Community.","metadata":{"source":"https://gitpod.io/guides/guide-ephemeral-dev-environment-on-gitpod/index"}}],["433",{"pageContent":"A common use case in organizations for developers, when working on Gitpod ephemeral environment, is the need to access various AWS services. For instance, sometimes developers need to pull or push images from or to AWS ECR. These images can be private, so some authentication is required, usually AWS SSO. AWS SSO is a cloud SSO service that makes it easy to centrally manage SSO access to multiple AWS accounts and enterprise applications.\n\nIn this guide, we will show you how you can set up AWS SSO &amp; AWS ECR on Gitpod ephemeral workspace. In 3 simple steps, we will:\n\nInstall aws-cli\nSetup aws-sso\nAccess aws ecr\n\nAll these steps would be automated. So you will always get a ready-to-use workspace with AWS CLI configured, including all the required secrets. This lets you work on many ephemeral workspaces at once frictionlessly as you will not have to install or configure the settings multiple times ‚ú®\n\ntl;dr; You need to configure AWS secrets, add this configuration shell script in your project &amp; this task in your .gitpod.yml for ready-to-code Gitpod Workspace üöÄ\n\n__SPLIT_HERE__\nOverview\n\nWe will provide you with a setup that will provision AWS CLI and enable SSO when you open a new ephemeral Gitpod workspace. The flow diagram below describes how we have done it in our demo-aws-with-gitpod template repo in 3 steps:\n\nCommand Task execution\n\nAs you open a new gitpod workspace, it gets configured through .gitpod.yml file, located at the root of your project. This initiates the config script.\n\nInstallation\n\nThe config script automates the whole process of installing CLI and ECR helper whenever you open a new Gitpod workspace.\n\nConfiguration\n\nWe will use some public configuration options from the SSO like AWS_SSO_REGION, AWS_SSO_URL etc. and add those as environment variables at Gitpod settings. It lets you configure the persistent env variables into your workspace and use them in your code.\n\nLet&#39;s understand the Installation, Configuration and Usage steps in detail.\n\n__SPLIT_HERE__\nüíª Installation\n\nWe will discuss various installation steps and show you a snippet of the configuration script. You can find these lines of code here in the config script.\n\n__SPLIT_HERE__\nInstall AWS CLI on Gitpod\n\nTo Install AWS CLI on Gitpod, you need to run a certain set of commands given in AWS CLI docs. To automate it, we wrote it as a shell script so that you don&#39;t need to run those commands every time.\n\n```sh\ncurl -fSsl \"https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip\" -o \"awscliv2.zip\"\nunzip -qq awscliv2.zip\nsudo ./aws/install --update\nrm awscliv2.zip\n```\n\nIn the above script, we download the AWS CLI zip, unzip it &amp; execute that to install AWS CLI, following which we remove the zip. To automatically get credentials for Amazon ECR, we would need to install ECR-Credential Helper.\n\n__SPLIT_HERE__\nInstall ECR-Credential Helper on Gitpod\n\nThe following script installs the ECR-Credential Helper:\n\n```sh\nif [ ! -f /usr/local/bin/docker-credential-ecr-login ]; then\n    echo \"Installing ecr-login helper\"\n    OLD_DIR=\"$PWD\"\n    TMP_DIR=\"$(mktemp -d)\"\n    cd \"${TMP_DIR}\" || exit 1\n    ECR_LATEST=$(curl -s https://api.github.com/repos/awslabs/amazon-ecr-credential-helper/releases/latest | jq -r \".tag_name\")\n    curl -o docker-credential-ecr-login -fSsL \"https://amazon-ecr-credential-helper-releases.s3.us-east-2.amazonaws.com/${ECR_LATEST##*v}/linux-amd64/docker-credential-ecr-login\"\n    curl -o docker-credential-ecr-login.sha256 -fSsL \"https://amazon-ecr-credential-helper-releases.s3.us-east-2.amazonaws.com/${ECR_LATEST##*v}/linux-amd64/docker-credential-ecr-login.sha256\"\n    sha256sum -c docker-credential-ecr-login.sha256\n    sudo mv docker-credential-ecr-login /usr/local/bin/docker-credential-ecr-login\n    sudo chmod +x /usr/local/bin/docker-credential-ecr-login\n    cd \"${OLD_DIR}\" || exit 1\n    rm -rf \"${TMP_DIR}\"\nfi\n```","metadata":{"source":"https://gitpod.io/guides/integrate-aws-cli-ecr/index"}}],["434",{"pageContent":"(Optional) Install AWS Session Manager Plugin\n\nThis is an optional step, but you should first install the Session Manager plugin on your local machine. This facilitates the AWS CLI to start and end sessions that connect you to your managed nodes.\n\n```sh\nif ! command -v session-manager-plugin; then\n    echo \"Installing AWS session manager plugin\"\n\n      TMP_DIR=\"$(mktemp -d)\"\n      cd \"$TMP_DIR\" || exit 1\n\n      curl \"https://s3.amazonaws.com/session-manager-downloads/plugin/latest/ubuntu_64bit/session-manager-plugin.deb\" -o \"session-manager-plugin.deb\"\n      sudo dpkg -i \"session-manager-plugin.deb\"\n\n      cd \"$OLD_DIR\"\n      rm -rf \"$TMP_DIR\"\nfi\n```\n\n__SPLIT_HERE__\nüß™ Configuration\n\n__SPLIT_HERE__\nConfigure AWS Environment Variables in Gitpod\n\nAWS CLI requires some environment variables to be configured for executing AWS CLI commands. To avoid configuring this every time you spawn a new gitpod ephemeral environment, you can add it with the following Key-Value Map in Gitpod Environment Variables settings:\n\nAWS_SSO_URL\nAWS_SSO_REGION\nAWS_ACCOUNT_ID\nAWS_ROLE_NAME\nAWS_REGION\n\nYou can read more about Configuring the Environment Variables in our documentation\n\n__SPLIT_HERE__\nConfigure AWS environment variable on Gitpod Workspace\n\nTo use configured env variables with aws cli, we need to set the variables in home/gitpod/.aws/config :\n\n```sh\n[[ -d /home/gitpod/.aws ]] || mkdir /home/gitpod/.aws\ncat <<- AWSFILE > /home/gitpod/.aws/config\n[default]\nsso_start_url = ${AWS_SSO_URL}\nsso_region = ${AWS_SSO_REGION}\nsso_account_id = ${AWS_ACCOUNT_ID}\nsso_role_name = ${AWS_ROLE_NAME}\nregion = ${AWS_REGION}\nAWSFILE\n```\n\n__SPLIT_HERE__\nConfigure Docker config to use ECR-Login\n\nTo use the ECR-Credential helper, we need to update the docker configs :\n\n```sh\n# if we don't have a .docker/config.json, create:\n\nif [ ! -d /home/gitpod/.docker ]; then\n    mkdir -p /home/gitpod/.docker && echo '{}' > /home/gitpod/.docker/config.json\nelif [ ! -f /home/gitpod/.docker/config.json ]; then\n    echo '{}' > /home/gitpod/.docker/config.json\nfi\n```\n\n__SPLIT_HERE__\nüöÄ Usage\n\nNow we have the whole AWS Configuration shell script ready. To execute this script at the start of your workspace, you need to add a command task in your .gitpod.yml file.\n\n```yml\ntasks:\n  - name: Initialize & Configure AWS\n    command: bash $GITPOD_REPO_ROOT/configure_aws_with_gitpod.sh\n```\n\nIn demo-aws-with-gitpod template repo, configure_aws_with_gitpod.sh is in the root directory of the repository. You can replace it with your own script‚Äôs path in command task.\n\nYou can find the example .gitpod.yml file here for your reference.\n\nBonus Tip ‚ú®: You can save more time in starting your workspace by using Gitpod Prebuilds. It will prebuild your workspace &amp; directly load that previously built container image to boot it up even faster.\n\nCongratulations üéâ Now, you are ready to use AWS CLI to access AWS ECR through SSO, to use private registries/images. You can also watch the following video, which thoroughly walks you through the whole process:\n\nyoutube: JR3fhDYEwFg\n\n__SPLIT_HERE__\nüìñ Recommended Reading\n\nGitpod\n\nBuild Projects in a Gitpod Ephemeral Dev Environment ‚Äî The Ultimate Guide\nOne workspace per task\nEnvironment variables\nCustom Docker Image\nConfig .gitpod.yml\n\nAWS\n\nAutomatically gets credentials for Amazon ECR on docker push/docker pull\nAWS CLI Command Reference // login\nUsing Amazon ECR with the AWS CLI\nAWS Systems Manager Session Manager\n\nDocker\n\nDocker command line configuration files","metadata":{"source":"https://gitpod.io/guides/integrate-aws-cli-ecr/index"}}],["435",{"pageContent":"Announcement üöÄ : Today, Gitpod and Jetbrains join forces to solve the &#39;works on my machine&#39; problem. Bringing JetBrains&#39; deep product integration with Gitpod&#39;s remote workspaces to developers around the world.\nThis gives developers the best of both worlds -\n\nReproducible developer environments provisioned by Gitpod\nFavorite desktop IDE from Jetbrains - IntelliJ IDEA, PyCharm, GoLand, and PhpStorm\n\nYou can read the full announcement on our blog here.\n\nJetBrains IDEs are one of the highly favored IDEs amongst developers. They provide excellent debugging and refactoring experience and built-in integrations with many tools such as docker, databases, web servers, etc. Through JetBrains Gateway, Gitpod delivers the choice of using JetBrains IDEs as a development environment for Gitpod workspaces. It will provide a familiar developer experience to long time users of JetBrains IDEs with the flexibility of cloud workspaces provided by Gitpod üçä","metadata":{"source":"https://gitpod.io/guides/set-up-spring-boot-application-remotely-with-gitpod-and-jetBrains-gateway/index"}}],["436",{"pageContent":"This guide will teach you to set up a Spring project using JetBrains Gateway and Gitpod. Let&#39;s get started üöÄ\n\n__SPLIT_HERE__\nSetting up your first Spring project using JetBrains Gateway and Gitpod\n\n__SPLIT_HERE__\n1. Setup\n\nGitpod JetBrains IDE integration is powered with JetBrains Gateway, a compact desktop app to connect to remote workspaces without installing an IDE.\n\nInstall JetBrains Gateway\n\n\nInstall Gitpod Plugin in JetBrains Gateway :\n\nOpen JetBrains Gateway Preferences from macOS application menu or Settings from File menu in Linux/Windows.\n\n\nNavigate to Plugins and search for Gitpod in the Marketplace to find and install the Gitpod Gateway plugin.\n\n\nUpdate your preferences on the Gitpod dashboard :\n\nSelect IntelliJ IDEA on the Gitpod preferences page. It will set IntelliJ IDEA as your default desktop IDE for future workspaces. This will launch an IDE window connected to your Gitpod workspace. You can also choose to use other JetBrains IDEs such as GoLand, PyCharm or PhpStorm.","metadata":{"source":"https://gitpod.io/guides/set-up-spring-boot-application-remotely-with-gitpod-and-jetBrains-gateway/index"}}],["437",{"pageContent":"Connect to your workspace from JetBrains Gateway :\n\nOpen JetBrains Gateway on your machine, and click Connect to Gitpod under the Gitpod section, connect to your workspace or create a new one from an existing repository.\n\nIf you want to read about the whole process in detail, you can refer to our online documentation üìñ.\n\n__SPLIT_HERE__\n2. How to create a new Spring Boot project\n\nYou can create a new Gitpod workspace using JetBrains Gateway with our Spring Boot template. This template uses Java 11 and Gradle and is configured for creating Gitpod workspaces.\n\nLaunch JetBrains Gateway and navigate to the Gitpod tab.\nEnter https://github.com/gitpod-io/template-java-spring-boot-gradle as the repository URL and click on New Workspace to start a new Gitpod workspace.\n\n__SPLIT_HERE__\n3. Run your project\n\nWait for the IDE to import the project and install the dependencies.\n\n\nRun your project by clicking on the Run button. IntelliJ IDEA starts your Spring application in the ‚ÄòRun window‚Äô.","metadata":{"source":"https://gitpod.io/guides/set-up-spring-boot-application-remotely-with-gitpod-and-jetBrains-gateway/index"}}],["438",{"pageContent":"Wait for the IDE to import the project and install the dependencies.\n\n\nRun your project by clicking on the Run button. IntelliJ IDEA starts your Spring application in the ‚ÄòRun window‚Äô.\n\n\nOnce the Spring application starts, IntelliJ IDEA will prompt you for the availability of port 8080. Click on the port and select Forward and open in browser to launch the application in your web browser.\n\n\nYou can use the IntelliJ IDEA integrated terminal to run shell commands on your Gitpod workspace as well.\n\nCongratulations üéâüòÑ You have successfully set up your first Spring Boot project using Gitpod and JetBrains Gateway! Further, if you want to learn more about running your existing codebase using Gitpod and JetBrains Gateway, you can follow the next section.\n\n__SPLIT_HERE__\nSetting up your existing codebase using JetBrains Gateway and Gitpod","metadata":{"source":"https://gitpod.io/guides/set-up-spring-boot-application-remotely-with-gitpod-and-jetBrains-gateway/index"}}],["439",{"pageContent":"__SPLIT_HERE__\nSetting up your existing codebase using JetBrains Gateway and Gitpod\n\nYou can open an existing codebase using Gitpod and JetBrains Gateway. To get started with Gitpod, add a .gitpod.yml file in the root directory of your existing codebase.\nThe .gitpod.yml file at the root of your project is where you tell Gitpod how to prepare &amp; build your project, start development servers and configure continuous prebuilds for GitHub.\nHence, improving the developer experience on Gitpod ‚ú®","metadata":{"source":"https://gitpod.io/guides/set-up-spring-boot-application-remotely-with-gitpod-and-jetBrains-gateway/index"}}],["440",{"pageContent":"Customizing .gitpod.yml\n\nHere is the .gitpod.yml, used in our template. It runs Gradle build when you open the workspace.\n\n```yaml\ntasks:\n  - init: ./gradlew build\n```\n\nYou can change the command to build your application or add more commands to run when your workspace starts. You can also add plugins to install in your IDEA instance automatically.\n\nTo learn more about customizing .gitpod.yml according to your requirements, refer to our documentation.\n\n__SPLIT_HERE__\nWorking on Gitpod workspace using JetBrains Gateway\n\nUsing Gitpod on JetBrains Gateway feels like working on a project on a locally installed copy of IntelliJ IDEA. You can use the same shortcuts, powerful debugging tools, refactoring and plugins as you do on your local IDE without needing to set up your entire project on your machine.\n\nThis integration provides you with the best experience of using the cloud development environment of Gitpod and the comfort and familiarity of your JetBrains IDE. ‚ú®","metadata":{"source":"https://gitpod.io/guides/set-up-spring-boot-application-remotely-with-gitpod-and-jetBrains-gateway/index"}}],["441",{"pageContent":"__SPLIT_HERE__\nBitbucket Server\n\nGitpod works with public, private, or internal repositories on your own instance of Bitbucket Server v7.20 or later. Setting this up requires 2 steps.\n\nA one-time registration of the Bitbucket server instance with Gitpod.\nEach Gitpod user connects their account to Bitbucket server the first time they start a workspace.\n\n__SPLIT_HERE__\nRegistering a Bitbucket Server\n\nThe Bitbucket Server Admin can register the Bitbucket Server in their own Gitpod account settings.\n\nStart by creating a New Integration and entering the Provider Host Name of Bitbucket Server.\n\nGitpod New Git Integration form\n\nCopy the Redirect URL from the form above.\n\nOpen your Bitbucket Server Administration settings in another browser tab, and create a new incoming link for an external application.\n\nBitbucket Server new OAuth2 application link\n\nConfigure the link with the required fields, including the redirect URL copied above, and choose &quot;Projects Admin&quot; permissions.\n\nBitbucket Server configure OAuth2 application link\n\nSaving the configuration opens a settings page where you can copy the OAuth Client ID and a Client secret.\n\nBitbucket Server new OAuth client ID and secret\n\nCopy the Client ID and Secret into the corresponding fields in the new Gitpod integration form, and activate the integration.\n\nRefreshing the integration settings page should show a new Git provider connection to your Bitbucket Server in addition to the Git Integration registration below that.\n\nBitbucket Server integration and connection in Gitpod settings\n\n__SPLIT_HERE__\nConnecting Gitpod accounts to Bitbucket Server\n\nOther Bitbucket Server users need to connect their own Gitpod account to their own Bitbucket Server account by starting a workspace.\n\nTo start a workspace, paste the URL of a Bitbucket Server repository into the New Workspace popup (CtrlCmd + O) in Gitpod, or prefix the repository URL as described in Getting started.\n\nOpen in Gitpod form\n\nThe first time you do this, you&#39;ll be prompted to authorize with your Bitbucket Server instance.\n\nPrompt to authorize with Bitbucket Server\n\nThe Bitbucket Server OAuth window will prompt for confirmation to access projects and repositories.\n\nOAuth confirmation from Bitbucket Server\n\nOnce confirmed, the connection will be saved, and the workspace should open. Subsequent workspaces with repositories from the same Bitbucket Server instance should open without reconnecting.\n\n__SPLIT_HERE__\nCreating a project in Gitpod\n\nTo create a new project with a Bitbucket Server repository in Gitpod, select your Bitbucket Server instance from the list of git providers.\n\nNew project with Bitbucket Server\n\nYou should see your own repositories and those for all projects to which you have access. Use the dropdown to switch between your personal account and other projects.\n\nNew project select Bitbucket Server repo\n\nSelecting the repository will install a webhook and enable automatic prebuilds for the project.","metadata":{"source":"https://gitpod.io/docs/configure/authentication/bitbucket-server"}}],["442",{"pageContent":"__SPLIT_HERE__\nBitbucket\n\nGitpod works with any public or private repository on Bitbucket.\n\nTo start a workspace from a Bitbucket project, prefix the Bitbucket project URL with gitpod.io/# as described in Getting started or use the browser extension to add a convenient Gitpod button to every Bitbucket page.\n\n__SPLIT_HERE__\nEnable Prebuilds\n\nAll prebuilds require a Gitpod project for the repository.\n\nTo enable prebuilt workspaces for your Bitbucket project, you need to grant the webhook permission in Gitpod&#39;s Integration Settings page. This allows Gitpod to install a webhook which creates a new prebuild for every push event.","metadata":{"source":"https://gitpod.io/docs/configure/authentication/bitbucket"}}],["443",{"pageContent":"__SPLIT_HERE__\nGitHub Enterprise\n\nGitpod works with public, private, or internal repositories on your own instance of GitHub Enterprise (GHE). Setting this up requires 2 steps.\n\nA one-time registration of the GHE server with Gitpod.\nEach Gitpod user connects their account to GHE the first time they start a workspace.\n\n__SPLIT_HERE__\nRegistering a GitHub Enterprise Server\n\nThe GHE Admin can register the GHE server in their own Gitpod account settings.\n\nStart by creating a New Integration and entering the Provider Host Name of GHE server.\n\nGitpod New Git Integration form\n\nCopy the Redirect URL from the form above.\n\nCreate a new OAuth application in your GHE developer settings, and fill in the Authorization callback URL with the copied value.\n\nGitHub Enterprise register new OAuth application form\n\nPopulate the remaining fields and register the application in GHE. This opens a settings page where you can copy the OAuth Client ID and a Client Secret.\n\nGitHub Enterprise new OAuth client ID and secret\n\nCopy the Client ID and Secret into the corresponding fields in Gitpod and activate the integration.\n\n__SPLIT_HERE__\nConnecting Gitpod accounts to GHE\n\nGHE users connect their Gitpod account to their GHE account by starting a workspace.\n\nTo start a workspace, paste the URL of a GHE repository into the New Workspace popup (CtrlCmd + O) in Gitpod, or prefix the repository URL as described in Getting started.\n\nOpen in Gitpod form\n\nThe first time you do this, you will be prompted to authorize with your GHE instance.\n\nPrompt to authorize with GitHub Enterprise\n\nThe GHE OAuth window will appear, showing the name of the registered Gitpod OAuth app.\n\nOAuth confirmation from GitHub Enterprise\n\nIf you are trying to open a private or internal repository in GHE, you will be prompted to grant additional authorization before the workspace starts.\n\nPrivate repo OAuth authorization from GitHub Enterprise\n\n__SPLIT_HERE__\nValidating your GHE connection with Gitpod\n\nYou should see the connection to your GHE instance, with your GHE account ID, in your Gitpod integration settings\n\nGitHub Enterprise connection in Gitpod integration settings\n\nIf necessary, you can modify your GHE OAuth permissions to allow private repository access using the context menu on the right.\n\nGitpod settings for GitHub integration permissions\n\n__SPLIT_HERE__\nCreating a project in Gitpod\n\nTo create a new project with a GHE repository in Gitpod, select the your GHE instance from the list of git providers.\n\nNew project with GitHub Enterprise\n\nYou should see your own repositories and those for all organizations to which you have access. Use the dropdown to switch between your personal account and other organization accounts. No additional GitHub app installation is required for each organization.\n\nNew project select GitHub Enterprise repo\n\nSelecting the repository will install a webhook and enable automatic prebuilds for the project.\n\nNew project on internal GitHub Enterprise repository","metadata":{"source":"https://gitpod.io/docs/configure/authentication/github-enterprise"}}],["444",{"pageContent":"__SPLIT_HERE__\nGitLab\n\nGitpod works nicely with GitLab: You can start Gitpod workspaces directly from the web pages of your GitLab repositories, and you can configure Gitpod to automatically prebuild these workspaces such that you can start coding on any branch in no time.\n\nTo use Gitpod on GitLab repositories, you have to link your GitLab account to Gitpod. Gitpod redirects you to GitLab&#39;s authentication workflow when needed. Alternatively, you might want to connect your GitLab account manually.\n\nAll of this is already pre-configured for GitLab.com (the SaaS version), and can easily be set up for self-hosted GitLab installations.\n\n__SPLIT_HERE__\nStarting Workspaces\n\nYou can start a Gitpod workspace directly from the web pages of a GitLab repository. Simply click on the dropdown arrow next to the Web IDE split button on the project or merge request page, and choose Gitpod. The Gitpod workspace will open in a new browser tab. The next time you visit a GitLab page, the last used action will be pre-selected.\n\nGitLab Integration\n\nTo launch new Gitpod workspaces for issues, branches, specific commits, etc. you can also prefix any GitLab URL with gitpod.io/# as described in the Getting started page, or use the browser extension to add a convenient Gitpod button to every GitLab page.\n\n__SPLIT_HERE__\nEnabling Prebuilds\n\nAll prebuilds require a Gitpod project for the repository.\n\nTo automatically create a prebuilt workspace for each commit, Gitpod needs access to install a webhook. To allow this, go to Gitpod&#39;s Integrations page, scroll to the &quot;Git Providers&quot; section, click on the three dot button that pops up when you hover over the &quot;GitLab&quot; entry. Then choose Edit Permissions from the popup menu.\n\nGitLab integration actions menu\n\nIn the &quot;Edit Permissions&quot; dialog, make sure that api is checked such that Gitpod is allowed to install the webhook.\n\nModal Edit Permissions of GitLab in the Gitpod settings","metadata":{"source":"https://gitpod.io/docs/configure/authentication/gitlab"}}],["445",{"pageContent":"Connecting Your GitLab Account\n\nTo use Gitpod on a GitLab repository, you have to connect your GitLab account with your Gitpod account. In the following, we assume that you already have a valid account on the GitLab instance you want to connect to.\n\nGitpod supports the following use cases:\n\nGitLabStarting Workspaces\nEnabling Prebuilds\nConnecting Your GitLab AccountConnecting Your GitLab.com Account\nConnecting Your Self-Hosted GitLab Account\nDisconnecting Your GitLab Account\n\n\nRegistering A Self-Hosted GitLab Installation\n\nConnecting Your GitLab.com Account\n\nIf you have initially logged into Gitpod using GitLab, your Gitpod account is already connected to your GitLab.com account and you can skip this section.\n\nIf you have logged into Gitpod with a different provider, you can manually add your GitLab account as follows:\n\nOpen the integrations page. Scroll to the section about &quot;Git Providers&quot; and click on the three dot button that pops up when you hover over the GitLab item. Select Connect from the popup menu.\n\nGitLab integration connect menu item\n\nYou will be redirected to GitLab&#39;s login page. Log in with your username and password or choose one of the OAuth providers from the list.\n\n\nOnce logged in successfully, you will be asked to authorize Gitpod to access your personal information on GitLab and use their API. Click Authorize.\n\nGitLab: Authorize Gitpod\n\nYou&#39;ll be directed back to Gitpod&#39;s settings page. A green bullet left to GitLab signals you&#39;ve successfully linked your GitLab account with Gitpod.\n\nGitLab integration connected\n\nConnecting Your Self-Hosted GitLab Account\n\nA Self-Hosted GitLab installation has to be registered to Gitpod before it can be used. Once that&#39;s done, you can link your GitLab account on that installation to GitPod using the following steps:\n\nMake sure you are logged into Gitpod.\nIn the same browser, open a new tab and navigate to a repository of the GitLab installation.\nStart a new Gitpod workspace on this repository.\n\nDisconnecting Your GitLab Account\n\nTo disconnect a GitLab account from your Gitpod account:\n\nOpen the integrations page. Scroll to the section about &quot;Git Providers&quot; and click on the three dot button that pops up when you hover over the item of the GitLab provider you want to disconnect. Select Disconnect from the popup menu.\n\nThis will only invalidate the current access token in Gitpod. To disable access for good you have to revoke the access to Gitpod on the GitLab side.","metadata":{"source":"https://gitpod.io/docs/configure/authentication/gitlab"}}],["446",{"pageContent":"Registering A Self-Hosted GitLab Installation\n\nThe SaaS service GitLab.com is already pre-configured in Gitpod. But if you are using a Self-Hosted GitLab installation, you have to register it in Gitpod before it can be used.\n\nNote that the registration has to be done by one Gitpod user only, and that the GitLab account of this user is automatically connected. All other users of the same GitLab installation should just link to their GitLab accounts.\n\nHere is how to register your Self-Hosted GitLab installation:\n\nIn your GitLab installation, enable the native Gitpod integration as described in the GitLab docs. This needs administrator privileges on the GitLab installation.\n\n\nHead over to the integrations page on Gitpod. Scroll to the section about Git Integrations and click on the &quot;New Integration&quot; button.\n\nGit Integrations section in the Gitpod settings\n\nIn the pop-up window, choose GitLab as the provider type and enter the URL of the GitLab installation you want to use.\n\nNew Git integration dialog\n\nThe next field in the form is the redirect URL that you need to register Gitpod on the GitLab side. Copy the redirect URL to your clipboard using the button on the right.\n\n\nGo to /profile/applications on your GitLab installation to create an OAuth app. Type in a name (e.g. &quot;Gitpod&quot;) and paste the redirect URL in the corresponding text area. Check the scopes api and read_user. Click the button Save Application below.\n\nCopy the Application ID and the Secret in the corresponding form fields (Client ID resp. Client Secret) of your Gitpod installation.\n\nPress Connect and go through the GitLab authentication flow to connect your user account.","metadata":{"source":"https://gitpod.io/docs/configure/authentication/gitlab"}}],["447",{"pageContent":"__SPLIT_HERE__\nGitHub\n\nGitpod works well with public or private repositories from github.com.\n\nThe first time you login to Gitpod with GitHub, you will be prompted to &quot;Authorize Gitpod&quot; to access your GitHub account. This creates a connection between Gitpod and your GitHub account, and installs an OAuth App in your GitHub settings.\n\nGitpod uses the name and email from your GitHub account ID to create a new Gitpod user account. This is sufficient to start a Gitpod workspace on a public repository.\n\nGitHub prompt for Gitpod OAuth App permissions with user:email scope\n\n__SPLIT_HERE__\nStarting Workspaces\n\nTo start a new workspace after logging into Gitpod, use CtrlCmd + O or click on the New Workspace button in https://gitpod.io/workspaces. This will prompt for a repository URL, or suggest recent repositories opened with your account.\n\nYou can also start a Gitpod workspace using a GitHub repository URL. Simply point your browser to the repository URL prefixed with gitpod.io/# as described in Getting started.\n\n__SPLIT_HERE__\nGranting additional GitHub OAuth permissions\n\nGitHub requires repo scope permissions to open a workspace on a private repository, or to push code changes from a workspace back to your repository.\n\nYou can grant these additional permissions for GitHub at https://gitpod.io/integrations using the context menu on the right.\n\nGitpod settings for GitHub integration permissions\n\n__SPLIT_HERE__\nAuthorizing GitHub webhooks\n\nThe first time you create a new Gitpod project you will need to configure our GitHub App to watch your repositories and trigger prebuilds.\n\nNOTE: Installing the GitHub App for webhooks is only required for github.com, not for GitHub Enterprise or other git providers.\n\nGitpod new project prompt for GitHub App authorization\n\nThe App must be installed on every GitHub user or organization account with repositories used in a Gitpod project. This allows you to grant permissions for all repositories or select repo-by-repo.\n\nGitHub App repo authorization\n\n__SPLIT_HERE__\nErrors with private repositories on GitHub orgs\n\nIf you encounter errors setting up a Gitpod project on a private repository in a GitHub org, you may need to approve the Gitpod OAuth app for 3rd party access to the org.\n\nIn https://github.com/settings/connections/applications/484069277e293e6d2a2a.\nLook for the org in question in the lower section of the page under &#39;Organization access&#39;.\nClick on the Grant button.\n\nFor more details, see Issue #8076.","metadata":{"source":"https://gitpod.io/docs/configure/authentication/github"}}],["448",{"pageContent":"__SPLIT_HERE__\nAuthentication\n\nGitpod comes with integrations for GitLab, GitHub, and Bitbucket projects. It also provides a browser extension or a browser bookmarklet for Chromium-based browsers (Chrome, Edge, Brave) and Firefox.\n\nyoutube: nXMlnMEP784\n\n__SPLIT_HERE__\nFAQs\n\n&quot;Email address already used in another account&quot; when trying to login into Gitpod\n\nSend us a message through the contact form with your Gitpod account email. After you reach out, we will delete your account so that you can sign up again, which should resolve your issue.\n\nHow to get SCM API token from Gitpod&#39;s GitLab, GitHub or Bitbucket integration as environment variable\n\nRun gp init on your terminal or manually create a file called .gitpod.yml\n\nPut the following line in your .gitpod.yml:\n\n```yaml\nimage:\n  file: .gitpod.Dockerfile\n```\n\nCreate a file called .gitpod.Dockerfile and put the following content in it:\n\n```dockerfile\nFROM gitpod/workspace-full\n\nRUN file=\"$HOME/.bashrc.d/770-scm_token.sh\" \\\n    && printf '%s\\n' 'if [[ \"${GITPOD_WORKSPACE_CONTEXT_URL:-}\" == *gitlab* ]]; then : \"gitlab\"; else : \"github\"; fi; scm_name=\"$_\"' > \"${file}\" \\\n    && printf 'export SCM_TOKEN=\"$(%s)\"\\n' \"gp credential-helper get <<<host=\\${scm_name}.com | sed -n 's/^password=//p'\" >> \"${file}\"\n```\n\nFollow see in action\n\nNow you can use $SCM_TOKEN environment variable after you commit and create a new workspace, this variable will contain an API token based on the Git context (i.e. Gitlab/GitHub/Bitbucket)\n\nHow to use a private GitHub email or custom email for Git commits\n\nAt the variables page, create two variables[1] called:\n\nGIT_COMMITTER_EMAIL\nGIT_AUTHOR_EMAIL\n\nand set the custom email address as the value and */* as the scope.\n\nNow all of your new workspaces should use them for Git commits. If you have a workspace running, you can restart it or run eval &quot;$(gp env -e)&quot; in it.","metadata":{"source":"https://gitpod.io/docs/configure/authentication/index"}}],["449",{"pageContent":"__SPLIT_HERE__\nBilling\n\nGitpod charges for usage based on how long workspaces run, and the resources consumed by different workspace classes. Metered usage also includes prebuilds.\n\nAs an individual user, you receive a free usage allowance so that you can try Gitpod without a billing account. A personal billing account is required for additional usage beyond that.\n\nOrganization billing accounts provide a way to pay for organization members&#39; usage when they run workspaces on organization projects.\n\n__SPLIT_HERE__\nCredits\n\nGitpod usage is measured in credits.\n\nLarger workspace classes use credits at a faster rate. E.g. Standard workspaces use 10 credits per hour, whereas Large workspaces use 20 credits per hour.\n\nYour invoice will show the total amount of credits consumed in a billing period.\n\n__SPLIT_HERE__\nConfigure personal billing\n\nThe personal billing page is located in your account settings.\n\nüí° If you do not see &quot;Billing&quot; in your settings, cancel your existing plan or organization plan first.\n\nThe Gitpod Free plan comes with 500 free credits, renewed monthly. These credits can be used for all workspace classes. Unused credits expire at the end of each month.\n\nConfiguring a Personal billing plan in your user billing settings will increase your monthly credit allowance from 500 to 1000. Additional usage will be charged at the pay-as-you-go rate.\n\nConfigure Personal billing\n\nYou can add a payment method with credit card details in Euros or Dollars.\n\nAdd payment details\n\nOnce billing has been configured, use the &quot;Manage Plan&quot; button to modify your payment details or cancel.\n\nActive Personal billing\n\nIf you are a member of an organization with billing, you can select the organization to pay for all your personal usage under &quot;Default Billing Account&quot;.\n\nSelect default billing account\n\n__SPLIT_HERE__\nConfigure organization billing\n\nOrganization owners can configure billing for an organization in their organization settings.\n\nüí° You may need to cancel your existing Professional or Unleashed organization-billing plan first.\n\nConfigure Team Billing\n\nOnce organization billing is configured, Gitpod will charge the organization billing account for usage by organization members, when they start workspaces on organization projects, and for prebuild usage on organization projects.\n\nActive Team billing\n\n__SPLIT_HERE__\nConfigure a usage limit\n\nThe usage limit prevents workspaces from starting once the limit has been reached. It will not stop running workspaces.\n\nTo change the usage limit, look for &quot;Update limit&quot; in the BALANCE section of your personal or organization billing settings, after you have configured billing.\n\nActive Team billing\n\n__SPLIT_HERE__\nView usage details\n\nYou can see the details of your personal usage when you click on &quot;View Usage ‚Üí&quot; in your personal billing settings. Organization owners can view usage details for their organization.\n\nActive Team billing\n\n__SPLIT_HERE__\nOld pricing plans\n\nUsers with old paid plans, may need to cancel those plans before configuring their personal or organization billing accounts.\n\nOrganization plans\nOrganization billing\n\n__SPLIT_HERE__\nFAQs\n\nHow can I limit or optimize prebuild costs?\n\nThere are a few built-in Gitpod features that can optimize your prebuild costs, such as:\n\nSkip prebuilds every X commits and use last successful prebuild\n\n\nStop prebuilds for all branches, PRs and etc. when on GitHub. See this page. (might not be necessary)\n\nWith prebuilds enabled, does every push to my repository cost me credits?\n\nIt depends on how you configured prebuilds. Prebuilds run on headless Gitpod workspaces and the cost depends on how long they run when triggered.","metadata":{"source":"https://gitpod.io/docs/configure/billing/index"}}],["450",{"pageContent":"__SPLIT_HERE__\nOrganization billing\n\nThe plans below have been superseded by our new billing model.\n\nThis page is for users who are looking to manage or cancel their existing organization billing plans.\n\nOrganization billing allows you to pay for your whole organization with a single subscription. You can choose between the Organization Professional plan, or the Organization Unleashed plan.\n\nWith Organization billing, all plan seats will be managed automatically, by auto-subscribing new members, and unsubscribing members who leave.\n\nOrganization billing can be accessed under Organization Settings if you are an organization owner.\n\nTeam billing New\n\nOnce a plan is active, Organization billing will auto-subscribe new members, and the count will update automatically.\n\nLook for the green button to manage your payment details or to cancel your subscription.\n\nTeam billing New\n\n__SPLIT_HERE__\nGood to know\n\nan organization can only have one active Organization billing plan.\nWith Organization billing, all organization members, including owners, are auto-subscribed to the plan.\nNew members are added using a shared invite URL which can be reset.\nWhen new members join in the middle of a billing period, you will be billed pro-rata for the remaining fraction of the month.\nSee Organizations &amp; Projects to create a new Organization.","metadata":{"source":"https://gitpod.io/docs/configure/billing/org-billing"}}],["451",{"pageContent":"__SPLIT_HERE__\nOrganization plans\n\nThe organization plans below have been superseded by our new billing model.\n\nThis page is for users who are looking to manage or cancel their existing organization plans.\n\nOrganization plans allow you to pay for your whole organization with a single subscription.\n\nOrganization plans are accessed from gitpod.io/orgs/ in your user settings.\n\nYou can choose between the Organization Professional plan, or the Organization Unleashed plan, and you can specify how many seats you want for each organization. Each member of the Organization Plan will then be able to use Gitpod as if they had purchased their own Professional or Unleashed plan.\n\nNew Team Plan\n\nOnce the payment process is complete, you can manage organization members, add more organization seats, and also invite organization members using a unique public URL.\n\nOrganization Plan Billing Manage Organization Plan Members\nTeam Plan Billing Manage Team Plan Members\n\nYou can either directly assign a seat by entering your organization member&#39;s GitHub, GitLab, or Bitbucket username, or use the Invite Members link from the more actions button to get a shareable link. Send the link to your organization so they can claim a seat.\n\nManage an organization Invite Members\nNew Team New Team\n\n__SPLIT_HERE__\nGood to know\n\nYou won&#39;t be assigned to a seat in your new organization plan when it is first created. Add yourself just like other members.\nIf you add seats in the middle of a monthly billing period, you will be charged for the whole period.","metadata":{"source":"https://gitpod.io/docs/configure/billing/org-plans"}}],["452",{"pageContent":"__SPLIT_HERE__\nOrganizations\n\nOrganizations are used to share Projects amongst organization members.\n\nThere are two roles within a Gitpod organization organization owners and organization members. Organization members and owners can view branches and prebuilds for the projects within an organization. Organization members can open new workspaces directly from a branch in the dashboard. Organization owners can manage other organization members, reset user invite URLs, and manage Organization billing.\n\nTo collaborate with others on projects you can create a Organization and invite others as organization members.\n\nView organizations\n\nTo view all your organizations, click on the scope selector on the left of the top bar.\n\nCreate an organization\n\nTo create a new organization:\n\nOn the top bar, click on the scope selector and select New Organization.\nNext, you will be asked for an organization name that will serve also as the organization slug.\n\nAdd members to an organization\n\nOnce you create an organization you can invite members by using the unique invite URL from the Members page within an organization.\n\nChange member permissions\n\nNew members will join with a Member role which you can later change if needed from the Members list using the more actions button. See Roles below.\n\nRemove a member from an organization\n\nYou can remove an organization member form the Members list using the more actions button while hovering over the user entry.\n\nFilter members in an organization\n\nOn the Members page you can filter users by membership role using the filters above the Members list.\n\nLeaving an organization\n\nYou can leave an organization using the more actions button in the Members list while hovering over your user entry.\n\n__SPLIT_HERE__\nRoles\n\nPermission Owner Member\nManage Organization Members Yes No\nEdit Organization Settings Yes No\nManage Organization Billing Yes No\nView Organization Usage Yes No\nEdit Project Settings Yes Yes\nEdit Project Variables Yes Yes\nInvite Organization Members Yes Yes\nAdd Projects Yes Yes\nRemove Projects Yes Yes\nAdd Projects Yes Yes\nView Branches Yes Yes\nView Prebuilds Yes Yes\nTrigger Prebuilds Yes Yes","metadata":{"source":"https://gitpod.io/docs/configure/orgs/index"}}],["453",{"pageContent":"__SPLIT_HERE__\nEnvironment Variables\n\nYou can pass environment variables into your workspace and use them in your code as usual. Please refer to the documentation of your programming language of choice for details on that.\n\nyoutube: dehln1E8ylY\n\n__SPLIT_HERE__\nDefault Environment Variables\n\nBelow are some environment variables which are set automatically by Gitpod and are guaranteed to exist:\n\nGITPOD_WORKSPACE_ID: The Universally Unique Identifier (UUID) associated with the workspace.\nGITPOD_WORKSPACE_URL: The unique URL of the workspace.\nGITPOD_REPO_ROOT: Path to the directory where your git repository was cloned inside the workspace.\n\nTip: Try running env | grep GITPOD_ on a workspace terminal to see all the Gitpod specific environment variables. These can be useful for scripting a dynamic workspace behavior.\n\nReserved Prefix\n\nEnvironment variables beginning with the prefix GITPOD_ are reserved for internal use by Gitpod and are overridden on every workspace startup. This means that a user-defined variable set with the name GITPOD_FOOBAR will be ignored and not accessible in the workspace.","metadata":{"source":"https://gitpod.io/docs/configure/projects/environment-variables"}}],["454",{"pageContent":"User-Specific Environment Variables\n\nGitpod supports encrypted, user-specific environment variables.\nThey are stored as part of your user settings and can be used to set access tokens, or pass any other kind of user-specific information to your workspaces.\n\nThe DOCKERD_ARGS environment variable can be used to specify additional arguments to the docker installation running in your workspace. Currently\nmapping a user in your container to the gitpod user in your workspace is supported. This helps if you are using an unprivileged user with your containers\n(e.g. user 1000 in a node image) but need to edit files with vscode that have been created within the container. The content of the environment variable\nshould look like this:\n\n```json\n{ \"remap-user\": \"1000\" }\n```\n\nWays of setting user-specific environment variables\n\nUsing the command line: gp env\n\nThe gp CLI prints and modifies the persistent environment variables associated with your user for the current repository.\n\nTo set the persistent environment variable foo to the value bar use:\n\n```sh\ngp env foo=bar\n```\n\nBeware that this does not modify your current terminal session, but rather persists this variable for the next workspace on this repository.\ngp can only interact with the persistent environment variables for this repository, not the environment variables of your terminal.\nIf you want to set that environment variable in your terminal, you can do so using -e:\n\n```sh\neval $(gp env -e foo=bar)\n```\n\nIf you&#39;re using fish shell:\n\n```sh\neval (gp env -e foo=bar)\n```\n\nTo update the current terminal session with the latest set of persistent environment variables, use:\n\n```sh\neval $(gp env -e)\n```\n\nIf you&#39;re using fish shell:\n\n```sh\neval (gp env -e)\n```\n\nTo delete a persistent environment variable use:\n\n```sh\ngp env -u foo\n\n# And if you want to remove it from your shell session too:\nunset foo\n```\n\nNote that you can delete/unset variables if their repository pattern matches the repository of this workspace exactly. I.e. you cannot\ndelete environment variables with a repository pattern of /foo, foo/ or /.\n\n```sh\nUsage:\n  gp env [flags]\n\nFlags:\n  -e, --export   produce a script that can be eval'ed in Bash\n  -h, --help     help for env\n  -u, --unset    deletes/unsets persisted environment variables\n```\n\nUsing the account settings\n\nYou can also configure and view the persistent environment variables in your account settings.\n\nEnvironment Variables in Account Settings\n\nYou can add as many environment variables as you wish.\n\nThe repository pattern of each variable determines in what workspace it will be available.\nRepository patterns follow the owner/repository pattern. You can use a wildcard on either of the two, e.g. gitpod-io/* would make that variable available in all repositories owned by gitpod-io.\nConversely */vscode would make that variable available on all repositories called vscode; this is especially useful for forks.\nSubsequently */* makes that variable available in every workspace.\n\nBeware: while the variable values are stored encrypted, they are available as plain text inside a workspace. Be careful when sharing your live workspace or when using */* as repository pattern.\n\n__SPLIT_HERE__\nProject-Specific Environment Variables\n\nEnvironment variables which are defined in project settings will be visible in prebuilds, and optionally also in workspaces. This is useful for prebuilds to access restricted services.\n\nImportant notes:\n\nProject-Specific Environment Variables will take precedence over User-Specific Environment Variables\nThe gp env command is only linked with User-Specific Environment Variables but not Project-Specific Environment Variables. That means, if you set an environment variable with the gp env command, it will be saved in your account settings.\n\nWarning: Care should be taken with secrets. Allowing secrets to be accessed from workspaces will expose those secrets to anyone who can open the workspace.","metadata":{"source":"https://gitpod.io/docs/configure/projects/environment-variables"}}],["455",{"pageContent":"Task terminal-specific Environment Variables\n\nYou can set environment variables for a Gitpod task terminal by setting the env property within the task definition in your .gitpod.yml. Please note that such environment variables will be limited to the task terminal and are not globally set across the workspace.\n\nUsing the env keyword\n\n```yaml\ntasks:\n  - name: Example of setting an environment variable for a task terminal\n    env:\n      PRINT_ME: \"Hello World!\"\n    command: echo \"$PRINT_ME\"\n```\n\nNote: The values should be a static string or integer, you can&#39;t refer to an existing variable via env keyword.\n\nUsing the task SHELL\n\n```yaml\ntasks:\n  - name: Example of starting yarn with a custom environment variable set\n    command: |\n      # Example for referring to the existing system variables\n      export API_URL=\"$HOSTNAME\"\n\n      # Print out the environment variable\n      echo \"$API_URL\"\n\n      yarn start\n\n  - name: Example of updating PATH environment variable inside a task shell\n    command: |\n      # Download and install `fzf` binary to ~/.local/bin/\n      mkdir -p ~/.local/bin\n      curl -sL \"https://github.com/junegunn/fzf/releases/download/0.35.1/fzf-0.35.1-linux_amd64.tar.gz\" | tar -C ~/.local/bin -xpz\n\n      # Update PATH variable\n      export PATH=\"$HOME/.local/bin:$PATH\"\n\n      # Now `fzf` can be called without full path from the task shell\n      ls / | fzf\n```\n\nNote: You can use this method when you need to refer to other variables or want to use scripting to set them conditionally.\n\nSee .gitpod.yml for more details.\n\n__SPLIT_HERE__\nProviding one-time environment variables via URL\n\n‚ùóÔ∏è This feature is great for setting one-time environment variables for dynamic workspace configurations or setups but is not appropriate for configuring sensitive information, such as passwords or long-lived API tokens. Gitpod and the Open Web Application Security Project recommends that you do not pass sensitive information through query strings. Refer to CWE-598 to learn more about this recommendation.\n\nIn addition to user-specific environment variables, Gitpod also allows passing in variables through the gitpod.io/# URL.\nThe syntax for that is:\n\n```\nhttps://gitpod.io/#var=value,var2=value2/https://github.com/my-org/repo-to-work-on\n```\n\nThe values are URL encoded to allow any non-ascii characters in values.\nIn case of a conflict, e.g. in the example above if the user already had a variable var2 set, the user&#39;s value would be used.\n\n__SPLIT_HERE__\nExporting all the Gitpod environment variables that you created\n\nYou can run the following command in your Gitpod Workspace terminal to save your environment variables (which you have configured in Gitpod Environment Variables) in a different file (e.g.: gitpod.env):\n\n```bash\ngp env > gitpod.env\n```","metadata":{"source":"https://gitpod.io/docs/configure/projects/environment-variables"}}],["456",{"pageContent":"__SPLIT_HERE__\nIncremental Prebuilds\n\nSimilar to last successful prebuild, incremental prebuilds leverage older prebuilds in order to create new prebuilds faster.\n\nEnable Incremental Prebuilds\n\nAn incremental prebuild is based on an older prebuild that was built for an older commit, in order to reuse pre-existing build artifacts. This is achieved by:\n\nLoading the older prebuild\nUpdating the source code to the latest commit\nRunning any before, prebuild, and init tasks again (incremental rebuild)Note: This means that your init tasks will be run twice on the same checkout, i.e. they need to be reentrant\n\n__SPLIT_HERE__\nHow is a base prebuild selected?\n\nWhen incremental prebuilds are enabled for a project, and a new prebuild is being triggered, Gitpod will do the following:\n\nRetrieve the commit history of the current commit to be built (up to 100 ancestor commits)\nFor each ancestor commit, check if there exists a corresponding prebuild that can be used as a &quot;base&quot;:A suitable &quot;base prebuild&quot; must have been successful (i.e. failed, canceled, or timed out prebuilds are not reused)\nIt must be a recent, direct ancestor of the current commit (i.e. not a commit from a different unrelated branch)\nIt must be based on the same project configuration as the current commit (for example, if the Docker image or the init tasks have recently been changed, older prebuilds are no longer relevant or useful and cannot be used as a &quot;base&quot;)\n\n\nIf a suitable base prebuild is found, Gitpod will load it; update the checkout to the latest commit; and then re-run any before, prebuild and init task on top of itIf no suitable base prebuild is found, Gitpod will build the new prebuild from scratch (i.e. a non-incremental prebuild)\n\n__SPLIT_HERE__\nWhen are incremental prebuilds useful?\n\nIncremental prebuilds can significantly speed up most of your prebuilds, especially if:\n\n```\n(time_to_load_older_prebuild + incremental_rebuild_duration) < full_prebuild_duration\n```\n\nTypically, enabling incremental prebuilds makes sense if:\n\nYour project&#39;s build system benefits from incremental rebuilds (i.e. rebuilds are significantly faster than your initial build)\nYour regular prebuilds take longer than 5 minutes (the longer they take, the bigger the potential speedup is)","metadata":{"source":"https://gitpod.io/docs/configure/projects/incremental-prebuilds"}}],["457",{"pageContent":"__SPLIT_HERE__\nProjects\n\nProjects live under a Gitpod organization. They connect Gitpod to a git repository. A Gitpod project can only have one git repository, and a git repository can only belong to one project.\n\nA project is required in order to trigger prebuilds on a repository. Organization members use the project to configure and view prebuilds.\n\nWith organization billing, all project usage such as workspaces and prebuilds, may be billed to the organization.\n\nProjects have a static URL based on the organization and project name, for example:\n\nhttps://gitpod.io/t/&lt;team&gt;/&lt;project&gt;\n\nView projects\n\nThe Projects page for a organization shows a card for each project.\n\nCards show the name, repository URL, quick links to project branches and prebuilds, and the branch and timestamp of the latest prebuild.\n\nAdd a new project\n\nTo add a new project, click on New Project on the Projects page for the organization, and select a repository from the list.\n\nThe list will show repositories from one of your git providers. Select a different provider if necessary. You may also be prompted to configure our GitHub app, the first time a project is created for a GitHub account. The new project will be associated with the current organization selected in the dashboard.\n\nConfigure a project\n\nOrganization members can configure Prebuilds, and set the workspace class used for project workspaces, in project settings.\n\nProject Settings\n\nRemove a project\n\nYou can remove a project using the &quot;Remove project&quot; action from a project card.\n\n__SPLIT_HERE__\nFAQs\n\nNew Project page is stuck at fetching repositories\n\nTo identify the problem: check browser console logs.\n\nPossible solution(s):\n\nTry to disconnect Git(Hub/Lab) or Bitbucket from https://gitpod.io/integrations, then reconnect.\nMake sure correct scopes are set for those Git integration providers as well.","metadata":{"source":"https://gitpod.io/docs/configure/projects/index"}}],["458",{"pageContent":"__SPLIT_HERE__\nLast Successful Prebuild\n\n{title} is currently in Alpha ¬∑ Send feedback.\n\nSimilar to incremental prebuilds, last successful prebuild leverages older prebuilds in order to create new workspaces faster.\n\nUse Last Successful Prebuild\n\nWhen enabled, new workspaces may start based on a prebuild that was built for an older commit, in order to reuse any existing build artifacts. This is achieved by:\n\nLoading the older prebuild\nUpdating the source code to the latest commit\nRunning any before, prebuild, and init tasks again interactively (incremental rebuild)Note: This means that your init tasks will be run twice on the same checkout, i.e. they need to be reentrant\n\nThus, your new workspace will both:\n\nload quickly: no waiting, even if a newer prebuild is still being computed (i.e. you&#39;ll never see the &quot;Prebuild in Progress&quot; screen again ‚è©)\nand it will be ready quickly: your IDE Terminal will run either no build at all (if none is needed), or just a quick incremental rebuild (faster than a full build ‚ôªÔ∏è)\n\n__SPLIT_HERE__\nSkip Prebuilds\n\nWhen Gitpod can leverage older prebuilds to start your workspaces faster, you no longer necessarily need to create a new prebuild for every commit that is pushed to your repository.\n\nThis is where the ability to skip prebuilds becomes helpful: For example, you could decide to only trigger a new prebuild every 5 commits, or every 10 commits.\n\nThe ideal number depends on your project. For example:\n\nIf you push new commits to your repository very frequently, you may want a higher number (especially if your prebuilds also take a long time to build)\nOn the other hand, if your prebuilds finish quickly, and you typically don&#39;t push new commits very often, it may be fine to not skip any prebuild (i.e. skip prebuilds = 0)\n\nPlease feel free to adjust and experiment with this value.","metadata":{"source":"https://gitpod.io/docs/configure/projects/last-successful-prebuild"}}],["459",{"pageContent":"&lt;OpenGraph\ndata={{\n    description:\n      &quot;Learn how to configure prebuilds for your Gitpod projects.&quot;,\n    title: &quot;Gitpod Prebuilds&quot;,\n    keywords: &quot;prebuilds, Gitpod, faster workspace start, faster workspace init, faster workspace creation&quot;,\n  }}\n/&gt;\n\n__SPLIT_HERE__\nPrebuilds\n\nPrebuilds reduce wait time, by installing dependencies or running builds before you start a new workspace.\n\nyoutube: DwkoOz1GSVg\n\n__SPLIT_HERE__\n.gitpod.yml\n\nPrebuilds are typically configured using an init task in your gitpod.yml.\n\nIn the example below, the init task installs npm packages into the node_modules directory of the workspace. The command task runs &#39;npm start&#39; on every workspace startup.\n\n```yaml\ntasks:\n  - init: |\n      npm install\n  - command: |\n      npm start\n```\n\n__SPLIT_HERE__\nEnable prebuilds on your repository project\n\nUse the following steps to enable prebuilds on your repository:\n\nCreate a project for the repository.\nDefine the prebuild steps in an init task in your gitpod.yml.\n\nSince prebuilds are included in all our metered pay-as-you-go plans, configuring prebuild settings in your project should help with managing prebuild usage.\n\n__SPLIT_HERE__\nProjects and prebuilds\n\nFor prebuilds to run automatically, you also need a project for your repository.\n\nTo create a new project:\n\nClick on New Project in the Projects page of one your organizations.\n\n\nIf necessary, you will be prompted for additional authorization to install and configure the Gitpod GitHub app,\nso that Gitpod can watch your repositories and trigger prebuilds.\n\n\nSelect the repository for your project.\n\nView prebuilds\n\nYou can find a list of recent prebuilds under the Prebuilds tab for your project.\n\nRecent prebuilds list for an example project\n\nFrom here, you may also trigger a new prebuild based on the last commit in the project. Selecting a prebuild will open the details page showing the current status as well as additional logs. From the prebuild details page, you may rerun the selected prebuild or start a new workspace based on it.\n\nRerun a prebuild\n\nPrebuilds can be triggered again which can be particularly useful when debugging an unexpected failure.\n\nTo rerun a prebuild:\n\nNavigate to your project and select the Prebuilds tab.\nSelect the prebuild you wish to rerun.\nSelect Rerun Prebuild.\n\nStart workspace based on existing prebuild\n\nTo start a workspace using an existing prebuild:\n\nNavigate to your project and select the Prebuilds tab.\nSelect the prebuild you wish to start a workspace on top of.\nSelect New Workspace (with this prebuild).\n\n__SPLIT_HERE__\nPrebuilds are shared\n\nGitpod can trigger a prebuild whenever there is a commit to a repository. That prebuild will then be used for all new workspaces opened on that branch. This is ideal for working together on branches for testing or code reviews.\n\nPrebuild users will see a message in their workspace terminal like this:\n\n```txt\nü§ô This task ran as a workspace prebuild\n```\n\n__SPLIT_HERE__\nWorkspace directory only\n\nPrebuilds save only the workspace directory. Other directories like the home directory are not saved by prebuilds.\n\nTo use global installs like &#39;npm install -g&#39;, we suggest using a custom Dockerfile or a before task, which runs before the init task, and runs again before the command task.\n\nProject environment variables\n\nEnvironment variables which are defined in project settings will be visible in prebuilds. This is useful for prebuilds to access restricted services.\n\nWARNING\nCare should be taken with secrets in prebuilds. Do not save secrets in a way which could leak into workspaces. This especially true for public repositories.","metadata":{"source":"https://gitpod.io/docs/configure/projects/prebuilds"}}],["460",{"pageContent":"Configuring prebuilds manually\n\nAll prebuilds require a Gitpod project for the repository.\n\nFor a GitLab or Bitbucket repository, allow Gitpod to install repository webhooks, by granting api permissions in your git provider integrations\n\nFor GitLab, if you want to trigger new Gitpod prebuilds for specific branches only, you can configure this in your GitLab project settings.\n\nBy default, Gitpod prepares prebuilt workspaces for all changes on the default branch and for pull/merge requests coming from the same repository.\n\nNote: Prebuilds are executed as the user who enabled them. This means that if you want to use\nprebuilds on a private repository, you must give Gitpod access to private repositories.\n\nPrebuilds are configured in your repository&#39;s .gitpod.yml file with the following start tasks:\n\nbefore\ninit\n\nNote the absence of the command task. Since this task may potentially run indefinitely, e.g. if you start a dev server, Gitpod does not execute the command task during prebuilds.\n\nPrebuilds have a timeout of 1 hour. If your before and init tasks combined exceed 1 hour, your prebuild will fail. Subscribe to this issue for updates when this limit will be lifted.\n\nEach prebuild starts with a clean environment. In other words, Gitpod does not cache artifacts between prebuilds.\n\nIncremental Prebuilds use an earlier, successful Prebuild as the base. This can reduce the duration of your Prebuilds significantly, especially if they normally take more than ten minutes to complete. Incremental Prebuilds can be found under the project settings in your Gitpod dashboard.","metadata":{"source":"https://gitpod.io/docs/configure/projects/prebuilds"}}],["461",{"pageContent":"GitHub-specific configuration\n\nThe github prebuilds section in the .gitpod.yml file configures when prebuilds are run.\nBy default, prebuilds are run on push to the default branch and for each pull request coming from the same repository.\nAdditionally, you can enable prebuilds for all branches (branches) and for pull requests from forks (pullRequestsFromForks).\n\nNote: The Gitpod GitHub app has no equivalent for GitLab or Bitbucket yet, so this entire section is GitHub-specific for now.\n\n```yaml\ngithub:\n  prebuilds:\n    # enable for the default branch (defaults to true)\n    master: true\n    # enable for all branches in this repo (defaults to false)\n    branches: false\n    # enable for pull requests coming from this repo (defaults to true)\n    pullRequests: true\n    # enable for pull requests coming from forks (defaults to false)\n    pullRequestsFromForks: false\n    # add a check to pull requests (defaults to true)\n    addCheck: true\n    # add a \"Review in Gitpod\" button as a comment to pull requests (defaults to false)\n    addComment: false\n    # add a \"Review in Gitpod\" button to the pull request's description (defaults to false)\n    addBadge: false\n```\n\nAdditional GitHub integration\n\nOnce the GitHub app is installed, Gitpod can add helpful annotations to your pull requests.\n\nChecks\n\nBy default, Gitpod registers itself as a check to pull requests - much like a continuous integration system would do.\n\nThe default behavior, however, would not make the checks fail when the prebuild failed.\nThis can be enabled with the following snippet:\n\n```yaml\ngithub:\n  prebuilds:\n    addCheck: prevent-merge-on-error\n```\n\nYou can disable this behaviour in the .gitpod.yml file in your default branch:\n\n```yaml\ngithub:\n  prebuilds:\n    addCheck: false\n```\n\nComment\n\nGitpod can add a comment with an &quot;Open in Gitpod&quot; button to your pull requests.\n\nYou can enable this behaviour in the .gitpod.yml file in your default branch:\n\n```yaml\ngithub:\n  prebuilds:\n    addComment: true\n```\n\nBadge\n\nInstead of adding a comment, Gitpod can also modify the description of a pull request to add the &quot;Open in Gitpod&quot; button.\nThis approach produces fewer GitHub notifications, but can also create a concurrent editing conflict when the bot and a user try to edit the description of a pull request at the same time.\n\nYou can enable this behaviour in the .gitpod.yml file in your default branch:\n\n```yaml\ngithub:\n  prebuilds:\n    addBadge: true\n```\n\nThe addComment and addBadge behaviours are not mutually exclusive (i.e. enabling one does not disable the other).\nIf you don&#39;t want the comments to be added, disable them using addComment: false.\n\n__SPLIT_HERE__\nUser specific environment variables in prebuilds\n\nIt is not necessarily best practice to have user specific environment variables in a prebuild init block, but sometimes there are build time requirements that mean certain tokens need setting or files need creating. Environment variables defined within your Gitpod Variables preferences are not imported by default, but they can be accessed with the following command within a before or init block:\n\n```yaml\ntasks:\n  - init: |\n      eval $(command gp env -e)\n      echo \"Hello ${MY_VAR}\"\n```\n\nAfter that, the available environment variables will be installed into the rest of you shell script and can be accessed normally.","metadata":{"source":"https://gitpod.io/docs/configure/projects/prebuilds"}}],["462",{"pageContent":"__SPLIT_HERE__\nAccess Tokens\n\nAccess Tokens are currently in Beta ¬∑ Send feedback.\n\nAccess Tokens are secrets that allow you to interact with Gitpod through Gitpod APIs. When you use an Access Token, all actions performed with the token assume the same level of authorization of the Access Token user.\n\nCreate Access Token\n\n__SPLIT_HERE__\nPermissions (Scopes)\n\nEach Access Token either has:\n\nNo Access.\nFull Access to Resources and APIs which the token owner also has access to.\n\nBy default, an Access Token has No Access. You need to explicitly select Full Access to succesfully authorize.\n\nIn the future, we will expand Access Tokens with fine grained permissions.\n\n__SPLIT_HERE__\nExpiration\n\nAll Access Tokens have an expiration time. When a token expires, requests made with the token will fail with Unathorized. When a token expires, you can regenerate it.\n\n__SPLIT_HERE__\nManaging Access Tokens\n\nListing Access Tokens\n\nYou can list your Access Tokens in your user Settings, or by going to gitpod.io/tokens.\n\nList Access Tokens\n\nCreating an Access Token\n\nYou can create an Access Token by navigating to gitpod.io/tokens or through Settings &gt; Access Tokens. Clicking New Access Token will prompt you to specify details of the token.\n\nYour access tokens will automatically expire after the specified duration.\nOnce you create an Access Token, it will be shown to you once. Make sure you store it in a secure place, you will not be able to retrieve it again.\n\n__SPLIT_HERE__\nUpdating an Access Token\n\nAccess Token can be updated. You can update the following properties on a token:\n\nName\nPermission scopes\n\nWhen you update a token, the token secret remains unaffected and you can continue to use it, until it expires.\n\n__SPLIT_HERE__\nRegenerating Access Tokens\n\nAccess Token can be regenerated. Regenerating a token will:\n\nCreate a new token secret, which you&#39;ll need to store in a secure place and replace your old one.\nThe new token will have a new expiration time.\nThe old token will no longer be valid and will receive Unathorized when interacting with APIs.\n\n__SPLIT_HERE__\nDeleting Access Tokens\n\nPersonal Access token can be deleted. Once deleted, the token is no longer valid for interaction with APIs.","metadata":{"source":"https://gitpod.io/docs/configure/user-settings/access-tokens"}}],["463",{"pageContent":"__SPLIT_HERE__\nBrowser Bookmarklet\n\nCreating a workspace is as easy as prefixing any GitHub URL with gitpod.io/#.\n\nFor convenience, we developed a Gitpod browser bookmarklet as an alternative to installing our browser extension that does the\nprefixing for you - as simple as that.\n\nDrag the following image to your bookmark bar.\n\nOpen in Gitpod\n\nSelect all of the code below and then copy it to your clipboard.\n\n```javascript\njavascript: (() => {\n  \"use strict\";\n  (function () {\n    for (\n      var t = document.getElementsByTagName(\"meta\"), n = 0;\n      n < t.length;\n      n++\n    ) {\n      var o = t[n];\n      if (o.content.toLowerCase().includes(\"gitlab\")) return !0;\n      if (\"hostname\" === o.name && o.content.includes(\"github\")) return !0;\n      if (\n        \"application-name\" === o.name &&\n        o.content.toLowerCase().includes(\"bitbucket\")\n      )\n        return !0;\n    }\n    return !1;\n  })() &&\n    window.open(\n      (\"https://gitpod.io\",\n      \"https://gitpod.io/#\" +\n        (window.location.protocol + \"//\" + window.location.host) +\n        window.location.pathname)\n    );\n})();\n```\n\nRight-click edit the bookmark and replace the contents of the URL field with the code that is in your clipboard:\n\nBrowser Extension\n\nDone! Next time you are viewing a repository on GitHub, GitLab or Bitbucket press the bookmarklet to open the repository in Gitpod.\n\n__SPLIT_HERE__\nUse with Gitpod Self-Hosted\n\nIf you are using Gitpod Self-Hosted you can still use the browser bookmarklet by configuring it with your self-hosted URL by replacing the gitpod.io URL with your self-hosted URL in the bookmarklet code.\n\n```javascript\nwindow.open((\"https://gitpod.io\",\"https://gitpod.io/#\n```\n\n__SPLIT_HERE__\nSource Code\n\nGitpod&#39;s browser bookmarklet is open source. You can check out its source code, or even open it in Gitpod:\n\nOpen in Gitpod","metadata":{"source":"https://gitpod.io/docs/configure/user-settings/browser-bookmarklet"}}],["464",{"pageContent":"__SPLIT_HERE__\nBrowser Extension\n\nCreating a workspace is as easy as prefixing any GitHub URL with gitpod.io/#.\n\nFor convenience, we developed a Gitpod browser extension. It adds a button to GitHub, GitLab or Bitbucket that does the\nprefixing for you - as simple as that.\n\nBrowser Extension\n\nWe provide the extension for:\n\nChrome - also works for Edge, Brave and other Chromium-based browsers.\nFirefox\n\n__SPLIT_HERE__\nAccess the extension settings\n\nRight-click on the Gitpod extension icon.\nSelect Options for chrome based browsers. For Firefox, select Manage Extension and then Preferences.\n\n__SPLIT_HERE__\nUse a custom Gitpod instance URL\n\nIf you are using custom Gitpod instance (e.g. dedicated) you can still use the browser extension by configuring it with your instance URL\n\nAfter you have installed the extension go to the options panel and enter your custom Gitpod instance URL.\n\n__SPLIT_HERE__\nOpen repositories with . (dot) keybind\n\nToggle on the Enable . keybind to open repositories in Gitpod option in the Gitpod extension preferences/options. After doing this, whenever you hit . on GitHub or GitLab, the current repository will open in Gitpod.\n\n__SPLIT_HERE__\nSource Code\n\nGitpod&#39;s browser extension is open source. You can check out its source code, or even open it in Gitpod:\n\nOpen in Gitpod","metadata":{"source":"https://gitpod.io/docs/configure/user-settings/browser-extension"}}],["465",{"pageContent":"__SPLIT_HERE__\nBrowser Settings\n\nFor the best experience when working with Gitpod, we recommend you whitelist the .gitpod.io domain in your browser for the following permissions:\n\nPaste content from your clipboard to a Gitpod workspace\nPop-ups, to preview your dev server in a new tab\n\nEach browser handles this slightly differently:\n\nChrome\nEdge\nBrave\nFirefox\nSafari\n\n__SPLIT_HERE__\nChrome\n\nClipboard\n\nNavigate to the Clipboard site permissions at chrome://settings/content/clipboard.\nTo the right of the &quot;Allowed to see your clipboard&quot; heading, click the &quot;Add&quot; button.\nPaste [*.]gitpod.io in the Site field and click &quot;Add&quot;.\n\nPop-ups\n\nNavigate to the Pop-ups site permissions at chrome://settings/content/popups.\nTo the right of the &quot;Allowed to send pop-ups and use redirects&quot; heading, click the &quot;Add&quot; button.\nPaste [*.]gitpod.io in the Site field and click &quot;Add&quot;.\n\n__SPLIT_HERE__\nEdge\n\nClipboard\n\nNavigate to the Clipboard site permissions at edge://settings/content/clipboard.\nTo the right of the &quot;Allow&quot; heading, click the &quot;Add&quot; button.\nPaste [*.]gitpod.io in the Site field and click &quot;Add&quot;.\n\nPop-ups\n\nNavigate to the Pop-ups site permissions at edge://settings/content/popups.\nTo the right of the &quot;All&quot; heading, click the &quot;Add&quot; button.\nPaste [*.]gitpod.io in the Site field and click &quot;Add&quot;.\n\n__SPLIT_HERE__\nBrave\n\nClipboard\n\nNavigate to the Clipboard site permissions at brave://settings/content/clipboard.\nTo the right of the &quot;Allowed to see your clipboard&quot; heading, click the &quot;Add&quot; button.\nPaste [*.]gitpod.io in the Site field and click &quot;Add&quot;.\n\nPop-ups\n\nNavigate to the Pop-ups site permissions at brave://settings/content/popups.\nTo the right of the &quot;Allowed to send pop-ups and use redirects&quot; heading, click the &quot;Add&quot; button.\nPaste [*.]gitpod.io in the Site field and click &quot;Add&quot;.\n\n__SPLIT_HERE__\nFirefox\n\nClipboard\n\nIt works by default.\n\nPop-ups\n\nNavigate to the Pop-ups site permissions at about:preferences#privacy.\nTo the right of the &quot;Block pop-up windows&quot; checkbox, click the &quot;Exceptions&quot; button.\nPaste gitpod.io in the Address of website field and click &quot;Allow&quot;.\nClick &quot;Save Changes&quot;.\n\n__SPLIT_HERE__\nSafari\n\nClipboard\n\nIt works by default.\n\nPop-ups\n\nü§∑‚Äç‚ôÇÔ∏è We can&#39;t find a solution to whitelist all Gitpod workspaces. If we missed anything, please do let us know through the feedback widget below üôè.","metadata":{"source":"https://gitpod.io/docs/configure/user-settings/browser-settings"}}],["466",{"pageContent":"__SPLIT_HERE__\nDotfiles\n\nDotfiles are a way to customize your developer environment according to your personal needs.\n\nTo configure Gitpod to use your own dotfiles for all your workspaces, enter the URL of a dotfiles repository in your user preferences.\n\nyoutube: 00dif9QWXNU\n\n__SPLIT_HERE__\nCustom installation script\n\nGitpod will recognize and run one of the following install scripts from your dotfiles repository.\n\ninstall.sh\ninstall\nbootstrap.sh\nbootstrap\nscript/bootstrap\nsetup.sh\nsetup\nscript/setup\n\nNote: Your installation script will be terminated if it exceeds 120 seconds.\n\nMake sure to make your installation script executable with chmod 755 &lt;install-script-name&gt;.sh before committing and pushing to your dotfiles repository.\n\nIf there is no install script, your dotfiles will be symlinked into /home/gitpod.\n\n__SPLIT_HERE__\nExample\n\nYou can refer this demo-dotfiles template to bring your dotfiles to Gitpod.\n\nThe example below has just one dotfile called .bash_aliases. If this file is present in a workspace home directory, it will be found by the &#39;.bashrc&#39; startup script in the Gitpod default image, so no additional install script is required.\n\n.bash_aliases\n\n```sh\necho Hello Gitpod\necho Here is my .bash_aliases dotfile\n\nalias gitsha='git rev-parse HEAD'\n```\n\nTroubleshooting\n\nThe dotfiles repository installation logs are saved to /home/gitpod/.dotfiles.log and can be viewed via\n\n```bash\ncat /home/gitpod/.dotfiles.log\n```","metadata":{"source":"https://gitpod.io/docs/configure/user-settings/dotfiles"}}],["467",{"pageContent":"FAQs\n\nHow to debug or test dotfiles changes inside an existing workspace without creating a new one each time?\n\nIf you want to quickly test out dotfiles inside an existing workspace created from your dotfiles repository, you can run the below command snippet in your terminal as a workaround:\n\n```bash\ngitpod_evars=\"${!GITPOD_*}\" gp_evars=\"${!GP_*}\"; for k in ${gitpod_evars:-} ${gp_evars:-}; do dargs+=(-e \"${k}\"); done; docker run \"${dargs[@]}\" --net=host --rm -v $PWD:/home/gitpod/.dotfiles -v /workspace:/workspace -v /ide:/ide -v /usr/bin/gp:/usr/bin/gp:ro -v /.supervisor:/.supervisor -v /var/run/docker.sock:/var/run/docker.sock --privileged -it gitpod/workspace-full bash -c 'trap \"echo -e \\\"=== Run \\033[1;32mexit\\033[0m command to leave debug workspace\\\"; exec bash -li\" EXIT ERR; echo \"PROMPT_COMMAND=\\\"echo -n \\\\\\\"[debug-workspace] \\\\\\\"; \\$PROMPT_COMMAND\\\"\" >> $HOME/.bashrc; eval \"$(gp env -e)\"; dot_path=\"${HOME}/.dotfiles\"; for s in install setup bootstrap; do if p=\"${dot_path}/${s}\" && test -x \"${p}\" || p=\"${p}.sh\" && test -x \"${p}\"; then set +m; \"$p\"; set -m; exit; fi; done; while read -r file; do rf_path=\"${file#\"${dot_path}\"/}\"; target_file=\"${HOME}/${rf_path}\"; target_dir=\"${target_file%/*}\"; if test ! -d \"$target_dir\"; then mkdir -p \"$target_dir\"; fi; ln -sf \"$file\" \"$target_file\"; done < <(find \"${dot_path}\" -type f);'\n```\n\nThis will simulate a fake minimal workspace inside your existing Gitpod workspace using docker, where your dotfiles will be installed so you can easily test.\n\nFor convenience, you can create a file called debug.sh in your dotfiles repository and paste the snippet there. You could then run bash debug.sh to use it.\n\nHow to install symlinks from dotfiles when using a custom installation script?\n\nWhen you commit a custom script such as install.sh in your dotfiles repository, Gitpod will no longer auto symlink your dotfiles under $HOME for you. It is by design so that you can have full control of how your dotfiles gets installed. An example of setting up a symlinking step is described below:\n\nCreate a directory called home_files inside your dotfiles repository. You can place your .dotfiles in the home_files directory, that means you could put files like .zshrc, .tmux.conf, .config/nvim/ and etc. in there.\nIn your custom installation script (e.g. install.sh), use/append the below snippet:\n\n```bash\ncurrent_dir=\"$(cd -- \"$( dirname -- \"${BASH_SOURCE[0]}\" )\" &> /dev/null && pwd)\"\ndotfiles_source=\"${current_dir}/home_files\"\n\nwhile read -r file; do\n\n    relative_file_path=\"${file#\"${dotfiles_source}\"/}\"\n    target_file=\"${HOME}/${relative_file_path}\"\n    target_dir=\"${target_file%/*}\"\n\n    if test ! -d \"${target_dir}\"; then\n        mkdir -p \"${target_dir}\"\n    fi\n\n    printf 'Installing dotfiles symlink %s\\n' \"${target_file}\"\n    ln -sf \"${file}\" \"${target_file}\"\n\ndone < <(find \"${dotfiles_source}\" -type f)\n```\n\nIt it possible to cache the dotfiles installation?\n\nIf your dotfiles installation relies on some heavy dependencies, that can take some time to install by nature.\n\nSo, everytime you start a workspace, you may have to wait for the dotfiles installation to complete before you can enter the workspace.\n\nFor some cases, you can start the commands in background from your install.sh, by adding &amp; disown at the end of a command:\n\n```bash\nsudo apt install qemu-user-static & disown\n```\n\nThis is a good workaround, so your workspace can start early and the long-running commands from your dotfiles installation script can happen in parallel.\n\nBut it may not work if you are installing a SHELL (e.g. zsh) or a dependency of something else that has to start before your dotfiles can get installed.\n\nSee #7592 for more info, please upvote and share your feedback on this issue.","metadata":{"source":"https://gitpod.io/docs/configure/user-settings/dotfiles"}}],["468",{"pageContent":"__SPLIT_HERE__\nUser settings\n\nUser settings allow you to customize your own personal Gitpod experience.\n\nBrowser Extension\nBrowser Settings\nBrowser Bookmarklet\nDotfiles\nSSH\nAccess Tokens","metadata":{"source":"https://gitpod.io/docs/configure/user-settings/index"}}],["469",{"pageContent":"__SPLIT_HERE__\nSSH\n\nSecure Shell Protocol (SSH) is the basis for connecting to your Gitpod workspace when using VS Code Desktop, JetBrains Gateway, or accessing via the command-line from a local machine.\n\nSee command-line editors &amp; IDEs documentation for more.\n\n__SPLIT_HERE__\nManage your SSH Keys\n\nInstalling a supported SSH client\n\nHow to install a local SSH client depending on your operating system.\n\nOS Instructions\nWindows 10 1803+ / Server 2016/2019 1803+ Install the Windows OpenSSH Client.\nEarlier Windows Install Git for Windows.\nmacOS Comes pre-installed.\nDebian / Ubuntu / Mint Run sudo apt-get install openssh-client\nRHEL / Fedora / CentOS Run sudo yum install openssh-clients\nArch / Manjaro Comes pre-installed.\n\n‚ùóÔ∏è PuTTY for Windows is not a supported client\n\nCreate an SSH key\n\nCheck to see if you already have an SSH key on your local machine. The key is typically located at ~/.ssh/id_ed25519.pub on macOS / Linux, and the .ssh directory in your user profile folder on Windows (for example C:\\Users\\your-user\\.ssh\\id_ed25519.pub).\n\nIf you do not have a key, run the following command in a local terminal / PowerShell to generate an SSH key pair:\n\n```bash\nssh-keygen -t ed25519\n```\n\nYou will then be prompted to enter a secure passphrase, but you can leave that blank. You should now have a id_ed25519.pub file which contains your new public SSH key.\n\nNote: If you are using a legacy system that doesn&#39;t support the Ed25519 algorithm, you can use rsa instead: ssh-keygen -t rsa -b 4096\n\nTip: Don&#39;t have ssh-keygen? Install a supported SSH client.\n\nSSH file and folder permissions\n\nmacOS / Linux:\n\nOn your local machine, make sure the following permissions are set:\n\nFolder / File Permissions\n.ssh in your user folder chmod 700 ~/.ssh\n.ssh/config in your user folder chmod 600 ~/.ssh/config\n.ssh/id_ed25519.pub in your user folder chmod 600 ~/.ssh/id_ed25519.pub\nAny other key file chmod 600 /path/to/key/file\n\nWindows:\n\nThe specific expected permissions can vary depending on the exact SSH implementation you are using. We recommend using the out of box Windows 10 OpenSSH Client.\n\nIn this case, make sure that all of the files in the .ssh folder for your remote user on the SSH host is owned by you and no other user has permissions to access it. See the Windows OpenSSH wiki for details.\n\nFor all other clients, consult your client&#39;s documentation for what the implementation expects.\n\nUpload an SSH key to Gitpod\n\nOnce you&#39;ve created an SSH key pair, you can upload your public SSH key to Gitpod, by navigating to gitpod.io/keys where you can upload one or more public SSH keys.\n\nSSH page of the Gitpod dashboard\nSSH page of the Gitpod dashboard\n\nPaste your public key, and give your key a memorable title so that you can remember the name of the public key later if you choose to add multiple keys, e.g. &quot;Gitpod Bastion Host SSH Key&quot;\n\nAdding an SSH Key to Gitpod\nAdding an SSH Key to Gitpod\n\nEdit an SSH key in Gitpod\n\nGitpod doesn&#39;t support editing an SSH key.\n\nTo update an SSH key, delete the key and re-upload the SSH key to Gitpod.\n\nDelete an SSH key from Gitpod\n\nTo delete an SSH key, click the kebab menu to the right of the SSH key in the dashboard and select &quot;delete&quot;.\n\nDeleting an SSH key from Gitpod\nDeleting an SSH key from Gitpod","metadata":{"source":"https://gitpod.io/docs/configure/user-settings/ssh"}}],["470",{"pageContent":"SSH Gateway\n\nSSH Gateway facilitates connection via SSH for direct SSH access using uploaded public keys, and using the workspace owner token. Both the VS Code Desktop and JetBrains integrations use SSH Gateway to connect to Gitpod workspaces.\n\nWhat is SSH Gateway?\n\nSSH Gateway is an intermediary service within Gitpod that proxies incoming SSH requests to the appropriate running workspaces.\n\nSSH Gateway architecture in Gitpod\nSSH Gateway architecture in Gitpod\n\nSSH Gateway in Self-Hosted\n\nIf you are running a Self-Hosted Gitpod installation, you will need to ensure that:\n\nThe installation has the SSH Gateway component configured and deployed\nYour networking and firewalls are configured to allow SSH traffic via port 22.\n\nSee the Self-Hosted Reference Architectures for more.\n\n__SPLIT_HERE__\nTroubleshooting\n\nVS Code Desktop and SSH explained blog has a bunch of good troubleshooting notes, you may check them out.\n\n__SPLIT_HERE__\nunix_listener: path &quot;/somewhere/xyz&quot; too long for Unix domain socket\n\nOpen your SSH config file in a text editor. (i.e. ~/.ssh/config or /etc/ssh/ssh_config[1])\nAppend the following to it:\n\n```\nHost *.gitpod.io\n     ControlPath /tmp/%r-gitpod\n```\n\nSave the file.\nNow try connecting via SSH or VSCode-Desktop again.","metadata":{"source":"https://gitpod.io/docs/configure/user-settings/ssh"}}],["471",{"pageContent":"__SPLIT_HERE__\nCollaboration &amp; Sharing of Workspaces\n\nThere are currently two ways to share a Gitpod workspace, either by creating a workspace snapshot, a &quot;point in time&quot; capture of a workspace state that can be then opened by another user. Or, by sharing a running workspace which shares access to a single running workspace to multiple users.\n\nyoutube: HcKlXfKpolM\n\n__SPLIT_HERE__\nWorkspace Snapshots\n\nSnapshotting a workspace is useful when you want to create reproducible workspace state for reporting support issues, or when giving training, or presentations. You can create up to three snapshots from any workspace.\n\nYou can create a snapshot URL of your workspace to share your workspace files with others. Following a Gitpod snapshot URL starts a new workspace, but under the account of the user who followed that original snapshot URL.\n\nThere are a few important things to note about workspace snapshots:\n\nSnapshots behave like workspace restarts - All workspace state, including files changed since the original workspace start are preserved in a snapshot. Any tasks or processes typically launched via a workspace start will not run for a workspace snapshot.\n\n\nAccess to secret information - Snapshotted workspaces do not grant access to Gitpod environment variables, Gitpod authentication or Git credentials within a snapshot. However, you should use caution that you did not store any secret or private information in any files of a workspace snapshot before generating a snapshot URL.\n\n\nDeleting and managing snapshots - If you want to remove any created snapshot URLs, deleting the workspace directly removes any created snapshot URLs associated with that workspace.\n\n\nUsers must have repository access - Each workspace snapshot creates a new unique URL. Access to a snapshot is based on the access rules on the repository the workspace is based on. This means snapshots based on private repositories can only be opened by those with access to the repository. Public repository snapshots can be accessed without authentication.\n\nNote: Caution should always be taken when sharing potentially sensitive information, including Gitpod workspace snapshots. If you are concerned you have accidentally shared sensitive information, we suggest you follow best practices such as immediately rotating credentials and adhere to your typical security response process.\n\nHow To Take a Snapshot URL\n\nTo create a snapshot, run &quot;Gitpod: Share Workspace Snapshot&quot; from the Backend Control Center, or from the JetBrains IDE search. Once you execute the command, the snapshot is taken and the URL is shown in a dialog.\n\nTo create a snapshot, run &quot;Gitpod: Share Workspace Snapshot&quot; from the hamburger menu at the top left of VS Code, from the Gitpod menu at the bottom, or via the VS Code command palette. Once you execute the command, the snapshot is taken and the URL is shown in a dialog.\n\nTo create a snapshot, run &quot;Gitpod: Share Workspace Snapshot&quot; from the hamburger menu at the top left of VS Code, from the Gitpod menu at the bottom, or via the VS Code command palette. Once you execute the command, the snapshot is taken and the URL is shown in a dialog.\n\n```undefined\nYou can run `gp snapshot` from any workspace to generate a snapshot URL.\n```","metadata":{"source":"https://gitpod.io/docs/configure/workspaces/collaboration"}}],["472",{"pageContent":"Sharing Running Workspaces\n\nSharing running workspaces makes it possible to quickly look at a workspace together with a (remote) colleague. It is similar to collaborating on Google Docs, in that you can see who is online and look at the same code and processes.\n\nTo share your workspace, navigate to the workspaces page at https://gitpod.io/workspaces. From there:\n\nMove your mouse over the workspace you want to share (change the filter to All if you don&#39;t see your workspace).\nClick the three dots menu to the right of the highlighted workspace.\nClick Share\n\nThis marks your workspace as shared. When you open it, you can copy &amp; share its URL.\n\nNote: You can join shared workspaces only by using VS Code Browser. If you prefer to use another editor, please consider using external collaboration plugins.\n\nSecurity note:\n\nBeware, anybody with this URL and a Gitpod account will be able to access the workspace as long as\nit is shared and running.\n\nEvery action involving Git in a shared workspace happens on behalf of the workspace owner&#39;s account without further authorization. This includes access to secrets used in a shared workspace.\nIt is highly recommended to give workspace URLs only to trusted users and unshare workspaces as soon as sharing them is no longer necessary.\n\nA running Gitpod workspace really is your personal machine.\n\nAt present, this feature cannot be disabled. If this is something you are interested in, please let us know in this issue.\n\n__SPLIT_HERE__\nExternal Collaboration Plugins\n\nWith Gitpod you can also use the following third-party integrations for real-time collaboration:\n\nCode Together - Works on VS Code Desktop, VS Code Browser, and via JetBrains or Eclipse.\nGitLive - Works on VS Code Desktop, VS Code Browser, and via JetBrains.\nDuckly - Works on VS Code Desktop and VS Code Browser.","metadata":{"source":"https://gitpod.io/docs/configure/workspaces/collaboration"}}],["473",{"pageContent":"__SPLIT_HERE__\nMulti-repo\n\n{title} is currently in Beta ¬∑ Send feedback.\n\nIf your software project is comprised of multiple source control repositories it is possible to configure Gitpod to clone these additional repositories through the configuration keys of additionalRepositories and mainConfiguration in the .gitpod.yml file which removes the need to run multiple workspaces, and makes it easier to configure services which need to be aware of each other.\n\n__SPLIT_HERE__\nCloning additional repositories\n\nThe additionalRepositories key is an array of repositories which contains two properties which define the source control url to clone and the checkoutLocation of where the repository is cloned is under /workspaces\n\n```yaml\n# example .gitpod.yml from https://github.com/gitpod-io/demo-multi-repo-frontend\nadditionalRepositories:\n  - url: https://github.com/gitpod-io/demo-multi-repo-backend\n    # checkoutLocation is relative to /workspaces\n    checkoutLocation: backend\n```\n\nWhen the above configuration is defined then the following additional steps happen when Gitpod workspace is started:\n\nIf you open a workspace on a branch, Gitpod will clone the same-named branch in all repositories. If such a branch doesn‚Äôt exist Gitpod checks out the default branch.\nThe contents of https://github.com/gitpod-io/demo-multi-repo-frontend is cloned to /workspaces/demo-multi-repo-frontend\nThe contents of https://github.com/gitpod-io/demo-multi-repo-backend is cloned to /workspaces/backend\n\nAfter all of the source control repositories have been cloned then the before, init and command tasks are executed as per normal. If you need to run commands (such as package installation or compilation) on the source control repositories which have been cloned then change your working directory the checkoutLocation location using the before task.\n\n```yaml\n# example .gitpod.yml from https://github.com/gitpod-io/demo-multi-repo-frontend\nadditionalRepositories:\n  - url: https://github.com/gitpod-io/demo-multi-repo-backend\n    checkoutLocation: backend\n\ntasks:\n  - name: backend\n    # change working directory as per configured in `checkoutLocation`\n    # which is configured above as `/workspaces/backend`\n    before: |\n      cd ../backend\n    init: |\n      echo npm install\n    command: |\n      echo npm run dev\n\n    # changing of working directory is not required as these tasks will\n    # by default by executed in `/workspaces/demo-multi-repo-frontend`\n  - name: frontend\n    init: |\n      echo npm install\n      echo npm run build\n    command: |\n      echo npm run dev\n```\n\nTry it out at https://github.com/gitpod-io/demo-multi-repo-frontend\n\n__SPLIT_HERE__\nDelegating configuration\n\nThe optional mainConfiguration configuration key when configured in additional repositories points to the repository with the main .gitpod.yml file and makes it possible to open the same workspace from any issue, branch or other context URL from any of the participating repositories. Since the main configuration is used for prebuilds, those will show up under the main project.\n\n```yaml\n# example .gitpod.yml from https://github.com/gitpod-io/demo-multi-repo-backend\nmainConfiguration: https://github.com/gitpod-io/demo-multi-repo-frontend\n```\n\nTry it out at https://github.com/gitpod-io/demo-multi-repo-backend","metadata":{"source":"https://gitpod.io/docs/configure/workspaces/multi-repo"}}],["474",{"pageContent":"Adding additional repo folders to VSCode Explorer\n\nVSCode workspace folders\n\nYou might want to see the additionalRepositories on your VSCode.\n\nTo do so:\n\nCreate a file called main.code-workspace (for example) on your main(e.g. frontend) repository that everyone is expected to open via Gitpod.\nNow you can define the folder paths:\n\n```json\n{\n  // All paths are relative to your main repo\n  // The additional repos are cloned inside /workspace dir\n    \"folders\": [\n        {\n            \"path\": \".\" // Main repo that you will open in Gitpod (e.g. frontend)\n        },\n        {\n            \"path\": \"../backend\" // Additional repo\n        },\n        {\n            \"path\": \"../db\" // Additional repo\n        },\n    ],\n\n}\n```\n\nSpecify your .code-workspace file path on .gitpod.yml:\n\n```yaml\nworkspaceLocation: frontend/main.code-workspace # Relative to /workspace dir\n```\n\nSee it in action!\n\n__SPLIT_HERE__\nFAQs\n\nSingle repo but instances of multiple branches\n\nIf you want to create multiple instances of one repository with different branches, you could use such a method:\n\n```yaml\ntasks:\n  - name: Multi branch\n    before: |\n      # Get primary repo dir path and name\n      main_repo_dir=\"${GITPOD_REPO_ROOT}\"\n      primary_repo_name=\"${main_repo_dir##*/}\"\n\n      # Array for BRANCH name(s).\n      extra_clone_branches=(\n          backend\n          docs\n          next\n      )\n\n      for reference in \"${extra_clone_branches[@]}\"; do {\n          dir=\"${main_repo_dir}-${reference}\"\n\n          if test ! -e \"${dir}\" && git -C \"${main_repo_dir}\" show-ref --quiet \"refs/heads/${reference}\"; then {\n            printf 'INFO: %s\\n' \"Duplicating ${primary_repo_name} to ${dir} with ${reference} branch\"\n            cp -ra \"${main_repo_dir}\" \"${dir}\"\n            git -C \"${dir}\" checkout \"${reference}\" 2>&1 | grep -v \"Switched to branch '${reference}'\"\n          } fi\n      } done\n\n      # Send signal to awaiting task(s)\n      gp sync-done multi_branch\n\n  - name: Some other task\n    command: |\n      # Wait for multi_branch to avoid race condition\n      gp sync-await multi_branch\n\n      echo hello\n      true 'something'\n```\n\nAnd to have such a feature built-in, please react with a &quot; üëç &quot; on this issue: https://github.com/gitpod-io/gitpod/issues/15608","metadata":{"source":"https://gitpod.io/docs/configure/workspaces/multi-repo"}}],["475",{"pageContent":"__SPLIT_HERE__\nWorkspaces\n\nWorkspaces are the developer environments where you code in Gitpod.\n\nWorkspaces can be created on their own, or as part of a Project.\n\nWorkspace Lifecycle\nWorkspace Image\nTasks\nPorts\nCollaboration\nMulti-repo\nWorkspace Classes","metadata":{"source":"https://gitpod.io/docs/configure/workspaces/index"}}],["476",{"pageContent":"__SPLIT_HERE__\nPorts\n\nGitpod supports exposing HTTP ports via a custom domain that is associated with your workspace. You can also use port forwarding, so that you do not need to update your application if it already references the localhost hostname. You can forward all ports using the local companion, natively in both VS Code Desktop, JetBrains and also via the command-line using SSH.\n\n__SPLIT_HERE__\nDefault port behaviors\n\nBy default, when a port is opening in a Gitpod workspace, Gitpod will:\n\nDirect HTTP traffic - When an application starts listening to an HTTP port, Gitpod detects the port and exposes it on a URL that requires authentication. Setting the port to &quot;public&quot; would make the port URL accessible to anyone on the internet (or the installed network if using self-hosted Gitpod).\nNotify the user - Gitpod sends the user a popup notification in their IDE or editor to let the user know that a port has been detected.\n\n__SPLIT_HERE__\nAccessing port URLs\n\nYou can access the dedicated port URL by pre-pending the port number to the workspace URL.\n\ne.g 3000-yourworkspace.ws-eu45.gitpod.io\n\nYou can also print the port URL using the gp url command (e.g. gp url 3000).\n\nAnd if you prefer listing all open ports URLs at once, use gp ports list command.\n\n__SPLIT_HERE__\nConfiguring port behaviors\n\nTo modify or change default port behaviors, update the ports section of your .gitpod.yml.\n\nAll changes to port behaviors take effect immediately, not requiring a workspace restart.\n\nNote: Some actions (e.g. setting a port public/private) can be taken via the IDE or editor.\n\nConfigure port opening\n\nThe port open event is triggered when a new port is detected as open within the workspace.\n\nPort opening behavior can only be set via the .gitpod.yml\n\nThe property onOpen configures port opening behaviors:\n\nnotify (default) - Show a notification for newly detected ports.\nopen-preview - Open the port URL in a preview within the editor or IDE.\nopen-browser - Open the port URL in a browser tab.\nignore - Ignore default behavior (notify).\n\nExample: Open a browser tab for port 8080\n\n```yaml\nports:\n  - name: Web App\n    description: The main application web server\n    port: 8080\n    onOpen: open-browser\n```\n\nSpecify port names &amp; descriptions\n\nYou can give ports a name and a description (both optional). These properties will help you to add context about what the port is being used for.\n\nThe property visibility configures who can access a port:\n\nprivate (default) - Only allow users with workspace access to access the port.\npublic - Allows everyone with the port URL to access the port.\n\nConfigure port visibility\n\nPort visibility can be set in .gitpod.yml, changed via the Gitpod CLI, or manually changed within the IDE or editor.\n\nConfigure port ranges\n\nAll port configurations can be applied to ranges as well as single ports.\n\nExample: Prevent notifications for ports between 3000 and 8999.\n\nPorts won&#39;t be shown in VS Code&#39;s PORTS view or in the Gitpod CLI until they are opened.\n\n```yaml\nports:\n  - port: 3000-8999\n    onOpen: ignore\n```\n\n__SPLIT_HERE__\nPorts ordering\n\nPorts are ordered according to their definition in .gitpod.yml. Any undefined ports are sorted numerically in ascending order. Port ordering rules apply to all ports views, for example, when using gp ports list or viewing ports in VS Code or JetBrains.","metadata":{"source":"https://gitpod.io/docs/configure/workspaces/ports"}}],["477",{"pageContent":"Port forwarding\n\nThere are two types of port forwarding: local and remote.\n\nLocal port forwarding allows you to forward a port running in your Gitpod workspace to access via your localhost hostname. Remote port forwarding exposes a locally running process to use in your workspace. Remote port forwarding is not currently supported.\n\nLocal port forwarding\n\n```undefined\n<figure>\n<img class=\"shadow-medium w-full rounded-xl max-w-3xl mt-x-small\" alt=\"Port forwarding in VS Code Desktop\" src=\"/images/editors/port-forwarding-vscode-desktop.png\">\n    <figcaption>Port forwarding in VS Code Desktop</figcaption>\n</figure>\n```\n\nLocal port forwarding via SSH\n\nUsing SSH command-line access to your workspace, ports can also be forwarded manually using tools such as the OpenSSH remote login client.\n\nExample: Forwarding port 3000 to localhost:3000\n\nssh -L 3000:localhost:3000 &lt;workspace-ssh-connection&gt;\n\nCross-Origin Resource Sharing (CORS)\n\nIf you start a server on a private port, let&#39;s say 5001, and want to connect to it from your web application which runs on a different port, e.g. 3000, you have to configure your requests. This is necessary because Gitpod requires credentials for private ports. Without credentials, Gitpod cannot verify that the request is made by an authorized user.\n\nConfigure your web application\n\nTo make this work, your web application&#39;s fetch request needs to have the credentials: &quot;include&quot; option set. See the MDN doc&#39;s credentials description for more details.\n\nConfigure your server\n\nIn your server (the one on port 5001 in the above example), you have to configure the response to include the Access-Control-Allow-Credentials header. Without it, your browser rejects the response and you see CORS errors in the browser console.","metadata":{"source":"https://gitpod.io/docs/configure/workspaces/ports"}}],["478",{"pageContent":"__SPLIT_HERE__\nTasks\n\nTo get the most out of ephemeral developer environments, it is important to let Gitpod know how to build your project. We can achieve this by defining tasks in the .gitpod.yml configuration file.\n\nNote: In your local developer environment, you likely set up your project only once. If you work in a team, you probably have written instructions on how to get started. With Gitpod, you automate these manual steps so that a new environment can be set up repeatedly by Gitpod.\n\nTasks are shell scripts that run on top of the Docker image you configure (learn more about custom Docker images).\n\nyoutube: E95oV_iqUtI\n\n__SPLIT_HERE__\nExecution order\n\nWith Gitpod, you have the following three types of tasks:\n\nbefore: Use this for tasks that need to run before init and before command. For example, customize the terminal or install global project dependencies.\ninit: Use this for heavy-lifting tasks such as downloading dependencies or compiling source code.\ncommand: Use this to start your database or development server.\n\nThe order in which these tasks execute depends on whether you have Prebuilds configured for your project and which startup scenario applies. Let&#39;s look at the details.\n\nCaveats\n\nAny file changes made outside of /workspace file hierarchy from init tasks will be lost on workspace start when prebuilds are enabled. Learn more\nUser specific environment variables are not loaded automatically for init and before tasks but can be loaded if you want. Learn more\n\nPrebuild and New Workspaces\n\nIn this startup scenario, you can see how Prebuilds impact the execution order of tasks:\n\nStart tasks for Prebuilds &amp; New Workspace\nStart tasks for Prebuilds &amp; New Workspace\n\nThe init task is where you want to do the heavy lifting, things like:\n\nDownload &amp; install dependencies\nCompile your source code\nRun your test suite\nAny other long-running, terminating processes necessary to prepare your project\n\nAs displayed in the diagram above, we highly recommend you enable Prebuilds for your project. In that case, Gitpod executes the before and most importantly, init tasks automatically for each new commit to your project.\n\nBy the time you start a new workspace, all that&#39;s left to do is execute the before (optional) and command tasks. The latter most often starts a database and/or development server.\n\nLet Gitpod run the time-consuming init tasks continuously behind the scene so you and anyone who opens your project on Gitpod doesn&#39;t have to wait.\n\nRestart a Workspace\n\nWhen you restart a workspace, Gitpod already executed the init task (see above) either as part of a Prebuild or when you started the workspace for the first time.\n\nAs part of a workspace restart, Gitpod executes the before and command tasks:\n\nRestart a workspace\nRestart a workspace\n\nStart a Snapshot\n\nWhen you start a snapshot, Gitpod already executed the init task (see above) either as part of a Prebuild or when you or a team member started the snapshot&#39;s initial workspace for the first time.\n\nAs part of starting a snapshot, Gitpod executes the before and command tasks:\n\nStart a snapshot\nStart a snapshot","metadata":{"source":"https://gitpod.io/docs/configure/workspaces/tasks"}}],["479",{"pageContent":"Configure the terminal\n\nYou can configure where terminals open using the openMode properties below.\nPlease note that this information is used if no previous terminals in the layout exist.\nSnapshots will first try to reuse existing terminals in the layout, before opening new ones.\n\n```yaml\ntasks:\n  - name: Static Server\n    command: python3 -m http.server 8080\n  - name: DB Server\n    command: sh ./scripts/start-db.sh\n    openMode: split-right\n```\n\nopenMode\n\nYou can configure how the terminal should be opened relative to the previous task.\n\nopenMode Description\nopenMode: tab-after Opens in the same tab group right after the previous tab\nopenMode: tab-before Opens in the same tab group left before the previous tab\nopenMode: split-right Splits and adds the terminal to the right\nopenMode: split-left Splits and adds the terminal to the left\nopenMode: split-top Deprecated. Splits and adds the terminal to the top\nopenMode: split-bottom Deprecated. Splits and adds the terminal to the bottom","metadata":{"source":"https://gitpod.io/docs/configure/workspaces/tasks"}}],["480",{"pageContent":"Example Tasks\n\nThe examples below are common use cases you can get inspired by and adjust for your project&#39;s needs.\n\nNote: before and init tasks need to terminate while command can run indefinitely (i.e. until cancelled with Ctrl + C). This is because before and init may run as part of a prebuild and if these tasks do not terminate, the prebuild will eventually fail with a timeout.\n\nOne-line tasks\n\nEach task contains a single npm command. The init task terminates once the dependencies are installed while the command task starts a development server and does not terminate.\n\n```yaml\ntasks:\n  - name: Dev Server\n    init: npm install\n    command: npm run dev\n```\n\nMulti-line tasks\n\nTo run multiple commands for a given task, you can use the | notation where each line below (make sure you indent correctly) runs in sequence once the previous command terminates.\n\nIn the following example, the init task installs dependencies and configures a database. Then, the command task starts the dev server(s).","metadata":{"source":"https://gitpod.io/docs/configure/workspaces/tasks"}}],["481",{"pageContent":"In the following example, the init task installs dependencies and configures a database. Then, the command task starts the dev server(s).\n\nNote: In case of multiple terminals, there is no guarantee on the order in which tasks execute. The only guarantee you have is that before, init and command execute in that sequence per terminal.\n\n```yaml\ntasks:\n  - name: Dependencies & Database\n    init: |\n      npm install\n      npm run configure-database\n    command: npm run dev\n```\n\nNote: This doesn&#39;t stop execution on errors. If npm install in the example above fails, the npm run configure-database will still run. See how to exit after failure below for a workaround.\n\nWait for commands to complete\n\nWhen working with multiple terminals, you may have a situation where terminal 1 runs build scripts and terminal 2 and 3 require that these scripts complete first. This can be achieved with gp sync-await and gp sync-done.","metadata":{"source":"https://gitpod.io/docs/configure/workspaces/tasks"}}],["482",{"pageContent":"```yaml\ntasks:\n  - name: Rails\n    init: >\n      bundle install &&\n      yarn install --check-files &&\n      rails db:setup &&\n      gp sync-done bundle # 'bundle' is an arbitrary name\n    command: rails server\n\n  - name: Webpack\n    init: gp sync-await bundle # wait for the above 'init' to finish\n    command: bin/webpack-dev-server\n\n  - name: Redis\n    init: gp sync-await bundle\n    command: redis-server\n\n  - name: Sidekiq\n    init: gp sync-await bundle\n    command: sidekiq\n```\n\nWait for a port to be available\n\nLet&#39;s say you have a web app dev server that takes a moment to start up to listen on port 3000. Once it&#39;s up and running, you want to run end-to-end tests against http://localhost:3000.\n\nYou can achieve this with two terminals and the gp ports await CLI command.\n\n```yaml\ntasks:\n  - name: Dev Server\n    init: npm install\n    command: npm run dev\n\n  - name: e2e Tests\n    command: |\n      gp ports await 3000\n      npm run test\n```\n\nImmediately exit for any command failure within a task","metadata":{"source":"https://gitpod.io/docs/configure/workspaces/tasks"}}],["483",{"pageContent":"- name: e2e Tests\n    command: |\n      gp ports await 3000\n      npm run test\n```\n\nImmediately exit for any command failure within a task\n\nIf you wish to halt an entire task with for an error within the task script, then you could do the following:\n\n```yaml\ntasks:\n  - init: |\n      (\n        set -e # Tells bash to immediately exit on failure off a command\n        bundle install\n        yarn install --frozen-lockfile\n        bundle exec rake\n        bundle exec nanoc compile\n      )\n```","metadata":{"source":"https://gitpod.io/docs/configure/workspaces/tasks"}}],["484",{"pageContent":"Gitpod starts all your tasks inside separate bash ($SHELL) shells. Gitpod can only assert the exit status of the shell process of a task. Normally bash or other shells don&#39;t halt on a failure of a command unless you explicitly ask it to. bash only inherits the last exit status of a script run with it before it&#39;s own exit. Hence Gitpod can&#39;t determine if all of your commands inside the init task succeeded. To have that effect, you can put set -e; on top of task shell-commands and wrap your whole task-script with () to configure that particular task shell to halt and immediately exit with an error code for a failure of any command. This can be specially helpful for prebuilds (i.e init tasks)\n\nMissing examples?\n\nWe&#39;d love to hear from you if you have specific questions or ideas for additional examples. Please click the following link to open a pre-configured GitHub issue: Ask for a new Start Task example.","metadata":{"source":"https://gitpod.io/docs/configure/workspaces/tasks"}}],["485",{"pageContent":"__SPLIT_HERE__\nWorkspace classes\n\nWorkspace classes allow you to select the resources available to your workspaces.\n\nOn gitpod.io, the options are:\n\nStandard: up to 4 cores, up to 8GB RAM, 30GB storage\nLarge: up to 8 cores, up to 16GB RAM, 50GB storage\n\nYou can override the default (Standard) workspace class in the Gitpod project settings for your repository.\n\nProject Settings\n\n__SPLIT_HERE__\nSelect a workspace class for your workspace\n\nYou can select workspace class directly from Gitpod Dashboard. You can do that from by clicking on the New Workspace button. Then, you can select the context url and Editor.\n\n__SPLIT_HERE__\nGood to know\n\nLarge workspace classes use credits at a faster rate. Standard workspaces use 10 credits per hour, whereas Large workspaces use 20 credits per hour.\nPrebuilds currently use the same workspace class as regular workspaces.\n\n__SPLIT_HERE__\nFAQs\n\nHow to select Large workspace type for extended storage and CPU\n\nCreate a team project on Gitpod, from the project settings you can select a large workspace.\n\nIs it possible to build (android) AOSP source on Gitpod?\n\nIt is not quite feasible to build an entire AOSP tree right now due to current storage capacity limitations. Please react with a &quot;üëç&quot; on https://github.com/gitpod-io/gitpod/issues/13950 and comment your requirements.","metadata":{"source":"https://gitpod.io/docs/configure/workspaces/workspace-classes"}}],["486",{"pageContent":"__SPLIT_HERE__\nWorkspace Image\n\nBy default, Gitpod uses a standard Docker Image called Workspace-Full as the foundation for workspaces. Workspaces started based on this default image come pre-installed with Docker, Nix, Go, Java, Node.js, C/C++, Python, Ruby, Rust, Clojure as well as tools such as Homebrew, Tailscale, Nginx and several more.\n\nIf this image does not include the tools you need for your project, you can provide a public Docker image or your own Dockerfile. This provides you with the flexibility to install the tools &amp; libraries required for your project.\n\nNote: Gitpod supports Debian/Ubuntu based Docker images. Alpine images do not include libgcc and libstdc++ which breaks Visual Studio Code. See also Issue #3356.\n\n__SPLIT_HERE__\nUse a public Docker image\n\nYou can define a public Docker image in your .gitpod.yml file with the following configuration:\n\n```yaml\nimage: node:buster\n```\n\nThe official Gitpod Docker images are hosted on Docker Hub.\n\nYou can find the source code for these images in this GitHub repository.\n\nDocker image tags\n\nFor public images, feel free to specify a tag, e.g. image: node:buster if you are interested in a particular version of the Docker image.\n\nFor Gitpod images, we recommend using timestamped tag for maximum reproducibility, for example image: gitpod/workspace-full:2022-05-08-14-31-53 (taken from the Tags panel on this dockerhub page for example)\n\n__SPLIT_HERE__\nUse a private Docker image\n\nThis is currently in Alpha.\n\nYou may also use private Docker images.\n\nTo do so you must provide the registry authentication details to Gitpod by setting GITPOD_IMAGE_AUTH with the following value &lt;registry-domain&gt;:&lt;base64-encoded &#39;username:password&#39;&gt; as a Project-level environment variable.\n\nFor example, if the registry is docker.io, the username is foo and the password is bar, the GITPOD_IMAGE_AUTH environment variable value may be calculated using the command echo -n &quot;docker.io:&quot;; echo -n &quot;foo:bar&quot; | base64 -w0 which outputs docker.io:Zm9vOmJhcg==.","metadata":{"source":"https://gitpod.io/docs/configure/workspaces/workspace-image"}}],["487",{"pageContent":"Use a custom Dockerfile\n\nThis option provides you with the most flexibility. Start by adding the following configuration in your .gitpod.yml file:\n\n```yaml\nimage:\n  file: .gitpod.Dockerfile\n```\n\nNext, create a .gitpod.Dockerfile file at the root of your project. The syntax is the regular Dockerfile syntax as documented on docs.docker.com.\n\nA good starting point for creating a custom .gitpod.Dockerfile is the\ngitpod/workspace-full image as it already contains all the tools necessary to work with all languages Gitpod supports.\n\n```dockerfile\n# You can find the new timestamped tags here: https://hub.docker.com/r/gitpod/workspace-full/tags\nFROM gitpod/workspace-full:2022-05-08-14-31-53\n\n# Install custom tools, runtime, etc.\nRUN brew install fzf\n```\n\n‚ö†Ô∏è Caveat: &gt; COPY instructions in a Dockerfile is only evaluated once and then cached.\nSee this to break the cache and trigger a rebuild.\n\n‚ö†Ô∏è Caveat: The base image of a custom Dockerfile must be public.","metadata":{"source":"https://gitpod.io/docs/configure/workspaces/workspace-image"}}],["488",{"pageContent":"‚ö†Ô∏è Caveat: The base image of a custom Dockerfile must be public.\n\nDocker support: If you use the gitpod/workspace-full image, you get Docker support built-in to your environment.\n\nIf you want a base image without the default tooling installed then use the gitpod/workspace-base image.\n\n```dockerfile\n# You can find the new timestamped tags here: https://hub.docker.com/r/gitpod/workspace-base/tags\nFROM gitpod/workspace-base:2022-05-08-14-31-53\n\n# Install custom tools, runtime, etc.\n# base image only got `apt` as the package manager\n# install-packages is a wrapper for `apt` that helps skip a few commands in the docker env.\nRUN sudo install-packages shellcheck tree llvm\n```\n\nWhen you launch a Gitpod workspace, the local console will use the gitpod user, so all local settings, config file, etc. should apply to /home/gitpod or be run using USER gitpod (we no longer recommend using USER root).","metadata":{"source":"https://gitpod.io/docs/configure/workspaces/workspace-image"}}],["489",{"pageContent":"You can however use sudo in your Dockerfile. The following example shows a typical .gitpod.Dockerfile inheriting from gitpod/workspace-full:\n\n```dockerfile\n# You can find the new timestamped tags here: https://hub.docker.com/r/gitpod/workspace-full/tags\nFROM gitpod/workspace-full:2022-05-08-14-31-53\n\n# Install custom tools, runtime, etc.\n# install-packages is a wrapper for `apt` that helps skip a few commands in the docker env.\nRUN sudo install-packages \\\n          binwalk \\\n          clang \\\n          tmux\n\n# Apply user-specific settings\n```\n\nOnce committed and pushed, Gitpod will automatically build this Dockerfile when (or before) new workspaces are created.\n\nSee also Gero&#39;s blog post running through an example.\n\nCustom base image\n\nWhile it is recommended to extend one of the Gitpod-provided base images for custom Dockerfiles to ensure the image has the required dependencies for a workspace, it is possible to configure a Dockerfile with a public (Debian/Ubuntu-based) image as its base.","metadata":{"source":"https://gitpod.io/docs/configure/workspaces/workspace-image"}}],["490",{"pageContent":"There are some requirements though for a public base image to work properly as a workspace. See the below Dockerfile as a reference. For instance, you&#39;ll need to set up the gitpod user with the right UID, and install git to enable your configured dotfiles for the workspace.\n\n```dockerfile\nFROM ubuntu:latest\n\n# Install:\n# - git (and git-lfs), for git operations (to e.g. push your work).\n#   Also required for setting up your configured dotfiles in the workspace.\n# - sudo, while not required, is recommended to be installed, since the\n#   workspace user (`gitpod`) is non-root and won't be able to install\n#   and use `sudo` to install any other tools in a live workspace.\nRUN apt-get update && apt-get install -yq \\\n    git \\\n    git-lfs \\\n    sudo \\\n    && apt-get clean && rm -rf /var/lib/apt/lists/* /tmp/*\n\n# Create the gitpod user. UID must be 33333.\nRUN useradd -l -u 33333 -G sudo -md /home/gitpod -s /bin/bash -p gitpod gitpod\n\nUSER gitpod\n```","metadata":{"source":"https://gitpod.io/docs/configure/workspaces/workspace-image"}}],["491",{"pageContent":"# Create the gitpod user. UID must be 33333.\nRUN useradd -l -u 33333 -G sudo -md /home/gitpod -s /bin/bash -p gitpod gitpod\n\nUSER gitpod\n```\n\nAdditional tools &amp; languages: see https://github.com/gitpod-io/workspace-images/tree/main/chunks for references to configure your workspace image with common tools and languages. For instance, this Dockerfile shows how to install docker and docker-compose.\n\nTailscale: see the Tailscale integration docs for setting up Tailscale in a custom Dockerfile.","metadata":{"source":"https://gitpod.io/docs/configure/workspaces/workspace-image"}}],["492",{"pageContent":"Trying out changes to your Dockerfile\n\nIn the existing workspace\n\ngp rebuild is currently in Beta ¬∑ Send feedback.\n\nTo test your custom .gitpod.Dockerfile, run the following command:\n\n```bash\ngp rebuild\n```\n\nThis builds a new image from your workspace, spins up a container and connects to it. Once connected, you can confirm all necessary tools and libraries are installed in the container. Finally, type exit to disconnect and return to your Gitpod workspace.\n\nAs a new workspace\n\nOnce you validated the .gitpod.Dockerfile with the approach described in the previous chapter, it is time to start a new Gitpod workspace based on that custom image.\n\nThe easiest way to try out your changes is as follows:\n\nCreate a new branch.\nCommit your changes &amp; push the branch to your git hosting server.\nOpen a pull / merge request and open it in your browser.\nPrefix the URL with gitpod.io/# and hit Enter.\n\nThis starts a new workspace with your changes applied. You notice you now have two Gitpod workspaces running. The one where you made the changes and the new one, based on the pull request.\n\nCaution: Keeping the first workspace open is important in case your Dockerfile has bugs and prevents Gitpod from starting a workspace based on your pull request.\n\nIn the second workspace, the Docker build will start and show the output. If your Dockerfile has issues and the build fails or the resulting workspace does not look like you expected, you can force push changes to your config using your first, still running workspace and simply start a fresh workspace again to try them out.\n\nWe are working on allowing Docker builds directly from within workspaces, but until then this approach has been proven to be the most productive.\n\n__SPLIT_HERE__\nManually rebuild a workspace image\n\nSometimes you find yourself in situations where you want to manually rebuild a workspace image, for example if packages you rely on released a security fix.\n\nYou can trigger a workspace image rebuild with the following URL pattern: https://gitpod.io/#imagebuild/&lt;your-repo-url&gt;.\n\n__SPLIT_HERE__\nConfigure a custom shell\n\nFeedback needed: Custom shell support is in the works. The below shows a method for running some of the ~/.bashrc.d startup scripts. To leave feedback on the approach, please see this GitHub issue: #10105.\n\nFor example, if you wish to default your workspace-image to zsh, you could do it from your custom dockerfile with the following line:\n\n```dockerfile\nENV SHELL=/usr/bin/zsh\n```\n\nTip: You could also create an environment variable at https://gitpod.io/variables called SHELL with */* scope for setting a personal default SHELL.\n\nCaveat: Shells like fish, zsh and etc. are not POSIX-compliant or bash-compatible, so your Gitpod tasks might error if you use some POSIX or bash specific features in your task scripts.\n\nLoad bash environment in custom shell\n\nCurrently we put some startup scripts for the workspace-images at ~/.bashrc.d, that means if you change your SHELL from bash to something else, they will not auto run. You could run the following command from your SHELL to workaround:\n\n```bash\nbash -lic 'true'\n```","metadata":{"source":"https://gitpod.io/docs/configure/workspaces/workspace-image"}}],["493",{"pageContent":"FAQs\n\nWhy is my custom dockerfile rebuild everytime even with no change made to it?\n\nThis usually happens when you don&#39;t pin the image tag (AKA version) inside your custom dockerfile.\n\nIn such casues, it could be that there has been long gaps between the time you reuse a workspace or create a new one. We usually release new images every week so if there was more than one week between each start then the image will be rebuild every time.\n\nSo, for example, if your .gitpod.Dockerfile looks like the following:\n\n```dockerfile\nFROM gitpod/workspace-full:latest\n\n# ... more stuff\n```\n\nYou could grab a timestamped tag from here for gitpod/workspace-full.\n\nAnd then your .gitpod.Dockerfile could look like:\n\n```dockerfile\nFROM gitpod/workspace-full:2023-01-16-03-31-28\n\n# ... more stuff\n```\n\nNote: Please grab a recent tag from the linked page, don&#39;t copy paste the example from here.\n\nAlso see docker-image-tags for more info.\n\nHow to run a Desktop app for GUI development inside a Gitpod workspace\n\nIf you wish to do GUI application development in Gitpod and getting errors such as:\n\nUnable to init server: Could not connect : Connection refused\nNo display server running\nXorg missing\nxdg-open command not found\n\nThen you need to use the gitpod/workspace-full-vnc docker image. See this page for more info.","metadata":{"source":"https://gitpod.io/docs/configure/workspaces/workspace-image"}}],["494",{"pageContent":"__SPLIT_HERE__\nWorkspace Lifecycle\n\nGitpod brings a new way to think about your development environment. Rather than a single local environment that you keep up-to-date, with Gitpod you can have as many workspaces as you need.\n\n__SPLIT_HERE__\nWorkspace Statuses\n\nThe state of the workspace is indicated by the color of the workspace indicator. For example, in the Gitpod dashboard, workspace state is shown on the workspace list.\n\nüü† Starting - Workspace provisioning, inaccessible to the user.\nüü¢ Running - Workspace loaded, accessible to the user.\nüü† Stopping - Workspace being stopped, backups performing.\nüî¥ Stopped - Workspace no longer accessible. File system preserved for restart.\n\nImportant: Only files in the /workspace directory are kept between state transitions.\n\nThe following describes each workspace status in detail, including what can cause a workspace to transition from one status to another.\n\nWorkspace Starting\n\nWhen you open a workspace, it will be in the &quot;starting&quot; state. This means that the workspace is being created and the initialization process is running.\n\nWhere a workspace is being provisioned and initialized.\nIf configured and available, a prebuild snapshot is used.\nOtherwise, source control is downloaded into the workspace.\n\nWorkspace Running\n\nAn active workspace is provisioned within Gitpod.\nThe workspace can be accessed by the user.\n\nWorkspace Stopped\n\nNo provisioned workspace is running (e.g. ports and URLs are not accessible).\nOnly files and directories inside /workspace are preserved.\nIf the workspace is restarted, the URL is preserved.\nA start is required before the workspace can be used.\n\nWorkspace Deleted\n\nWorkspaces are deleted after 14 days. Pinned workspaces are never deleted automatically.\n\n__SPLIT_HERE__\nWorkspace Actions\n\nWorkspace Pinning\n\nA pinned workspace is never deleted. You can pin a workspace from your workspace list in the Gitpod dashboard.\n\nWorkspace Snapshotting\n\nYou can create a snapshot of a workspace to save its state. This is useful if you want to keep a workspace around for a longer period of time, than the default. Read more about Snapshots.\n\n__SPLIT_HERE__\nWorkspace Deletion\n\nStopped workspaces are automatically deleted 14 days since the last workspace start. Pinned workspaces are never deleted. You can pin a workspace from your workspace list in the Gitpod dashboard.\n\n__SPLIT_HERE__\nWorkspace Timeouts\n\nRunning workspaces will stop automatically after a period of inactivity.\n\nWorkspace Inactivity\n\nBy default, workspaces stop following 30 minutes without user input (e.g. keystrokes or terminal input commands). You can increase the workspace timeout up to a maximum of 24 hours.\n\nEditor Disconnect\n\nCurrently, all timeouts are dependent on an active editor connection. Closing your Gitpod connected editor or IDE will reduce the workspace timeout to 5 minutes.\n\nExtending Timeouts\n\nPaying users of Gitpod can extend the inactivity timeout of their current workspace using the gp timeout set from the Gitpod CLI, which is installed in all gitpod workspaces by default. Extending the workspace timeout does not affect the inactivity timeout of other any other workspaces.","metadata":{"source":"https://gitpod.io/docs/configure/workspaces/workspace-lifecycle"}}],["495",{"pageContent":"__SPLIT_HERE__\nContribute\n\nThe team behind Gitpod has built in the open for the last decade. Transparency is key and as a company Gitpod strives to be as open about as many things as possible. This refers to both developing Gitpod in the open (public issues, public roadmap, public milestones) as well as how employees interact on a personal level with other human beings. Gitpodders are strong believers in the benefits that an open culture provides. At Gitpod we are open-minded, inclusive, transparent, and curious. We always remain students of the game, not masters of the game.\n\nyoutube: KcSeDGSMexs\n\nWe üß° the people who are involved in this project, and we‚Äôd love to have you on board, especially if you are just getting started or have never contributed to open-source before. So here&#39;s to you, lovely person who wants to join us ‚Äî this is how you can support us:\n\nContribute to Gitpod Samples\nParticipating in the Gitpod Discord community.\nResponding to questions on StackOverflow.\nCreating content that shares your experiences with Gitpod\nUsing the feedback widget at the bottom of each page in our documentation.\nSubmitting documentation updates when you learn something that you think other developers would also benefit from.\nMaking contributions to the code base.","metadata":{"source":"https://gitpod.io/docs/help/contribute/index"}}],["496",{"pageContent":"__SPLIT_HERE__\nRelease Cycle\n\nInformation regarding how, and when Gitpod releases updates.\n\nFor information on latest changes, please see the changelog.\n\n__SPLIT_HERE__\nGitpod Release Cycle\n\nEarly Access - Available by invitation to gather user feedback -- changes likely.\nAlpha - Feature and published APIs unstable.\nBeta - Feature and published APIs are relatively stable.\nGeneral Availability (GA) - Features and published API&#39;s are stable. Deprecations and API changes will be communicated in advance.","metadata":{"source":"https://gitpod.io/docs/help/public-roadmap/release-cycle"}}],["497",{"pageContent":"__SPLIT_HERE__\nPublic roadmap\n\nThe most up-to-date Gitpod roadmap can be found at www.gitpod.io/roadmap.\n\nTo provide feedback or ask for feature requests, please open an issue in the Gitpod repository.","metadata":{"source":"https://gitpod.io/docs/help/public-roadmap/index"}}],["498",{"pageContent":"&lt;OpenGraph\ndata={{\n    description:\n      &quot;Learn how to start your first workspace, set up a gitpod.yml configuration file and enable Prebuilds. Get started for free.&quot;,\n    title: &quot;Getting started with Gitpod&quot;,\n    keywords: &quot;get started, fast, free&quot;,\n  }}\n/&gt;\n\n__SPLIT_HERE__\nGetting started\n\nGitpod can provide fully initialized, perfectly set-up developer environments for any kind of software project. This page helps you understand how to provide such a configuration for your project.\nyoutube: ij1msCffQZA\n\n__SPLIT_HERE__\nStart your first workspace\n\nThe best way to configure Gitpod is by using Gitpod - you could perform the following steps in your local environment as well, but we may as well experience ephemeral developer environments right from the beginning.\n\nIn a browser, navigate to your project&#39;s GitHub, GitLab or Bitbucket page.\nIn the browser&#39;s address bar, prefix the entire URL with gitpod.io/# and press Enter.For example, gitpod.io/#https://github.com/gitpod-io/website\nWe recommend you install the Gitpod browser extension to make this a one-click operation.\n\n\nSign in with one of the listed providers and let the workspace start up.\n\nCongratulations, you have started your first of many ephemeral developer environments üéâ!\n\nüí° You can also start a Gitpod workspace with more options. Learn more\n\n__SPLIT_HERE__\nOpen in Gitpod button\n\nYou can add the following button to your Development/Setup Docs so that users can launch projects in Gitpod and begin working on them without having to go through the entire setup process.\n\n```markdown\n[![Open in Gitpod](https://gitpod.io/button/open-in-gitpod.svg)](https://gitpod.io/#<your-repository-url>)\n```\n\nhere, your-repository-url can be something like: https://github.com/gitpod-samples/awesome-gitpod or any of your Repository URLs.\n\nContribute with Gitpod badge\n\nTo make it easy for anyone to start a Gitpod workspace based on your project, we recommend you add a badge to your README.md.\n\n```html\n<a href=\"https://gitpod.io/#<your-repository-url>\">\n  <img\n    src=\"https://img.shields.io/badge/Contribute%20with-Gitpod-908a85?logo=gitpod\"\n    alt=\"Contribute with Gitpod\"\n  />\n</a>\n```\n\nNext, let&#39;s help Gitpod understand your repository to automate the developer environment and turn on prebuilds to supercharge your development workflow.","metadata":{"source":"https://gitpod.io/docs/introduction/getting-started/index"}}],["499",{"pageContent":"Help Gitpod understand your repository\n\nWhen you started your first workspace above, Gitpod didn&#39;t do much. In fact, all it did was start the workspace and git clone your source code.\nTo develop, you still would have to install dependencies, run build scripts and start the development server every time you start a workspace... We can do better, so let&#39;s automate that!\n\nIn the workspace terminal, make sure you are in your project&#39;s root directory (pwd should be /workspace/&lt;repo&gt;).\nRun gp init to generate a scaffold .gitpod.yml configuration file (see the .gitpod.yml reference for all configuration options).\nOpen the newly created .gitpod.yml file.\n\nInit script\n\nMost projects require some sort of initialization script to download and install dependencies, compile the source code, etc. For example, a Node.js project requires npm install. The init task by default reads echo &#39;init script&#39;, let&#39;s replace that with your project-specific init command, for example:\n\n```yaml\ntasks:\n  - init: npm install\n    command: echo 'start script'\n```\n\nExcellent! To learn more about the difference between init and command, please have a look at Start Tasks.\n\nCommand script\n\nNext, let&#39;s adjust the command script. This is the script Gitpod executes when the workspace successfully started up. In most cases, this is where you start your application&#39;s development server, e.g. npm run dev.\n\n```yaml\ntasks:\n  - init: npm install\n    command: npm run dev\n```\n\nConfigure your app&#39;s ports\n\nIf your application starts a development server that listens on a certain port, we can let Gitpod know how to deal with that. To get started, update the port according to what your application listens on, e.g. 3000.\n\n```yaml\ntasks:\n  - init: npm install\n    command: npm run dev\nports:\n  - port: 3000\n    onOpen: open-preview\n```\n\nWhen Gitpod notices port 3000 is available, it automatically opens your application in a preview to the right of your editor - ready for you to develop and see your changes.\n\nCommit .gitpod.yml\n\nLastly, make sure to commit the .gitpod.yml configuration file to Git and push it to your repository.\n\n__SPLIT_HERE__\nStart your second workspace\n\nOnce you committed and pushed .gitpod.yml, open a new browser tab and navigate to your project&#39;s page on GitHub, GitLab or Bitbucket.\n\nIf you pushed to a branch, please make sure you switch to that branch before you continue.\n\nOpen a new workspace (see Start your first workspace above).\nObserve how Gitpod automatically runs the tasks you configured.\nWait until the development server started and your application&#39;s preview is displayed on the right side of the editor.\n\nIf for some reason the second workspace does not start, simply close the tab and navigate back to the first workspace. Fix the errors that caused the workspace to fail based on the error output you see, commit and push your changes and start yet another workspace to test the latest changes.\n\nCongratulations, again üòä! You now have a basic Gitpod configuration and for each new workspace you start, Gitpod automatically runs the scripts you manually have to run locally.\n\n__SPLIT_HERE__\nShut down your workspaces\n\nThis is easy - close the workspace browser tabs.\n\nWithin three minutes, the workspaces will be stopped. You can always find them at https://gitpod.io/workspaces - to be honest though, you can forget about them and start a new workspace the next time you work on your project.","metadata":{"source":"https://gitpod.io/docs/introduction/getting-started/index"}}],["500",{"pageContent":"Supercharge your experience with prebuilds\n\nThe automation you have experienced so far is nice, but there&#39;s more! Remember that init task we configured earlier?\n\nYou may have wondered why there are separate init and command tasks. This is because we can tell Gitpod to run the init script every time new code is pushed to your project. By the time you or one of your organization members starts a new workspace, the init task already finished and you don&#39;t have to wait for that - saving you precious time. We call this prebuilds.\n\nAn intro to prebuilds\n\nLet&#39;s first look at an example and then configure your project to take advantage of prebuilds.\n\nImagine this common workflow where Nina and Paul work on the same project:\n\nNina opens a pull request where she developed a feature that requires a new dependency.\nGitpod notices the new code and kicks off a prebuild by cloning the source code and executing the init task. The result is saved as a prebuilt workspace.\nSome time later, Paul opens the pull request to start his code review.\nHe opens a Gitpod workspace for that given pull request (learn more about contexts).\nGitpod recognizes it already ran the init task and loads the prebuilt workspace\nBy the time the workspace starts, Paul sees the development server starting up and the application&#39;s preview is ready for review.\n\nFor each new commit to your project, Gitpod continuously creates prebuilt workspaces so that the project is always ready-to-code. If your project is open source, anyone gets to enjoy the efficiency of prebuilds regardless of whether they are part of your organization or not.\n\nConfigure prebuilds for your projects\n\nDepending on your Git provider, the steps to configure prebuilds vary slightly. Please refer to the dedicated Prebuilds page for detailed instructions on how to configure prebuilds for your project.\n\n__SPLIT_HERE__\nNext steps\n\nAt this point, you have a .gitpod.yml configuration file to automate repetitive tasks and prebuilds configured to let Gitpod execute many of these tasks continuously whenever new code is pushed to your project - freeing you from waiting to download, install &amp; build your project and its dependencies.\n\nTo explore more of what Gitpod has to offer, we recommend the following next topics:\n\nConfigure to learn more about start tasks, environment variables and how to provide your own custom Docker image as the foundation for workspaces.\nDevelop to learn more about the productivity gains you get with ephemeral workspaces, how contexts assist you and how to collaborate with organization members.","metadata":{"source":"https://gitpod.io/docs/introduction/getting-started/index"}}],["501",{"pageContent":"__SPLIT_HERE__\nContext URL\n\nGitpod understands a variety of common situations you experience as part of your development workflow and automates repetitive tasks, giving you time to focus on more impactful work.\n\nThe context is determined by a Gitpod URL&#39;s anchor, i.e. the link provided at the end of the # character in the gitpod.io/# URL.\n\nRegardless of the context, Gitpod performs the tasks configured in .gitpod.yml if this configuration file is available for a given repository.\n\nGitpod is aware of the following contexts:\n\nContext URLRepository Context\nBranch and Commit Contexts\nIssue Context\nPull/Merge Request Context\n\nPlease note, these contexts are supported for GitHub, GitLab, and Bitbucket. This also includes Self-Hosted installations of these git providers, where available.\n\n__SPLIT_HERE__\nRepository Context\n\nTo start a new workspace, you prefix your repository URL with gitpod.io/#. E.g. gitpod.io/#https://github.com/gitpod-io/website.\n\nThis is the most basic context and Gitpod simply checks out the default branch and opens the Welcome screen once the workspace is ready.\n\nAn example URL for the repository context is:\n\n```\ngitpod.io/#https://github.com/gitpod-io/website\n```\n\n__SPLIT_HERE__\nBranch and Commit Contexts\n\nThe branch and commit contexts are very similar to the repository context described above. When you open a new workspace for a given branch or commit, Gitpod automatically checks out that branch or commit, allowing you to browse the repository on that branch or at the time of the given commit.\n\nAn example URL for the branch context is:\n\n```\ngitpod.io/#https://github.com/gitpod-io/website/tree/my-branch\n```\n\nAn example URL for the commit SHA context is:\n\n```\ngitpod.io/#https://github.com/gitpod-io/website/commit/f5d4eb4cd3859a760ac613598e840b94e8094649\n```\n\n__SPLIT_HERE__\nIssue Context\n\nThe fastest way to work on an issue is to start a Gitpod workspace with an issue context. Gitpod automatically creates a local branch based on the following pattern:\n\n```text\n<your-username>/<issue-title>-<issue-number>\n```\n\nThis branch is based on the most recent commit in your project&#39;s default branch.\n\nYou can commit your changes with the git command line interface or use the Source Control panel on the left side of the editor. From there, you can also create a new pull/merge request without leaving Gitpod.\n\nAn example URL for the issue context is:\n\n```\ngitpod.io/#https://github.com/gitpod-io/website/issues/470\n```\n\n__SPLIT_HERE__\nPull/Merge Request Context\n\nNote: Currently pull-request based context URLs are only supported by GitHub authentication as a Gitpod authentication method.\n\nWhen Gitpod recognizes a pull or merge request context, it knows you most likely have one of two intentions:\n\nAs a reviewer, provide PR/MR feedback\nAs an author, process feedback and update the code\n\nIn either case, Gitpod automatically performs the following tasks for you:\n\nStarts a workspace with the correct branch checked out\nOpens the PR/MR review panel where you can see and contribute to existing conversations\nDisplays a list of files changed as part of that PR/MR\nEnables you to leave comments right within individual files (yep, no need to switch between the code and the PR/MR in your browser)\n\nIn addition, Gitpod lets you merge a PR/MR. Once merged, you close the browser tab and move on to your next task - in a new, ephemeral developer environment üéâ.\n\nAn example URL for the pull/merge request context is:\n\n```\ngitpod.io/#https://github.com/gitpod-io/website/pull/494\n```","metadata":{"source":"https://gitpod.io/docs/introduction/learn-gitpod/context-url"}}],["502",{"pageContent":"__SPLIT_HERE__\n.gitpod.yml\n\nA workspace gets configured through a .gitpod.yml file, located at the root of your project, written in YAML syntax. Here&#39;s an example:\n\n```yaml\n# Commands to start on workspace startup\ntasks:\n  - name: Setup & Build\n    before: yarn global add express\n    init: yarn install\n    command: yarn build\n\n# Ports to expose on workspace startup\nports:\n  - port: 3000\n    onOpen: open-preview\n    name: Website\n    description: Website Preview\n```\n\nTo see a full reference of all available properties, please refer to the .gitpod.yml reference page.\n\nyoutube: E95oV_iqUtI\n\n__SPLIT_HERE__\nHow to provide the .gitpod.yml config file\n\nIn order to tell Gitpod how to prepare a dev environment for your project, you check in a .gitpod.yml file into the root of your repository. This way you can\nversion your workspace configuration together with your code. If, for example, you need to go back to\nan old branch that required a different configuration, Gitpod will start with the correct configuration, since that\nbit of configuration is part of your codebase.\n\n__SPLIT_HERE__\nGenerate Your Gitpod Config File\n\nThe quickest way to create a .gitpod.yml file is with the gp CLI. In the terminal of a Gitpod workspace, type:\n\n```sh\ngp init\n```\n\nThis generates example content you can adjust to meet your needs.\n\nAlternatively, you can use the interactive mode with gp init -i. It will ask you about the different configuration options, generate the .gitpod.yml file and open it in an editor tab so you can review and extend as necessary.\n\nGitpod provides auto-complete, hover info and validation for the .gitpod.yml file so you get instant feedback and can rest assure your configuration is valid.\n\n__SPLIT_HERE__\nSee it in action\n\nTo test your .gitpod.yml file, you need to commit and push the file to your repository and open a new workspace either by using the Gitpod extension or prefixing your repo URL with https://gitpod.io/#.\n\nIf you don&#39;t want to have multiple commits as you&#39;re testing and making changes to your .gitpod.yml, you can make changes from a new branch.","metadata":{"source":"https://gitpod.io/docs/introduction/learn-gitpod/gitpod-yaml"}}],["503",{"pageContent":"__SPLIT_HERE__\nLearn Gitpod\n\nOne workspace per task\nThe Life of a workspace\nContext URL\n.gitpod.yml","metadata":{"source":"https://gitpod.io/docs/introduction/learn-gitpod/index"}}],["504",{"pageContent":"__SPLIT_HERE__\nOne workspace per task\n\nOn any given day, you may be involved in tasks such as the following:\n\nImplement a new feature\nFix a bug\nReview a pull/merge request\nPair-program with a team member\nBrowse an open source project&#39;s source code\n\nFor each of these tasks, you start a clean, ephemeral Gitpod workspace. You can even start multiple workspaces in parallel. For example, while you&#39;re working on a feature, you can start a second workspace to review a production hotfix. When the review is complete, you close the browser tab of that workspace and continue to work on your feature. This works for any GitLab, GitHub or Bitbucket project.\n\nYou can learn more about the [Life of a workspace](/docs/configure/workspaces/workspace-lifecycle\n\nyoutube: n7Ca3jHFtZg\n\n__SPLIT_HERE__\nGitpod vs. local development\n\nA Gitpod workspace is similar to your local developer environment, except for two key differentiators:\n\nIt is configured as code\nIt is ephemeral and only lives for as long as you work on a task\n\nConfiguration vs. manual setup\n\nYour project&#39;s .gitpod.yml and optional .gitpod.Dockerfile files control what tools will be available in your Gitpod workspace. Both files are version-controlled and let you monitor changes to the developer environment over time. There is no longer a need to @channel in your team&#39;s communication software to tell everyone to upgrade their version of Node.js, only to find out that some people were on vacation and didn&#39;t see the message.\n\nEphemeral vs. long-lived\n\nThanks to the fact that Gitpod workspaces are configured as code, you can start and stop them as frequently as you want. You know that each workspace has the tools it needs and even more importantly, has the latest code from your default branch checked out! You no longer have to pull the latest default branch a few times per day because each time you start a new workspace, it has the latest code already available.","metadata":{"source":"https://gitpod.io/docs/introduction/learn-gitpod/one-workspace-per-task"}}],["505",{"pageContent":"__SPLIT_HERE__\nFebruary Release 2019 üéâ\n\nWe are close to leaving the beta phase and with that are also approaching a more regular release schedule.\nThis means we are going to have monthly release notes. They will pop up only once and you can easily dismiss them by pressing [ESC].\nIf you want to look up the release notes later you can open them through the command palette [F1]. Simply search for &#39;Release Notes&#39;.\n\nSo here are the new &amp; noteworthy things that we have been hard at work at this time.\n\n__SPLIT_HERE__\nGitHub Links\n\nYou can now navigate to GitHub directly from the editor. The GitHub URL of any editor position or selection can be accessed with a right-click, and used for example in GitHub issues or Pull Request comments to reference interesting code locations.\n\nGitHub Links\n\n__SPLIT_HERE__\nSnapshots\n\nIn addition to live sharing a running Gitpod workspace, you can now take a snapshot. Snapshots capture the current state of a workspace session including the UI layout and the file changes. Anyone who has a snapshot link can create a fresh workspace based on that.\n\nThis is super handy for providing reproducibles in GitHub issues and StackOverflow posts. They are also great to prepare trainigs, tutorials, or just to showcase stuff you have thrown together.\n\nPlease see this blog post as well as the documentation for more details.\n\nSnapshot\n\n__SPLIT_HERE__\nConfiguration\n\nThe possibilities to fine-tune the developer experience when using Gitpod on your repository have been improved. Here are the features you can define in your .gitpod.yml:\n\nTasks\n\nYou can now specify multiple tasks. Each task will have its own terminal view on start. You can even specify where those terminals whould be opened.\nThe following config, for instance, will make sure that two terminals are opened next to each other.\n\n```yaml\ntasks:\n  - command: echo 'left'\n  - command: echo 'right'\n    openMode: split-right\n```\n\nSplit Terminals\n\nLifecycles\n\nIn addition we have introduced multiple lifecycle phases for the tasks, such as init and before. The main purpose is to avoid rerunning unnecessary commands such as full builds, when restarting workspaces or opening snapshots.\n\nCheck the table below for an overview of the different starting scenarios.\n\nStart Mode Execution\nFresh Workspace before &amp;&amp; init &amp;&amp; command\nRestart Workspace before &amp;&amp; command\nSnapshot before &amp;&amp; command\n\nPorts\n\nYou can now specify the default behavior on port detection. By default users get a notification when starting a server, asking whether they want to open a web view or an external browser.\n\nThis behavior can now be pre-configured so users are not bothered with annoying notifications. Here is an example where we configure port 8080 to automatically open in a web preview pane:\n\n```yaml\nports:\n  - port: 8080\n    onOpen: open-preview\n```\n\nCheck out the docs to learn more about pre-configuring things in Gitpod.\n\n__SPLIT_HERE__\nYAML Support\n\nGitpod now understands YAML syntax and uses json schema specifications to validate and guide developers. While this works for any YAML files it comes in especially handy when editing .gitpod.yml.\n\nyaml in action","metadata":{"source":"https://gitpod.io/docs/release-notes/2019-02-15/february-2019"}}],["506",{"pageContent":"Gitpod CLI\n\nThe CLI for Gitpod has learned new tricks. Check out all the cool things you can do with it by typing gp help.\n\nHere are the new commands we added:\n\ngp init\n\nTo get the best experience with Gitpod, you should configure your repository to have the right tools, run the right commands on start, etc. This information is stored in a .gitpod.yml file sitting in your repository.\n\nThe gp init command walks you through the basic setup and generates a .gitpod.yml and if desired a corresponding Dockerfile.\n\n```sh\ngitpod /workspace/my-repo $ gp init\nUse the arrow keys to navigate: ‚Üì ‚Üë ‚Üí ‚Üê\n? Workspace Docker image:\n  ‚ñ∏ default\n    custom image\n    docker file\n```\n\nMore information about writing .gitpod.yml configurations can be found in the docs.\n\ngp url\n\nOne of the things you do in a .gitpod.yml is declaring the exposed ports. Gitpod maps them to a specific subdomain in order to make them accessible. For instance if you have a dev server running on 0.0.0.0:3000 the gp url command gives you the external url for that service.\n\nHere is an example:\n\n```sh\ngitpod /workspace/release-notes $ gp url 3000\nhttps://3000-b33f605e-b32a-4e44-ae5a-acad9641de0a.ws-eu0.gitpod.io/\n```\n\ngp url can also give you the URL of the workspace itself:\n\n```sh\ngitpod /workspace/release-notes $ gp url\nhttps://b33f605e-b32a-4e44-ae5a-acad9641de0a.ws-eu0.gitpod.io/\n```\n\ngp preview\n\ngp preview is similar to gp open, except that it does not open a file in the editor but a URL in a preview pane on the right.\n\nThis is especially handy together with gp url if you want to open a specific path from a script.\n\nHere&#39;s an example:\n\n```sh\ngp preview $(gp url 3000)my/special/path.html\n```\n\n__SPLIT_HERE__\nImproved Docker Performance\n\nIn addition to the .gitpod.yml you can provide a Dockerfile which is automatically picked up by Gitpod. See this blog post for more information on setting up a Dockerfile for your project.\n\nFor example, here is a Dockerfile that allows developing native UI applications in Go on Gitpod:\n\n```sh\nFROM gitpod/workspace-full-vnc\nRUN sudo apt-get update && \\\n    sudo apt-get install -y libgtk-3-dev && \\\n    sudo rm -rf /var/lib/apt/lists/*\n```\n\nSince we launched this feature, the performance and logging for docker builds have also been improved significantly.\n\n__SPLIT_HERE__\nStatus Page\n\nAs we continuously improve and expand Gitpod, there are times when things inevitably don&#39;t go as planned, occasionally causing downtime. If you&#39;re ever curious about the status of gitpod.io, or you&#39;d like to follow how we resolve an incident, we made status.gitpod.io just for you.\n\nIn fact, thanks to Statusfy, it took us just a few hours to build an entire open source status page. Learn more about this short adventure in this blog post.\n\n__SPLIT_HERE__\nJava Debugging\n\nIn addition to Node.js one can now also launch and debug Java applications directly from within the editor. Code lense actions on main() methods will automatically use the right classpath from the current project settings (based on maven, gradle or eclipse classpath information).\n\nLaunch configs are stored in a VS Code compatible launch.json file.\n\nDebug Java\n\n__SPLIT_HERE__\nXML Support\n\nThe new improved XML support not only does syntax highlighting for XML and XSD but also uses associated schemas to provide diagnostics, content assist and hover information.\n\nXML Support\n\n__SPLIT_HERE__\nBetter Previews\n\nPreviews can now easily be opened by clicking on the top right icon (icon) on any previewable files, such as Markdown, HTML and SVG files.\n\nThe inverse is supported, too. I.e. clicking the file icon on the top right of a preview will open the corresponding editor on the left. For Markdown even scrolling is synced between the two views.\n\n__SPLIT_HERE__\nAsciiDoc Support\n\nIn addition to Markdown, Gitpod now also supports previewing AsciiDoc as you type.","metadata":{"source":"https://gitpod.io/docs/release-notes/2019-02-15/february-2019"}}],["507",{"pageContent":"AsciiDoc Support\n\nIn addition to Markdown, Gitpod now also supports previewing AsciiDoc as you type.\n\n__SPLIT_HERE__\nMany Bugfixes, small features and other improvements\n\nThese are just the most noteworthy features we have been working on.\nFor a more detailed list of bugfixes and enhancemenst see all the issues we&#39;ve closed:\n\nClosed Issues in Gitpod\nMerged PRs in Theia","metadata":{"source":"https://gitpod.io/docs/release-notes/2019-02-15/february-2019"}}],["508",{"pageContent":"__SPLIT_HERE__\nBash in Gitpod\n\nBash is the default shell for Gitpod. However, if you&#39;re developing a Bash script yourself, you may want to configure additional language support.\n\n__SPLIT_HERE__\nExample Repositories\n\nHere are a few Bash example projects that are already automated with Gitpod:\n\nRepository Description Try It\ninlets/inlets Reverse proxy and service tunnel Open in Gitpod\n\n__SPLIT_HERE__\nVSCode Extensions\n\nShellCheck\n\nShellCheck provides linting for common mistakes in your shell script.\n\nTo use ShellCheck in Gitpod, first, we must install the shellcheck tool. Here is a simple Dockerfile to get you started:\n\n```dockerfile\nFROM gitpod/workspace-full\n\nUSER gitpod\n\nRUN brew install shellcheck\n```\n\nYou should also install the shellcheck VS Code extension in Gitpod, by adding a .gitpod.yml configuration file to your repository that looks like this (notice the vscode extensions section):\n\n```yaml\nimage:\n  file: .gitpod.Dockerfile\n\nvscode:\n  extensions:\n    - timonwong.shellcheck@0.9.0:hsU/Rd39aqPYowTqL+DbXg==\n```\n\nNot sure about ShellCheck? Try it in Gitpod!\n\ngitpod-io/Gitpod-ShellCheck\n\nBash IDE\n\nA Bash IDE demonstration\n\nJust to name a few things Bash IDE adds: Code completion, hovers, and diagnostic reporting.\n\nTo install Bash IDE to your repository add the following to your .gitpod.Dockerfile\n\n```dockerfile\nRUN npm i -g bash-language-server\n```\n\nAlso the following in your\n.gitpod.yml\n\n```yaml\nvscode:\n  extensions:\n    - mads-hartmann.bash-ide-vscode@1.4.0:/qx+rdXE/fGTGWhelNf3aQ==\n```\n\nNot sure about Bash IDE? Try it in Gitpod\n\nOpen in Gitpod\n\n__SPLIT_HERE__\nFurther Reading\n\nFor more information about ShellCheck please see shellcheck.net\n\n__SPLIT_HERE__\nKnown issues\n\nThe shellcheck program was not found\n\nIt has been reported that shellcheck extension fails to detect shellcheck from homebrew which results in:\nshellcheck notification\n\nTo resolve this you need to set &quot;shellcheck.executablePath&quot;: &quot;/home/linuxbrew/.linuxbrew/bin/shellcheck&quot;, (or to path that point to shellcheck on your system), See https://github.com/vivek-verma202/GWAS_FM/pull/3/files","metadata":{"source":"https://gitpod.io/docs/introduction/languages/bash"}}],["509",{"pageContent":"__SPLIT_HERE__\nC++ in Gitpod\n\nGitpod supports C++ right out of the box, but there are still ways to enhance your C++ experience within Gitpod.\n\n__SPLIT_HERE__\nExample Repositories\n\nHere are a few C++ example projects that are already automated with Gitpod:\n\nRepository Description Try it\nComponent Editor circuito.io Component Editor Open in Gitpod\ntinyraycaster old-school FPS in a weekend Open in Gitpod\nHelloGitPod Example Gitpod C++ configuration with clang-tidy linter enabled Open in Gitpod\n\n__SPLIT_HERE__\nEnvironment\n\nC++ Tools\n\nAll Gitpod workspaces come with the latest available clang, gcc, cmake, gdb, and other useful C++ tools pre-installed by default.\n\nHowever, if you&#39;re missing some additional tools, you can simply run brew install &lt;tool_name&gt; to install it in the current workspace or write your own .gitpod.Dockerfile to install it across all workspaces for your repository.\n\n__SPLIT_HERE__\nIDE Features\n\nDebugging\n\nSince gdb is already pre-installed in Gitpod, you can already debug any C, C++, Go, etc. program directly from the Terminal with a single command.\n\nHowever, you can also get the IDE&#39;s Debugging features to work with your C++ program, using GDB as a backend.\n\nTo enable C++ debugging for your project, simply follow these steps:\n\nOpen the Extensions panel (in the IDE&#39;s left vertical menu bar)\n\n\nUse the Search feature to find the extension called &quot;Native Debug&quot;, then click on Install, and select Install for this project\n\n\nNext, open the Debug panel (also in the IDE&#39;s left vertical menu bar), and click on the Gear (‚öôÔ∏è) icon to open the launch.json configuration file\n\n\nFinally, configure debugging for your project by adding a GDB launch configuration. You can use auto-completion for assistance. In the end, your launch.json should look something like this:\n\n```js\n{\n  // Use IntelliSense to learn about possible attributes.\n  // Hover to view descriptions of existing attributes.\n  \"version\": \"0.2.0\",\n  \"configurations\": [\n      {\n          \"type\": \"gdb\",\n          \"request\": \"launch\",\n          \"name\": \"Debug Firefox (GDB)\",\n          \"target\": \"./obj-x86_64-pc-linux-gnu/dist/bin/firefox\",\n          \"cwd\": \"${workspaceRoot}\",\n          \"valuesFormatting\": \"parseText\"\n      }\n  ]\n}\n```\n\nNote: This example GDB launch configuration points to a compiled Firefox browser binary. You&#39;ll need to adjust it to point to your project&#39;s own compiled binary.\n\nWith this, you should be able to set breakpoints in your C++ code directly from the code editor margin, then start a debugging session from the Debug panel. The IDE should then show you debug information, hopefully pause execution on your breakpoint, and allow you to step through the code.\n\nIf that doesn&#39;t work, please feel free to ask for help in community.gitpod.io and we&#39;ll be happy to help you make debugging work for your project.\n\nFor a more in-depth walk-through of how do debug applications, please refer to this comment on GitHub.\n\n__SPLIT_HERE__\nFurther Reading\n\nHow to enable the clang-tidy linter in Gitpod","metadata":{"source":"https://gitpod.io/docs/introduction/languages/cpp"}}],["510",{"pageContent":"__SPLIT_HERE__\nDart in Gitpod\n\n__SPLIT_HERE__\nExample Repositories\n\nHere are a few Dart example projects that are already automated with Gitpod:\n\nRepository Description Try it\nFlutter Hello World Demo The Flutter hello world demo template configured for Gitpod Open in Gitpod\n\n__SPLIT_HERE__\nInstalling Dart\n\nTo install the Dart SDK in Gitpod one must add the following to your .gitpod.Dockerfile\n\n```dockerfile\nRUN brew tap dart-lang/dart && brew install dart\n```\n\n__SPLIT_HERE__\nVSCode Extensions\n\nDart\n\nThis Extension adds cool syntax highlighting\n\nSyntax highlighting example\n\nIt adds IntelliSense support for autocompletion\n\nDart IntelliSense example\n\n__SPLIT_HERE__\nTry it\n\nHere is a hello world example of a Gitpodified project running in the browser, try it!\n\nOpen in Gitpod","metadata":{"source":"https://gitpod.io/docs/introduction/languages/dart"}}],["511",{"pageContent":"__SPLIT_HERE__\nDeno in Gitpod\n\nIt&#39;s easy to set up Deno in Gitpod.\n\n__SPLIT_HERE__\nSetting up the Dockerfile\n\nAdd a Dockerfile to your project as .gitpod.Dockerfile:\n\n```dockerfile\nFROM gitpod/workspace-full\n\nRUN curl -fsSL https://deno.land/x/install/install.sh | sh\nRUN /home/gitpod/.deno/bin/deno completions bash > /home/gitpod/.bashrc.d/90-deno && \\\n    echo 'export DENO_INSTALL=\"/home/gitpod/.deno\"' >> /home/gitpod/.bashrc.d/90-deno && \\\n    echo 'export PATH=\"$DENO_INSTALL/bin:$PATH\"' >> /home/gitpod/.bashrc.d/90-deno\n```\n\nAnd configure this Dockerfile in your .gitpod.yml:\n\n```YAML\nimage:\n  file: .gitpod.Dockerfile\n```\n\nIt&#39;ll run the latest Deno version and install the Bash completions.\n\n__SPLIT_HERE__\nExample Repositories\n\nHere are a few Deno example projects that are already automated with Gitpod:\n\nRepository Description Try it\nfake-log-generator Generator for fake log files as CLI application Open in Gitpod\n\n__SPLIT_HERE__\nVSCode Extensions\n\nHere is a useful extensions that you&#39;ll likely want to install in your Deno project.\n\nDeno\n\nTo add this extension to your repository, simply open Gitpod&#39;s Extensions panel (see left vertical menu in the IDE), then search for &quot;Deno&quot; and install it &quot;for this project&quot;.\n\nNext, simply commit the .gitpod.yml configuration file that was automatically created (or updated) by Gitpod.","metadata":{"source":"https://gitpod.io/docs/introduction/languages/deno"}}],["512",{"pageContent":"__SPLIT_HERE__\n.NET in Gitpod\n\n__SPLIT_HERE__\nExample Repositories\n\nRepository Description Try it\ndotnetcore C# .NET Core template Open in Gitpod\nuno Build Mobile, Desktop and WebAssembly apps with C# and XAML Open in Gitpod\nuno.quickstart An Uno &quot;Hello world!&quot; project using Windows UWP, iOS, Android and WebAssembly Open in Gitpod\n\n__SPLIT_HERE__\nInstalling the .NET Tools\n\nTo get all the .NET tools that you need pre-installed in your Gitpod workspaces, use the following base image in your .gitpod.yml:\n\n```YAML\nimage: gitpod/workspace-dotnet\n```\n\nIf your project requires a GUI or Virtual Desktop, please use this image instead:\n\n```YAML\nimage: gitpod/workspace-dotnet-vnc\n```\n\nThis will give you a full GUI Virtual Desktop for your .NET application! The Virtual Desktop will be running on port 6080.\n\n__SPLIT_HERE__\nCompiling .NET Code in Gitpod\n\nTo compile your C# or F# Code in Gitpod, run dotnet build &lt;FILE&gt;, where &lt;FILE&gt; is the path to the C# or F# project file or .NET solution file you want to compile.\n\n__SPLIT_HERE__\nRunning .NET Code in Gitpod\n\nTo run your code after it has been compiled run dotnet &lt;FILE&gt; where &lt;FILE&gt; is the path to the EXE file you want to run. You can also run application with dotnet run &lt;FILE&gt; where &lt;FILE&gt; is the path to the C# or F# project file you want to compile and run.\n\n__SPLIT_HERE__\nRunning .NET Code in watch-mode\n\nAlternatively, you can also run your application in so-called watch-mode. In such configuration the application will recompile and rerun itself every time you save any source file belonging to the project. To run your code in watch-mode use dotnet watch --project &lt;FILE&gt; run where &lt;FILE&gt; is the path to the C# or F# project file you want to compile and run.\n\n__SPLIT_HERE__\nUseful VSCode Extensions\n\nC#\n\nThe official C# extension from Microsoft is proprietary and unfortunately cannot be used. The MIT licensed muhammad-sammy.csharp extension from Samsung brings code completion, snippets, auto-formatting, peek definition, refactoring, hover documentation and breakpoint debugging for C# however!\n\nC# Extension Demo\n\nTo add this extension to your repository, add the following to your .gitpod.yml:\n\n```yaml\nvscode:\n  extensions:\n    - muhammad-sammy.csharp\n```\n\nF#\n\nThe Ionide-fsharp extensin gives F# developers the following features:\n\nA Widget for your F# needs\nAuto completion\nShows errors inline\nQuickfix\nGoto definition\nPeek definition\nAnd more...\n\nIonide fsharp Example\n\nTo add this extension to your repository, add the following to your .gitpod.yml:\n\n```yaml\nvscode:\n  extensions:\n    - Ionide.Ionide-fsharp@4.6.2:yBkAE6j7z7gJ5WEcyMjEOg==\n```","metadata":{"source":"https://gitpod.io/docs/introduction/languages/dotnet"}}],["513",{"pageContent":"__SPLIT_HERE__\nGo in Gitpod\n\nGitpod includes Go in the default image, but if you need to customize your Go version or IDE setup in Gitpod, this guide will help you.\n\n__SPLIT_HERE__\nPrerequisites\n\nThis guide assumes familiarity with:\n\nDocker, YAML, Linux, Bash and Linux environment variables.\n\n__SPLIT_HERE__\nGetting started / Quick Start\n\nyoutube: ij1msCffQZA\n\nTo see a full working Go application, take a look at gitpod-samples/template-golang-cli. To update an existing Go application, follow the steps below in this guide.\n\n__SPLIT_HERE__\nInstalling Dependencies\n\nThe default base image\n\nThe default Gitpod workspace image default is workspace-full based on Ubuntu.\n\nThis base image includes:\n\nGo v1.19.1 (go version)\n\nNote: We discuss how to set up a custom base image later in the guide.\n\nUpdating Go Versions\n\nGitpod uses the latest stable version of Go by default. If you want to use a different version, you can use the Go Version Manager to install and manage multiple versions of Go or you can following their official guide.\n\nSetting up a custom Dcokerfile\n\nyoutube: jFsbmcXCRf8\n\nTo ensure Gitpod workspaces always start with the correct dependencies, configure a Dockerfile:\n\nCreate a .gitpod.yml\n\n```bash\ntouch .gitpod.yml\n```\n\nCreate a custom Dockerfile\n\n```bash\ntouch .gitpod.Dockerfile\n```\n\nReference your newly created Dockerfile in your .gitpod.yml\n\n```yaml\nimage:\n  file: .gitpod.Dockerfile\n```\n\nUpdate your .gitpod.Dockerfile to install your preferred dependency versions\n\n```dockerfile\n# You can find the new timestamped tags here: https://hub.docker.com/r/gitpod/workspace-base/tags\nFROM gitpod/workspace-base:latest\n\n# Change your version here\nENV GO_VERSION=1.17\n\n# For ref, see: https://github.com/gitpod-io/workspace-images/blob/61df77aad71689504112e1087bb7e26d45a43d10/chunks/lang-go/Dockerfile#L10\nENV GOPATH=$HOME/go-packages\nENV GOROOT=$HOME/go\nENV PATH=$GOROOT/bin:$GOPATH/bin:$PATH\nRUN curl -fsSL https://dl.google.com/go/go${GO_VERSION}.linux-amd64.tar.gz | tar xzs \\\n    && printf '%s\\n' 'export GOPATH=/workspace/go' \\\n                      'export PATH=$GOPATH/bin:$PATH' > $HOME/.bashrc.d/300-go\n```\n\nCommit and push both .gitpod.yml and .gitpod.Dockerfile\n\n```bash\ngit commit -m \"configuring gitpod with go\" && git push\n```\n\nStart a new workspace from the branch with the committed .gitpod.Dockerfile\n\nFor example, opening: gitpod.io/#https://github.com/gitpod-io/gitpod\n\nTest your dependencies are correct in the new workspace\n\n```bash\ngo version\n```\n\nNote: If your changes are not taking effect, ensure your workspace is building from the correct context, where your gitpod.yml or gitpod.Dockerfile are checked in to version control and are on the branch or commit that you are opening.\n\nSee configure Docker for more.\n\nUsing the dep dependency manager in Gitpod\n\nIf your project uses the dep (deprecated - v0.5.4) dependency manager then you need to add a .gitpod.Dockerfile to your project. A basic example that extends the default workspace image might be something like:\n\n```dockerfile\nFROM gitpod/workspace-full\n\nUSER gitpod\n\nRUN sudo apt-get install go-dep\n```\n\nAlso, don&#39;t forget to reference the above Dockerfile in your .gitpod.yml configuration file, like so:\n\n```YAML\nimage:\n  file: .gitpod.Dockerfile\n\ntasks:\n  - init: dep ensure\n\nvscode:\n  extensions:\n    - golang.go\n    - premparihar.gotestexplorer\n```","metadata":{"source":"https://gitpod.io/docs/introduction/languages/go"}}],["514",{"pageContent":"Debugging your Go application in Gitpod\n\nDebugging your Go applications in VS Code\n\nHere is a quick clip on how to automatically configure debugging for Go!\n\nSo, basically in this video we:\n\nFirst, open the Go file that we want to debug\nThen, go to the debug menu and select &quot;Add Configuration...&quot;\nNext, in the dropdown choose &quot;Go launch file&quot;\nFinally, start debugging your Go program!\n\nYou can also create the Go debug configuration file manually\n\nTo start debugging your Go application in Gitpod, please create a new directory called .theia/, and inside add a file called launch.json, finally, add the following to it:\n\n```json\n{\n  // Use IntelliSense to learn about possible attributes.\n  // Hover to view descriptions of existing attributes.\n  \"version\": \"0.2.0\",\n  \"configurations\": [\n    {\n      \"name\": \"Launch file\",\n      \"type\": \"go\",\n      \"request\": \"launch\",\n      \"mode\": \"debug\",\n      \"program\": \"${file}\"\n    }\n  ]\n}\n```\n\nThen, simply open the Go file you want to debug, open the Debug panel (in the left vertical toolbar, click the icon with the crossed-out-spider), and click the green &quot;Run&quot; button.\n\nTo see a basic repository with Go debugging, please check out gitpod-samples/template-golang-cli:\n\nOpen in Gitpod\n\nDebugging your Go applications in GoLand\n\nSteps to debug your Go application in GoLand:\n\nOpen your project in Gitpod with GoLand.\nOpen the main.go file in the editor.\nClick on the Run menu and select Edit Configurations....\nClick on the + button and select Go Application.\nIn the Go Application window, enter the name of the configuration and the path to the file you want to debug.\nClick on the Apply button.\nClick on the Debug button to start debugging your Go application.\n\nUsing $GOPATH\n\nOlder Go projects without module support need a specific workspace layout:\nthe source code of your repository and its dependencies must be in the directories\n\n```sh\nsrc/[repository-provider]/[repository-owner]/[repository-name]\n```\n\nin the $GOPATH. Using the .gitpod.yml file, you can bring about such a workspace layout. Here is\nhow we do that for the example go-gin-app repository:\n\n```yaml\n---\ncheckoutLocation: \"src/github.com/demo-apps/go-gin-app\"\nworkspaceLocation: \".\"\ntasks:\n  - init: |\n      cd /workspace/src/github.com/demo-apps/go-gin-app &&\n      go get -v ./... &&\n      go build -o app\n    command: |\n      cd /workspace/src/github.com/demo-apps/go-gin-app &&\n      ./app\n```\n\nIn more detail:\n\nBy default, Gitpod clones the repository into the directory /workspace, which becomes the\nroot directory for the workspace. With checkoutLocation and workspaceLocation you can\nchange this behavior (the paths are taken relative to /workspace).\nGitpod preconfigures the $GOPATH environment variable to include the directory /workspace/go.\nWith go get -v ./... we retrieve the sources of the dependencies from GitHub.\nTo build the app, we run go build -o app.\nLastly, we start the application.\n\n__SPLIT_HERE__\nExample Repositories\n\nHere are a few Go example projects that are already automated with Gitpod:\n\nRepository Description Try It\nprometheus The Prometheus monitoring system and time series database Open in Gitpod\ngo-swagger A simple yet powerful representation of your RESTful API Open in Gitpod\ngo-gin-app Gin example running in Gitpod Open in Gitpod\ngosh-terminal A terminal implemented in Go where you can do anything Open in Gitpod\n\n__SPLIT_HERE__\nFurther Reading\n\nVSCode/Go Documentation The stuff here also applies to Gitpod!\nJetBrains/GoLand Documentation The stuff here also applies to Gitpod!\nVSCode/Go debugging VSCode&#39;s Documentation on Go debugging","metadata":{"source":"https://gitpod.io/docs/introduction/languages/go"}}],["515",{"pageContent":"__SPLIT_HERE__\nHTML &amp; CSS in Gitpod\n\nGitpod has great HTML and CSS support. In fact, Gitpod was made with web development in mind. And, depending on your needs, you may want to customize this experience further!\n\n__SPLIT_HERE__\nExample Repositories\n\nHere are a few HTML/CSS example projects that are already automated with Gitpod:\n\nRepository Description Try it\nFront-End-Checklist The perfect Front-End Checklist for modern websites and meticulous developers Open in Gitpod\nDevhints TL;DR for developer documentation - a ridiculous collection of cheatsheets Open in Gitpod\n\n__SPLIT_HERE__\nemmet &nbsp;Support\n\nemmet demo\nGitpod comes with emmet support right out of the box giving you access to powerful snippets and completions\n\n__SPLIT_HERE__\nLive Preview\n\nLive Preview Demo\nWith Gitpod you can open a preview for HTML files while you are coding. You can do this by opening a web server python -m http.server 8000.\n\nYou can also automate this in your .gitpod.yml file, so that every time you start a new workspace your preview is ready to go. For example:\n\n```yaml\ntasks:\n  - name: Start web server\n    init: python -m http.server 8000\n\nports:\n  - port: 8000\n    onOpen: open-preview\n```\n\n__SPLIT_HERE__\nTry It!\n\nWant to see a minimal example in action? Try it out by opening an example on Gitpod:\n\ngitpod-io/Gitpod-Web-Development-Example","metadata":{"source":"https://gitpod.io/docs/introduction/languages/html"}}],["516",{"pageContent":"__SPLIT_HERE__\nLanguages\n\nGitpod is a very flexible tool and can be configured with many languages.","metadata":{"source":"https://gitpod.io/docs/introduction/languages/index"}}],["517",{"pageContent":"__SPLIT_HERE__\nJava in Gitpod\n\nGitpod comes with great support for Java. This guide walks you through how to fully configure a Java application using Gitpod.\n\n__SPLIT_HERE__\nPrerequisites\n\nThis guide assumes familiarity with:\n\nDocker, YAML, Linux, Bash and Linux environment variables.\n\n__SPLIT_HERE__\nGetting started / Quick Start\n\nyoutube: ij1msCffQZA\n\nTo see a full working Java application, take a look at gitpod-io/spring-petclinic. To update an existing Java application, follow the steps below in this guide.\n\n__SPLIT_HERE__\nInstalling dependencies\n\nThe default base image\n\nThe default Gitpod workspace image default is workspace-full based on Ubuntu.\n\nAlong with other languages and tools, this base image includes:\n\nSDKMAN! v5.16.0 (sdk version)\nJava v11.0.16 (java -version)\nGradle v7.5.1 (gradle -version)\nMaven v3.8.6 (mvn -version)\n\nNote: We discuss how to set up a custom base image later in the guide.\n\nUpdating Java, Maven &amp; Gradle\n\nFor alternative versions to those provided in the Gitpod base image, with SDKMAN! you can quickly update your dependencies: sdk install &lt;candidate&gt; [version]\n\nImportant: Dynamically swapping Java, Maven or Gradle versions manually is a quick way to explore Gitpod. However, for day-to-day development strongly recommend to add explicit dependency versions in your gitpod.yml or Dockerfile.\n\nUpdating Java version\n\nsdk list java - to see available java versions\nsdk install java 18.0.1.fx-zulu - to install a specific version\n\nUpdating Maven version\n\nsdk list maven - to see available maven versions\nsdk install maven 3.8.6 - to install a specific version\n\nUpdating Gradle version\n\nsdk list gradle - to see available gradle versions\nsdk install gradle 7.4.1 - to install a specific version\n\nSetting up a custom Dockerfile\n\nyoutube: jFsbmcXCRf8\n\nTo ensure Gitpod workspaces always start with the correct dependencies, configure a Dockerfile:\n\nCreate a .gitpod.yml\n\n```bash\ntouch .gitpod.yml\n```\n\nCreate a custom Dockerfile\n\n```bash\ntouch .gitpod.Dockerfile\n```\n\nReference your newly created Dockerfile in your .gitpod.yml\n\n```yaml\nimage:\n  file: .gitpod.Dockerfile\n```\n\nUpdate your .gitpod.Dockerfile to install your dependency versions\n\n```Dockerfile\nFROM gitpod/workspace-full\n\nUSER gitpod\n\nRUN bash -c \". /home/gitpod/.sdkman/bin/sdkman-init.sh && \\\n    sdk install java 17.0.3-ms && \\\n    sdk default java 17.0.3-ms\"\n```\n\nCommit and push both gitpod.yml and .gitpod.Dockerfile\n\n```bash\ngit commit -m \"configuring gitpod with java\" && git push\n```\n\nStart a new workspace from the branch with the committed .gitpod.Dockerfile\n\nFor example, opening: gitpod.io/#https://github.com/gitpod-io/gitpod\n\nTest your dependencies are correct in the new workspace\n\n```bash\nsdk current\n```\n\nNote: If your changes are not taking effect, ensure your workspace is building from the correct context, where your gitpod.yml or gitpod.Dockerfile are checked in to version control and are on the branch or commit that you are opening.\n\nSee configure Docker for more.","metadata":{"source":"https://gitpod.io/docs/introduction/languages/java"}}],["518",{"pageContent":"Build and run your application\n\nBuilding a Java application\n\nTo build your application, you&#39;ll need to configure a start task.\n\nStart tasks are processes that are initiated on every workspace start. Depending on your project setup, start tasks can be used to build your application, run your application directly, or start any necessary tools for the application to run, such as starting database processes.\n\nAdd the command to build your application to your .gitpod.yml\n\nExample with Gradle\n\n```yaml\ntasks:\n  - init: gradle build\n```\n\nExample with Maven\n\n```yaml\ntasks:\n  - init: mvn package\n```\n\nOptional: Validate by stopping and starting (restart) your workspace\n\n```bash\ngp stop\n```\n\nOptional: Validate your commands by running gp tasks\n\n```shell\ngp tasks\n```\n\nTip: If you&#39;re using VS Code Browser or VS Code Desktop, then your tasks will open as terminal windows. You can configure their layout using the openMode property.","metadata":{"source":"https://gitpod.io/docs/introduction/languages/java"}}],["519",{"pageContent":"```shell\ngp tasks\n```\n\nTip: If you&#39;re using VS Code Browser or VS Code Desktop, then your tasks will open as terminal windows. You can configure their layout using the openMode property.\n\nNote: We are using the init property so that we can perform application building during a prebuild, for increased performance. We&#39;ll discuss prebuilds more later on.\n\nSee start tasks and .gitpod.yml reference for more.\n\nRunning a Java application\n\nTo run your application, you have two options:\n\nUpdate your start task command - Starting your application using the command start task will run the start process on workspace start. With both VS Code Browser and VS Code Desktop, tasks are automatically opened in the terminal(s). With IntelliJ / JetBrains Gateway, configured tasks can be viewed by running gp tasks in the workspace.\nUse a run / launch configuration - Alternatively, you can commit a run/debug configuration in IntelliJ IDEA or a launch configuration in VS Code as a way to start your application.","metadata":{"source":"https://gitpod.io/docs/introduction/languages/java"}}],["520",{"pageContent":"Using start tasks to run Java\n\nAdd a command for starting your application to your .gitpod.yml\n\nExample with Gradle\n\n```yaml\ntasks:\n  - init: gradle build\n    command: gradle run\n```\n\nExample with Maven\n\n```yaml\ntasks:\n  - init: mvn package\n    command: mvn exec:java\n```\n\nOptional: Validate by stopping and starting (restart) your workspace\n\n```bash\ngp stop\n```\n\nOptional: Validate your commands by running gp tasks\n\n```shell\ngp tasks\n```\n\nConfiguring environment variables\n\nyoutube: dehln1E8ylY\n\nGitpod supports encrypted, user-specific environment variables.\n\nEnvironment variables are stored as part of your user settings and can be used to set access tokens, or pass any other kind of user-specific information to your workspaces. You can set environment variables using gp env, or in your project and account settings.\n\nSee environment variables for more.\n\nConfiguring ports","metadata":{"source":"https://gitpod.io/docs/introduction/languages/java"}}],["521",{"pageContent":"See environment variables for more.\n\nConfiguring ports\n\nWhen your project starts a service that listens on a given port, Gitpod automatically serves traffic to this port of your application on an authenticated URL.\n\nIf you want to configure ports, such as: their visibility, what Gitpod does when it detects a new port being available, etc, you can do that in the ports section of the .gitpod.yml configuration file.\n\nFor example, add the following to your .gitpod.yml to configure port 3000 to open in your browser on workspace start.\n\n```yaml\nports:\n  - port: 3000\n    onOpen: open-browser\n```\n\nSee configuring ports for more\n\nConfiguring localhost\n\nYour development application might rely on the localhost hostname to effectively run.\n\nTo ensure your localhost address works with Gitpod, you have two options:\n\nReplace localhost references - Swap localhost references within the application with the output of gp url &lt;port&gt;, typically via an environment variable.","metadata":{"source":"https://gitpod.io/docs/introduction/languages/java"}}],["522",{"pageContent":"Replace localhost references - Swap localhost references within the application with the output of gp url &lt;port&gt;, typically via an environment variable.\n\nExample: Using the DEV_ENVIRONMENT_HOST environment variable instead of localhost within the application, configured in the command of the .gitpod.yml start tasks.\n\n```yaml\ntasks:\n  - command: |\n    export DEV_ENVIRONMENT_HOST=`gp url 3000`\n    java <application-entry>\n```\n\nSetup localhost port forwarding - Connect your local machine with your running workspace means that you don&#39;t need to replace localhost references, to do that you&#39;ll need to configure port forwarding. Port forwarding is useful if you&#39;re working with a framework that needs localhost, and the application cannot be reconfigured.\n\nWith VS Code Desktop, local port-forwarding is handled automatically and can be configured via the ports view within VS Code Desktop.\n\nWith IntelliJ IDEA using JetBrains Gateway you can setup remote port-forwarding manually.","metadata":{"source":"https://gitpod.io/docs/introduction/languages/java"}}],["523",{"pageContent":"With IntelliJ IDEA using JetBrains Gateway you can setup remote port-forwarding manually.\n\nAlternatively, by using local companion all workspace ports will be forwarded automatically.\n\nSee configuring ports for more.\n\nConfiguring VS Code extensions\n\nTo set default plugins to be installed for all users starting a workspace for the project, add a list of the JetBrains plugin identifiers to your .gitpod.yml under vscode.extensions.\n\n```yaml\nvscode:\n  extensions:\n    - vscjava.vscode-java-pack\n```\n\nSee .gitpod.yml reference for more.\n\nConfiguring VS Code Launch configurations","metadata":{"source":"https://gitpod.io/docs/introduction/languages/java"}}],["524",{"pageContent":"```yaml\nvscode:\n  extensions:\n    - vscjava.vscode-java-pack\n```\n\nSee .gitpod.yml reference for more.\n\nConfiguring VS Code Launch configurations\n\nLaunch configurations can be shared by committing the .vscode/launch.json file to version control. To use a launch configuration with Java, need Java version 11 or above, and some VS Code extensions. Assuming you have configured your base image with a compatible JDK version as described above, a simple way to get set up is by adding the Extension Pack for Java will configure the correct VS Code extensions. Alternatively, you can selectively choose the extensions to install.\n\n```yaml\nvscode:\n  extensions:\n    - vscjava.vscode-java-pack\n```\n\nSee Debugging in Visual Studio Code and VS Code Java Extensions for more.\n\nConfiguring JetBrains Run/Debug configurations","metadata":{"source":"https://gitpod.io/docs/introduction/languages/java"}}],["525",{"pageContent":"```yaml\nvscode:\n  extensions:\n    - vscjava.vscode-java-pack\n```\n\nSee Debugging in Visual Studio Code and VS Code Java Extensions for more.\n\nConfiguring JetBrains Run/Debug configurations\n\nTo share your run/debug configurations, you can commit their definitions to source control. Since the .idea folder contains lots of information used for IntelliJ (which can include sensitive information or secrets) you may wish to ignore the .idea from version control, and explicitly allow .idea/runConfigurations.\n\nAdd run/debug configurations to git, by adding the following to your .gitignore.\n\n```\n/.idea/*\n!/.idea/runConfigurations\n```\n\nSee JetBrains Run/Debug configuration documentation for more.\n\nConfiguring JetBrains Plugins\n\nTo set default extensions to be installed for all users starting a workspace for the project, add a list of the VS Code extension identifiers to your .gitpod.yml.\n\n```yaml\njetbrains:\n  intellij:\n    plugins:\n      - com.intellij.lang.jsgraphql\n```\n\nSee .gitpod.yml reference for more.","metadata":{"source":"https://gitpod.io/docs/introduction/languages/java"}}],["526",{"pageContent":"Optimising Java Applications\n\nGitpod prebuilds reduce wait time by installing dependencies or running builds before you start a new workspace. By default, Gitpod prepares prebuilt workspaces for all changes on the default branch and pull/merge requests coming from the same repository. However, prebuilds save only the workspace directory, any files stored outside of the workspace directory will be lost. For Java applications, we recommend to execute build commands within an init startup task.\n\nyoutube: DwkoOz1GSVg\n\nSee prebuilds and start tasks for more.\n\nOptimising JetBrains indexing\n\nJetBrains prebuilds support (via gitpod.yml) is currently in Alpha ¬∑ Send feedback.\n\nGitpod currently has early support for improved indexing performance with JetBrains IDEs that works out-of-the-box. You can enable this setting via the .gitpod.yml.\n\nExample: Index both the stable and latest of the IntelliJ IDE\n\n```yaml\njetbrains:\n  intellij:\n    prebuilds:\n      version: stable\n```\n\nCaching Maven dependencies\n\nThe default cache location for Maven is the .m2 directory. However, since this location is by default outside of the /workspace directory caches will not be stored as part of a prebuild.\n\nIf you are using the workspace-full image, Maven caching configuration is already enabled.\n\nTo configure Maven caching, add the following to your custom Dockerfile.\n\nCreate an .m2 directory in the users (gitpod) home directory.\n\n```bash\nmkdir /home/gitpod/.m2\n```\n\nCreate a settings.xml and configure localRepository within workspace.\n\n```bash\nprintf '<settings>\\n  <localRepository>/workspace/m2-repository/</localRepository>\\n</settings>\\n' > /home/gitpod/.m2/settings.xml\n```\n\nSee prebuilds for more.\n\nCaching Gradle dependencies\n\nThe default location of the gradle home is $USER_HOME/.gradle, however, since this location is by default outside of the /workspace directory caches will not be stored as part of a prebuild.\n\nIf you are using the workspace-full image, Gradle caching configuration is already enabled.\n\nTo configure Gradle caching, add the following to your custom Dockerfile.\n\n```\nENV GRADLE_USER_HOME=/workspace/.gradle/\n```\n\nSee prebuilds for more.\n\n__SPLIT_HERE__\nPersonalizing Gitpod\n\nAll settings introduced so far, such as .gitpod.yml and Dockerfile apply for all users using of the gitpod project. To apply personalisation, consider setting up dotfiles, the Gitpod Browser Extension,\n\nDotfiles\n\nDotfiles allow you to setup per-user configurations in your Gitpod workspace, such as modifying your shell and adding command aliases. To configure Gitpod to use your own dotfiles for all your workspaces, enter the URL of a public dotfiles repository in your Gitpod preferences.\n\nSee dotfiles for more.\n\nBrowser Extension\n\nBrowser Extension\n\nTo make opening Gitpod workspaces easier, install the Gitpod browser extension, which enables an &quot;Open in Gitpod&quot; button on GitHub, GitLab and Bitbucket.\n\nSee Browser Extension for more.\n\nConfigure your IDE or editor\n\nWith Gitpod, you can work with VS Code Browser, VS Code Desktop or JetBrains IDEs, such as IntelliJ IDEA. Setting your preference ensures all future workspaces start with the chosen IDE or editor. Visit the preferences page to configure these settings.\n\nSee IDEs &amp; Editors for more.\n\nVS Code Desktop Settings Sync\n\nEnable Settings Sync with Gitpod\nEnable Settings Sync with Gitpod\nEnable Settings Sync with Gitpod\n\nVS Code Desktop by default is not setup to sync your VS Code settings (e.g. your fonts, layouts, etc) with VS Code running in the browser of Gitpod. You can configure Gitpod to sync settings between browser and desktop by running the command palette action &quot;Settings Sync: Enable signing in with Gitpod&quot; from the Gitpod VS Code extension.\n\nSee VS Code settings sync for more.","metadata":{"source":"https://gitpod.io/docs/introduction/languages/java"}}],["527",{"pageContent":"__SPLIT_HERE__\nJavaScript in Gitpod\n\nGitpod comes with great built-in support for JavaScript, TypeScript, and tools like Node.js, npm, pnpm &amp; yarn pre-installed with Gitpod workspace image. This guide walks you through how to fully configure a JavaScript application using Gitpod.\n\n__SPLIT_HERE__\nPrerequisites\n\nThis guide assumes familiarity with:\n\nDocker, YAML, Linux, Bash and Linux environment variables.\n\n__SPLIT_HERE__\nGetting started / Quick Start\n\nyoutube: ij1msCffQZA\n\nTo see a full working Node/TypeScript application, take a look at gitpod-samples/template-typescript-node. To update an existing JavaScript application, follow the steps below in this guide.\n\n__SPLIT_HERE__\nInstalling dependencies\n\nThe default base image\n\nThe default Gitpod workspace image default is workspace-full based on Ubuntu.\n\nAlong with other languages and tools, this base image includes:\n\nNode.js v16.18.1 (node -v)\nNode Package Manager - npm v8.19.2 (npm -v)\nNode Version Manager - nvm 0.39.0 (nvm -v)\n\nNote: We discuss how to set up a custom base image later in the guide.\n\nUpdating Node Versions\n\nGitpod comes with the latest stable Node.js version pre-installed but let&#39;s say your project uses a different version of node (say 14.8.0 for example), well the good news is that Gitpod also comes with nvm (a tool used to manage multiple active Node.js versions) installed. To install and configure the desired version of node: nvm install 14.8.0 and nvm use 14.8.0 (you can also use nvm alias default 14.8.0 to set the default version of node) or you can setup custom Dockerfile to install the desired version of node &amp; other required tools.\n\nSetting up a custom Dcokerfile\n\nyoutube: jFsbmcXCRf8\n\nTo ensure Gitpod workspaces always start with the correct dependencies, configure a Dockerfile:\n\nCreate a .gitpod.yml\n\n```bash\ntouch .gitpod.yml\n```\n\nCreate a custom Dockerfile\n\n```bash\ntouch .gitpod.Dockerfile\n```\n\nReference your newly created Dockerfile in your .gitpod.yml\n\n```yaml\nimage:\n  file: .gitpod.Dockerfile\n```\n\nUpdate your .gitpod.Dockerfile to install your dependency versions\n\n```dockerfile\nFROM gitpod/workspace-full:latest\n\nRUN bash -c 'VERSION=\"14.8.0\" \\\n    && source $HOME/.nvm/nvm.sh && nvm install $VERSION \\\n    && nvm use $VERSION && nvm alias default $VERSION'\n\nRUN echo \"nvm use default &>/dev/null\" >> ~/.bashrc.d/51-nvm-fix\n```\n\nCommit and push both .gitpod.yml and .gitpod.Dockerfile\n\n```bash\ngit commit -m \"configuring gitpod with javascript\" && git push\n```\n\nStart a new workspace from the branch with the committed .gitpod.Dockerfile\n\nFor example, opening: gitpod.io/#https://github.com/gitpod-io/gitpod\n\nTest your dependencies are correct in the new workspace\n\n```bash\nnode -v\n```\n\nNote: If your changes are not taking effect, ensure your workspace is building from the correct context, where your gitpod.yml or gitpod.Dockerfile are checked in to version control and are on the branch or commit that you are opening.\n\nSee configure Docker for more.","metadata":{"source":"https://gitpod.io/docs/introduction/languages/javascript"}}],["528",{"pageContent":"Build and run your application\n\nBuilding a JavaScript application\n\nTo build your application, you&#39;ll need to configure a start task.\n\nStart tasks are processes that are initiated on every workspace start. Depending on your project setup, start tasks can be used to build your application, run your application directly, or start any necessary tools for the application to run, such as starting database processes.\n\nAdd the command to build your application to your .gitpod.yml\n\nExample with npm\n\n```yaml\ntasks:\n  - init: npm install && npm run build\n```\n\nExample with yarn\n\n```yaml\ntasks:\n  - init: yarn install && yarn build\n```\n\nOptional: Validate by stopping and starting (restart) your workspace\n\n```bash\ngp stop\n```\n\nOptional: Validate your commands by running gp tasks\n\n```shell\ngp tasks\n```\n\nTip: If you&#39;re using VS Code Browser or VS Code Desktop, then your tasks will open as terminal windows. You can configure their layout using the openMode property.","metadata":{"source":"https://gitpod.io/docs/introduction/languages/javascript"}}],["529",{"pageContent":"```shell\ngp tasks\n```\n\nTip: If you&#39;re using VS Code Browser or VS Code Desktop, then your tasks will open as terminal windows. You can configure their layout using the openMode property.\n\nNote: We are using the init property so that we can perform application building during a prebuild, for increased performance. We&#39;ll discuss prebuilds more later on.\n\nSee start tasks and .gitpod.yml reference for more.\n\nRunning a JavaScript application\n\nTo run your application, you have two options:\n\nUpdate your start task command - Starting your application using the command start task will run the start process on workspace start. With both VS Code Browser and VS Code Desktop, tasks are automatically opened in the terminal(s). With IntelliJ / JetBrains Gateway, configured tasks can be viewed by running gp tasks in the workspace.\n\nUsing start tasks to run JavaScript\n\nAdd a command for starting your application to your .gitpod.yml\n\nExample with npm","metadata":{"source":"https://gitpod.io/docs/introduction/languages/javascript"}}],["530",{"pageContent":"Using start tasks to run JavaScript\n\nAdd a command for starting your application to your .gitpod.yml\n\nExample with npm\n\n```yaml\ntasks:\n  - init: npm install && npm run build\n    command: npm run dev\n```\n\nExample with yarn\n\n```yaml\ntasks:\n  - init: yarn install && yarn build\n    command: yarn start\n```\n\nOptional: Validate by stopping and starting (restart) your workspace\n\n```bash\ngp stop\n```\n\nOptional: Validate your commands by running gp tasks\n\n```shell\ngp tasks\n```\n\nUsing ESLint for linting\n\nIf your project&#39;s package.json does not mention ESLint as a dependency then you have to install it first. For installing it add the following to the end of the init phase of your .gitpod.yml as shown:\n\n```yaml\ntasks:\n  - init: npm install && npm run build && npm install -g eslint\n```\n\nand then search for eslint in the extensions tab and then install it from there using the install button as shown in the screenshot.\n\nInstall ESLint in Gitpod\n\nHot Module Replacement (HMR)","metadata":{"source":"https://gitpod.io/docs/introduction/languages/javascript"}}],["531",{"pageContent":"and then search for eslint in the extensions tab and then install it from there using the install button as shown in the screenshot.\n\nInstall ESLint in Gitpod\n\nHot Module Replacement (HMR)\n\nEspecially when it comes to Frontend Projects, the dev-server should be able to auto-reload on file changes. The implementation varies from server to server. To make this work, some additional config is required:\n\nVite\n\nIn your .gitpod.yml file, you should export the workspace url for the port your server runs into the environment.\n\n```yaml title=\".gitpod.yml\"\ntasks:\n  - init: npm install\n    command: |\n      export HMR_HOST=`gp url 5173`\n```\n\nAfter exporting it to the environment, the URL can be accessed in the vite.config.js. With the following snippet, you are able to configure HMR to work inside Gitpod, as well as on localhost.","metadata":{"source":"https://gitpod.io/docs/introduction/languages/javascript"}}],["532",{"pageContent":"After exporting it to the environment, the URL can be accessed in the vite.config.js. With the following snippet, you are able to configure HMR to work inside Gitpod, as well as on localhost.\n\n```js title=\"vite.config.js\"\nconst config = () => ({\n  server: {\n    hmr: {\n      clientPort: process.env.HMR_HOST ? 443 : 5173,\n      host: process.env.HMR_HOST\n        ? new URL(process.env.HMR_HOST).hostname\n        : \"localhost\",\n    },\n  },\n});\n\nexport default config;\n```\n\nWebpack\n\nSimilar to the setup in Vite, the setup for Webpack consists of two steps: exporting the URL to the environment and consuming the environment variable in the config:\n\n```yaml title=\".gitpod.yml\"\ntasks:\n  - init: npm install\n    command: |\n      export HMR_HOST=`gp url 3000`\n```\n\nAfter the workspace URL with the given port is exported to the environment, it can be used in the webpack.config.js to determine the right port and hostname.","metadata":{"source":"https://gitpod.io/docs/introduction/languages/javascript"}}],["533",{"pageContent":"After the workspace URL with the given port is exported to the environment, it can be used in the webpack.config.js to determine the right port and hostname.\n\n```js title=\"webpack.config.js\"\nmodule.exports = {\n  devServer: {\n    client: {\n      webSocketURL: {\n        hostname: process.env.HMR_HOST\n          ? new URL(process.env.HMR_HOST).hostname\n          : \"localhost\",\n        port: process.env.HMR_HOST ? 443 : 3000,\n        protocol: \"wss\",\n      },\n    },\n  },\n};\n```\n\nUse of Private Packages\n\nIf you want to use private packages from npm or yarn on Gitpod, you can use the NPM_TOKEN environment variable. You can set it in your Gitpod user settings.","metadata":{"source":"https://gitpod.io/docs/introduction/languages/javascript"}}],["534",{"pageContent":"Debug your JavaScript application in Gitpod\n\nDebugging JavaScript applications in VS Code\n\nTo debug your application, you can use the VS Code Browser or VS Code Desktop IDE. You can start debugging by clicking the Debug button in the IDE&#39;s status bar or by pressing F5 or following the steps below:\n\nDebugger Option in Gitpod VS Code\n\nYou Can follow this official blog for more.\n\nDebugging JavaScript applications in JetBrains IDE (WebStorm)\n\nTo debug your application, you can use the WebStorm IDE. You can start debugging by clicking the Add Configurations button in the IDE&#39;s top status bar.\n\nDebugger Option in Gitpod WebStorm\n\nYou Can follow this official blog for more.\n\n__SPLIT_HERE__\nExample Repositories\n\nHere are a few JavaScript/TypeScript example projects that are automated with Gitpod:\n\nRepository Description Try it\nTesseract.js Pure JavaScript OCR for more than 100 Languages Open in Gitpod\nfreeCodeCamp freeCodeCamp.org&#39;s open source codebase and curriculum Open in Gitpod\nMozilla PDF.js PDF.js is a PDF viewer that is built with HTML5 Open in Gitpod\n\n__SPLIT_HERE__\nRecommended Reading\n\nBuild Projects in a Gitpod Ephemeral Dev Environment ‚Äî The Ultimate Guide\nSustainable Node.js development with only a browser.\nDeveloping a Nuxt.js app entirely in your browser\nGitpodifying ‚Äî The Ultimate Guide\nDebugging Node.js applications in Theia","metadata":{"source":"https://gitpod.io/docs/introduction/languages/javascript"}}],["535",{"pageContent":"__SPLIT_HERE__\nJulia in Gitpod\n\n__SPLIT_HERE__\nExample Repositories\n\nHere are a few Julia example projects that are already automated with Gitpod:\n\nA minimal example of a ready-to-code Julia developer environment is JesterOrNot/Gitpod-Julia. Feel free to take a look.\n\nAnd to showcase a real-world Julia project in Gitpod, we&#39;ve gitpodified the Julia repository itself! Try it via the following button:\n\nJesterOrNot/Julia","metadata":{"source":"https://gitpod.io/docs/introduction/languages/julia"}}],["536",{"pageContent":"__SPLIT_HERE__\nKotlin in Gitpod\n\nTo work with Kotlin in Gitpod, you will need to properly configure your repository. Here is how to do it.\n\n__SPLIT_HERE__\nInstalling Kotlin\n\nTo install Kotlin in Gitpod add the following to your .gitpod.Dockerfile:\n\n```dockerfile\nRUN brew install kotlin\n```\n\nA full example could look like this:\n\n```dockerfile\nFROM gitpod/workspace-full\n\nUSER gitpod\nRUN brew install kotlin\n```\n\n__SPLIT_HERE__\nVS Code extensions\n\nKotlin Language\n\nThis extension provides Kotlin language support for Gitpod and other IDEs, with:\n\nSyntax highlighting\nCode snippets\nRegion code folding\n\nTo get it, open Gitpod&#39;s Extensions panel (left vertical menu), then search for &quot;Kotlin&quot; and install the extension by Mathias Fr√∂hlich for your project. Next, commit the .gitpod.yml file that was automatically created (or updated) by Gitpod.\n\nCode Runner\n\nWhile this extension isn&#39;t Kotlin-specific, but allows to run code snippets in many different languages, including Kotlin.\n\nTo get it, open Gitpod&#39;s Extensions panel, then search for &quot;Code Runner&quot; and install it for your project.\n\n__SPLIT_HERE__\nTry it\n\nPlease use the button below to see a gitpodified Kotlin example project in Gitpod:\n\nOpen in Gitpod","metadata":{"source":"https://gitpod.io/docs/introduction/languages/kotlin"}}],["537",{"pageContent":"__SPLIT_HERE__\nLaTeX in Gitpod\n\nThis tutorial will demonstrate how to configure Gitpod to work with LaTeX files. You can find a complete example repository at the end.\n\n__SPLIT_HERE__\nInstalling LaTeX\n\nFirst, you will probably want to install LaTeX in Gitpod. To do this, add a new file to your repository called .gitpod.Dockerfile, and add the following content to it:\n\n```dockerfile\nFROM gitpod/workspace-full\n\n# Install LaTeX\nRUN sudo apt-get -q update && \\\n    sudo apt-get install -yq texlive && \\\n    sudo rm -rf /var/lib/apt/lists/*\n```\n\nNext, create a file called .gitpod.yml and add the following to it:\n\n```YAML\nimage:\n  file: .gitpod.Dockerfile\n```\n\nNow commit both files into source control, and push them to your GitHub or GitLab repository.\n\nThis will be your base configuration for LaTeX in Gitpod ‚Äî from now on, every time you create a new Gitpod workspace for your repository, it will be configured as specified in your .gitpod.yml and .gitpod.Dockerfile.\n\n__SPLIT_HERE__\nAutomatically compiling LaTeX files on save\n\nOne way to achieve this is to install inotify-tools by modifying your earlier .gitpod.Dockerfile like so:\n\n```dockerfile\nFROM gitpod/workspace-full\n\n# Install LaTeX\nRUN sudo apt-get -q update && \\\n    sudo apt-get install -yq texlive-full inotify-tools && \\\n    sudo rm -rf /var/lib/apt/lists/*\n```\n\nNext, modify your .gitpod.yml like so:\n\n```YAML\nimage:\n  file: .gitpod.Dockerfile\n\ntasks:\n  - name: LaTeX auto-rebuild\n    command: >\n      while find . -name '*.tex' | xargs inotifywait -qqre modify .; do \\\n        latexmk -pdf ; \\\n      done\n  - name: Terminal\n```\n\nThis will start a watcher process that automatically recompiles your *.tex files when they are changed. Note: The watcher process will start in a separate Terminal on every workspace start.\n\n__SPLIT_HERE__\nVSCode Extensions\n\nTexLab\n\nThis extension provides rich editing support for the LaTeX typesetting system powered by the TexLab language server.\n\nTo install it in Gitpod, simply download the corresponding *.vsix file Open VSX, and then drag-and-drop it into Gitpod&#39;s Extensions view (which can be found in the left vertical menu bar).\n\nThis will automatically append something like this to your .gitpod.yml file:\n\n```yml\nvscode:\n  extensions:\n    - efoerster.texlab@1.10.0:/Vq+k9Ug/81LYWajjTgMpA==\n```\n\n(Note: You can also append these lines yourself if you don&#39;t want to download &amp; re-upload the *.vsix file.)\n\nLaTeX Workshop\n\nAnother great LaTeX extension is LaTeX Workshop:\n\nBoost LaTeX typesetting efficiency with preview, compile, autocomplete, colorize, and more.\n\nIt is also available on Open VSX.\n\nLaTeX Snippets\n\nThere is also LaTeX Snippets:\n\nThis extension includes a variety of snippets for LaTeX including making environments and plotting images for functions, etc.\n\n__SPLIT_HERE__\nTry it!\n\nTo see a complete minimal example repository with a Gitpod configuration for LaTeX, including most of the tools we&#39;ve covered, see ptrottier/latex. You can try it in your browser:\n\nOpen in Gitpod","metadata":{"source":"https://gitpod.io/docs/introduction/languages/latex"}}],["538",{"pageContent":"__SPLIT_HERE__\nPHP in Gitpod\n\nGitpod supports PHP right out of the box, but more advanced features such as debugging can be configured, so here is how to do it!\n\nThere is also an awesome community project that utilizes ddev with Gitpod and makes things much easier.\nBe sure to check it out first from below!\n\nhttps://drud.github.io/ddev-gitpod-launcher/\n\nWith it, you can run XDebug out of the box, change PHP versions on the fly, and much more!\n\n__SPLIT_HERE__\nExample Repositories\n\nRepository Description Try it\nsymfony-demo A PHP/Symfony reference application following best practices Open in Gitpod\nmagento2gitpod Magento 2 optimized setup for Gitpod: Nginx, MySQL, PHP 7.2, PHP-FPM and more Open in Gitpod\nkoel A personal music streaming server that works Open in Gitpod\ndrupal Drupal 9 with MySQL, suitable for site building and contrib module development Open in Gitpod\nphpmyadmin A phpMyAdmin example with Node.js, a REST API and MySQL for data persistence Open in Gitpod\n\n__SPLIT_HERE__\nSwitching PHP versions\n\nGitpod installs PHP from Ond≈ôej Sur√Ω&#39;s PPA in here. The default version should be set to PHP8.\n\nBut let&#39;s say you want to switch to PHP7.4, follow along!\nAt first, add a .gitpod.Dockerfile file on your repo with the following content in it:\n\n```dockerfile\n# You can find the new timestamped tags here: https://hub.docker.com/r/gitpod/workspace-full/tags\nFROM gitpod/workspace-full:2022-05-08-14-31-53\n\n# Change your version here\nRUN sudo update-alternatives --set php $(which php7.4)\n```\n\nSecondly, reference the above Dockerfile in your .gitpod.yml configuration file, like so:\n\n```yaml\nimage:\n  file: .gitpod.Dockerfile\n```\n\nNow you can See it in action on a new workspace\n\n__SPLIT_HERE__\nDebugging PHP in Gitpod\n\nPHP debugging example\n\nThe PHP Debug extension allows debugging PHP applications from within Gitpod.\n\nTo get this extension for your project, you must do two things:\n\nFirst, you must create a .gitpod.Dockerfile for your repository:\n\n```dockerfile\nFROM gitpod/workspace-full:2022-05-08-14-31-53\n\nRUN sudo install-packages php-xdebug\n```\n\nSecond, reference the above Dockerfile in a .gitpod.yml file, and then also install the extension, like so:\n\n```yaml\nimage:\n  file: .gitpod.Dockerfile\n\nvscode:\n  extensions:\n    - felixfbecker.php-debug\n```\n\nNow you can See it in action on a new workspace\n\nLater, you can head over to Run and Debug on the left hand side and have fun debugging PHP! You can also create a launch.json file.\n\nFinally, here is a full example repository containing the complete Gitpod PHP debug configuration described above. You can try it by clicking here:\n\nOpen in Gitpod\n\n__SPLIT_HERE__\nPECL Package Manager\n\nGitpod&#39;s default workspace image also comes with the PECL package manager pre-installed. To install packages with it, you must use sudo pecl install &lt;EXTENSION&gt; in your repository&#39;s .gitpod.Dockerfile, e.g. like so:\n\n```dockerfile\nFROM gitpod/workspace-full\n\nRUN sudo pecl channel-update pecl.php.net && \\\n    sudo pecl install <EXTENSION>\n```\n\nwhere &lt;EXTENSION&gt; is the PHP extension you want to install, e.g. xdebug.\n\n__SPLIT_HERE__\nSetting GitHub token to Composer\n\nSome composer plugins like symfony/flex does direct API call against GitHub to fetch additional information. These unauthenticated requests will be rate-limited and may fail your task steps. To fix this behavior we can use the default credential-helper to obtain a GitHub Token and configure composer properly\n\n```bash\ncomposer config --global github-oauth.github.com $(printf '%s\\n' host=github.com | gp credential-helper get | sort | head -2 | tail -1 | sed 's;password=;;')\n```\n\n__SPLIT_HERE__\nFurther Reading\n\nGitpodifying a new Laravel Application by Etin Obaseki","metadata":{"source":"https://gitpod.io/docs/introduction/languages/php"}}],["539",{"pageContent":"__SPLIT_HERE__\nPython in Gitpod\n\nGitpod comes with great support for Python built-in. Still, depending on your project, you might want to further optimize the experience.\n\n__SPLIT_HERE__\nPython Project Examples\n\nBefore we get started, here are some examples of already-gitpodified repositories!\n\nRepository Description Try it\npython-flask-api-tutorial A step by step Todo List API tutorial with Flask + Python Open in Gitpod\ndjango-locallibrary-tutorial An example website written in Django by MDN Open in Gitpod\nGitpod-PyQt A PyQt example for Gitpod Open in Gitpod\nwxPython-example A wxPython example for Gitpod Open in Gitpod\ntemplate-python-django A Django example for Gitpod Open in Gitpod\ntemplate-python-flask A Flask example for Gitpod Open in Gitpod\n\n__SPLIT_HERE__\nPandas\n\nWelcome data scientists! This part of the guide will show you how to configure Gitpod for Pandas development.\n\nTry Pandas in Gitpod\n\nTo see a minimal project with Pandas installed and configured, please check out gitpod-io/Gitpod-Pandas:\n\nOpen in Gitpod\n\nUse Gitpod for Pandas development\n\nPandas Team has their official docs on how to use Gitpod for Pandas development. Please check out Pandas Team&#39;s Gitpod guide.\n\n__SPLIT_HERE__\nPython Versions\n\nRun pyenv versions to see which Python versions are pre-installed in Gitpod.\n\nThe easiest way to install a new Python version is to use pyenv install &lt;VERSION&gt;. For example, suppose you wanted to install Python 3.6.4, you would run pyenv install 3.6.4.\n\nYou can switch between Python versions using pyenv local &lt;VERSION&gt;. For example, if you wanted to switch to Python version 2.7.17 you would run pyenv local 2.7.17. This will create a .python-version file that controls which Python version is the default in your project.\n\nIf you want to setup a custom dockerfile so that you don&#39;t have to repeat the process, here&#39;s how your .gitpod.Dockerfile could look like:\n\n```dockerfile\n# You could use `gitpod/workspace-full` as well.\nFROM gitpod/workspace-python\n\nRUN pyenv install 3.11 \\\n    && pyenv global 3.11\n```\n\n__SPLIT_HERE__\nStart tasks\n\nYou can start building your project when, or even before you start your Gitpod workspace. Are you using a requirements.txt file to manage dependencies? If so, add this to your .gitpod.yml to automatically pre-install all dependencies when starting a workspace:\n\n```yaml\ntasks:\n  - init: pip3 install -r requirements.txt\n    command: python3 main.py\n```\n\n__SPLIT_HERE__\nLinting\n\nYou can create a setup.cfg or a pycodestyle.cfg in the project root and adjust pycodestyle rules there like this:\n\n```toml\n[pycodestyle]\nignore = E226,E302,E41\nmax-line-length = 160\nstatistics = True\n```\n\nYou&#39;ll need to refresh the browser in order to update these rule. Source.\n\n__SPLIT_HERE__\nVSCode Extensions\n\nWhile the most popular Python VSCode extensions are built into Gitpod, here are a few &quot;nice to have&quot; extensions that you can use as well.\n\nARepl for Python\n\nARepl for Python is helpful for constantly checking your code and debugging.\nTo install this extension for your repository, add the following to your .gitpod.yml:\n\n```yaml\nvscode:\n  extensions:\n    - almenon.arepl\n```\n\nPython Test Explorer\n\nPython test explorer example\nEasily test your python extensions with the Python Test Explorer.\nTo add this to your repository add the following to your .gitpod.yml\n\n```yaml\nvscode:\n  extensions:\n    - littlefoxteam.vscode-python-test-adapter@0.3.16:tZ/6xOSSdKUaq6JCUVkD+A==\n```","metadata":{"source":"https://gitpod.io/docs/introduction/languages/python"}}],["540",{"pageContent":"GUI Applications with wxPython\n\nTo install wxPython to your repository please add the following to your .gitpod.Dockerfile. If you don&#39;t have one, simply run gp init and commit the two generated files.\n\n```dockerfile\n# This will pull the official Gitpod `vnc` image\n# which has much of what you need to start\nFROM gitpod/workspace-full-vnc\n\nUSER gitpod\n\n# Install wxPython dependencies\nRUN sudo apt-get -q update && \\\n    sudo DEBIAN_FRONTEND=noninteractive apt-get install -yq freeglut3-dev python3.7-dev libpython3.7-dev libgl1-mesa-dev libglu1-mesa-dev libgstreamer-plugins-base1.0-dev libgtk-3-dev libnotify-dev libsdl2-dev libwebkit2gtk-4.0-dev libxtst-dev libgtk2.0-dev && \\\n    sudo rm -rf /var/lib/apt/lists/*\n\n# Install wxPython\nRUN pip3 install -U -f https://extras.wxpython.org/wxPython4/extras/linux/gtk3/ubuntu-18.04/ wxPython\n```\n\nHere is a corresponding .gitpod.yml example:\n\n```yaml\nimage:\n  file: .gitpod.Dockerfile\n\n# This will expose all necessary ports needed for your VNC image\nports:\n  - port: 6080\n    onOpen: open-preview\n  - port: 5900\n    onOpen: ignore\n  - port: 35900\n    onOpen: ignore\n\n# This will make it so that on workspace start it will run a file called `app.py`\ntasks:\n  - command: python3 app.py\n```\n\nName Framework Try it\nTic-Tac-Toe-GUI Kivy Open in Gitpod\nPong Kivy Open in Gitpod\nGitpod-PyQt PyQt Open in Gitpod\n\n__SPLIT_HERE__\nDebugging\n\nHere is a quick clip on how to automatically configure debugging for Python!\n\nSo, basically in this video we:\n\nFirst, open the Python file that we want to debug\nThen, go to the debug menu and select &quot;Add Configuration...&quot;\nNext, in the dropdown choose &quot;Python&quot;\nNext, choose &quot;Python File&quot; as the debug configuration\nFinally, start debugging your Python program!\n\nYou can also create the Python debug configuration file manually\n\nTo start debugging your Python application in Gitpod, please create a new directory called .theia/, and inside add a file called launch.json, finally, add the following to it:\n\n```json\n{\n  \"version\": \"0.2.0\",\n  \"configurations\": [\n    {\n      \"name\": \"Python: Current File\",\n      \"type\": \"python\",\n      \"request\": \"launch\",\n      \"program\": \"${file}\",\n      \"console\": \"internalConsole\"\n    }\n  ]\n}\n```\n\nThen, simply open the Python file you want to debug, open the Debug panel (in the left vertical toolbar, click the icon with the crossed-out-spider), and click the green &quot;Run&quot; button.\n\nTo see a basic repository with Python debugging enabled, please check out gitpod-io/Gitpod-Python-Debug:\n\nOpen in Gitpod\n\n__SPLIT_HERE__\nFurther Reading\n\nVSCode documentation for Python debugging All the information there should also apply to Gitpod as well.\nTroubleshooting Matplotlib/TK Here is how to troubleshoot Matplotlib/TK issues for Python GUI applications.\nDebugging Django This is how to debug Django applications in Gitpod.","metadata":{"source":"https://gitpod.io/docs/introduction/languages/python"}}],["541",{"pageContent":"__SPLIT_HERE__\nR in Gitpod\n\nTo work with R in Gitpod, you will need to properly configure your repository. Here is how to do it.\n\n__SPLIT_HERE__\nInstalling R\n\nFirst, you&#39;ll probably want to install R itself. To do this, add a new file to your repository called .gitpod.Dockerfile, and add the following content to it:\n\n```dockerfile\nFROM gitpod/workspace-full\n\nRUN brew install R\n```\n\nNext, create a Gitpod configuration file called .gitpod.yml (you can also simply run gp init and Gitpod will generate the file), and reference the above Dockerfile in it like so:\n\n```yml\nimage:\n  file: .gitpod.Dockerfile\n```\n\nThen commit and push both files to your repository. After that, every new Gitpod workspace created for your project will have R pre-installed.\n\n__SPLIT_HERE__\nVSCode Extensions\n\nR Extension\n\nR extension\nTo install the R extension to your repository, add the following to your .gitpod.yml file:\n\n```yaml\nvscode:\n  extensions:\n    - Ikuyadeu.r@1.2.1:z5vr1v1bfS++U/aHLSXQ6Q==\n```\n\nHere is a minimal example of R running in Gitpod. You can try it here:\n\nOpen in Gitpod","metadata":{"source":"https://gitpod.io/docs/introduction/languages/r"}}],["542",{"pageContent":"__SPLIT_HERE__\nRuby in Gitpod\n\nIt&#39;s relatively easy to set up your Ruby project in Gitpod.\n\n__SPLIT_HERE__\nRuby Versions\n\nAs of this writing, Gitpod comes with Ruby 3.1 pre-installed in the gitpod/workspace-full.\n\nTo use a different Ruby version, you can change the base image to one of the following:\n\ngitpod/workspace-ruby-2\ngitpod/workspace-ruby-3.0\n\nThese images are automatically updated every week with the latest ruby patch versions.\n\nTo use a fixed version, you may use a custom Dockerfile.\n\n```dockerfile\nFROM gitpod/workspace-full\nUSER gitpod\n\n# Install Ruby version 2.7.6 and set it as default\nRUN _ruby_version=ruby-2.7.6 \\\n    && printf \"rvm_gems_path=/home/gitpod/.rvm\\n\" > ~/.rvmrc \\\n    && bash -lc \"rvm reinstall ${_ruby_version} && \\\n                 rvm use ${_ruby_version} --default\" \\\n    && printf \"rvm_gems_path=/workspace/.rvm\" > ~/.rvmrc \\\n    && printf \"{ rvm use \\$(rvm current); } >/dev/null 2>&1\\n\" >> \"$HOME/.bashrc.d/70-ruby\"\n```\n\nüí° Explanation: Gitpod initially sets up RVM in /home/gitpod/.rvm, but then later switches the RVM configuration directory to /workspace/.rvm, so that any user-made changes (like installing new gems) are persisted within a Gitpod workspace. However, during the Dockerfile build, the /workspace directory doesn&#39;t exist yet, so we temporarily reset RVM&#39;s configuration directory to /home/gitpod/.rvm.\n\n__SPLIT_HERE__\nExample Repositories\n\nHere are a few Ruby example projects that are already automated with Gitpod:\n\nRepository Description Try it\nRuby on Rails template Ruby on Rails template with a PostgreSQL database Open in Gitpod\nForem The platform that powers dev.to Open in Gitpod\nGitLab The open source end-to-end software development platform Open in Gitpod\n\n__SPLIT_HERE__\nVSCode Extensions\n\nHere are a few useful extensions that you&#39;ll likely want to install in your Ruby project.\n\nRuby Test Explorer\n\nWith the Ruby test explorer, you can run unit tests from within the Gitpod UI.\nRuby test explorer example\nTo add this extension to your repository, simply add these lines to your .gitpod.yml configuration file:\n\n```YAML\nvscode:\n  extensions:\n    - connorshea.vscode-ruby-test-adapter@0.9.0\n    - hbenl.vscode-test-explorer@2.21.1\n```\n\n__SPLIT_HERE__\nRuby On Rails\n\nSo, you want to write your cool new Ruby On Rails application in Gitpod? Well, here is an idea of how to do it. Please take a look at our minimal Rails example running in Gitpod:\n\nOpen in Gitpod","metadata":{"source":"https://gitpod.io/docs/introduction/languages/ruby"}}],["543",{"pageContent":"__SPLIT_HERE__\nRust in Gitpod\n\nWelcome, Rustacean!\n\nRust is a first-class language in Gitpod, and we believe that Gitpod is a great tool for Rust projects. Some of Gitpod&#39;s core developers frequently work with Rust code (in Gitpod), and several key components of Gitpod are written in Rust:\n\nThe fantastic language support is provided by the rls\nThe blazing-fast workspace search is powered by ripgrep\n\n__SPLIT_HERE__\nRust Version\n\nGitpod always comes with the latest available Rust toolchain pre-installed using rustup. (As of this writing, the Rust version is 1.66.0.\n\nYou can also use rustup yourself in Gitpod in order to switch to a different Rust version, or to install extra components. See the rustup book to learn more about rustup itself.\n\nNote: If you try to use rustup in your repository&#39;s .gitpod.Dockerfile, you might get the following error:\n\n```\n/bin/sh: rustup command not found\n```\n\nTo fix this, simply wrap the rustup command in a login Bash shell, like so:\n\n```dockerfile\nRUN bash -cl \"rustup toolchain install nightly\"\n```\n\nYou can override this default by committing a rustup-toolchain file in the root of your repository. Say for example you need the nightly compiler for March 4th, 2020, you would create a rustup-toolchain file and add the following\n\n```text\nnightly-2020-03-04\n```\n\nwhich will set the required Rust version and if you commit the file into source control it will set the default nightly version across all workspaces.\n\n__SPLIT_HERE__\nExample Repositories\n\nHere are a few Rust example projects that are already automated with Gitpod:\n\nRepository Description Try it\nNushell A next-gen shell for the GitHub era Open in Gitpod\nMathLang Basic maths language in Rust Open in Gitpod\nServo The Servo Browser Engine Open in Gitpod\n\n__SPLIT_HERE__\nVSCode Extensions\n\nThe most popular Rust VSCode extensions are already pre-installed in Gitpod. But here are a few &quot;nice to have&quot; extensions you may choose to install as well.\n\nIn order to install one of these extensions for your repository, simply head to Gitpod&#39;s Extensions panel (find it in the IDE&#39;s left vertical menu), then search for the desired extension by name, and install it for your project. This will add an entry to your .gitpod.yml file that ensures all future Gitpod workspaces for your repository will already have this extension pre-installed.\n\nRust Test Explorer\n\nRust test explorer example\n\n\nThe Rust Test Explorer makes it easy to run Rust tests.\n\nCrates\n\nNote: This extension outputs emojis by default if the crate version is set at the latest. You can disable this by using crates.upToDateDecorator option in your preferences &gt; \n\nThe VSCode extension Crates makes it easier to manage your Cargo dependency versions.\n\nSearch Crates.io\n\nDo you have an idea of a library you want to use but don&#39;t know the version well just type in the name of the library and Search Crates.io will get the version.\n\nBetter TOML\n\nTOML Syntax highlighting example\n\nBetter TOML adds syntax highlighting to your Cargo.toml.\n\n__SPLIT_HERE__\nCross-compiling with MUSL\n\nTo cross-compile with MUSL in Gitpod, you can:\n\nRun rustup target add x86_64-unknown-linux-musl, for example in your .gitpod.Dockerfile\nThen, build with cargo build --target x86_64-unknown-linux-musl\n\nTo learn more, see MUSL support for fully static binaries.","metadata":{"source":"https://gitpod.io/docs/introduction/languages/rust"}}],["544",{"pageContent":"Debugging\n\nIn this section we will show you how to configure your project for debugging in Gitpod.\n\nFirst, before we get to that we need to get some prerequisites set-up.\n\nFirst we&#39;ll install the needed extension. If you haven&#39;t already, head over to Gitpod&#39;s Extensions panel (left vertical menu in the IDE) and search for an extension called Native Debug by webfreak. When you see it, click to install it for your project.\n\nThe next prerequisite is a Docker configuration.\n\nIf you already have a .gitpod.Dockerfile just add the following:\n\n```dockerfile\nRUN sudo apt-get -q update \\\n    && sudo apt-get install -yq \\\n        libpython3.6 \\\n        rust-lldb \\\n    && sudo rm -rf /var/lib/apt/lists/*\n\nENV RUST_LLDB=/usr/bin/lldb-8\n```\n\nIf not there are two steps. First, create a file called .gitpod.Dockerfile with the following content:\n\n```dockerfile\nFROM gitpod/workspace-full\n\nUSER gitpod\n\nRUN sudo apt-get -q update \\\n    && sudo apt-get install -yq \\\n        libpython3.6 \\\n        rust-lldb \\\n    && sudo rm -rf /var/lib/apt/lists/*\n\nENV RUST_LLDB=/usr/bin/lldb-8\n```\n\nNext, add the following to your .gitpod.yml file:\n\n```yaml\nimage:\n  file: .gitpod.Dockerfile\n```\n\nNow that&#39;s out of the way, here is a video on how to configure the debug configuration\n\nSo, basically in this video we:\n\nGo to the debug menu and select &quot;Add Configuration...&quot;\nNext, in the dropdown choose &quot;GDB: Launch Program&quot;\nGo to the Cargo.toml file and find the name of the program.\nModify the target field and change it to ${workspaceFolder}/target/debug/&lt;PROGRAM_NAME&gt; where &lt;PROGRAM_NAME&gt; is the name of the program under the name field in the Cargo.toml file.\nAdd another property to the created file called preLaunchTask and set it to &quot;cargo&quot;\nGo to the terminal menu and click configure tasks\nSelect cargo build from the menu that pops up\nchange the tag type to command\nchange the tag subcommand to args and the value to [&quot;build&quot;]\nNext remove the problemMatcher field.\nAdd a field called type and set it to process\nAdd a field called label and set it to cargo\nGo to the Rust file you want to debug\nAdd a breakpoint or two\nGo back to the debug menu that has the crossed out spider\nClick the green run button.\nFinally, start debugging your Rust program!\n\nYou can also create the Rust debug configuration file manually\n\nTo start debugging your Rust application in Gitpod, please create a new directory called .theia/, and inside add a file called launch.json, add the following to it:\n\n```json\n{\n  // Use IntelliSense to learn about possible attributes.\n  // Hover to view descriptions of existing attributes.\n  \"version\": \"0.2.0\",\n  \"configurations\": [\n    {\n      \"type\": \"gdb\",\n      \"request\": \"launch\",\n      \"name\": \"Debug Rust Code\",\n      \"preLaunchTask\": \"cargo\",\n      \"target\": \"${workspaceFolder}/target/debug/rust_debug\",\n      \"cwd\": \"${workspaceFolder}\",\n      \"valuesFormatting\": \"parseText\"\n    }\n  ]\n}\n```\n\nNext create another file in the same .theia/ directory called tasks.json with the following content:\n\n```json\n{\n  \"tasks\": [\n    {\n      \"command\": \"cargo\",\n      \"args\": [\"build\"],\n      \"type\": \"process\",\n      \"label\": \"cargo\"\n    }\n  ]\n}\n```\n\nThen, simply open the Rust file you want to debug, add some breakpoints, and open the Debug panel (in the left vertical toolbar, click the icon with the crossed-out-spider), and click the green &quot;Run&quot; button.\n\nTo see a basic repository with Rust debugging configured, please check out gitpod-io/Gitpod-Rust-Debug:\n\nOpen in Gitpod\n\n__SPLIT_HERE__\nFurther Reading\n\nRocket-Example For an example of how to setup a project for the Rocket web-development framework","metadata":{"source":"https://gitpod.io/docs/introduction/languages/rust"}}],["545",{"pageContent":"__SPLIT_HERE__\nSvelte in Gitpod\n\nTo work with Svelte in Gitpod, you will need to properly configure your repository. Here is how to do that, assuming that you&#39;re using the official sveltejs template which uses Rollup:\n\n__SPLIT_HERE__\nCreate a .gitpod.yml\n\nStart by creating a .gitpod.yml file in the root of your project and add the following to it:\n\n```yml\ntasks:\n  - init: npm install\n    command: npm run dev\n\nports:\n  - port: 5000\n    onOpen: open-preview\n  - port: 35729\n    onOpen: ignore\n```\n\nAfter committing and pushing this file to your repository, start a new Gitpod workspace. You&#39;ll see that Gitpod will automatically install the dependencies; start the dev server; and open a preview on the side for port 5000.\n\nSveltejs Template in Gitpod\n\n__SPLIT_HERE__\nMaking Live Reload work\n\nIn order to make live reload work we need to add a bit of configuration as specified below:\n\nSetup an environment variable called CLIENT_URL in the .gitpod.yml config file as shown below please make sure that you set it up before the task which starts the dev server(which is npm run dev in this case):\n\n```bash\n- init: npm install\n    command: |\n      export CLIENT_URL=\"$(gp url 35729)/livereload.js?snipver=1&port=443\"\n      npm run dev\n```\n\n\nPass the value of CLIENT_URL environment variable to the rollup-plugin-livereload in rollup-config.js inside of the plugins array as shown:\n\n```js\nplugins: [\n  !production &&\n    livereload({\n      watch: \"public\",\n      clientUrl: process.env.CLIENT_URL,\n    }),\n];\n```\n\nThis will set CLIENT_URL to the workspace url of port 35729 (default port for livereload in Gitpod).\n\n__SPLIT_HERE__\nExample Projects\n\nRepository Description Try it\nSvelteJS template A project template for Svelte apps Open in Gitpod\n\n__SPLIT_HERE__\nVSCode Extensions\n\nSvelte for VS Code\n\nSvelte for VS Code Provides syntax highlighting and rich IntelliSense for Svelte components in VS Code, utilising the svelte language server.\n\nTo add this extension to your repository, simply head to Gitpod‚Äôs Extensions panel (find it in the IDE‚Äôs left vertical menu), then search for the desired extension by name, and install it for your project. This will add an entry to your .gitpod.yml file that ensures all future Gitpod workspaces for your repository will already have this extension pre-installed.\n\nhttps://github.com/gitpod-io/sveltejs-template repo is a working example of the config described above üëÜ.","metadata":{"source":"https://gitpod.io/docs/introduction/languages/svelte"}}],["546",{"pageContent":"__SPLIT_HERE__\nVue.js in Gitpod\n\nTo work with Vue.js in Gitpod, you will need to properly configure your repository. Here is how to do it.\n\n__SPLIT_HERE__\nExample Repositories\n\nHere are a few Vue.js example projects that are already automated with Gitpod:\n\nRepository Description Try it\nvuepress Minimalistic Vue-powered static site generator Open in Gitpod\npostwoman A free, fast and beautiful API request builder (web alternative to Postman) Open in Gitpod\nnuxtjs.org Nuxt.js Documentation Website (Universal Vue.js Application built with Nuxt.js) Open in Gitpod\n\n__SPLIT_HERE__\nVue-CLI\n\nTo install the Vue.js command-line interface in your current workspace run the following\n\n```bash\nnpm i -g vue-cli\n```\n\nTo install globally across all workspaces add the following to your .gitpod.Dockerfile\n\n```dockerfile\nRUN npm i -g vue-cli\n```\n\nPlease note: If you don&#39;t already have one please run gp init which should generate two files .gitpod.yml and .gitpod.Dockerfile\n\n__SPLIT_HERE__\nVSCode Extensions\n\nVetur\n\nVetur extension\n\nVetur provides syntax highlighting, snippets, Emmet support, linting/error checking, auto-formatting, and auto-complete for Vue files.\n\nTo add this extension to your repository add the following to your .gitpod.yml\n\n```yaml\nvscode:\n  extensions:\n    - octref.vetur@0.23.0:TEzauMObB6f3i2JqlvrOpA==\n```\n\nFor projects that already have a .gitpod.yml, you can skip the first part and just add the provided snippet.","metadata":{"source":"https://gitpod.io/docs/introduction/languages/vue"}}],["547",{"pageContent":"__SPLIT_HERE__\nScala in Gitpod\n\nWelcome, Scala programmer. Today we will show you how to configure Gitpod for your project.\n\n__SPLIT_HERE__\nInstalling Scala\n\nFirst, you&#39;ll probably want to install Scala. To do this, add a new file to your repository called .gitpod.Dockerfile, and add the following content to it:\n\n```dockerfile\nFROM gitpod/workspace-full\n\nRUN brew install scala\n```\n\nAdditionally create a file called .gitpod.yml and add the following:\n\n```YAML\nimage:\n  file: .gitpod.Dockerfile\n```\n\nNow commit both files into source control.\n\nWhat are these files for?\n\nLet&#39;s break this down. First, in .gitpod.Dockerfile, we declare FROM gitpod/workspace-full to have your project use Gitpod&#39;s default workspace image (recommended). You can use other images too, but some Gitpod features might not work as well with untested images.\n\nNext, we declare RUN brew install scala. This simply installs Scala into the workspace image via HomeBrew.\n\nThen, we register our custom Dockerfile in Gitpod&#39;s configuration file .gitpod.yml, so that Gitpod knows it should pick it up and build it on-the-fly when booting up new workspaces.\n\nFinally, please note that these changes will only take effect in new workspaces. To try out your new automated dev setup, simply commit both files; push them to GitHub; and then open a new Gitpod workspace for your repository. üöÄ\n\n__SPLIT_HERE__\nUsing the Ammonite REPL\n\nThe Ammonite REPL in action\n\nTo install the Ammonite REPL in Gitpod, you must add the following to our previously-created .gitpod.Dockerfile:\n\n```dockerfile\nRUN sudo sh -c '(echo \"#!/usr/bin/env sh\" && curl -L https://github.com/lihaoyi/Ammonite/releases/download/2.0.4/2.13-2.0.4) > /usr/local/bin/amm && chmod +x /usr/local/bin/amm'\n```\n\nThen commit the changes and push to your repository. Finally, when you open a new workspace, you will be able to type amm in the terminal, and behold a super cool Scala REPL in your workspace!\n\n__SPLIT_HERE__\nBuilding projects with sbt\n\nTo use sbt (simple build tool) in Gitpod, you can add the following to that .gitpod.Dockerfile we created:\n\n```dockerfile\nRUN brew install sbt\n```\n\nAs usual, commit and push the changes, and sbt will be installed in all future workspaces.\n\n__SPLIT_HERE__\nManaging Scala versions with scalaenv\n\nSay your project needs a specific Scala version. You can use scalaenv, a version manager for Scala, to switch between different Scala versions. But first, we must install scalaenv. As usual, we need to change our .gitpod.Dockerfile, by adding this to it:\n\n```dockerfile\nRUN brew install scalaenv\n```\n\nThen, say you need Scala version 2.12.11, you would add the following line as well:\n\n```dockerfile\nRUN scalaenv install scala-2.12.11 && scalaenv global scala-2.12.11\n```\n\n__SPLIT_HERE__\nUsing coursier, an artifact fetcher for Scala\n\ncoursier is useful for building certain Scala projects and installing different tools.\n\n```dockerfile\nRUN brew install coursier/formulas/coursier\n```\n\n(Don&#39;t forget to commit and push this change!)\n\n__SPLIT_HERE__\nFormatting Scala code with scalafmt\n\nTo install scalafmt for your repository, add the following to your .gitpod.Dockerfile:\n\n```dockerfile\nRUN sudo env \"PATH=$PATH\" coursier bootstrap org.scalameta:scalafmt-cli_2.12:2.4.2 \\\n  -r sonatype:snapshots \\\n  -o /usr/local/bin/scalafmt --standalone --main org.scalafmt.cli.Cli\n```\n\nThen to format your code simply run scalafmt!","metadata":{"source":"https://gitpod.io/docs/introduction/languages/scala"}}],["548",{"pageContent":"Putting it all together\n\nA full example of a .gitpod.Dockerfile configured for Scala could look something like:\n\n```dockerfile\nFROM gitpod/workspace-full\n\nRUN sudo sh -c '(echo \"#!/usr/bin/env sh\" && curl -L https://github.com/lihaoyi/Ammonite/releases/download/2.0.4/2.13-2.0.4) > /usr/local/bin/amm && chmod +x /usr/local/bin/amm'\n\nRUN brew install scala coursier/formulas/coursier sbt scalaenv\n\nRUN sudo env \"PATH=$PATH\" coursier bootstrap org.scalameta:scalafmt-cli_2.12:2.4.2 \\\n  -r sonatype:snapshots \\\n  -o /usr/local/bin/scalafmt --standalone --main org.scalafmt.cli.Cli\n\nRUN scalaenv install scala-2.12.11 && scalaenv global scala-2.12.11\n```\n\nYou will notice that all the brew install commands are on the same line. We recommend grouping similar commands together to minimize the number of Docker layers.\n\nAdditionally, your .gitpod.yml file should still look like this:\n\n```YAML\nimage:\n  file: .gitpod.Dockerfile\n```\n\n__SPLIT_HERE__\nVSCode Extensions\n\nScala Syntax (official)\n\nScala Syntax demo\n\nScala Syntax adds basic syntax highlighting for Scala and sbt files.\n\nTo get it, open Gitpod&#39;s Extensions panel (left vertical menu in the IDE), then search for &quot;Scala Syntax&quot;, and install it &quot;for this project&quot;. Then, commit the automatic .gitpod.yml change that was made by Gitpod.\n\nMetals\n\nAn example of the metals in Gitpod\n\nMetals adds helpful Scala features to Gitpod, for example, advanced autocompletion and debugging support just to name a few. Although to use it you must also have the previously mentioned Scala Syntax.\n\nTo get it, open Gitpod&#39;s Extensions panel (left vertical menu in the IDE), then search for &quot;Scala Metals&quot;, and install it &quot;for this project&quot;. Then, commit the automatic .gitpod.yml change that was made by Gitpod.\n\nBoom! You&#39;re done! (Just a reminder, don&#39;t forget to push the changes.)\n\n__SPLIT_HERE__\nDebugging Scala code\n\nTo debug Scala code in Gitpod you should use the Metals extension which we just went over. Here is an example of Scala Debugging in action:\n\nIn general when debugging Scala code, go to the main method, and click the Debug button over it! And boom you&#39;re debugging.\n\n__SPLIT_HERE__\nTry it!\n\nTo see a minimal repository with a Gitpod configuration that installs all the tools we&#39;ve covered, see gitpod-io/Gitpod-Scala. You can try it in your browser:\n\nOpen in Gitpod\n\n__SPLIT_HERE__\nNeed help?\n\nIf you are having trouble and need help please find us in the Gitpod community, or, file an issue on GitHub.\n\n__SPLIT_HERE__\nFeedback\n\nWe love feedback and want to continuously improve all of our guides and documentation. If you found a grammar mistake, or we left out your favorite Scala tool, or you just have general feedback on the guide, please feel free to edit this guide or to file a website issue on GitHub.","metadata":{"source":"https://gitpod.io/docs/introduction/languages/scala"}}],["549",{"pageContent":"__SPLIT_HERE__\nJune 2019\n\nAfter the public launch of Gitpod.io in April, we have spent most of our time on changing our internal architecture to better scale and improve the cloud density as well\nas supporting VS Code extension. Although this work is not yet finished, we have added a bunch of new features on the way, which are listed below.\n\n__SPLIT_HERE__\nToggle Maximize\n\nSimple but useful: Double-clicking a tab will maximize the corresponding panel.\n\n__SPLIT_HERE__\nLinks in terminals\n\nYou can now follow links and open files from the terminal by clicking on the respective links.\n\nTerminal Links\n\n__SPLIT_HERE__\nEnvironment Variables\n\nGitpod allows users to inject environment variables into workspaces. Based on a simple pattern against the repository name\none can filter which env vars are actually injected. Also please note that all environment variable values are encrypted before stored in the database.\n\nIn addition to user-based environment variables, you can pass environment variables through the context link on start.\nSee the docs for more information.\n\n__SPLIT_HERE__\nBi-directional Scroll Sync\n\nWhen editing Markdown files it is very convenient to see the preview next to the editor. You can open a preview by click the icon on the top right of the editor.\nNow you can scroll both the editor or the preview and see how the other part is scrolling with it, showing the corresponding sections.\n\nContributed through PR #5442.\n\n__SPLIT_HERE__\nBetter Rust support\n\nIn addition to the Go VS Code extension, Gitpod now also runs the official Rust VS Code extensions.\nSo expect faster and more reliable support for Rust.\n\n__SPLIT_HERE__\nEmmet support\n\nGitpod comes with support for emmet, a web-developer‚Äôs toolkit that can greatly improve your HTML &amp; CSS workflow.\nAmong other things it allows to quickly generate html boilerplate using shortcuts.\n\nEmmet\nSee the cheat-sheet for a quick overview of what&#39;s supported.\n\n__SPLIT_HERE__\nDebugging in Java\n\nThe debugging of Java applications had a problem in that it the process would pick a wrong java executable when launching processes.\nThis is now fixed.\n\n__SPLIT_HERE__\nBetter Upload\n\nYou can now upload large files through drag and drop and see proper progress information on the top of the window.\n\n__SPLIT_HERE__\nImproved C++ Language Support\n\nWe have upgrade the language services to use the latest clangd version.\n\n__SPLIT_HERE__\nBetter Git Amend\n\nThe git amend UI has been improved so that you can amend / squash multiple commits but also\nundo that.\n\nAlso the entire SCM widget has been rewritten to match VS Code&#39;s UX.\n\n__SPLIT_HERE__\nConfig: Port ranges\n\nIn your .gitpod.yml one can now specify port ranges, so you can manage antire ranges addition\nand tell Gitpod what to do when a service opens on one of those ports.\n\n__SPLIT_HERE__\nCLI: gp await-port\n\nThe cli learned a new thing, that let&#39;s you wait for a certain port to open.\nThis is useful if you want to wait for a certain path and then take a specific action.\n\nHere&#39;s an example that will open a certain path in the preview once a service is a available port 3000:\n\n```sh\ngp await-port 3000 && gp preview $(gp url 3000)my/path/index.html\n```\n\n__SPLIT_HERE__\nMany Small Improvements\n\nBesides these bigger features, we have fixed many bugs and improved the performance and user experience of Gitpod.\nWe have merged 146 PRs in Gitpod and 220 in Theia.\n\n__SPLIT_HERE__\nWhat&#39;s next?\n\nWith this release we have added some additional VS Code extensions.\nThe upcoming release will allow you to install arbitrary VS Code extensions and add that as configuration to your .gitpod.yml files.\nThe GitLab integration as well as a easy-to-install, Self-Hosted version of Gitpod is in the works.\nFinally, we are looking into optimizing start-up time improvements and, of course, bug-fixing and offering you a great development experience.","metadata":{"source":"https://gitpod.io/docs/release-notes/2019-06-17/june-2019"}}],["550",{"pageContent":"__SPLIT_HERE__\nApril 2019\n\nToday we are happy to announce that we are moving out of beta.\nWe want to thank all the beta testers who have provided great feedback. Gitpod wouldn&#39;t be what it is without you! ‚ù§Ô∏è\n\nYou can read more about the announcement in the blog post.\n\nBesides a complete relaunch of the website and app, we have added some very exciting new features:\n\n__SPLIT_HERE__\nGitHub App / Prebuilt Workspaces üöÄ\n\nWe have been busy developing a new GitHub app, that once installed on your repository will prebuild your project on every push.\nOn GitHub pull requests this is communicated through a status check.\n\nPrebuilt Check on PR\n\nAs a result, Gitpod is now the first IDE that builds your project, before you open it.\n\nRead more about this exciting feature in the docs and in Chris&#39; blog post.\n\n__SPLIT_HERE__\nBetter localhost Handling\n\nWhen starting web servers in Gitpod, often times you need to explicitly make sure the dev server allows connections from non-localhost.\nStarting today, you no longer need to worry about that. Gitpod now forwards the port locally and rewrites the host headers,\nso that dev servers will be fine.\n\n__SPLIT_HERE__\nBetter Go Support\n\nGitpod now directly uses Microsoft&#39;s great Go support for VS Code.\n\nVS Code Go Extension\n\n__SPLIT_HERE__\nUnlimited Hours\n\nIf you don&#39;t feel comfortable with a time-based limit, you can now purchase the &#39;Unlimited&#39; plan to use Gitpod as much as you like on public and private repositories.\n\nWe also offer unlimited plans for teams, and for students the price for an unlimited plan is only 9$ or 8‚Ç¨.\n\nIf you have created your account during the beta, i.e. before April 5th, you will be able to work on private repositories for free for another month, on us.\n\nYou can check out the various pricing options on the website.\n\n__SPLIT_HERE__\nNew Design üíÑ\n\nAs part of the launch, we have refreshed the design of Gitpod. The website and dashboard now use a new dark theme that we hope you&#39;ll like, and the UI of the\nIDE is more closely matching the look of VS Code.\n\nNew Dashboard\n\n__SPLIT_HERE__\nDelete Workspace\n\nYou can now delete workspaces in the dashboard. Please note that deletion can not be reversed as we are really\ndeleting all the contents of your workspace.\n\nYou can also delete your entire account (hopefully the least used feature).\n\n__SPLIT_HERE__\nMany Small Improvements\n\nBesides these bigger features, we have fixed many bugs and improved the performance and user experience of Gitpod.\nWe have merged 146 PRs in Gitpod and 206 in Theia.\n\n__SPLIT_HERE__\nWhat&#39;s next?\n\nWith this release we have already added some VS Code extensions. Going forward we will double down on the integration.\nWe are looking at one programming language after the other, making sure the experience is excellent and the VS Code extensions\nwork as expected. Once we&#39;ve reached a state where we are confident VS Code extensions work reliably in general, we will allow users to install them.\nFurthermore, we are focusing on start-up time improvements and, of course, bug-fixing and offering you a great development experience.","metadata":{"source":"https://gitpod.io/docs/release-notes/2019-04-05/april-2019"}}],["551",{"pageContent":"__SPLIT_HERE__\nCLion\n\n{title} is currently in Beta ¬∑ Send feedback.\n\n__SPLIT_HERE__\nGetting started\n\nInstall JetBrains Gateway - With the JetBrains Gateway and Gitpod plugin you can create and manage your latest 20 Gitpod workspaces.\nInstall the Gitpod plugin - Open JetBrains Gateway and you&#39;ll see the Gitpod logo on the main page. Click &quot;install&quot; to install the Gitpod plugin for JetBrains Gateway.\nUpdate your Gitpod preferences - Select {title} on the Gitpod preferences page which will set {title} as your default IDE for future workspace starts.\nStart (or restart) your workspace - Either start a workspace directly from within the JetBrains Gateway via the Gitpod plugin OR open a new workspace directly in Gitpod where on workspace start you will be prompted to open {title} for that workspace.\n\nImportant: You must restart any started workspaces for your IDE preferences to take effect.","metadata":{"source":"https://gitpod.io/docs/references/ides-and-editors/clion"}}],["552",{"pageContent":"Install Plugins\n\nThis section relates to plugin management when using JetBrains IDEs in a remote development context. For information on regular plugin management, refer to {title} docs.\n\nUnlike with regular development, JetBrains Remote development with {title} allows users to install plugins in different locations:","metadata":{"source":"https://gitpod.io/docs/references/ides-and-editors/clion"}}],["553",{"pageContent":"{title} backend plugins - The JetBrains {title} backend runs within the remote Gitpod workspace. Backend plugins contribute functionality for IDE experiences relating to the filesystem, tools or languages and frameworks. When installed, a backend plugin only applies to the currently running Gitpod workspace and is not associated with a user. However, a plugin can be preconfigured for all users of a repository so that the plugin is enabled with every workspace start. It is not currently possible to install a backend plugin that applies to all workspaces of a Gitpod user or organization.","metadata":{"source":"https://gitpod.io/docs/references/ides-and-editors/clion"}}],["554",{"pageContent":"JetBrains Client plugins - The JetBrains client runs on the users local machine and can be thought of as the user interface to the remote {title} backend. Client plugins are different to backend plugins as they contribute to the user interface aspect of the IDE experience (e.g. keyboard shortcuts and themes). Once installed, a client plugin is enabled for all Gitpod workspaces the user opens (if the workspace is running the exact same version of the {title} backend where the plugin was initially installed).\nJetBrains Gateway plugins - The JetBrains Gateway is an application downloaded onto a users local machine which allows users to start JetBrains Clients that are compatible with the {title} backend, running in a Gitpod workspace. JetBrains Gateway plugins are installed directly in JetBrains Gateway and contribute to remote development connection experiences (e.g. the Gitpod JetBrains Gateway plugin).","metadata":{"source":"https://gitpod.io/docs/references/ides-and-editors/clion"}}],["555",{"pageContent":"Install on JetBrains Client\n\nThe JetBrains client runs on the users local machine and can be thought of as the user interface to the remote {title} backend. Client plugins contribute to the user interface aspect of the IDE experience (e.g. keyboard shortcuts and themes).\n\nOnce installed, a client plugin is enabled for all Gitpod workspaces the user opens (if the workspace is running the exact same version of the {title} backend where the plugin was initially installed).\n\nTo install a plugin on JetBrains Client follow these steps:\n\nIn JetBrains Client open the IDE settings and select Plugins.\nFind the plugin in the Marketplace and click Install.\n\nInstall on {title} backend\n\nThe JetBrains {title} backend runs within the remote Gitpod workspace. Backend plugins contribute functionality requiring access to IDE experiences such as the remote filesystem (e.g. contributing support of languages and frameworks).","metadata":{"source":"https://gitpod.io/docs/references/ides-and-editors/clion"}}],["556",{"pageContent":"When installed, a backend plugin only applies to the currently running Gitpod workspace and is not associated with a user. However, a plugin can be preconfigured for all users of a repository so that the plugin is enabled with every workspace start.\n\nIt is not currently possible to install a backend plugin that applies to all workspaces of a Gitpod user or organization.\n\nInstall for your current workspace\n\nYou can install a plugin only for your current workspace following these steps:\n\nIn JetBrains Client open the IDE settings and select Plugins On Host.\nFind the plugin in the Marketplace and click Install.\n\nPreconfigure for repository\n\nJetBrains plugin support is currently in Beta ¬∑ Send feedback.\n\nYou can share a plugin on {title} backend with everybody working on the repository by adding it to .gitpod.yml and pushing to your Git repository.\nEach workspace is preconfigured with plugins from the gitpod.yml configuration file. For example:","metadata":{"source":"https://gitpod.io/docs/references/ides-and-editors/clion"}}],["557",{"pageContent":"```yaml\njetbrains:\n  clion:\n    plugins:\n      - zielu.gittoolbox\n      - izhangzhihao.rainbow.brackets\n```\n\nYou can find the pluginId on the JetBrains Marketplace page:\n\nFind a page of the required plugin.\nSelect the Versions tab.\nClick any version to copy the pluginId (short name such as org.rust.lang) of the plugin you want to install.\n\nInstall for your user\n\nIt is not yet possible to install plugins on {title} backend for your user to share across all your Gitpod workspaces.","metadata":{"source":"https://gitpod.io/docs/references/ides-and-editors/clion"}}],["558",{"pageContent":"Configure JVM options\n\nConfiguration of JVM options is currently in Alpha ¬∑ Send feedback.\n\nYou can adjust JVM options for {title} backend, especially if you want to increase the -Xmx memory size. For example:\n\n```yaml\njetbrains:\n  clion:\n    vmoptions: \"-Xmx4g\"\n```\n\nFor more detailed information on JVM options, refer to Common JVM Options from JetBrains documentation.\n\n__SPLIT_HERE__\nConfigure IDE settings\n\nFeedback needed: The JetBrains Gitpod integration is currently beta. Gitpod continues to collaborate with JetBrains. The below shows how you can configure global settings with JetBrains. To leave feedback on the approach, please see this GitHub issue: #6576. Also note that JetBrains is working on comprehensive settings sync functionality.\n\nWhen running {title} locally, the JetBrains IDE applies global settings to all projects on your machine. However when running in a remote context using JetBrains Gateway, it&#39;s important to note that some IDE settings are configured on the JetBrains Client and others in the {title} backend running in your Gitpod Workspace. See below instructions for more.\n\nOn JetBrains Client\n\nIDE Settings that are configured on the JetBrains Client are stored on your local machine and don&#39;t have On Host label in the IDE settings. These IDE settings are reused if the workspace is running the exact same version of the {title} backend where the settings were initially configured.\n\nOn {title} backend\n\nSettings configured on {title} backend are stored in a Gitpod workspace and have On Host label in the IDE settings.\n\nConfigure IDE settings per project\n\nSome IDE settings cannot be configured via environment variables or through setting vm options. These settings can only be set via the UI of JetBrains client, and must be manually copied to be syned between workspaces. The below steps detail how to configure your IDE settings for all the users of a given Gitpod project:\n\nStep 1: Manually use JetBrains UI to configure settings - Set your IDE settings as you normally would, using the JetBrains UI.\n\nStep 2: Find generated IDE settings - You will need to manually find any global settings generated by JetBrains backend within the following path: /workspace/.config/JetBrains&lt;-latest&gt;/RemoteDev-/&lt;your-project-name&gt;/options\n\nStep 3: Move any relevant settings manually to a persistent location within your Gitpod project. Either via a Workspace Image, or persisted in the version control of your project, for example by committing settings data to GitHub.\n\nInclude relevant IDE settings in your Workspace Image\n\n/home/gitpod/.gitpod/jetbrains/options - This location applies settings to all JetBrains products (IntelliJ IDEA, GoLang, etc).\n/home/gitpod/.gitpod/jetbrains/clion/options - This location will apply settings only to the given IDE, e.g. {title}.\n\nCommit relevant IDE settings to source control\n\n/workspace/&lt;your-project-name&gt;/.gitpod/jetbrains/options - This location applies settings to all JetBrains products (IntelliJ IDEA, GoLang, etc).\n/workspace/&lt;your-project-name&gt;/.gitpod/jetbrains/clion/options - This location will apply settings only to the given IDE, e.g. {title}.\n\nFor any further changes to your IDE settings, you will need to follow the above steps again.\n\nNote: When locating and applying IDE settings, Gitpod will read the locations specified above in priority order. The locations specified first are overriden by the locations specified later.\n\nConfigure IDE settings per user\n\nTo configure IDE settings for your user only, and not all those using a project.\n\nFollow the instructions for configuring IDE settings per project, but instead use .dotfiles rather than a workspace image or source control to store your IDE settings.","metadata":{"source":"https://gitpod.io/docs/references/ides-and-editors/clion"}}],["559",{"pageContent":"Indexing using Prebuilds\n\nJetBrains Prebuilds is currently in Alpha ¬∑ Send feedback.\n\nWhen you open the project {title} starts indexing to load modules and\nenable the core functionality like code completion and navigation.\nDepending on the size of your project indexing speed can vary significantly.\n\nYou can speed up the indexing of a project by applying these general recommendations.\nGitpod prebuilds allow you to improve it further by indexing before you start a new workspace.\n\nTo leverage it:\n\nconfigure prebuilds for your repository, refer to Prebuilds;\nenable indexing for {title} in prebuilds by editing .gitpod.yml in your repository:\n\n```yaml\njetbrains:\n  clion:\n    prebuilds:\n      version: stable\n```\n\npush changes to your Git repository to apply.\n\nThe version property allows you to control whether to index for stable, latest, or both versions of {title} compatible with Gitpod.\nUsers can switch between stable and latest versions of {title} on the user preferences page.\n\n__SPLIT_HERE__\nWorkspace performance\n\nWhen using a Gitpod workspace you might experience performance issues caused by:\n\nAn application using more resources than expected\nResource consumption in adjacent containers running on the workspace node.\n\nIn your JetBrains IDE within the JetBrains Gateway Backend Control Center you can find two metrics relating to your running workspace: Workspace CPU and Workspace Memory.\n\nThe remaining metrics you can find in the Backend Control Center regarding the node that your workspace is running on, and not the workspace itself.\n\nNote: Performance information shown in the Backend Control Center is the same as the information that is shown when running the command gp top in your workspace, see the Command Line Interface documentation for more.\n\njetbrains performance\n\n__SPLIT_HERE__\nFAQs\n\nFor the questions about supported IDEs and Editors in Gitpod, refer to FAQs.\n\n\nFor the general questions about JetBrains Remote Development, refer to refer to the general IDE {title} FAQ.\n\nAre there any JetBrains optimizations I can make if my workspace is slow?\n\nDebugging performance can be challenging, as performance issues can depend on many factors such as how Gitpod is configured (if you&#39;re operating Gitpod on Self-Hosted). However, there are some ways you can gather performance information and optimise your JetBrains IDE setup with Gitpod:\n\nFirstly, to gather information on performance, you can view workspace performance metrics from within the IDE in the Backend Control Center, or by using gp top.\nYou may also want to try adjusting the Max Heap Size allocated to the JetBrains Backend in the Settings tab of the Backend Control Center. If updating this setting helps your performance, you can set the vmoptions value for your JetBrains IDE in your .gitpod.yml.\n\nNote: If the performance metrics show that your workspace is hitting its resource limits, and you are using Gitpod Self-Hosted, it might make sense to consider changing the resource configuration for your workspaces. This can be done via a config-patch. Configuring workspace resources is not yet available on SaaS.\n\n__SPLIT_HERE__\nTroubleshooting\n\nWhat should I do if JetBrains Gateway and Gitpod aren‚Äôt working?\nGitpod logs in JetBrains Client\nGitpod logs in JetBrains Gateway","metadata":{"source":"https://gitpod.io/docs/references/ides-and-editors/clion"}}],["560",{"pageContent":"__SPLIT_HERE__\nCommand Line (SSH)\n\nYou can directly access your workspace via SSH for editing code directly using a command-line editor, such as Vim &amp; Emacs or for connecting SSH supported applications such as a database client.\n\n__SPLIT_HERE__\nWorkspace SSH approaches\n\nThere are two ways to access a workspace via SSH using an SSH key or an Access Token.\n\nCopy SSH key from modal\nCopy SSH key from modal\n\nSSH Key (recommended) - By creating your own public/private SSH key pair, and uploading the public key to Gitpod you can directly SSH into a Gitpod workspace. Uploading a public key means that you do not need to keep re-visiting the Gitpod dashboard to retrieve an SSH command. It is also a more secure approach. See configure SSH for more.\n\n\nAccess Token - Alternatively, you can access a workspace using the copy/paste SSH command. This approach uses an access token which is reset on every workspace start. This approach is useful for quick SSH access, or when installing an SSH key locally is not possible, such as on some devices.\n\n__SPLIT_HERE__\nSSH key Access\n\nNote: You must upload a public key to Gitpod before you can access your workspace using an SSH key. See configure SSH for more.\n\nTo access a workspace using an SSH Key:\n\nVisit your workspace list in Gitpod\nView a running Gitpod workspace and click the more actions menu\nSelect &quot;connect via SSH&quot;\nCopy paste the selected command\n\nAccessing an SSH key from the workspace list\nAccessing an SSH key from the workspace list\n\nSSH Key access via modal\nSSH Key access via modal\n\nYou can also access the SSH connection string from the workspace start page, which is shown to users who have selected a desktop IDE or editor as their preference.\n\nSSH to a workspace via the workspace splash page\nSSH to a workspace via the workspace splash page\n\n__SPLIT_HERE__\nAccess Token SSH\n\nYou can currently copy/paste a simple SSH command to get command line access to your workspace from the Gitpod dashboard.\n\nVisit your workspace list in Gitpod\nView a running Gitpod workspace and click the more actions menu\nSelect &quot;connect via SSH&quot;\nNavigate to the &quot;Access Token&quot; tab\nCopy paste the selected command\n\nAccessing an SSH key from the workspace list\nAccessing an SSH key from the workspace list\n\nSSH via access token from the workspace list\nSSH via access token from the workspace list\n\nYou can also access the SSH connection string from the workspace start page, which is shown to users who have selected a desktop IDE or editor as their preference.\n\nSSH to a workspace via the workspace splash page\nSSH to a workspace via the workspace splash page\n\n__SPLIT_HERE__\nSSH via Local Companion\n\nNote: It is possible to access your Gitpod workspaces via the command line using local companion, however access using an SSH key is the preferred approach.","metadata":{"source":"https://gitpod.io/docs/references/ides-and-editors/command-line"}}],["561",{"pageContent":"__SPLIT_HERE__\nFAQs\n\n__SPLIT_HERE__\nIs there a limit of IDE/editor connections to Gitpod?\n\nThere is no hard-limit about how many IDE/editors can be connected to a running Gitpod workspace. All connected IDEs/editors will have access to the same underlying file system and directories.\n\n__SPLIT_HERE__\nWhat version of VS Code runs in Gitpod (in the browser)?\n\nVS Code in the browser in Gitpod uses a fork of VS Code called openvscode-server. Gitpod actively monitors VS Code&#39;s release cycle, and releases the latest version of VS Code shortly after the upstream repository is updated. You can find more information about which version of VS Code is running in the browser by navigating to &quot;Help &gt; About&quot; from a running Gitpod workspace.\n\n__SPLIT_HERE__\nDoes Gitpod VS Code settings sync work with other products (e.g. Codespaces)?\n\nGitpod doesn&#39;t currently support settings sync with other hosted VS Code environments, such as Codespaces or vscode.dev.\n\n__SPLIT_HERE__\nMy VS Code extensions are not syncing, what should I do?\n\nWhen installing an extension in Gitpod using the Install (Do Not Sync) option.\nExtensions defined in gitpod.yml\nExtensions manually installed from a vsix file\n\n__SPLIT_HERE__\nCan I use both a desktop IDE and a browser editor in Gitpod?\n\nYes, you can. Both desktop and browser IDEs/editors have full access to files and directories within the workspace. So, when you connect to your Gitpod workspace from your Desktop you can also access your workspace via your browser. This means browser-based editing can either be used as your first-choice editor, or as a &quot;fall back&quot; alternative option for when you want to make edits on the move. With Gitpod, where and how you edit your code is very flexible.\n\n__SPLIT_HERE__\nWhat is the preferred IDE/editor for Gitpod?\n\nThere are many supported ways to edit your code in Gitpod, there is no preferred experience. Gitpod is intended to be flexible to allow you and your team to use the tools you are most familiar and comfortable with. You can edit code in Gitpod using:\n\nJetBrains IDE&#39;s via JetBrains Gateway\nVS Code in the browser and VS Code on desktop\nCommand-line based editors such as Vim\n\nPlease see the IDEs &amp; editors documentation for more details.\n\n__SPLIT_HERE__\nDo I need a license to use JetBrains and Gitpod?\n\nThe licensing of Remote Development is handled on the local machine and is covered by your existing active IDE license. See JetBrains documentation for more.\n\n__SPLIT_HERE__\nWill Gitpod support all the JetBrains IDE&#39;s?\n\nYes, the plan is to eventually support all of the JetBrains IDE&#39;s. Please refer to the Gitpod roadmap for future updates.\n\n__SPLIT_HERE__\nDoes Gitpod support the IntelliJ IDEA Community edition?\n\nNo, JetBrains Remote Development and Gateway are available only in the IntelliJ IDEA Ultimate edition, please refer to IntelliJ IDEA FAQ.\n\n__SPLIT_HERE__\nWill Gitpod support JetBrains Fleet?\n\nJetBrains Fleet is a next-generation IDE from JetBrains. The currently supported method of using JetBrains IDE&#39;s with Gitpod is on desktop via JetBrains Gateway, please refer to our documentation for current IDE and editor support and the Gitpod roadmap for future updates.\n\n__SPLIT_HERE__\nCan I use JetBrains Projector with Gitpod?\n\nGitpod does not officially support JetBrains Projector. Gitpod has support for JetBrains Gateway, which is the primary tool for remote development when using JetBrains IDE&#39;s.","metadata":{"source":"https://gitpod.io/docs/references/ides-and-editors/faqs"}}],["562",{"pageContent":"__SPLIT_HERE__\nGoLand\n\n{title} is currently in Beta ¬∑ Send feedback.\n\n__SPLIT_HERE__\nGetting started\n\nInstall JetBrains Gateway - With the JetBrains Gateway and Gitpod plugin you can create and manage your latest 20 Gitpod workspaces.\nInstall the Gitpod plugin - Open JetBrains Gateway and you&#39;ll see the Gitpod logo on the main page. Click &quot;install&quot; to install the Gitpod plugin for JetBrains Gateway.\nUpdate your Gitpod preferences - Select {title} on the Gitpod preferences page which will set {title} as your default IDE for future workspace starts.\nStart (or restart) your workspace - Either start a workspace directly from within the JetBrains Gateway via the Gitpod plugin OR open a new workspace directly in Gitpod where on workspace start you will be prompted to open {title} for that workspace.\n\nImportant: You must restart any started workspaces for your IDE preferences to take effect.","metadata":{"source":"https://gitpod.io/docs/references/ides-and-editors/goland"}}],["563",{"pageContent":"Install Plugins\n\nThis section relates to plugin management when using JetBrains IDEs in a remote development context. For information on regular plugin management, refer to {title} docs.\n\nUnlike with regular development, JetBrains Remote development with {title} allows users to install plugins in different locations:","metadata":{"source":"https://gitpod.io/docs/references/ides-and-editors/goland"}}],["564",{"pageContent":"{title} backend plugins - The JetBrains {title} backend runs within the remote Gitpod workspace. Backend plugins contribute functionality for IDE experiences relating to the filesystem, tools or languages and frameworks. When installed, a backend plugin only applies to the currently running Gitpod workspace and is not associated with a user. However, a plugin can be preconfigured for all users of a repository so that the plugin is enabled with every workspace start. It is not currently possible to install a backend plugin that applies to all workspaces of a Gitpod user or organization.","metadata":{"source":"https://gitpod.io/docs/references/ides-and-editors/goland"}}],["565",{"pageContent":"JetBrains Client plugins - The JetBrains client runs on the users local machine and can be thought of as the user interface to the remote {title} backend. Client plugins are different to backend plugins as they contribute to the user interface aspect of the IDE experience (e.g. keyboard shortcuts and themes). Once installed, a client plugin is enabled for all Gitpod workspaces the user opens (if the workspace is running the exact same version of the {title} backend where the plugin was initially installed).\nJetBrains Gateway plugins - The JetBrains Gateway is an application downloaded onto a users local machine which allows users to start JetBrains Clients that are compatible with the {title} backend, running in a Gitpod workspace. JetBrains Gateway plugins are installed directly in JetBrains Gateway and contribute to remote development connection experiences (e.g. the Gitpod JetBrains Gateway plugin).","metadata":{"source":"https://gitpod.io/docs/references/ides-and-editors/goland"}}],["566",{"pageContent":"Install on JetBrains Client\n\nThe JetBrains client runs on the users local machine and can be thought of as the user interface to the remote {title} backend. Client plugins contribute to the user interface aspect of the IDE experience (e.g. keyboard shortcuts and themes).\n\nOnce installed, a client plugin is enabled for all Gitpod workspaces the user opens (if the workspace is running the exact same version of the {title} backend where the plugin was initially installed).\n\nTo install a plugin on JetBrains Client follow these steps:\n\nIn JetBrains Client open the IDE settings and select Plugins.\nFind the plugin in the Marketplace and click Install.\n\nInstall on {title} backend\n\nThe JetBrains {title} backend runs within the remote Gitpod workspace. Backend plugins contribute functionality requiring access to IDE experiences such as the remote filesystem (e.g. contributing support of languages and frameworks).","metadata":{"source":"https://gitpod.io/docs/references/ides-and-editors/goland"}}],["567",{"pageContent":"When installed, a backend plugin only applies to the currently running Gitpod workspace and is not associated with a user. However, a plugin can be preconfigured for all users of a repository so that the plugin is enabled with every workspace start.\n\nIt is not currently possible to install a backend plugin that applies to all workspaces of a Gitpod user or organization.\n\nInstall for your current workspace\n\nYou can install a plugin only for your current workspace following these steps:\n\nIn JetBrains Client open the IDE settings and select Plugins On Host.\nFind the plugin in the Marketplace and click Install.\n\nPreconfigure for repository\n\nJetBrains plugin support is currently in Beta ¬∑ Send feedback.\n\nYou can share a plugin on {title} backend with everybody working on the repository by adding it to .gitpod.yml and pushing to your Git repository.\nEach workspace is preconfigured with plugins from the gitpod.yml configuration file. For example:","metadata":{"source":"https://gitpod.io/docs/references/ides-and-editors/goland"}}],["568",{"pageContent":"```yaml\njetbrains:\n  goland:\n    plugins:\n      - zielu.gittoolbox\n      - izhangzhihao.rainbow.brackets\n```\n\nYou can find the pluginId on the JetBrains Marketplace page:\n\nFind a page of the required plugin.\nSelect the Versions tab.\nClick any version to copy the pluginId (short name such as org.rust.lang) of the plugin you want to install.\n\nInstall for your user\n\nIt is not yet possible to install plugins on {title} backend for your user to share across all your Gitpod workspaces.","metadata":{"source":"https://gitpod.io/docs/references/ides-and-editors/goland"}}],["569",{"pageContent":"Configure JVM options\n\nConfiguration of JVM options is currently in Alpha ¬∑ Send feedback.\n\nYou can adjust JVM options for {title} backend, especially if you want to increase the -Xmx memory size. For example:\n\n```yaml\njetbrains:\n  goland:\n    vmoptions: \"-Xmx4g\"\n```\n\nFor more detailed information on JVM options, refer to Common JVM Options from JetBrains documentation.\n\n__SPLIT_HERE__\nConfigure IDE settings\n\nFeedback needed: The JetBrains Gitpod integration is currently beta. Gitpod continues to collaborate with JetBrains. The below shows how you can configure global settings with JetBrains. To leave feedback on the approach, please see this GitHub issue: #6576. Also note that JetBrains is working on comprehensive settings sync functionality.\n\nWhen running {title} locally, the JetBrains IDE applies global settings to all projects on your machine. However when running in a remote context using JetBrains Gateway, it&#39;s important to note that some IDE settings are configured on the JetBrains Client and others in the {title} backend running in your Gitpod Workspace. See below instructions for more.\n\nOn JetBrains Client\n\nIDE Settings that are configured on the JetBrains Client are stored on your local machine and don&#39;t have On Host label in the IDE settings. These IDE settings are reused if the workspace is running the exact same version of the {title} backend where the settings were initially configured.\n\nOn {title} backend\n\nSettings configured on {title} backend are stored in a Gitpod workspace and have On Host label in the IDE settings.\n\nConfigure IDE settings per project\n\nSome IDE settings cannot be configured via environment variables or through setting vm options. These settings can only be set via the UI of JetBrains client, and must be manually copied to be syned between workspaces. The below steps detail how to configure your IDE settings for all the users of a given Gitpod project:\n\nStep 1: Manually use JetBrains UI to configure settings - Set your IDE settings as you normally would, using the JetBrains UI.\n\nStep 2: Find generated IDE settings - You will need to manually find any global settings generated by JetBrains backend within the following path: /workspace/.config/JetBrains&lt;-latest&gt;/RemoteDev-GO/&lt;your-project-name&gt;/options\n\nStep 3: Move any relevant settings manually to a persistent location within your Gitpod project. Either via a Workspace Image, or persisted in the version control of your project, for example by committing settings data to GitHub.\n\nInclude relevant IDE settings in your Workspace Image\n\n/home/gitpod/.gitpod/jetbrains/options - This location applies settings to all JetBrains products (IntelliJ IDEA, GoLang, etc).\n/home/gitpod/.gitpod/jetbrains/goland/options - This location will apply settings only to the given IDE, e.g. {title}.\n\nCommit relevant IDE settings to source control\n\n/workspace/&lt;your-project-name&gt;/.gitpod/jetbrains/options - This location applies settings to all JetBrains products (IntelliJ IDEA, GoLang, etc).\n/workspace/&lt;your-project-name&gt;/.gitpod/jetbrains/goland/options - This location will apply settings only to the given IDE, e.g. {title}.\n\nFor any further changes to your IDE settings, you will need to follow the above steps again.\n\nNote: When locating and applying IDE settings, Gitpod will read the locations specified above in priority order. The locations specified first are overriden by the locations specified later.\n\nConfigure IDE settings per user\n\nTo configure IDE settings for your user only, and not all those using a project.\n\nFollow the instructions for configuring IDE settings per project, but instead use .dotfiles rather than a workspace image or source control to store your IDE settings.","metadata":{"source":"https://gitpod.io/docs/references/ides-and-editors/goland"}}],["570",{"pageContent":"Indexing using Prebuilds\n\nJetBrains Prebuilds is currently in Alpha ¬∑ Send feedback.\n\nWhen you open the project {title} starts indexing to load modules and\nenable the core functionality like code completion and navigation.\nDepending on the size of your project indexing speed can vary significantly.\n\nYou can speed up the indexing of a project by applying these general recommendations.\nGitpod prebuilds allow you to improve it further by indexing before you start a new workspace.\n\nTo leverage it:\n\nconfigure prebuilds for your repository, refer to Prebuilds;\nenable indexing for {title} in prebuilds by editing .gitpod.yml in your repository:\n\n```yaml\njetbrains:\n  goland:\n    prebuilds:\n      version: stable\n```\n\npush changes to your Git repository to apply.\n\nThe version property allows you to control whether to index for stable, latest, or both versions of {title} compatible with Gitpod.\nUsers can switch between stable and latest versions of {title} on the user preferences page.\n\n__SPLIT_HERE__\nWorkspace performance\n\nWhen using a Gitpod workspace you might experience performance issues caused by:\n\nAn application using more resources than expected\nResource consumption in adjacent containers running on the workspace node.\n\nIn your JetBrains IDE within the JetBrains Gateway Backend Control Center you can find two metrics relating to your running workspace: Workspace CPU and Workspace Memory.\n\nThe remaining metrics you can find in the Backend Control Center regarding the node that your workspace is running on, and not the workspace itself.\n\nNote: Performance information shown in the Backend Control Center is the same as the information that is shown when running the command gp top in your workspace, see the Command Line Interface documentation for more.\n\njetbrains performance\n\n__SPLIT_HERE__\nFAQs\n\nFor the questions about supported IDEs and Editors in Gitpod, refer to FAQs.\n\n\nFor the general questions about JetBrains Remote Development, refer to refer to the general IDE {title} FAQ.\n\nAre there any JetBrains optimizations I can make if my workspace is slow?\n\nDebugging performance can be challenging, as performance issues can depend on many factors such as how Gitpod is configured (if you&#39;re operating Gitpod on Self-Hosted). However, there are some ways you can gather performance information and optimise your JetBrains IDE setup with Gitpod:\n\nFirstly, to gather information on performance, you can view workspace performance metrics from within the IDE in the Backend Control Center, or by using gp top.\nYou may also want to try adjusting the Max Heap Size allocated to the JetBrains Backend in the Settings tab of the Backend Control Center. If updating this setting helps your performance, you can set the vmoptions value for your JetBrains IDE in your .gitpod.yml.\n\nNote: If the performance metrics show that your workspace is hitting its resource limits, and you are using Gitpod Self-Hosted, it might make sense to consider changing the resource configuration for your workspaces. This can be done via a config-patch. Configuring workspace resources is not yet available on SaaS.\n\n__SPLIT_HERE__\nTroubleshooting\n\nWhat should I do if JetBrains Gateway and Gitpod aren‚Äôt working?\nGitpod logs in JetBrains Client\nGitpod logs in JetBrains Gateway","metadata":{"source":"https://gitpod.io/docs/references/ides-and-editors/goland"}}],["571",{"pageContent":"__SPLIT_HERE__\nIntelliJ IDEA Ultimate\n\n{title} is currently in Beta ¬∑ Send feedback.\n\n__SPLIT_HERE__\nGetting started\n\nInstall JetBrains Gateway - With the JetBrains Gateway and Gitpod plugin you can create and manage your latest 20 Gitpod workspaces.\nInstall the Gitpod plugin - Open JetBrains Gateway and you&#39;ll see the Gitpod logo on the main page. Click &quot;install&quot; to install the Gitpod plugin for JetBrains Gateway.\nUpdate your Gitpod preferences - Select {title} on the Gitpod preferences page which will set {title} as your default IDE for future workspace starts.\nStart (or restart) your workspace - Either start a workspace directly from within the JetBrains Gateway via the Gitpod plugin OR open a new workspace directly in Gitpod where on workspace start you will be prompted to open {title} for that workspace.\n\nImportant: You must restart any started workspaces for your IDE preferences to take effect.","metadata":{"source":"https://gitpod.io/docs/references/ides-and-editors/intellij"}}],["572",{"pageContent":"Install Plugins\n\nThis section relates to plugin management when using JetBrains IDEs in a remote development context. For information on regular plugin management, refer to {title} docs.\n\nUnlike with regular development, JetBrains Remote development with {title} allows users to install plugins in different locations:","metadata":{"source":"https://gitpod.io/docs/references/ides-and-editors/intellij"}}],["573",{"pageContent":"{title} backend plugins - The JetBrains {title} backend runs within the remote Gitpod workspace. Backend plugins contribute functionality for IDE experiences relating to the filesystem, tools or languages and frameworks. When installed, a backend plugin only applies to the currently running Gitpod workspace and is not associated with a user. However, a plugin can be preconfigured for all users of a repository so that the plugin is enabled with every workspace start. It is not currently possible to install a backend plugin that applies to all workspaces of a Gitpod user or organization.","metadata":{"source":"https://gitpod.io/docs/references/ides-and-editors/intellij"}}],["574",{"pageContent":"JetBrains Client plugins - The JetBrains client runs on the users local machine and can be thought of as the user interface to the remote {title} backend. Client plugins are different to backend plugins as they contribute to the user interface aspect of the IDE experience (e.g. keyboard shortcuts and themes). Once installed, a client plugin is enabled for all Gitpod workspaces the user opens (if the workspace is running the exact same version of the {title} backend where the plugin was initially installed).\nJetBrains Gateway plugins - The JetBrains Gateway is an application downloaded onto a users local machine which allows users to start JetBrains Clients that are compatible with the {title} backend, running in a Gitpod workspace. JetBrains Gateway plugins are installed directly in JetBrains Gateway and contribute to remote development connection experiences (e.g. the Gitpod JetBrains Gateway plugin).","metadata":{"source":"https://gitpod.io/docs/references/ides-and-editors/intellij"}}],["575",{"pageContent":"Install on JetBrains Client\n\nThe JetBrains client runs on the users local machine and can be thought of as the user interface to the remote {title} backend. Client plugins contribute to the user interface aspect of the IDE experience (e.g. keyboard shortcuts and themes).\n\nOnce installed, a client plugin is enabled for all Gitpod workspaces the user opens (if the workspace is running the exact same version of the {title} backend where the plugin was initially installed).\n\nTo install a plugin on JetBrains Client follow these steps:\n\nIn JetBrains Client open the IDE settings and select Plugins.\nFind the plugin in the Marketplace and click Install.\n\nInstall on {title} backend\n\nThe JetBrains {title} backend runs within the remote Gitpod workspace. Backend plugins contribute functionality requiring access to IDE experiences such as the remote filesystem (e.g. contributing support of languages and frameworks).","metadata":{"source":"https://gitpod.io/docs/references/ides-and-editors/intellij"}}],["576",{"pageContent":"When installed, a backend plugin only applies to the currently running Gitpod workspace and is not associated with a user. However, a plugin can be preconfigured for all users of a repository so that the plugin is enabled with every workspace start.\n\nIt is not currently possible to install a backend plugin that applies to all workspaces of a Gitpod user or organization.\n\nInstall for your current workspace\n\nYou can install a plugin only for your current workspace following these steps:\n\nIn JetBrains Client open the IDE settings and select Plugins On Host.\nFind the plugin in the Marketplace and click Install.\n\nPreconfigure for repository\n\nJetBrains plugin support is currently in Beta ¬∑ Send feedback.\n\nYou can share a plugin on {title} backend with everybody working on the repository by adding it to .gitpod.yml and pushing to your Git repository.\nEach workspace is preconfigured with plugins from the gitpod.yml configuration file. For example:","metadata":{"source":"https://gitpod.io/docs/references/ides-and-editors/intellij"}}],["577",{"pageContent":"```yaml\njetbrains:\n  intellij:\n    plugins:\n      - zielu.gittoolbox\n      - izhangzhihao.rainbow.brackets\n```\n\nYou can find the pluginId on the JetBrains Marketplace page:\n\nFind a page of the required plugin.\nSelect the Versions tab.\nClick any version to copy the pluginId (short name such as org.rust.lang) of the plugin you want to install.\n\nInstall for your user\n\nIt is not yet possible to install plugins on {title} backend for your user to share across all your Gitpod workspaces.","metadata":{"source":"https://gitpod.io/docs/references/ides-and-editors/intellij"}}],["578",{"pageContent":"Configure JVM options\n\nConfiguration of JVM options is currently in Alpha ¬∑ Send feedback.\n\nYou can adjust JVM options for {title} backend, especially if you want to increase the -Xmx memory size. For example:\n\n```yaml\njetbrains:\n  intellij:\n    vmoptions: \"-Xmx4g\"\n```\n\nFor more detailed information on JVM options, refer to Common JVM Options from JetBrains documentation.\n\n__SPLIT_HERE__\nConfigure IDE settings\n\nFeedback needed: The JetBrains Gitpod integration is currently beta. Gitpod continues to collaborate with JetBrains. The below shows how you can configure global settings with JetBrains. To leave feedback on the approach, please see this GitHub issue: #6576. Also note that JetBrains is working on comprehensive settings sync functionality.\n\nWhen running {title} locally, the JetBrains IDE applies global settings to all projects on your machine. However when running in a remote context using JetBrains Gateway, it&#39;s important to note that some IDE settings are configured on the JetBrains Client and others in the {title} backend running in your Gitpod Workspace. See below instructions for more.\n\nOn JetBrains Client\n\nIDE Settings that are configured on the JetBrains Client are stored on your local machine and don&#39;t have On Host label in the IDE settings. These IDE settings are reused if the workspace is running the exact same version of the {title} backend where the settings were initially configured.\n\nOn {title} backend\n\nSettings configured on {title} backend are stored in a Gitpod workspace and have On Host label in the IDE settings.\n\nConfigure IDE settings per project\n\nSome IDE settings cannot be configured via environment variables or through setting vm options. These settings can only be set via the UI of JetBrains client, and must be manually copied to be syned between workspaces. The below steps detail how to configure your IDE settings for all the users of a given Gitpod project:\n\nStep 1: Manually use JetBrains UI to configure settings - Set your IDE settings as you normally would, using the JetBrains UI.\n\nStep 2: Find generated IDE settings - You will need to manually find any global settings generated by JetBrains backend within the following path: /workspace/.config/JetBrains&lt;-latest&gt;/RemoteDev-IU/&lt;your-project-name&gt;/options\n\nStep 3: Move any relevant settings manually to a persistent location within your Gitpod project. Either via a Workspace Image, or persisted in the version control of your project, for example by committing settings data to GitHub.\n\nInclude relevant IDE settings in your Workspace Image\n\n/home/gitpod/.gitpod/jetbrains/options - This location applies settings to all JetBrains products (IntelliJ IDEA, GoLang, etc).\n/home/gitpod/.gitpod/jetbrains/intellij/options - This location will apply settings only to the given IDE, e.g. {title}.\n\nCommit relevant IDE settings to source control\n\n/workspace/&lt;your-project-name&gt;/.gitpod/jetbrains/options - This location applies settings to all JetBrains products (IntelliJ IDEA, GoLang, etc).\n/workspace/&lt;your-project-name&gt;/.gitpod/jetbrains/intellij/options - This location will apply settings only to the given IDE, e.g. {title}.\n\nFor any further changes to your IDE settings, you will need to follow the above steps again.\n\nNote: When locating and applying IDE settings, Gitpod will read the locations specified above in priority order. The locations specified first are overriden by the locations specified later.\n\nConfigure IDE settings per user\n\nTo configure IDE settings for your user only, and not all those using a project.\n\nFollow the instructions for configuring IDE settings per project, but instead use .dotfiles rather than a workspace image or source control to store your IDE settings.","metadata":{"source":"https://gitpod.io/docs/references/ides-and-editors/intellij"}}],["579",{"pageContent":"Indexing using Prebuilds\n\nJetBrains Prebuilds is currently in Alpha ¬∑ Send feedback.\n\nWhen you open the project {title} starts indexing to load modules and\nenable the core functionality like code completion and navigation.\nDepending on the size of your project indexing speed can vary significantly.\n\nYou can speed up the indexing of a project by applying these general recommendations.\nGitpod prebuilds allow you to improve it further by indexing before you start a new workspace.\n\nTo leverage it:\n\nconfigure prebuilds for your repository, refer to Prebuilds;\nenable indexing for {title} in prebuilds by editing .gitpod.yml in your repository:\n\n```yaml\njetbrains:\n  intellij:\n    prebuilds:\n      version: stable\n```\n\npush changes to your Git repository to apply.\n\nThe version property allows you to control whether to index for stable, latest, or both versions of {title} compatible with Gitpod.\nUsers can switch between stable and latest versions of {title} on the user preferences page.\n\n__SPLIT_HERE__\nWorkspace performance\n\nWhen using a Gitpod workspace you might experience performance issues caused by:\n\nAn application using more resources than expected\nResource consumption in adjacent containers running on the workspace node.\n\nIn your JetBrains IDE within the JetBrains Gateway Backend Control Center you can find two metrics relating to your running workspace: Workspace CPU and Workspace Memory.\n\nThe remaining metrics you can find in the Backend Control Center regarding the node that your workspace is running on, and not the workspace itself.\n\nNote: Performance information shown in the Backend Control Center is the same as the information that is shown when running the command gp top in your workspace, see the Command Line Interface documentation for more.\n\njetbrains performance\n\n__SPLIT_HERE__\nFAQs\n\nFor the questions about supported IDEs and Editors in Gitpod, refer to FAQs.\n\n\nFor the general questions about JetBrains Remote Development, refer to refer to the general IDE {title} FAQ.\n\nAre there any JetBrains optimizations I can make if my workspace is slow?\n\nDebugging performance can be challenging, as performance issues can depend on many factors such as how Gitpod is configured (if you&#39;re operating Gitpod on Self-Hosted). However, there are some ways you can gather performance information and optimise your JetBrains IDE setup with Gitpod:\n\nFirstly, to gather information on performance, you can view workspace performance metrics from within the IDE in the Backend Control Center, or by using gp top.\nYou may also want to try adjusting the Max Heap Size allocated to the JetBrains Backend in the Settings tab of the Backend Control Center. If updating this setting helps your performance, you can set the vmoptions value for your JetBrains IDE in your .gitpod.yml.\n\nNote: If the performance metrics show that your workspace is hitting its resource limits, and you are using Gitpod Self-Hosted, it might make sense to consider changing the resource configuration for your workspaces. This can be done via a config-patch. Configuring workspace resources is not yet available on SaaS.\n\n__SPLIT_HERE__\nTroubleshooting\n\nWhat should I do if JetBrains Gateway and Gitpod aren‚Äôt working?\nGitpod logs in JetBrains Client\nGitpod logs in JetBrains Gateway","metadata":{"source":"https://gitpod.io/docs/references/ides-and-editors/intellij"}}],["580",{"pageContent":"&lt;OpenGraph\ndata={{\n    description:\n      &quot;Connect and integrate Gitpod workspaces with your favourite IDE or editor. VS Code Browser and Desktop. JetBrains. IntelliJ. GoLand. PhpStorm. PyCharm. Vim. Emacs. SSH.&quot;,\n    title: &quot;Gitpod integrates with VS Code, JetBrains and SSH.&quot;,\n    keywords: &quot;online IDEs, JetBrains, VS Code, IntelliJ, PHPStorm, PyCharm, Rider, RubyMine, WebStorm, CLion etc.&quot;,\n  }}\n/&gt;\n\n__SPLIT_HERE__\nIDEs &amp; Editors\n\nIn line with our ambition to &quot;remove all friction from the developer experience&quot;, Gitpod currently supports many popular IDE/editors e.g. JetBrains and VS Code through both the browser and on desktop. You can even use the command-line directly for editors like Vim (via SSH). There are many ways to configure your IDE/editor in Gitpod to match your preferred workflow or setup.\n\n__SPLIT_HERE__\nConnecting an IDE/editor to Gitpod\n\nThe three main ways to edit code or access a Gitpod workspace:\n\nBrowser - Using VS Code Browser.\nSSH - Using an SSH key or an Access Token.\nDesktop - Using VS Code Desktop or JetBrains Gateway.\n\nSupported IDE/editors\n\nVS Code Browser\nVS Code Desktop\nIntelliJ\nGoLand\nPhpStorm\nPyCharm\nRubyMine\nWebStorm\nRider\nCLion\nCommand Line (e.g. Vim)\n\nStart a workspace with an IDE/editor\n\nYou can start a workspace with your favourite IDE/editor directly from Gitpod Dashboard. You can do that from by clicking on the New Workspace button. Then, you can select the context url, Editor and custom workspace class.","metadata":{"source":"https://gitpod.io/docs/references/ides-and-editors/index"}}],["581",{"pageContent":"__SPLIT_HERE__\nGitpod Local Companion\n\n{title} is currently in Beta ¬∑ Send feedback.\n\nPlease refer to the Gitpod Local Companion - localhost is going remote announcement blog post for more details on how to explore the beta release of the Gitpod local companion.\n\n__SPLIT_HERE__\nConnect To VS Code Desktop\n\nWhilst it is possible to use the Gitpod local companion to connect your desktop VS Code application to Gitpod, the best way is to use the Gitpod VSCode Plugin, which you can access directly from the command pallette via any Gitpod the workspace. For more details about VS Code Desktop, please refer to the VS Code desktop support docs.","metadata":{"source":"https://gitpod.io/docs/references/ides-and-editors/local-companion"}}],["582",{"pageContent":"__SPLIT_HERE__\nPhpStorm\n\n{title} is currently in Beta ¬∑ Send feedback.\n\n__SPLIT_HERE__\nGetting started\n\nInstall JetBrains Gateway - With the JetBrains Gateway and Gitpod plugin you can create and manage your latest 20 Gitpod workspaces.\nInstall the Gitpod plugin - Open JetBrains Gateway and you&#39;ll see the Gitpod logo on the main page. Click &quot;install&quot; to install the Gitpod plugin for JetBrains Gateway.\nUpdate your Gitpod preferences - Select {title} on the Gitpod preferences page which will set {title} as your default IDE for future workspace starts.\nStart (or restart) your workspace - Either start a workspace directly from within the JetBrains Gateway via the Gitpod plugin OR open a new workspace directly in Gitpod where on workspace start you will be prompted to open {title} for that workspace.\n\nImportant: You must restart any started workspaces for your IDE preferences to take effect.","metadata":{"source":"https://gitpod.io/docs/references/ides-and-editors/phpstorm"}}],["583",{"pageContent":"Install Plugins\n\nThis section relates to plugin management when using JetBrains IDEs in a remote development context. For information on regular plugin management, refer to {title} docs.\n\nUnlike with regular development, JetBrains Remote development with {title} allows users to install plugins in different locations:","metadata":{"source":"https://gitpod.io/docs/references/ides-and-editors/phpstorm"}}],["584",{"pageContent":"{title} backend plugins - The JetBrains {title} backend runs within the remote Gitpod workspace. Backend plugins contribute functionality for IDE experiences relating to the filesystem, tools or languages and frameworks. When installed, a backend plugin only applies to the currently running Gitpod workspace and is not associated with a user. However, a plugin can be preconfigured for all users of a repository so that the plugin is enabled with every workspace start. It is not currently possible to install a backend plugin that applies to all workspaces of a Gitpod user or organization.","metadata":{"source":"https://gitpod.io/docs/references/ides-and-editors/phpstorm"}}],["585",{"pageContent":"JetBrains Client plugins - The JetBrains client runs on the users local machine and can be thought of as the user interface to the remote {title} backend. Client plugins are different to backend plugins as they contribute to the user interface aspect of the IDE experience (e.g. keyboard shortcuts and themes). Once installed, a client plugin is enabled for all Gitpod workspaces the user opens (if the workspace is running the exact same version of the {title} backend where the plugin was initially installed).\nJetBrains Gateway plugins - The JetBrains Gateway is an application downloaded onto a users local machine which allows users to start JetBrains Clients that are compatible with the {title} backend, running in a Gitpod workspace. JetBrains Gateway plugins are installed directly in JetBrains Gateway and contribute to remote development connection experiences (e.g. the Gitpod JetBrains Gateway plugin).","metadata":{"source":"https://gitpod.io/docs/references/ides-and-editors/phpstorm"}}],["586",{"pageContent":"Install on JetBrains Client\n\nThe JetBrains client runs on the users local machine and can be thought of as the user interface to the remote {title} backend. Client plugins contribute to the user interface aspect of the IDE experience (e.g. keyboard shortcuts and themes).\n\nOnce installed, a client plugin is enabled for all Gitpod workspaces the user opens (if the workspace is running the exact same version of the {title} backend where the plugin was initially installed).\n\nTo install a plugin on JetBrains Client follow these steps:\n\nIn JetBrains Client open the IDE settings and select Plugins.\nFind the plugin in the Marketplace and click Install.\n\nInstall on {title} backend\n\nThe JetBrains {title} backend runs within the remote Gitpod workspace. Backend plugins contribute functionality requiring access to IDE experiences such as the remote filesystem (e.g. contributing support of languages and frameworks).","metadata":{"source":"https://gitpod.io/docs/references/ides-and-editors/phpstorm"}}],["587",{"pageContent":"When installed, a backend plugin only applies to the currently running Gitpod workspace and is not associated with a user. However, a plugin can be preconfigured for all users of a repository so that the plugin is enabled with every workspace start.\n\nIt is not currently possible to install a backend plugin that applies to all workspaces of a Gitpod user or organization.\n\nInstall for your current workspace\n\nYou can install a plugin only for your current workspace following these steps:\n\nIn JetBrains Client open the IDE settings and select Plugins On Host.\nFind the plugin in the Marketplace and click Install.\n\nPreconfigure for repository\n\nJetBrains plugin support is currently in Beta ¬∑ Send feedback.\n\nYou can share a plugin on {title} backend with everybody working on the repository by adding it to .gitpod.yml and pushing to your Git repository.\nEach workspace is preconfigured with plugins from the gitpod.yml configuration file. For example:","metadata":{"source":"https://gitpod.io/docs/references/ides-and-editors/phpstorm"}}],["588",{"pageContent":"```yaml\njetbrains:\n  phpstorm:\n    plugins:\n      - zielu.gittoolbox\n      - izhangzhihao.rainbow.brackets\n```\n\nYou can find the pluginId on the JetBrains Marketplace page:\n\nFind a page of the required plugin.\nSelect the Versions tab.\nClick any version to copy the pluginId (short name such as org.rust.lang) of the plugin you want to install.\n\nInstall for your user\n\nIt is not yet possible to install plugins on {title} backend for your user to share across all your Gitpod workspaces.","metadata":{"source":"https://gitpod.io/docs/references/ides-and-editors/phpstorm"}}],["589",{"pageContent":"Configure JVM options\n\nConfiguration of JVM options is currently in Alpha ¬∑ Send feedback.\n\nYou can adjust JVM options for {title} backend, especially if you want to increase the -Xmx memory size. For example:\n\n```yaml\njetbrains:\n  phpstorm:\n    vmoptions: \"-Xmx4g\"\n```\n\nFor more detailed information on JVM options, refer to Common JVM Options from JetBrains documentation.\n\n__SPLIT_HERE__\nConfigure IDE settings\n\nFeedback needed: The JetBrains Gitpod integration is currently beta. Gitpod continues to collaborate with JetBrains. The below shows how you can configure global settings with JetBrains. To leave feedback on the approach, please see this GitHub issue: #6576. Also note that JetBrains is working on comprehensive settings sync functionality.\n\nWhen running {title} locally, the JetBrains IDE applies global settings to all projects on your machine. However when running in a remote context using JetBrains Gateway, it&#39;s important to note that some IDE settings are configured on the JetBrains Client and others in the {title} backend running in your Gitpod Workspace. See below instructions for more.\n\nOn JetBrains Client\n\nIDE Settings that are configured on the JetBrains Client are stored on your local machine and don&#39;t have On Host label in the IDE settings. These IDE settings are reused if the workspace is running the exact same version of the {title} backend where the settings were initially configured.\n\nOn {title} backend\n\nSettings configured on {title} backend are stored in a Gitpod workspace and have On Host label in the IDE settings.\n\nConfigure IDE settings per project\n\nSome IDE settings cannot be configured via environment variables or through setting vm options. These settings can only be set via the UI of JetBrains client, and must be manually copied to be syned between workspaces. The below steps detail how to configure your IDE settings for all the users of a given Gitpod project:\n\nStep 1: Manually use JetBrains UI to configure settings - Set your IDE settings as you normally would, using the JetBrains UI.\n\nStep 2: Find generated IDE settings - You will need to manually find any global settings generated by JetBrains backend within the following path: /workspace/.config/JetBrains&lt;-latest&gt;/RemoteDev-PS/&lt;your-project-name&gt;/options\n\nStep 3: Move any relevant settings manually to a persistent location within your Gitpod project. Either via a Workspace Image, or persisted in the version control of your project, for example by committing settings data to GitHub.\n\nInclude relevant IDE settings in your Workspace Image\n\n/home/gitpod/.gitpod/jetbrains/options - This location applies settings to all JetBrains products (IntelliJ IDEA, GoLang, etc).\n/home/gitpod/.gitpod/jetbrains/phpstorm/options - This location will apply settings only to the given IDE, e.g. {title}.\n\nCommit relevant IDE settings to source control\n\n/workspace/&lt;your-project-name&gt;/.gitpod/jetbrains/options - This location applies settings to all JetBrains products (IntelliJ IDEA, GoLang, etc).\n/workspace/&lt;your-project-name&gt;/.gitpod/jetbrains/phpstorm/options - This location will apply settings only to the given IDE, e.g. {title}.\n\nFor any further changes to your IDE settings, you will need to follow the above steps again.\n\nNote: When locating and applying IDE settings, Gitpod will read the locations specified above in priority order. The locations specified first are overriden by the locations specified later.\n\nConfigure IDE settings per user\n\nTo configure IDE settings for your user only, and not all those using a project.\n\nFollow the instructions for configuring IDE settings per project, but instead use .dotfiles rather than a workspace image or source control to store your IDE settings.","metadata":{"source":"https://gitpod.io/docs/references/ides-and-editors/phpstorm"}}],["590",{"pageContent":"Indexing using Prebuilds\n\nJetBrains Prebuilds is currently in Alpha ¬∑ Send feedback.\n\nWhen you open the project {title} starts indexing to load modules and\nenable the core functionality like code completion and navigation.\nDepending on the size of your project indexing speed can vary significantly.\n\nYou can speed up the indexing of a project by applying these general recommendations.\nGitpod prebuilds allow you to improve it further by indexing before you start a new workspace.\n\nTo leverage it:\n\nconfigure prebuilds for your repository, refer to Prebuilds;\nenable indexing for {title} in prebuilds by editing .gitpod.yml in your repository:\n\n```yaml\njetbrains:\n  phpstorm:\n    prebuilds:\n      version: stable\n```\n\npush changes to your Git repository to apply.\n\nThe version property allows you to control whether to index for stable, latest, or both versions of {title} compatible with Gitpod.\nUsers can switch between stable and latest versions of {title} on the user preferences page.\n\n__SPLIT_HERE__\nWorkspace performance\n\nWhen using a Gitpod workspace you might experience performance issues caused by:\n\nAn application using more resources than expected\nResource consumption in adjacent containers running on the workspace node.\n\nIn your JetBrains IDE within the JetBrains Gateway Backend Control Center you can find two metrics relating to your running workspace: Workspace CPU and Workspace Memory.\n\nThe remaining metrics you can find in the Backend Control Center regarding the node that your workspace is running on, and not the workspace itself.\n\nNote: Performance information shown in the Backend Control Center is the same as the information that is shown when running the command gp top in your workspace, see the Command Line Interface documentation for more.\n\njetbrains performance\n\n__SPLIT_HERE__\nFAQs\n\nFor the questions about supported IDEs and Editors in Gitpod, refer to FAQs.\n\n\nFor the general questions about JetBrains Remote Development, refer to refer to the general IDE {title} FAQ.\n\nAre there any JetBrains optimizations I can make if my workspace is slow?\n\nDebugging performance can be challenging, as performance issues can depend on many factors such as how Gitpod is configured (if you&#39;re operating Gitpod on Self-Hosted). However, there are some ways you can gather performance information and optimise your JetBrains IDE setup with Gitpod:\n\nFirstly, to gather information on performance, you can view workspace performance metrics from within the IDE in the Backend Control Center, or by using gp top.\nYou may also want to try adjusting the Max Heap Size allocated to the JetBrains Backend in the Settings tab of the Backend Control Center. If updating this setting helps your performance, you can set the vmoptions value for your JetBrains IDE in your .gitpod.yml.\n\nNote: If the performance metrics show that your workspace is hitting its resource limits, and you are using Gitpod Self-Hosted, it might make sense to consider changing the resource configuration for your workspaces. This can be done via a config-patch. Configuring workspace resources is not yet available on SaaS.\n\n__SPLIT_HERE__\nTroubleshooting\n\nWhat should I do if JetBrains Gateway and Gitpod aren‚Äôt working?\nGitpod logs in JetBrains Client\nGitpod logs in JetBrains Gateway","metadata":{"source":"https://gitpod.io/docs/references/ides-and-editors/phpstorm"}}],["591",{"pageContent":"__SPLIT_HERE__\nPyCharm\n\n{title} is currently in Beta ¬∑ Send feedback.\n\n__SPLIT_HERE__\nGetting started\n\nInstall JetBrains Gateway - With the JetBrains Gateway and Gitpod plugin you can create and manage your latest 20 Gitpod workspaces.\nInstall the Gitpod plugin - Open JetBrains Gateway and you&#39;ll see the Gitpod logo on the main page. Click &quot;install&quot; to install the Gitpod plugin for JetBrains Gateway.\nUpdate your Gitpod preferences - Select {title} on the Gitpod preferences page which will set {title} as your default IDE for future workspace starts.\nStart (or restart) your workspace - Either start a workspace directly from within the JetBrains Gateway via the Gitpod plugin OR open a new workspace directly in Gitpod where on workspace start you will be prompted to open {title} for that workspace.\n\nImportant: You must restart any started workspaces for your IDE preferences to take effect.","metadata":{"source":"https://gitpod.io/docs/references/ides-and-editors/pycharm"}}],["592",{"pageContent":"Install Plugins\n\nThis section relates to plugin management when using JetBrains IDEs in a remote development context. For information on regular plugin management, refer to {title} docs.\n\nUnlike with regular development, JetBrains Remote development with {title} allows users to install plugins in different locations:","metadata":{"source":"https://gitpod.io/docs/references/ides-and-editors/pycharm"}}],["593",{"pageContent":"{title} backend plugins - The JetBrains {title} backend runs within the remote Gitpod workspace. Backend plugins contribute functionality for IDE experiences relating to the filesystem, tools or languages and frameworks. When installed, a backend plugin only applies to the currently running Gitpod workspace and is not associated with a user. However, a plugin can be preconfigured for all users of a repository so that the plugin is enabled with every workspace start. It is not currently possible to install a backend plugin that applies to all workspaces of a Gitpod user or organization.","metadata":{"source":"https://gitpod.io/docs/references/ides-and-editors/pycharm"}}],["594",{"pageContent":"JetBrains Client plugins - The JetBrains client runs on the users local machine and can be thought of as the user interface to the remote {title} backend. Client plugins are different to backend plugins as they contribute to the user interface aspect of the IDE experience (e.g. keyboard shortcuts and themes). Once installed, a client plugin is enabled for all Gitpod workspaces the user opens (if the workspace is running the exact same version of the {title} backend where the plugin was initially installed).\nJetBrains Gateway plugins - The JetBrains Gateway is an application downloaded onto a users local machine which allows users to start JetBrains Clients that are compatible with the {title} backend, running in a Gitpod workspace. JetBrains Gateway plugins are installed directly in JetBrains Gateway and contribute to remote development connection experiences (e.g. the Gitpod JetBrains Gateway plugin).","metadata":{"source":"https://gitpod.io/docs/references/ides-and-editors/pycharm"}}],["595",{"pageContent":"Install on JetBrains Client\n\nThe JetBrains client runs on the users local machine and can be thought of as the user interface to the remote {title} backend. Client plugins contribute to the user interface aspect of the IDE experience (e.g. keyboard shortcuts and themes).\n\nOnce installed, a client plugin is enabled for all Gitpod workspaces the user opens (if the workspace is running the exact same version of the {title} backend where the plugin was initially installed).\n\nTo install a plugin on JetBrains Client follow these steps:\n\nIn JetBrains Client open the IDE settings and select Plugins.\nFind the plugin in the Marketplace and click Install.\n\nInstall on {title} backend\n\nThe JetBrains {title} backend runs within the remote Gitpod workspace. Backend plugins contribute functionality requiring access to IDE experiences such as the remote filesystem (e.g. contributing support of languages and frameworks).","metadata":{"source":"https://gitpod.io/docs/references/ides-and-editors/pycharm"}}],["596",{"pageContent":"When installed, a backend plugin only applies to the currently running Gitpod workspace and is not associated with a user. However, a plugin can be preconfigured for all users of a repository so that the plugin is enabled with every workspace start.\n\nIt is not currently possible to install a backend plugin that applies to all workspaces of a Gitpod user or organization.\n\nInstall for your current workspace\n\nYou can install a plugin only for your current workspace following these steps:\n\nIn JetBrains Client open the IDE settings and select Plugins On Host.\nFind the plugin in the Marketplace and click Install.\n\nPreconfigure for repository\n\nJetBrains plugin support is currently in Beta ¬∑ Send feedback.\n\nYou can share a plugin on {title} backend with everybody working on the repository by adding it to .gitpod.yml and pushing to your Git repository.\nEach workspace is preconfigured with plugins from the gitpod.yml configuration file. For example:","metadata":{"source":"https://gitpod.io/docs/references/ides-and-editors/pycharm"}}],["597",{"pageContent":"```yaml\njetbrains:\n  pycharm:\n    plugins:\n      - zielu.gittoolbox\n      - izhangzhihao.rainbow.brackets\n```\n\nYou can find the pluginId on the JetBrains Marketplace page:\n\nFind a page of the required plugin.\nSelect the Versions tab.\nClick any version to copy the pluginId (short name such as org.rust.lang) of the plugin you want to install.\n\nInstall for your user\n\nIt is not yet possible to install plugins on {title} backend for your user to share across all your Gitpod workspaces.","metadata":{"source":"https://gitpod.io/docs/references/ides-and-editors/pycharm"}}],["598",{"pageContent":"Configure JVM options\n\nConfiguration of JVM options is currently in Alpha ¬∑ Send feedback.\n\nYou can adjust JVM options for {title} backend, especially if you want to increase the -Xmx memory size. For example:\n\n```yaml\njetbrains:\n  pycharm:\n    vmoptions: \"-Xmx4g\"\n```\n\nFor more detailed information on JVM options, refer to Common JVM Options from JetBrains documentation.\n\n__SPLIT_HERE__\nConfigure IDE settings\n\nFeedback needed: The JetBrains Gitpod integration is currently beta. Gitpod continues to collaborate with JetBrains. The below shows how you can configure global settings with JetBrains. To leave feedback on the approach, please see this GitHub issue: #6576. Also note that JetBrains is working on comprehensive settings sync functionality.\n\nWhen running {title} locally, the JetBrains IDE applies global settings to all projects on your machine. However when running in a remote context using JetBrains Gateway, it&#39;s important to note that some IDE settings are configured on the JetBrains Client and others in the {title} backend running in your Gitpod Workspace. See below instructions for more.\n\nOn JetBrains Client\n\nIDE Settings that are configured on the JetBrains Client are stored on your local machine and don&#39;t have On Host label in the IDE settings. These IDE settings are reused if the workspace is running the exact same version of the {title} backend where the settings were initially configured.\n\nOn {title} backend\n\nSettings configured on {title} backend are stored in a Gitpod workspace and have On Host label in the IDE settings.\n\nConfigure IDE settings per project\n\nSome IDE settings cannot be configured via environment variables or through setting vm options. These settings can only be set via the UI of JetBrains client, and must be manually copied to be syned between workspaces. The below steps detail how to configure your IDE settings for all the users of a given Gitpod project:\n\nStep 1: Manually use JetBrains UI to configure settings - Set your IDE settings as you normally would, using the JetBrains UI.\n\nStep 2: Find generated IDE settings - You will need to manually find any global settings generated by JetBrains backend within the following path: /workspace/.config/JetBrains&lt;-latest&gt;/RemoteDev-PY/&lt;your-project-name&gt;/options\n\nStep 3: Move any relevant settings manually to a persistent location within your Gitpod project. Either via a Workspace Image, or persisted in the version control of your project, for example by committing settings data to GitHub.\n\nInclude relevant IDE settings in your Workspace Image\n\n/home/gitpod/.gitpod/jetbrains/options - This location applies settings to all JetBrains products (IntelliJ IDEA, GoLang, etc).\n/home/gitpod/.gitpod/jetbrains/pycharm/options - This location will apply settings only to the given IDE, e.g. {title}.\n\nCommit relevant IDE settings to source control\n\n/workspace/&lt;your-project-name&gt;/.gitpod/jetbrains/options - This location applies settings to all JetBrains products (IntelliJ IDEA, GoLang, etc).\n/workspace/&lt;your-project-name&gt;/.gitpod/jetbrains/pycharm/options - This location will apply settings only to the given IDE, e.g. {title}.\n\nFor any further changes to your IDE settings, you will need to follow the above steps again.\n\nNote: When locating and applying IDE settings, Gitpod will read the locations specified above in priority order. The locations specified first are overriden by the locations specified later.\n\nConfigure IDE settings per user\n\nTo configure IDE settings for your user only, and not all those using a project.\n\nFollow the instructions for configuring IDE settings per project, but instead use .dotfiles rather than a workspace image or source control to store your IDE settings.","metadata":{"source":"https://gitpod.io/docs/references/ides-and-editors/pycharm"}}],["599",{"pageContent":"Indexing using Prebuilds\n\nJetBrains Prebuilds is currently in Alpha ¬∑ Send feedback.\n\nWhen you open the project {title} starts indexing to load modules and\nenable the core functionality like code completion and navigation.\nDepending on the size of your project indexing speed can vary significantly.\n\nYou can speed up the indexing of a project by applying these general recommendations.\nGitpod prebuilds allow you to improve it further by indexing before you start a new workspace.\n\nTo leverage it:\n\nconfigure prebuilds for your repository, refer to Prebuilds;\nenable indexing for {title} in prebuilds by editing .gitpod.yml in your repository:\n\n```yaml\njetbrains:\n  pycharm:\n    prebuilds:\n      version: stable\n```\n\npush changes to your Git repository to apply.\n\nThe version property allows you to control whether to index for stable, latest, or both versions of {title} compatible with Gitpod.\nUsers can switch between stable and latest versions of {title} on the user preferences page.\n\n__SPLIT_HERE__\nWorkspace performance\n\nWhen using a Gitpod workspace you might experience performance issues caused by:\n\nAn application using more resources than expected\nResource consumption in adjacent containers running on the workspace node.\n\nIn your JetBrains IDE within the JetBrains Gateway Backend Control Center you can find two metrics relating to your running workspace: Workspace CPU and Workspace Memory.\n\nThe remaining metrics you can find in the Backend Control Center regarding the node that your workspace is running on, and not the workspace itself.\n\nNote: Performance information shown in the Backend Control Center is the same as the information that is shown when running the command gp top in your workspace, see the Command Line Interface documentation for more.\n\njetbrains performance\n\n__SPLIT_HERE__\nFAQs\n\nFor the questions about supported IDEs and Editors in Gitpod, refer to FAQs.\n\n\nFor the general questions about JetBrains Remote Development, refer to refer to the general IDE {title} FAQ.\n\nAre there any JetBrains optimizations I can make if my workspace is slow?\n\nDebugging performance can be challenging, as performance issues can depend on many factors such as how Gitpod is configured (if you&#39;re operating Gitpod on Self-Hosted). However, there are some ways you can gather performance information and optimise your JetBrains IDE setup with Gitpod:\n\nFirstly, to gather information on performance, you can view workspace performance metrics from within the IDE in the Backend Control Center, or by using gp top.\nYou may also want to try adjusting the Max Heap Size allocated to the JetBrains Backend in the Settings tab of the Backend Control Center. If updating this setting helps your performance, you can set the vmoptions value for your JetBrains IDE in your .gitpod.yml.\n\nNote: If the performance metrics show that your workspace is hitting its resource limits, and you are using Gitpod Self-Hosted, it might make sense to consider changing the resource configuration for your workspaces. This can be done via a config-patch. Configuring workspace resources is not yet available on SaaS.\n\n__SPLIT_HERE__\nTroubleshooting\n\nWhat should I do if JetBrains Gateway and Gitpod aren‚Äôt working?\nGitpod logs in JetBrains Client\nGitpod logs in JetBrains Gateway","metadata":{"source":"https://gitpod.io/docs/references/ides-and-editors/pycharm"}}],["600",{"pageContent":"__SPLIT_HERE__\nRubyMine\n\n{title} is currently in Beta ¬∑ Send feedback.\n\n__SPLIT_HERE__\nGetting started\n\nInstall JetBrains Gateway - With the JetBrains Gateway and Gitpod plugin you can create and manage your latest 20 Gitpod workspaces.\nInstall the Gitpod plugin - Open JetBrains Gateway and you&#39;ll see the Gitpod logo on the main page. Click &quot;install&quot; to install the Gitpod plugin for JetBrains Gateway.\nUpdate your Gitpod preferences - Select {title} on the Gitpod preferences page which will set {title} as your default IDE for future workspace starts.\nStart (or restart) your workspace - Either start a workspace directly from within the JetBrains Gateway via the Gitpod plugin OR open a new workspace directly in Gitpod where on workspace start you will be prompted to open {title} for that workspace.\n\nImportant: You must restart any started workspaces for your IDE preferences to take effect.","metadata":{"source":"https://gitpod.io/docs/references/ides-and-editors/rubymine"}}],["601",{"pageContent":"Install Plugins\n\nThis section relates to plugin management when using JetBrains IDEs in a remote development context. For information on regular plugin management, refer to {title} docs.\n\nUnlike with regular development, JetBrains Remote development with {title} allows users to install plugins in different locations:","metadata":{"source":"https://gitpod.io/docs/references/ides-and-editors/rubymine"}}],["602",{"pageContent":"{title} backend plugins - The JetBrains {title} backend runs within the remote Gitpod workspace. Backend plugins contribute functionality for IDE experiences relating to the filesystem, tools or languages and frameworks. When installed, a backend plugin only applies to the currently running Gitpod workspace and is not associated with a user. However, a plugin can be preconfigured for all users of a repository so that the plugin is enabled with every workspace start. It is not currently possible to install a backend plugin that applies to all workspaces of a Gitpod user or organization.","metadata":{"source":"https://gitpod.io/docs/references/ides-and-editors/rubymine"}}],["603",{"pageContent":"JetBrains Client plugins - The JetBrains client runs on the users local machine and can be thought of as the user interface to the remote {title} backend. Client plugins are different to backend plugins as they contribute to the user interface aspect of the IDE experience (e.g. keyboard shortcuts and themes). Once installed, a client plugin is enabled for all Gitpod workspaces the user opens (if the workspace is running the exact same version of the {title} backend where the plugin was initially installed).\nJetBrains Gateway plugins - The JetBrains Gateway is an application downloaded onto a users local machine which allows users to start JetBrains Clients that are compatible with the {title} backend, running in a Gitpod workspace. JetBrains Gateway plugins are installed directly in JetBrains Gateway and contribute to remote development connection experiences (e.g. the Gitpod JetBrains Gateway plugin).","metadata":{"source":"https://gitpod.io/docs/references/ides-and-editors/rubymine"}}],["604",{"pageContent":"Install on JetBrains Client\n\nThe JetBrains client runs on the users local machine and can be thought of as the user interface to the remote {title} backend. Client plugins contribute to the user interface aspect of the IDE experience (e.g. keyboard shortcuts and themes).\n\nOnce installed, a client plugin is enabled for all Gitpod workspaces the user opens (if the workspace is running the exact same version of the {title} backend where the plugin was initially installed).\n\nTo install a plugin on JetBrains Client follow these steps:\n\nIn JetBrains Client open the IDE settings and select Plugins.\nFind the plugin in the Marketplace and click Install.\n\nInstall on {title} backend\n\nThe JetBrains {title} backend runs within the remote Gitpod workspace. Backend plugins contribute functionality requiring access to IDE experiences such as the remote filesystem (e.g. contributing support of languages and frameworks).","metadata":{"source":"https://gitpod.io/docs/references/ides-and-editors/rubymine"}}],["605",{"pageContent":"When installed, a backend plugin only applies to the currently running Gitpod workspace and is not associated with a user. However, a plugin can be preconfigured for all users of a repository so that the plugin is enabled with every workspace start.\n\nIt is not currently possible to install a backend plugin that applies to all workspaces of a Gitpod user or organization.\n\nInstall for your current workspace\n\nYou can install a plugin only for your current workspace following these steps:\n\nIn JetBrains Client open the IDE settings and select Plugins On Host.\nFind the plugin in the Marketplace and click Install.\n\nPreconfigure for repository\n\nJetBrains plugin support is currently in Beta ¬∑ Send feedback.\n\nYou can share a plugin on {title} backend with everybody working on the repository by adding it to .gitpod.yml and pushing to your Git repository.\nEach workspace is preconfigured with plugins from the gitpod.yml configuration file. For example:","metadata":{"source":"https://gitpod.io/docs/references/ides-and-editors/rubymine"}}],["606",{"pageContent":"```yaml\njetbrains:\n  rubymine:\n    plugins:\n      - zielu.gittoolbox\n      - izhangzhihao.rainbow.brackets\n```\n\nYou can find the pluginId on the JetBrains Marketplace page:\n\nFind a page of the required plugin.\nSelect the Versions tab.\nClick any version to copy the pluginId (short name such as org.rust.lang) of the plugin you want to install.\n\nInstall for your user\n\nIt is not yet possible to install plugins on {title} backend for your user to share across all your Gitpod workspaces.","metadata":{"source":"https://gitpod.io/docs/references/ides-and-editors/rubymine"}}],["607",{"pageContent":"Configure JVM options\n\nConfiguration of JVM options is currently in Alpha ¬∑ Send feedback.\n\nYou can adjust JVM options for {title} backend, especially if you want to increase the -Xmx memory size. For example:\n\n```yaml\njetbrains:\n  rubymine:\n    vmoptions: \"-Xmx4g\"\n```\n\nFor more detailed information on JVM options, refer to Common JVM Options from JetBrains documentation.\n\n__SPLIT_HERE__\nConfigure IDE settings\n\nFeedback needed: The JetBrains Gitpod integration is currently beta. Gitpod continues to collaborate with JetBrains. The below shows how you can configure global settings with JetBrains. To leave feedback on the approach, please see this GitHub issue: #6576. Also note that JetBrains is working on comprehensive settings sync functionality.\n\nWhen running {title} locally, the JetBrains IDE applies global settings to all projects on your machine. However when running in a remote context using JetBrains Gateway, it&#39;s important to note that some IDE settings are configured on the JetBrains Client and others in the {title} backend running in your Gitpod Workspace. See below instructions for more.\n\nOn JetBrains Client\n\nIDE Settings that are configured on the JetBrains Client are stored on your local machine and don&#39;t have On Host label in the IDE settings. These IDE settings are reused if the workspace is running the exact same version of the {title} backend where the settings were initially configured.\n\nOn {title} backend\n\nSettings configured on {title} backend are stored in a Gitpod workspace and have On Host label in the IDE settings.\n\nConfigure IDE settings per project\n\nSome IDE settings cannot be configured via environment variables or through setting vm options. These settings can only be set via the UI of JetBrains client, and must be manually copied to be syned between workspaces. The below steps detail how to configure your IDE settings for all the users of a given Gitpod project:\n\nStep 1: Manually use JetBrains UI to configure settings - Set your IDE settings as you normally would, using the JetBrains UI.\n\nStep 2: Find generated IDE settings - You will need to manually find any global settings generated by JetBrains backend within the following path: /workspace/.config/JetBrains&lt;-latest&gt;/RemoteDev-RM/&lt;your-project-name&gt;/options\n\nStep 3: Move any relevant settings manually to a persistent location within your Gitpod project. Either via a Workspace Image, or persisted in the version control of your project, for example by committing settings data to GitHub.\n\nInclude relevant IDE settings in your Workspace Image\n\n/home/gitpod/.gitpod/jetbrains/options - This location applies settings to all JetBrains products (IntelliJ IDEA, GoLang, etc).\n/home/gitpod/.gitpod/jetbrains/rubymine/options - This location will apply settings only to the given IDE, e.g. {title}.\n\nCommit relevant IDE settings to source control\n\n/workspace/&lt;your-project-name&gt;/.gitpod/jetbrains/options - This location applies settings to all JetBrains products (IntelliJ IDEA, GoLang, etc).\n/workspace/&lt;your-project-name&gt;/.gitpod/jetbrains/rubymine/options - This location will apply settings only to the given IDE, e.g. {title}.\n\nFor any further changes to your IDE settings, you will need to follow the above steps again.\n\nNote: When locating and applying IDE settings, Gitpod will read the locations specified above in priority order. The locations specified first are overriden by the locations specified later.\n\nConfigure IDE settings per user\n\nTo configure IDE settings for your user only, and not all those using a project.\n\nFollow the instructions for configuring IDE settings per project, but instead use .dotfiles rather than a workspace image or source control to store your IDE settings.","metadata":{"source":"https://gitpod.io/docs/references/ides-and-editors/rubymine"}}],["608",{"pageContent":"Indexing using Prebuilds\n\nJetBrains Prebuilds is currently in Alpha ¬∑ Send feedback.\n\nWhen you open the project {title} starts indexing to load modules and\nenable the core functionality like code completion and navigation.\nDepending on the size of your project indexing speed can vary significantly.\n\nYou can speed up the indexing of a project by applying these general recommendations.\nGitpod prebuilds allow you to improve it further by indexing before you start a new workspace.\n\nTo leverage it:\n\nconfigure prebuilds for your repository, refer to Prebuilds;\nenable indexing for {title} in prebuilds by editing .gitpod.yml in your repository:\n\n```yaml\njetbrains:\n  rubymine:\n    prebuilds:\n      version: stable\n```\n\npush changes to your Git repository to apply.\n\nThe version property allows you to control whether to index for stable, latest, or both versions of {title} compatible with Gitpod.\nUsers can switch between stable and latest versions of {title} on the user preferences page.\n\n__SPLIT_HERE__\nWorkspace performance\n\nWhen using a Gitpod workspace you might experience performance issues caused by:\n\nAn application using more resources than expected\nResource consumption in adjacent containers running on the workspace node.\n\nIn your JetBrains IDE within the JetBrains Gateway Backend Control Center you can find two metrics relating to your running workspace: Workspace CPU and Workspace Memory.\n\nThe remaining metrics you can find in the Backend Control Center regarding the node that your workspace is running on, and not the workspace itself.\n\nNote: Performance information shown in the Backend Control Center is the same as the information that is shown when running the command gp top in your workspace, see the Command Line Interface documentation for more.\n\njetbrains performance\n\n__SPLIT_HERE__\nFAQs\n\nFor the questions about supported IDEs and Editors in Gitpod, refer to FAQs.\n\n\nFor the general questions about JetBrains Remote Development, refer to refer to the general IDE {title} FAQ.\n\nAre there any JetBrains optimizations I can make if my workspace is slow?\n\nDebugging performance can be challenging, as performance issues can depend on many factors such as how Gitpod is configured (if you&#39;re operating Gitpod on Self-Hosted). However, there are some ways you can gather performance information and optimise your JetBrains IDE setup with Gitpod:\n\nFirstly, to gather information on performance, you can view workspace performance metrics from within the IDE in the Backend Control Center, or by using gp top.\nYou may also want to try adjusting the Max Heap Size allocated to the JetBrains Backend in the Settings tab of the Backend Control Center. If updating this setting helps your performance, you can set the vmoptions value for your JetBrains IDE in your .gitpod.yml.\n\nNote: If the performance metrics show that your workspace is hitting its resource limits, and you are using Gitpod Self-Hosted, it might make sense to consider changing the resource configuration for your workspaces. This can be done via a config-patch. Configuring workspace resources is not yet available on SaaS.\n\n__SPLIT_HERE__\nTroubleshooting\n\nWhat should I do if JetBrains Gateway and Gitpod aren‚Äôt working?\nGitpod logs in JetBrains Client\nGitpod logs in JetBrains Gateway","metadata":{"source":"https://gitpod.io/docs/references/ides-and-editors/rubymine"}}],["609",{"pageContent":"__SPLIT_HERE__\nRider\n\n{title} is currently in Beta ¬∑ Send feedback.\n\n__SPLIT_HERE__\nGetting started\n\nInstall JetBrains Gateway - With the JetBrains Gateway and Gitpod plugin you can create and manage your latest 20 Gitpod workspaces.\nInstall the Gitpod plugin - Open JetBrains Gateway and you&#39;ll see the Gitpod logo on the main page. Click &quot;install&quot; to install the Gitpod plugin for JetBrains Gateway.\nUpdate your Gitpod preferences - Select {title} on the Gitpod preferences page which will set {title} as your default IDE for future workspace starts.\nStart (or restart) your workspace - Either start a workspace directly from within the JetBrains Gateway via the Gitpod plugin OR open a new workspace directly in Gitpod where on workspace start you will be prompted to open {title} for that workspace.\n\nImportant: You must restart any started workspaces for your IDE preferences to take effect.\n\n__SPLIT_HERE__\nPrerequisites\n\nTo successfully use Rider and load a .NET project, your workspace needs the .NET Framework or a compatible alternative, to be installed. The default workspace image does not come with .NET pre-installed, so you have two options:\n\nUsing the .NET workspace image (Recommended)\n\nCreate a .gitpod.yml file\nSet the image property to image: gitpod/workspace-dotnet:latest or alternatively, use a custom Dockerfile\n\nIf you need a specific version of .NET, check out our Dockerfile so you can create your own, specifying the version you need.\n\nFor additional examples, check out .NET in Gitpod.\n\nManually install .NET\n\nUsing a workspace terminal, install dotnet or a compatible alternative\nRestart the IDE\n\nNote: manually installed dependencies are only available in the current workspace, when you start a new workspace dotnet will not be pre-installed, for this reason we recommend the first option.","metadata":{"source":"https://gitpod.io/docs/references/ides-and-editors/rider"}}],["610",{"pageContent":"Install Plugins\n\nThis section relates to plugin management when using JetBrains IDEs in a remote development context. For information on regular plugin management, refer to {title} docs.\n\nUnlike with regular development, JetBrains Remote development with {title} allows users to install plugins in different locations:","metadata":{"source":"https://gitpod.io/docs/references/ides-and-editors/rider"}}],["611",{"pageContent":"{title} backend plugins - The JetBrains {title} backend runs within the remote Gitpod workspace. Backend plugins contribute functionality for IDE experiences relating to the filesystem, tools or languages and frameworks. When installed, a backend plugin only applies to the currently running Gitpod workspace and is not associated with a user. However, a plugin can be preconfigured for all users of a repository so that the plugin is enabled with every workspace start. It is not currently possible to install a backend plugin that applies to all workspaces of a Gitpod user or organization.","metadata":{"source":"https://gitpod.io/docs/references/ides-and-editors/rider"}}],["612",{"pageContent":"JetBrains Client plugins - The JetBrains client runs on the users local machine and can be thought of as the user interface to the remote {title} backend. Client plugins are different to backend plugins as they contribute to the user interface aspect of the IDE experience (e.g. keyboard shortcuts and themes). Once installed, a client plugin is enabled for all Gitpod workspaces the user opens (if the workspace is running the exact same version of the {title} backend where the plugin was initially installed).\nJetBrains Gateway plugins - The JetBrains Gateway is an application downloaded onto a users local machine which allows users to start JetBrains Clients that are compatible with the {title} backend, running in a Gitpod workspace. JetBrains Gateway plugins are installed directly in JetBrains Gateway and contribute to remote development connection experiences (e.g. the Gitpod JetBrains Gateway plugin).","metadata":{"source":"https://gitpod.io/docs/references/ides-and-editors/rider"}}],["613",{"pageContent":"Install on JetBrains Client\n\nThe JetBrains client runs on the users local machine and can be thought of as the user interface to the remote {title} backend. Client plugins contribute to the user interface aspect of the IDE experience (e.g. keyboard shortcuts and themes).\n\nOnce installed, a client plugin is enabled for all Gitpod workspaces the user opens (if the workspace is running the exact same version of the {title} backend where the plugin was initially installed).\n\nTo install a plugin on JetBrains Client follow these steps:\n\nIn JetBrains Client open the IDE settings and select Plugins.\nFind the plugin in the Marketplace and click Install.\n\nInstall on {title} backend\n\nThe JetBrains {title} backend runs within the remote Gitpod workspace. Backend plugins contribute functionality requiring access to IDE experiences such as the remote filesystem (e.g. contributing support of languages and frameworks).","metadata":{"source":"https://gitpod.io/docs/references/ides-and-editors/rider"}}],["614",{"pageContent":"When installed, a backend plugin only applies to the currently running Gitpod workspace and is not associated with a user. However, a plugin can be preconfigured for all users of a repository so that the plugin is enabled with every workspace start.\n\nIt is not currently possible to install a backend plugin that applies to all workspaces of a Gitpod user or organization.\n\nInstall for your current workspace\n\nYou can install a plugin only for your current workspace following these steps:\n\nIn JetBrains Client open the IDE settings and select Plugins On Host.\nFind the plugin in the Marketplace and click Install.\n\nPreconfigure for repository\n\nJetBrains plugin support is currently in Beta ¬∑ Send feedback.\n\nYou can share a plugin on {title} backend with everybody working on the repository by adding it to .gitpod.yml and pushing to your Git repository.\nEach workspace is preconfigured with plugins from the gitpod.yml configuration file. For example:","metadata":{"source":"https://gitpod.io/docs/references/ides-and-editors/rider"}}],["615",{"pageContent":"```yaml\njetbrains:\n  rider:\n    plugins:\n      - zielu.gittoolbox\n      - izhangzhihao.rainbow.brackets\n```\n\nYou can find the pluginId on the JetBrains Marketplace page:\n\nFind a page of the required plugin.\nSelect the Versions tab.\nClick any version to copy the pluginId (short name such as org.rust.lang) of the plugin you want to install.\n\nInstall for your user\n\nIt is not yet possible to install plugins on {title} backend for your user to share across all your Gitpod workspaces.","metadata":{"source":"https://gitpod.io/docs/references/ides-and-editors/rider"}}],["616",{"pageContent":"Configure JVM options\n\nConfiguration of JVM options is currently in Alpha ¬∑ Send feedback.\n\nYou can adjust JVM options for {title} backend, especially if you want to increase the -Xmx memory size. For example:\n\n```yaml\njetbrains:\n  rider:\n    vmoptions: \"-Xmx4g\"\n```\n\nFor more detailed information on JVM options, refer to Common JVM Options from JetBrains documentation.\n\n__SPLIT_HERE__\nConfigure IDE settings\n\nFeedback needed: The JetBrains Gitpod integration is currently beta. Gitpod continues to collaborate with JetBrains. The below shows how you can configure global settings with JetBrains. To leave feedback on the approach, please see this GitHub issue: #6576. Also note that JetBrains is working on comprehensive settings sync functionality.\n\nWhen running {title} locally, the JetBrains IDE applies global settings to all projects on your machine. However when running in a remote context using JetBrains Gateway, it&#39;s important to note that some IDE settings are configured on the JetBrains Client and others in the {title} backend running in your Gitpod Workspace. See below instructions for more.\n\nOn JetBrains Client\n\nIDE Settings that are configured on the JetBrains Client are stored on your local machine and don&#39;t have On Host label in the IDE settings. These IDE settings are reused if the workspace is running the exact same version of the {title} backend where the settings were initially configured.\n\nOn {title} backend\n\nSettings configured on {title} backend are stored in a Gitpod workspace and have On Host label in the IDE settings.\n\nConfigure IDE settings per project\n\nSome IDE settings cannot be configured via environment variables or through setting vm options. These settings can only be set via the UI of JetBrains client, and must be manually copied to be syned between workspaces. The below steps detail how to configure your IDE settings for all the users of a given Gitpod project:\n\nStep 1: Manually use JetBrains UI to configure settings - Set your IDE settings as you normally would, using the JetBrains UI.\n\nStep 2: Find generated IDE settings - You will need to manually find any global settings generated by JetBrains backend within the following path: /workspace/.config/JetBrains&lt;-latest&gt;/RemoteDev-/&lt;your-project-name&gt;/options\n\nStep 3: Move any relevant settings manually to a persistent location within your Gitpod project. Either via a Workspace Image, or persisted in the version control of your project, for example by committing settings data to GitHub.\n\nInclude relevant IDE settings in your Workspace Image\n\n/home/gitpod/.gitpod/jetbrains/options - This location applies settings to all JetBrains products (IntelliJ IDEA, GoLang, etc).\n/home/gitpod/.gitpod/jetbrains/rider/options - This location will apply settings only to the given IDE, e.g. {title}.\n\nCommit relevant IDE settings to source control\n\n/workspace/&lt;your-project-name&gt;/.gitpod/jetbrains/options - This location applies settings to all JetBrains products (IntelliJ IDEA, GoLang, etc).\n/workspace/&lt;your-project-name&gt;/.gitpod/jetbrains/rider/options - This location will apply settings only to the given IDE, e.g. {title}.\n\nFor any further changes to your IDE settings, you will need to follow the above steps again.\n\nNote: When locating and applying IDE settings, Gitpod will read the locations specified above in priority order. The locations specified first are overriden by the locations specified later.\n\nConfigure IDE settings per user\n\nTo configure IDE settings for your user only, and not all those using a project.\n\nFollow the instructions for configuring IDE settings per project, but instead use .dotfiles rather than a workspace image or source control to store your IDE settings.\n\n__SPLIT_HERE__\nIndexing using Prebuilds\n\nCurrently, prebuilds for Rider are not supported. To leave feedback or check for updates, see gitpod/issues/6740.","metadata":{"source":"https://gitpod.io/docs/references/ides-and-editors/rider"}}],["617",{"pageContent":"Indexing using Prebuilds\n\nCurrently, prebuilds for Rider are not supported. To leave feedback or check for updates, see gitpod/issues/6740.\n\n__SPLIT_HERE__\nWorkspace performance\n\nWhen using a Gitpod workspace you might experience performance issues caused by:\n\nAn application using more resources than expected\nResource consumption in adjacent containers running on the workspace node.\n\nIn your JetBrains IDE within the JetBrains Gateway Backend Control Center you can find two metrics relating to your running workspace: Workspace CPU and Workspace Memory.\n\nThe remaining metrics you can find in the Backend Control Center regarding the node that your workspace is running on, and not the workspace itself.\n\nNote: Performance information shown in the Backend Control Center is the same as the information that is shown when running the command gp top in your workspace, see the Command Line Interface documentation for more.\n\njetbrains performance\n\n__SPLIT_HERE__\nFAQs\n\nFor the questions about supported IDEs and Editors in Gitpod, refer to FAQs.\n\n\nFor the general questions about JetBrains Remote Development, refer to refer to the general IDE {title} FAQ.\n\nAre there any JetBrains optimizations I can make if my workspace is slow?\n\nDebugging performance can be challenging, as performance issues can depend on many factors such as how Gitpod is configured (if you&#39;re operating Gitpod on Self-Hosted). However, there are some ways you can gather performance information and optimise your JetBrains IDE setup with Gitpod:\n\nFirstly, to gather information on performance, you can view workspace performance metrics from within the IDE in the Backend Control Center, or by using gp top.\nYou may also want to try adjusting the Max Heap Size allocated to the JetBrains Backend in the Settings tab of the Backend Control Center. If updating this setting helps your performance, you can set the vmoptions value for your JetBrains IDE in your .gitpod.yml.\n\nNote: If the performance metrics show that your workspace is hitting its resource limits, and you are using Gitpod Self-Hosted, it might make sense to consider changing the resource configuration for your workspaces. This can be done via a config-patch. Configuring workspace resources is not yet available on SaaS.\n\n__SPLIT_HERE__\nTroubleshooting\n\nWhat should I do if JetBrains Gateway and Gitpod aren‚Äôt working?\nGitpod logs in JetBrains Client\nGitpod logs in JetBrains Gateway","metadata":{"source":"https://gitpod.io/docs/references/ides-and-editors/rider"}}],["618",{"pageContent":"__SPLIT_HERE__\nVS Code settings sync\n\nVS Code is beloved for its endless customization possibilities.\n\nHowever, you may come across the challenge of having many multiple VS Code instances needing to share the same extensions, themes and settings. Since every start of a Gitpod workspace is a new instance of VS Code, using Settings Sync helps you avoid re-setting your environment for each new workspace and embrace ephemeral Gitpod workspaces.\n\n__SPLIT_HERE__\nHow VS Code Setting Sync works\n\nOnce enabled, Settings Sync polls the backend to ensure that your settings are stored. To save network bandwidth and allow for more frequent synchronization only changed items are pushed to the server after the first sync.\n\nThe following settings are synced via Settings Sync:\n\nVS Code preferences\nKeybindings\nSnippets\nTasks\nInstalled Extensions\nGlobal State\n\n__SPLIT_HERE__\nGitpod vs Microsoft Settings Sync\n\nBy default, most desktop VS Code installations are configured to sync settings via a GitHub or a Microsoft account. These settings are synced to Microsoft&#39;s servers and are inaccessible to third-parties, including Gitpod. Due to this limitation of access to settings stored in Microsoft servers, Gitpod implements its own VS Code settings sync server. Gitpod Settings Sync is enabled by default for VS Code in the browser, but must be configured for desktop.\n\nEnabling Settings Sync in VS Code Browser\n\nVS Code in the browser with Gitpod has Settings Sync enabled by default, syncing preferences to Gitpod&#39;s servers.\n\nEnabling Settings Sync in VS Code Desktop\n\nInstall and enable the Gitpod extension.\n\nNote: If you open VS Code Desktop directly from Gitpod, the Gitpod extension is automatically installed for you.\n\nUsing the Command Palette select: &quot;Settings Sync: Enable signing in with Gitpod&quot;.\n\nEnable Settings Sync with Gitpod\nEnable Settings Sync with Gitpod\nEnable Settings Sync with Gitpod\n\nRestart your VS Code Desktop application.\n\nImportant: You must entirely close VS Code Desktop for changes to take effect.\n\nEnable settings sync from the Manage gear menu at the bottom of the Activity Bar.\n\nYou must authenticate with Gitpod to enable settings sync.\n\nYou will be prompted which settings to sync, and to authenticate via Gitpod.\n\nResolve any settings conflicts\n\nSettings in VS Code Desktop might differ from your remote settings, follow the instructions in VS Code to resolve any conflicts with the preferences files.\n\n__SPLIT_HERE__\nFAQs\n\nHow do I disable VS Code Settings Sync?\n\nSearch for settings sync off in your VS Code Command Palette and hit Enter.\n\nNote: This will only work properly inside of VS Code Desktop. If you choose to disable Settings Sync inside of VS Code Browser, you will have to disable it in every new workspace and every time a workspace restarts.","metadata":{"source":"https://gitpod.io/docs/references/ides-and-editors/settings-sync"}}],["619",{"pageContent":"__SPLIT_HERE__\nVS Code extensions\n\nGitpod already comes well equipped for most development tasks, and provides language support for the most popular programming languages such as Python, JavaScript, Go, Rust, C/C++, Java, Ruby, and many more out of the box.\n\nStill, you may wish to customize Gitpod, or to extend it with new features. You can do this by installing VS Code extensions.\n\nyoutube: TwXYbZKEuoA\n\n__SPLIT_HERE__\nInstalling an Extension\n\nTo install a VS Code extension in Gitpod, simply go to the left vertical menu, and open the Extensions view. There you can search for an extension and install it with one click.\n\nFor VS Code Browser, we use the Open VSX registry. If you can&#39;t find an extension you use in your local VS Code, please read the &quot;Where do I find extensions?&quot; section below.\n\nIf the extension is helpful to anyone who works on the project, you can add it to the .gitpod.yml configuration file so that it gets installed for anyone who works on the project. To do that:\n\nVisit the extension page (where you installed it from)\nClick the settings icon\nSelect &quot;Add to .gitpod.yml&quot; from the menu\n\nYour project&#39;s .gitpod.yml is updated automatically and lists the given extension. You can also directly edit this file to install or remove extensions manually.\n\nHere is an example of what a .gitpod.yml with installed extensions may look like:\n\n```yaml\nvscode:\n  extensions:\n    - svelte.svelte-vscode\n    - bradlc.vscode-tailwindcss@0.6.11\n    - https://example.com/abc/releases/extension-0.26.0.vsix\n```\n\nYou can share the installed extensions with your organization by committing the .gitpod.yml change and pushing it to your Git repository.\n\nExtensions are installed in the /workspace/.vscode-remote/extensions/ directory.\n\n__SPLIT_HERE__\nUser Extensions\n\nYou have two options to install extensions for yourself only:\n\nFor the current workspace only - if you don&#39;t want extensions to be synced across workspaces, select Install (Do Not Sync) instead of Install when installing new extensions.\nFor all your workspaces - can be useful for extensions that you want to have in all your projects (for example a custom theme), and this doesn&#39;t require changing every project&#39;s .gitpod.yml configuration. All manually installed extensions are synced across workspaces by default.\n\nYou can read more about why and how extensions are synced on the Settings Sync page.\n\n__SPLIT_HERE__\nBuilt-in Extensions\n\nGitpod already comes with a number of commonly used VS Code extensions pre-installed by default.\n\nYou can view all pre-installed extensions by navigating to VS Code&#39;s Extensions section on the left-hand side. In the &quot;Search Extensions in Marketplace&quot; input field, type @builtin to see the built-in extensions.\n\n__SPLIT_HERE__\nUse of Microsoft-owned extensions in Gitpod\n\nYou can only use extensions available on the Open VSX registry with VS Code Browser on Gitpod. Microsoft only permits use of their marketplace via &quot;Microsoft‚Äôs publicly supported interfaces&quot; (see their ToS section 1f), and this restriction applies to the Gitpod VS Code Browser integration. If you wish to use extensions from Microsoft&#39;s VS Code Marketplace, you must use VS Code Desktop.\n\nThe following extensions are therefore not available in VS Code Browser:\n\nMicrosoft Pylance\nMicrosoft C#\nMicrosoft .Net\nMicrosoft C++\nGitHub Copilot\n\n__SPLIT_HERE__\nInstall VS Code extensions from a VSIX file\n\nIt is possible to develop, install and test your own custom VS Code extensions in Gitpod. While developing the extension, you can test it by uploading the .vsix file to your Gitpod workspace.\n\nPlease note:\n\nYou can install any private extensions using manual VSIX installation.\nInstalling a .vsix in Gitpod does not list that extension anywhere public.\nAny .vsix referenced in the .gitpod.yml must be publicly accessible.","metadata":{"source":"https://gitpod.io/docs/references/ides-and-editors/vscode-extensions"}}],["620",{"pageContent":"Open VSX\n\nOpen VSX is an open source VS Code extensions registry. For VS Code Browser in Gitpod, Gitpod uses a self-hosted mirror of the public Open VSX instance provided by the Eclipse Foundation, open-vsx.org. Any extensions published to Open VSX are immediately reflected in the Gitpod OpenVSX mirror.\n\nWhy do we need Open VSX?\n\nVS Code Browser is prohibited from accessing the Microsoft VS Code Extensions marketplace.\n\nSee Use of Microsoft owned extensions in Gitpod for more.\n\nWhere do I find extensions?\n\nIf you cannot find an extension by searching in Gitpod using VS Code Browser, the extension, in many cases, was not yet added to the Open VSX registry.\n\nIn that case, please reach out to the extension author and politely ask them to publish their extension to the vendor-neutral, open-source Open VSX registry. The &quot;how to Publish an Extension&quot; docs provide step-by-step instructions.\n\nNote: .vsix files downloaded from the Visual Studio Marketplace should not be installed in Gitpod.\n\nSee Use of Microsoft owned extensions in Gitpod for more.","metadata":{"source":"https://gitpod.io/docs/references/ides-and-editors/vscode-extensions"}}],["621",{"pageContent":"__SPLIT_HERE__\nVS Code Browser\n\nVS Code Browser is the default editor that workspaces open in when using Gitpod. You can even configure your VS Code extension preferences by updating your .gitpod.yml.\n\nVS Code\n\n__SPLIT_HERE__\nChanging the VS Code Browser version\n\nVS Code Browser in Gitpod is based on a fork of VS Code called OpenVSCode Server\n. VS Code in the browser in Gitpod is updated frequently, to use the latest nightly build of Gitpod you can switch to the &quot;insiders&quot; version of VS Code from your Gitpod preferences page.\n\n__SPLIT_HERE__\nSettings Sync\n\nBy default, all your extensions and other preferences are synced between all of your workspaces on Gitpod. You can read more about over at Settings Sync.\n\n__SPLIT_HERE__\nUpload Files\n\nYou can upload files to your workspace by dragging and dropping them into the editor. You can also upload files by clicking the &quot;Upload&quot; button in the file explorer.","metadata":{"source":"https://gitpod.io/docs/references/ides-and-editors/vscode-browser"}}],["622",{"pageContent":"__SPLIT_HERE__\nVS Code Desktop\n\nWith VS Code Desktop Support, you keep your local editor configurations1 and benefit from Gitpod&#39;s high-spec servers &amp; automated prebuilds. As usual, your code executes in an ephemeral Gitpod workspace, keeping each of your projects isolated from one another.\n\nyoutube: kI6firDA0Bw\n\n__SPLIT_HERE__\nOpen a workspace in VS Code Desktop\n\nThere are currently three supported ways to open a VS Code Desktop session connected to a Gitpod workspace, either by opening it from the Gitpod dashboard, choosing VS Code Desktop as your default preference, or directly from within VS Code Browser itself.\n\nOpen VS Code Desktop from the Gitpod Dashboard\n\nYou can start a workspace with VS Code Desktop directly from Gitpod Dashboard. You can do that from by clicking on the New Workspace button. Then, you can select the context url, Editor and custom workspace class.\n\nOpen VS Code Desktop from VS Code Browser\n\nStart a new Gitpod workspace\nOpen the command palette (CtrlCmd + Shift + P)\nType &quot;Open in VS Code&quot; and hit Enter\n\nYou will now be redirected to VS Code Desktop.\n\nOpen VS Code via the Command Palette\nOpen VS Code via the Command Palette\nOpen VS Code via the Command Palette\n\nOpen VS Code Desktop using your preferences\n\nNavigate to your Gitpod preferences\nSelect &quot;VS Code&quot; (without the browser label)\nRestart any running workspaces\n\nWhen the workspace starts, you will be prompted to open VS Code Desktop. You can also access your workspace using VS Code Browser, or copy SSH credentials from this page.\n\nOpen VS Code Desktop from the workspace start page\nOpen VS Code Desktop from the workspace start page\nOpen VS Code Desktop from the workspace start page\n\nSelecting VS Code Desktop as an editor preference\nSelecting VS Code Desktop as an editor preference\nSelecting VS Code Desktop as an editor preference","metadata":{"source":"https://gitpod.io/docs/references/ides-and-editors/vscode"}}],["623",{"pageContent":"Connecting to VS Code Desktop (SSH)\n\nThe three main methods granting VS Code Desktop access to your workspace are:\n\nSSH Gateway access using an uploaded public SSH key (recommended)\nSSH Gateway access using the owner token\nUsing Local Companion (legacy)\n\nSee configure SSH for more on SSH Gateway.\n\nImportant: You must first ensure that gitpod.remote.useLocalApp is set to false in your VS Code user preferences for Gitpod to connect via the two SSH Gateway methods.\n\nConnect to VS Code Desktop using an uploaded public SSH key\n\nFirst, VS Code Desktop will check if you have already added a public SSH key to Gitpod and that the associated private key is available on your device.\n\nIf you haven&#39;t set up an SSH key with Gitpod, you can go to gitpod.io/keys to upload a public key. Alternatively, you can continue using the owner token approach detailed below.\n\nYou must have at least one public key uploaded to Gitpod, and a matching private key locally on your device to avoid this prompt. VS Code Desktop will look to find private keys in the following named files within the .ssh directory listed under your home directory.\n\nid_dsa\nid_dsa\nid_ecdsa\nid_rsa\nid_ed25519\nid_xmss\nid_ecdsa_sk\nid_ed25519_sk\n\nConnect to VS Code Desktop using the workspace owner token\n\nIf you cannot upload a public key to Gitpod (for whatever reason) selecting Copy will allow you to proceed to access your Gitpod workspace using the owner token approach. Selecting Copy will copy the necessary password to your clipboard to be pasted in the subsequent password prompt.\n\nVS Code prompting for a password. This message is shown when the public key warning notice is dismissed on the previous page by selecting Copy\nVS Code prompting for a password. This message is shown when the public key warning notice is dismissed on the previous page by selecting Copy\nVS Code prompting for a password. This message is shown when the public key warning notice is dismissed on the previous page by selecting Copy.\n\nNote: Gitpod previously required a local private SSH key to be stored in the default SSH directory, otherwise Gitpod would prompt for a &quot;password&quot;. This limitation is no longer required. If not using an SSH uploaded key, you may be prompted for a password (the owner token), or asked for the passphrase associated with your SSH key.\n\nConnect to VS Code Desktop using Local Companion (Legacy)\n\nIf VS Code Desktop cannot connect directly via the SSH Gateway methods described above, the Local Companion approach is used as a fallback to tunnel your SSH connection. Gitpod via the VS Code Desktop plugin will download and start the Local Companion process on your behalf.\n\nThis approach is not recommended because:\n\nIt overwrites your remote.SSH.configFile VS Code setting.\nDownloads and starts Local Companion in a non-transparent way.\nIs less performant than the SSH Gateway approach.\n\nIf required, you manually can force VS Code Desktop to always fallback to the Local Companion by setting the property gitpod.remote.useLocalApp in your user preferences to true.\n\nThe VS Code Desktop Gitpod extension useLocalApp setting\nThe VS Code Desktop Gitpod extension useLocalApp setting\nThe VS Code Desktop Gitpod extension &quot;useLocalApp&quot; setting\n\nDeprecation Notice: The fallback SSH connection using Local Companion for VS Code Desktop will be deprecated in a future release of Gitpod. If you cannot connect to your workspaces directly via SSH, for example, because your firewall is blocking the SSH connection, please contact support with troubleshooting logs.","metadata":{"source":"https://gitpod.io/docs/references/ides-and-editors/vscode"}}],["624",{"pageContent":"Reconnect to VS Code Desktop\n\nWhen VS Code Desktop disconnects from the workspace, either you are experiencing genuine connectivity issues, or it&#39;s possible that the workspace has timed out and stopped.\n\nVS Code Desktop attempting to reconnect\nVS Code Desktop attempting to reconnect\nVS Code Desktop attempting to reconnect\n\nTo restart the workspace, click Open Workspace from the workspace start page or from the dashboard and VS Code Desktop should automatically reconnect.\n\nPlease note: There is currently no way to start a workspace directly from VS Code Desktop.\n\nOpen workspace button shown on a stopped workspace page\nOpen workspace button shown on a stopped workspace page\nThe open workspace button shown on a stopped workspace page\n\n__SPLIT_HERE__\nVS Code settings sync\n\nYou can optionally enable Settings Sync with Gitpod to keep your extensions, themes and settings up-to-date with VS Code Browser and Desktop. See VS Code settings sync for more\n\nEnable Settings Sync with Gitpod\nEnable Settings Sync with Gitpod\nEnable Settings Sync with Gitpod\n\n__SPLIT_HERE__\nManaging VS Code extensions\n\nVS Code runs extensions in one of two places: locally on the UI / client side, or remotely on your Gitpod workspace.\n\nFor further details, please refer to the official VS Code docs on how to manage extensions.\n\n__SPLIT_HERE__\nCustom fonts in VS Code Desktop\n\nThe process of installing fonts matches how you typically install custom fonts locally:\n\nDownload the desired font to your local machine and install it locally on your operating system.\nOpen the editor&#39;s user settings (e.g. File &gt; Preferences &gt; Settings &gt; User)\nConfigure your font with the editor.fontFamily setting:```json\n{\n  \"editor.fontFamily\": \"Your custom font name\"\n}\n```","metadata":{"source":"https://gitpod.io/docs/references/ides-and-editors/vscode"}}],["625",{"pageContent":"Optimizing VS Code Desktop\n\nIf you&#39;re using VS Code Desktop for frequent work you&#39;ll want to optimize your setup. Below are some tips to get a workspace set up as efficient as possible.\n\nSSH fingerprint\n\nAccepting the SSH fingerprint in VS Code\nAccepting the SSH fingerprint in VS Code\nAccepting the SSH fingerprint in VS Code\n\nIt is common convention to be asked for a fingerprint when accessing a new SSH server. When the fingerprint is accepted, a reference to the server is stored in your local known_hosts file, which suppresses subsequent SSH connection prompts for that server.\n\nYou should only be presented with a request to trust the Gitpod workspace when using the legacy Local Companion approach of connecting to VS Code Desktop.\n\nBy swapping to the SSH Gateway approach of accessing VS Code Desktop, your known hosts file will be updated automatically. See connecting to VS Code Desktop for more.\n\nWorkspace Trust\n\nThe VS Code Workspace Trust popup\nThe VS Code Workspace Trust popup\nThe VS Code Workspace Trust popup\n\nWorkspace Trust is a feature within VS Code implemented to help prevent automatic code execution by disabling or limiting the operation of several VS Code features: tasks, debugging, workspace settings, and extensions.\n\nWhen opening a Gitpod workspace with VS Code Desktop for the first time you will be prompted by a trust modal (given that you have not disabled the workspace trust setting in VS Code).\n\nSelecting &quot;Yes, I trust the authors&quot; will open the workspace and store a reference to the workspace host and directory. Opening the same workspace will not show the prompt again. However, due to a hostname change, new workspaces require trust to be accepted on first open.\n\nChoosing &quot;No, I do not trust the authors&quot; will enter you into the VS Code Restricted Mode. You can edit code in your workspace, but some features will be restricted. You can disable the VS Code Restricted Mode after the initial prompt.\n\nIf required, you can disable the workspace trust feature, however this is not recommended. Select &quot;Manage Workspace Trust&quot; from the Manage gear menu to view and modify your VS Code Workspace Trust settings.\n\nUpdating Workspace Trust settings\nUpdating Workspace Trust settings\nUpdating Workspace Trust settings\n\nSee Workspace Trust in the VS Code official documentation for more.","metadata":{"source":"https://gitpod.io/docs/references/ides-and-editors/vscode"}}],["626",{"pageContent":"FAQs\n\nWhen opening VS Code Desktop, the owner token wasn&#39;t copied to my clipboard, where can I find it?\n\nWhen opening VS Code Desktop, if you are being prompted for the owner token password, but cannot copy it to clipboard, you can find the password on the gitpod workspaces page under &quot;connect via SSH&quot;.\n\nThe password prompt in VS Code Desktop for the owner token\nThe password prompt in VS Code Desktop for the owner token\nThe password prompt in VS Code Desktop for the owner token\n\nAccessing the owner token string manually from the Gitpod dashboard\nAccessing the owner token string manually from the Gitpod dashboard\nAccessing the owner token string manually from the Gitpod dashboard\n\nNote: Pattern of the owner token is: user#password@host\n\nHow do I know whether I&#39;m connecting to VS Code Desktop via Local Companion or SSH Gateway?\n\nIf you&#39;re unsure whether you&#39;re connecting via the local companion, or SSH Gateway approach, when connected to your Gitpod workspace, VS Code Desktop will show the connection host in the bottom left.\n\nSSH Gateway - SSH: workspaceid.ssh.*.gitpod.io\nLocal Companion: workspaceid (no domain)\n\nThe SSH host information shown in the bottom left of VS Code Desktop\nThe SSH host information shown in the bottom left of VS Code Desktop\nThe SSH host information shown in the bottom left of VS Code Desktop\n\nI&#39;m being asked to choose the platform of the remote host. What should I choose?\n\nWhen connecting, sometimes VS Code Desktop fails to automatically detect the host OS of a Gitpod workspace, asking the following: Select the platform of the remote host &quot;{id}&quot;.\n\nNo matter what the OS is on your computer, you should always choose Linux as the remote host platform, since this is the operating system all Gitpod workspaces run on.\n\nIf you choose another option, you may encounter an error like this:\n\n```text\nResolver error: Error: Got bad result from install script\n```\n\nI&#39;m being prompted for a password/passphrase but VS Code Desktop cannot authenticate?\n\nThe owner token prompt and passphrase prompt in VS Code Desktop can look similar, however require different inputs. If you&#39;re seeing a failure to connect it could be you are using the incorrect authentication method, e.g. pasting an owner token for a passphrase, or vice versa.\n\nOwner token - If the password prompt in VS Code Desktop asks Enter password for workspace@\\*.gitpod.io, this prompt is for the owner token of the workspace, not the passphrase associated with your SSH key.\n\nThe password prompt in VS Code Desktop for the owner token\nThe password prompt in VS Code Desktop for the owner token\nThe password prompt in VS Code Desktop for the owner token\n\nAccessing the owner token string manually from the Gitpod dashboard\nAccessing the owner token string manually from the Gitpod dashboard\nAccessing the owner token string manually from the Gitpod dashboard\n\nSSH key Passphrase - If your SSH key has a &quot;passphrase&quot; associated with the SSH key (it is not required for SSH keys), you&#39;ll need to enter your passphrase. If your public key has no passphrase, you should not see the passphrase prompt.\n\nPassphrase prompt from VS Code requiring the SSH key passphrase\nPassphrase prompt from VS Code requiring the SSH key passphrase\n\nNote: If you cannot remember your passphrase, consider creating a new SSH key and uploading the new key to Gitpod.\n\nHow do I enable SSH agent forwarding for Desktop VSCode?\n\nGitpod extension delegates ssh connection to the MS Remote - SSH extension so agent forwarding should just work if you configure it in your ~/.ssh/config file:\n\n```\nHost *.gitpod.io\n    ForwardAgent yes\n```\n\n__SPLIT_HERE__\nUpload Files\n\nYou can upload files to your workspace by dragging and dropping them into the editor. This method works with every IDE (e.g. Intellij, PyCharm, etc.)","metadata":{"source":"https://gitpod.io/docs/references/ides-and-editors/vscode"}}],["627",{"pageContent":"Upload Files\n\nYou can upload files to your workspace by dragging and dropping them into the editor. This method works with every IDE (e.g. Intellij, PyCharm, etc.)\n\n__SPLIT_HERE__\nTroubleshooting\n\nIf you are still having issues connecting to VS Code Desktop from Gitpod, try:\n\nChecking your Gitpod VS Code Desktop extension version is using the latest version.\nAttempt to directly connect via SSH using the -v to show verbose SSH logs. For example: ssh -v workspacename@hostname. You can find the ssh command in the workspace list on your Gitpod dashboard, see the command-line docs for more.\nIf you&#39;re a self-hosted customer, ensure SSH Gateway is configured correctly.\n\nIf you are still experiencing issues using VS Code Desktop and Gitpod, please contact support with any related troubleshooting logs","metadata":{"source":"https://gitpod.io/docs/references/ides-and-editors/vscode"}}],["628",{"pageContent":"__SPLIT_HERE__\nWebStorm\n\n{title} is currently in Beta ¬∑ Send feedback.\n\n__SPLIT_HERE__\nGetting started\n\nInstall JetBrains Gateway - With the JetBrains Gateway and Gitpod plugin you can create and manage your latest 20 Gitpod workspaces.\nInstall the Gitpod plugin - Open JetBrains Gateway and you&#39;ll see the Gitpod logo on the main page. Click &quot;install&quot; to install the Gitpod plugin for JetBrains Gateway.\nUpdate your Gitpod preferences - Select {title} on the Gitpod preferences page which will set {title} as your default IDE for future workspace starts.\nStart (or restart) your workspace - Either start a workspace directly from within the JetBrains Gateway via the Gitpod plugin OR open a new workspace directly in Gitpod where on workspace start you will be prompted to open {title} for that workspace.\n\nImportant: You must restart any started workspaces for your IDE preferences to take effect.","metadata":{"source":"https://gitpod.io/docs/references/ides-and-editors/webstorm"}}],["629",{"pageContent":"Install Plugins\n\nThis section relates to plugin management when using JetBrains IDEs in a remote development context. For information on regular plugin management, refer to {title} docs.\n\nUnlike with regular development, JetBrains Remote development with {title} allows users to install plugins in different locations:","metadata":{"source":"https://gitpod.io/docs/references/ides-and-editors/webstorm"}}],["630",{"pageContent":"{title} backend plugins - The JetBrains {title} backend runs within the remote Gitpod workspace. Backend plugins contribute functionality for IDE experiences relating to the filesystem, tools or languages and frameworks. When installed, a backend plugin only applies to the currently running Gitpod workspace and is not associated with a user. However, a plugin can be preconfigured for all users of a repository so that the plugin is enabled with every workspace start. It is not currently possible to install a backend plugin that applies to all workspaces of a Gitpod user or organization.","metadata":{"source":"https://gitpod.io/docs/references/ides-and-editors/webstorm"}}],["631",{"pageContent":"JetBrains Client plugins - The JetBrains client runs on the users local machine and can be thought of as the user interface to the remote {title} backend. Client plugins are different to backend plugins as they contribute to the user interface aspect of the IDE experience (e.g. keyboard shortcuts and themes). Once installed, a client plugin is enabled for all Gitpod workspaces the user opens (if the workspace is running the exact same version of the {title} backend where the plugin was initially installed).\nJetBrains Gateway plugins - The JetBrains Gateway is an application downloaded onto a users local machine which allows users to start JetBrains Clients that are compatible with the {title} backend, running in a Gitpod workspace. JetBrains Gateway plugins are installed directly in JetBrains Gateway and contribute to remote development connection experiences (e.g. the Gitpod JetBrains Gateway plugin).","metadata":{"source":"https://gitpod.io/docs/references/ides-and-editors/webstorm"}}],["632",{"pageContent":"Install on JetBrains Client\n\nThe JetBrains client runs on the users local machine and can be thought of as the user interface to the remote {title} backend. Client plugins contribute to the user interface aspect of the IDE experience (e.g. keyboard shortcuts and themes).\n\nOnce installed, a client plugin is enabled for all Gitpod workspaces the user opens (if the workspace is running the exact same version of the {title} backend where the plugin was initially installed).\n\nTo install a plugin on JetBrains Client follow these steps:\n\nIn JetBrains Client open the IDE settings and select Plugins.\nFind the plugin in the Marketplace and click Install.\n\nInstall on {title} backend\n\nThe JetBrains {title} backend runs within the remote Gitpod workspace. Backend plugins contribute functionality requiring access to IDE experiences such as the remote filesystem (e.g. contributing support of languages and frameworks).","metadata":{"source":"https://gitpod.io/docs/references/ides-and-editors/webstorm"}}],["633",{"pageContent":"When installed, a backend plugin only applies to the currently running Gitpod workspace and is not associated with a user. However, a plugin can be preconfigured for all users of a repository so that the plugin is enabled with every workspace start.\n\nIt is not currently possible to install a backend plugin that applies to all workspaces of a Gitpod user or organization.\n\nInstall for your current workspace\n\nYou can install a plugin only for your current workspace following these steps:\n\nIn JetBrains Client open the IDE settings and select Plugins On Host.\nFind the plugin in the Marketplace and click Install.\n\nPreconfigure for repository\n\nJetBrains plugin support is currently in Beta ¬∑ Send feedback.\n\nYou can share a plugin on {title} backend with everybody working on the repository by adding it to .gitpod.yml and pushing to your Git repository.\nEach workspace is preconfigured with plugins from the gitpod.yml configuration file. For example:","metadata":{"source":"https://gitpod.io/docs/references/ides-and-editors/webstorm"}}],["634",{"pageContent":"```yaml\njetbrains:\n  webstorm:\n    plugins:\n      - zielu.gittoolbox\n      - izhangzhihao.rainbow.brackets\n```\n\nYou can find the pluginId on the JetBrains Marketplace page:\n\nFind a page of the required plugin.\nSelect the Versions tab.\nClick any version to copy the pluginId (short name such as org.rust.lang) of the plugin you want to install.\n\nInstall for your user\n\nIt is not yet possible to install plugins on {title} backend for your user to share across all your Gitpod workspaces.","metadata":{"source":"https://gitpod.io/docs/references/ides-and-editors/webstorm"}}],["635",{"pageContent":"Configure JVM options\n\nConfiguration of JVM options is currently in Alpha ¬∑ Send feedback.\n\nYou can adjust JVM options for {title} backend, especially if you want to increase the -Xmx memory size. For example:\n\n```yaml\njetbrains:\n  webstorm:\n    vmoptions: \"-Xmx4g\"\n```\n\nFor more detailed information on JVM options, refer to Common JVM Options from JetBrains documentation.\n\n__SPLIT_HERE__\nConfigure IDE settings\n\nFeedback needed: The JetBrains Gitpod integration is currently beta. Gitpod continues to collaborate with JetBrains. The below shows how you can configure global settings with JetBrains. To leave feedback on the approach, please see this GitHub issue: #6576. Also note that JetBrains is working on comprehensive settings sync functionality.\n\nWhen running {title} locally, the JetBrains IDE applies global settings to all projects on your machine. However when running in a remote context using JetBrains Gateway, it&#39;s important to note that some IDE settings are configured on the JetBrains Client and others in the {title} backend running in your Gitpod Workspace. See below instructions for more.\n\nOn JetBrains Client\n\nIDE Settings that are configured on the JetBrains Client are stored on your local machine and don&#39;t have On Host label in the IDE settings. These IDE settings are reused if the workspace is running the exact same version of the {title} backend where the settings were initially configured.\n\nOn {title} backend\n\nSettings configured on {title} backend are stored in a Gitpod workspace and have On Host label in the IDE settings.\n\nConfigure IDE settings per project\n\nSome IDE settings cannot be configured via environment variables or through setting vm options. These settings can only be set via the UI of JetBrains client, and must be manually copied to be syned between workspaces. The below steps detail how to configure your IDE settings for all the users of a given Gitpod project:\n\nStep 1: Manually use JetBrains UI to configure settings - Set your IDE settings as you normally would, using the JetBrains UI.\n\nStep 2: Find generated IDE settings - You will need to manually find any global settings generated by JetBrains backend within the following path: /workspace/.config/JetBrains&lt;-latest&gt;/RemoteDev-WS/&lt;your-project-name&gt;/options\n\nStep 3: Move any relevant settings manually to a persistent location within your Gitpod project. Either via a Workspace Image, or persisted in the version control of your project, for example by committing settings data to GitHub.\n\nInclude relevant IDE settings in your Workspace Image\n\n/home/gitpod/.gitpod/jetbrains/options - This location applies settings to all JetBrains products (IntelliJ IDEA, GoLang, etc).\n/home/gitpod/.gitpod/jetbrains/webstorm/options - This location will apply settings only to the given IDE, e.g. {title}.\n\nCommit relevant IDE settings to source control\n\n/workspace/&lt;your-project-name&gt;/.gitpod/jetbrains/options - This location applies settings to all JetBrains products (IntelliJ IDEA, GoLang, etc).\n/workspace/&lt;your-project-name&gt;/.gitpod/jetbrains/webstorm/options - This location will apply settings only to the given IDE, e.g. {title}.\n\nFor any further changes to your IDE settings, you will need to follow the above steps again.\n\nNote: When locating and applying IDE settings, Gitpod will read the locations specified above in priority order. The locations specified first are overriden by the locations specified later.\n\nConfigure IDE settings per user\n\nTo configure IDE settings for your user only, and not all those using a project.\n\nFollow the instructions for configuring IDE settings per project, but instead use .dotfiles rather than a workspace image or source control to store your IDE settings.","metadata":{"source":"https://gitpod.io/docs/references/ides-and-editors/webstorm"}}],["636",{"pageContent":"Indexing using Prebuilds\n\nJetBrains Prebuilds is currently in Alpha ¬∑ Send feedback.\n\nWhen you open the project {title} starts indexing to load modules and\nenable the core functionality like code completion and navigation.\nDepending on the size of your project indexing speed can vary significantly.\n\nYou can speed up the indexing of a project by applying these general recommendations.\nGitpod prebuilds allow you to improve it further by indexing before you start a new workspace.\n\nTo leverage it:\n\nconfigure prebuilds for your repository, refer to Prebuilds;\nenable indexing for {title} in prebuilds by editing .gitpod.yml in your repository:\n\n```yaml\njetbrains:\n  webstorm:\n    prebuilds:\n      version: stable\n```\n\npush changes to your Git repository to apply.\n\nThe version property allows you to control whether to index for stable, latest, or both versions of {title} compatible with Gitpod.\nUsers can switch between stable and latest versions of {title} on the user preferences page.\n\n__SPLIT_HERE__\nWorkspace performance\n\nWhen using a Gitpod workspace you might experience performance issues caused by:\n\nAn application using more resources than expected\nResource consumption in adjacent containers running on the workspace node.\n\nIn your JetBrains IDE within the JetBrains Gateway Backend Control Center you can find two metrics relating to your running workspace: Workspace CPU and Workspace Memory.\n\nThe remaining metrics you can find in the Backend Control Center regarding the node that your workspace is running on, and not the workspace itself.\n\nNote: Performance information shown in the Backend Control Center is the same as the information that is shown when running the command gp top in your workspace, see the Command Line Interface documentation for more.\n\njetbrains performance\n\n__SPLIT_HERE__\nFAQs\n\nFor the questions about supported IDEs and Editors in Gitpod, refer to FAQs.\n\n\nFor the general questions about JetBrains Remote Development, refer to refer to the general IDE {title} FAQ.\n\nAre there any JetBrains optimizations I can make if my workspace is slow?\n\nDebugging performance can be challenging, as performance issues can depend on many factors such as how Gitpod is configured (if you&#39;re operating Gitpod on Self-Hosted). However, there are some ways you can gather performance information and optimise your JetBrains IDE setup with Gitpod:\n\nFirstly, to gather information on performance, you can view workspace performance metrics from within the IDE in the Backend Control Center, or by using gp top.\nYou may also want to try adjusting the Max Heap Size allocated to the JetBrains Backend in the Settings tab of the Backend Control Center. If updating this setting helps your performance, you can set the vmoptions value for your JetBrains IDE in your .gitpod.yml.\n\nNote: If the performance metrics show that your workspace is hitting its resource limits, and you are using Gitpod Self-Hosted, it might make sense to consider changing the resource configuration for your workspaces. This can be done via a config-patch. Configuring workspace resources is not yet available on SaaS.\n\n__SPLIT_HERE__\nTroubleshooting\n\nWhat should I do if JetBrains Gateway and Gitpod aren‚Äôt working?\nGitpod logs in JetBrains Client\nGitpod logs in JetBrains Gateway","metadata":{"source":"https://gitpod.io/docs/references/ides-and-editors/webstorm"}}],["637",{"pageContent":"__SPLIT_HERE__\nSecurity FAQ\n\n__SPLIT_HERE__\nWhat type of data does Gitpod collect?\n\nGitpod processes first name, last name, and email in order to provide the services, in addition to the user account from your company‚Äôs code repository. For more information, please contact your Account Manager for the Gitpod DPA.\n\n__SPLIT_HERE__\nHow does Gitpod integrate with code repositories?\n\nAuthentication occurs via OAuth tokens which can be revoked and/or re-authorized at any time.\n\n__SPLIT_HERE__\nHow is data secured within the Gitpod platform?\n\nAll Workspace content is encrypted at rest with (AES256) and in-transit (TLS 1.2 or above).\n\n__SPLIT_HERE__\nAre Workspaces isolated?\n\nWorkspaces deploy as Kubernetes pods. Each Workspace operates within its own set of namespaces, so that they cannot interfere with each other.\n\n__SPLIT_HERE__\nHow is Gitpod‚Äôs Infrastructure deployed?\n\nGitpod is deployed on GCP and AWS. Their certifications are available here and here.\n\n__SPLIT_HERE__\nWhat certifications does Gitpod have?\n\nWe are SOC 2 Type 2 compliant for two years running and conduct pentesting at least annually. Reports are available upon request and under MNDA; please contact your Account Manager.\n\n__SPLIT_HERE__\nHow does Gitpod deploy?\n\nGitpod can be hosted end-to-end by us, or deployed by you in your own AWS account. For more information, please see this link for deployment architecture.","metadata":{"source":"https://gitpod.io/docs/references/security/faq"}}],["638",{"pageContent":"__SPLIT_HERE__\nBackground\n\n‚ö†Ô∏è Self-hosted as a product is no longer supported\n\nThe last official update of this product is the November 2022 self-hosted release. We no longer sell commercial self-hosted licenses. If you want to self-host Gitpod, you can still request our free community license. However, we no longer offer support or updates for it. If you are interested in an isolated, private installation of Gitpod, take a look at Gitpod Dedicated.\nRead our blog on Gitpod Dedicated to learn why we made the decision to discontinue self-hosted.\n\nThis section gives you relevant background information about Gitpod Self-Hosted:\n\nDisaster Recovery - Best practices around disaster recovery","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/background"}}],["639",{"pageContent":"__SPLIT_HERE__\nHow to Backup and Restore Gitpod\n\n‚ö†Ô∏è Self-hosted as a product is no longer supported\n\nThe last official update of this product is the November 2022 self-hosted release. We no longer sell commercial self-hosted licenses. If you want to self-host Gitpod, you can still request our free community license. However, we no longer offer support or updates for it. If you are interested in an isolated, private installation of Gitpod, take a look at Gitpod Dedicated.\nRead our blog on Gitpod Dedicated to learn why we made the decision to discontinue self-hosted.\n\nFor business continuity purposes, it is important to think about how you might restore your ability to use Gitpod, and thus develop software in the event of a catastrophic failure of Gitpod or the underlying infrastructure it runs on. This guide assumes that you will use the backup and restore strategy for disaster recovery and will guide you towards what needs to be backed up and how to restore using said backup. Please see our background reading on disaster recovery for more information.\n\nImportant: When using Gitpod in a production setting, we recommend you base your installation on the single cluster reference architecture. Using in-cluster dependencies is not recommended because there is no means to produce backups, and the database/storages systems are within failure domain of the cluster. If possible consider using Gitpod SaaS.\n\nNote: We recommend to regularly trial run a recovery using this method to ensure that it works in practice and to allow yourself the chance to spot any unforeseen issues.","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/backup-restore"}}],["640",{"pageContent":"What to back up\n\nIt is critical to consider what needs to be backed up and ensure you take the necessary steps to secure each of the listed elements. What needs to be backed up is closely aligned with Gitpod‚Äôs architecture and how it runs.\n\nDatabase\n\nThe database is a central component in Gitpod where all metadata about users and workspaces, as well as settings of the Gitpod instance (such as auth providers) are stored. This makes the database a critical component. In case of a database outage, you are not able to log in, use the Gitpod dashboard, or start workspaces. We recommend using a cloud provider native relational database service that supports MySQL - see required components. This means that you can rely on the best practices of each service for disaster recovery. For example:","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/backup-restore"}}],["641",{"pageContent":"AWS Relational Database Service: You can rely on RDS‚Äôs backup and restore mechanisms and set it up to run in multiple availability zones to allow for higher availability. You can also consider other disaster best practices.\nGoogle Cloud SQL: You can rely on Cloud SQLs backup and restore features and run the instance in a high availability configuration to decrease the chance of failure. You can also refer to the general Google Cloud disaster recovery best practices.\n\nObject Storage\n\nGitpod uses¬†object storage¬†to store blob data. This includes workspace backups created when a workspace stops and are used to restore the state upon restart. As such, to secure the work of your users, it is critical to think about backing up this data and/or relying on the best practices for disaster recovery of the object storage service being used. For example:","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/backup-restore"}}],["642",{"pageContent":"AWS S3: You can consider using cross-region replication to increase reliability further - although S3 already stores your data across multiple geographically distant Availability Zones by default.\nGoogle Cloud Storage: Consider using the Multi-Regional Storage option for additional availability.\n\nOCI Image Registry\n\nGitpod uses an image registry to cache images and store images it builds on behalf of users. Note: For non-airgapped environments, this is¬†not¬†the registry that contains the images of Gitpod‚Äôs services. As such, losing this data means that workspace starts may take longer because images need to be re-built. Consider implementing best practices for securing the registry you are using.\n\nApplication Config\n\nImportant: KOTS Snapshots will NOT save any data from your Gitpod database, registry or object storage. It will also not backup any data outside of your gitpod namespace. It will backup:","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/backup-restore"}}],["643",{"pageContent":"Important: KOTS Snapshots will NOT save any data from your Gitpod database, registry or object storage. It will also not backup any data outside of your gitpod namespace. It will backup:\n\nthe KOTS dashboard\nthe KOTS configuration\nthe version of Gitpod installed\nthe TLS certificate generated by cert-manager (if enabled)\n\nAlthough you could simply re-install Gitpod using the regular installation path, this can take some time and you would need to re-configure it to the state you had last had it in. To minimize your recovery time, you can persist the application configuration (ideally regularly).\n\nConfiguring Velero\n\nVelero is an open source tool to safely backup and restore, perform disaster recovery, and migrate Kubernetes cluster resources and persistent volumes. It is used by KOTS to connect to your backup location. It supports many data sources, including AWS, Azure and GCP storage solutions.","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/backup-restore"}}],["644",{"pageContent":"Please follow the installation instructions as per the Velero documentation. KOTS requires Restic integration to function correctly, which can be added by appending the --use-restic flag to the velero install command.\n\nTriggering Your First Backup\n\nFor full documentation on the KOTS backup solution, please see their documentation.\n\nTo create a new backup via the KOTS CLI or in the Snapshots section of your KOTS dashboard, you can do this by running the following command:\n\n```bash\nkubectl kots backup --namespace gitpod\n```\n\nWhen that has finished, you will be able to list your backups:\n\n```bash\nkubectl kots backup ls\n```\n\nAnd it will display a list that looks similar to this:\n\n```bash\nNAME              STATUS       ERRORS    WARNINGS    STARTED                          COMPLETED                        EXPIRES\ninstance-ab1cd    Completed    0         0           2022-08-11 13:36:38 +0100 BST    2022-08-11 13:36:54 +0100 BST    29d\n```\n\nCluster Configuration","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/backup-restore"}}],["645",{"pageContent":"Cluster Configuration\n\nTo reduce the time it takes you to re-create a cluster, you can move to an infrastructure as code flow, e.g. by codifying the infrastructure you need using Terraform.","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/backup-restore"}}],["646",{"pageContent":"How to restore\n\nThe following explains how you might restore Gitpod after its underlying cluster fails.\n\nRecreate your infrastructure. Ideally, you do this using something like a Terraform script.\nConfigure Velero using the instructions above - it is recommended that you install the same version that you used previously.\nList your available backups using:\n\n```bash\nkubectl kots backup ls\n```\n\nRestore the backup using:\n\n```bash\nkubectl kots restore --from-backup instance-ab1cd\n```\n\nLoad the KOTS dashboard:\n\n```bash\nkubectl kots admin-console --namespace gitpod\n```\n\nHit the &quot;Redeploy&quot; button.\nThis should result in your Gitpod instance having the same state as before, thus allowing your users to pick up where they left off.\n\n__SPLIT_HERE__\nSecurity considerations\n\nApplication Config\n\nVelero should be configured so that is deployed to a different namespace to Gitpod. The Velero deployment will contain secrets which will allow access to your backup source of choice. Your Kubernetes cluster should be configured to limit access to these resources with use of a role-based access policy (RBAC).\n\nYou should always consult with the Velero documentation to ensure that you are following their best practice guidelines to ensure the integrity of your backup artifacts.","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/backup-restore"}}],["647",{"pageContent":"__SPLIT_HERE__\nCluster Requirements\n\n‚ö†Ô∏è Self-hosted as a product is no longer supported\n\nThe last official update of this product is the November 2022 self-hosted release. We no longer sell commercial self-hosted licenses. If you want to self-host Gitpod, you can still request our free community license. However, we no longer offer support or updates for it. If you are interested in an isolated, private installation of Gitpod, take a look at Gitpod Dedicated.\nRead our blog on Gitpod Dedicated to learn why we made the decision to discontinue self-hosted.\n\nGitpod is a Kubernetes application running with certain expectations on the characteristics of the cluster it is running on.\n\ncluster requirements\n\n__SPLIT_HERE__\nReference Architectures","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/cluster-requirements"}}],["648",{"pageContent":"Gitpod is a Kubernetes application running with certain expectations on the characteristics of the cluster it is running on.\n\ncluster requirements\n\n__SPLIT_HERE__\nReference Architectures\n\nWe have created a set of reference architectures for all the major cloud providers that fulfil the requirements below. These are intended as a starting point for you to create an environment to install Gitpod into. If you wish to use K3s, please refer to the k3s guide.\n\n__SPLIT_HERE__\nSupported Kubernetes Distributions\n\nGitpod requires Kubernetes as an orchestration technology in order to spin workspaces up and down--ideally in combination with cluster autoscaling to minimize cost. We strongly recommend deploying a dedicated Kubernetes cluster just for Gitpod Self-Hosted.\n\nKubernetes version 1.21 or above is required\n\nGitpod Self-Hosted runs well on:\n\nAmazon Elastic Kubernetes Service\nGoogle Kubernetes Engine\nMicrosoft Azure Kubernetes Service\nK3s\n\nIncompatible Kubernetes Distributions","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/cluster-requirements"}}],["649",{"pageContent":"Gitpod Self-Hosted runs well on:\n\nAmazon Elastic Kubernetes Service\nGoogle Kubernetes Engine\nMicrosoft Azure Kubernetes Service\nK3s\n\nIncompatible Kubernetes Distributions\n\nThese platforms do not currently work with Gitpod Self-Hosted but we would like to support them in the future. Gitpod is an open-source project, maybe you could contribute the required changes to help get them working sooner?\n\nRed Hat¬Æ OpenShift¬Æ\nRancher Kubernetes Engine (RKE)\n\nIf you are considering purchasing a commercial license for Gitpod Self-Hosted and need one of the above platforms then please contact us to start discussions about making support for them happen sooner.\n\n__SPLIT_HERE__\nNode Affinity Labels Requirements\n\nYour Kubernetes cluster must have node(s) with the following labels applied to them:\n\ngitpod.io/workload_meta=true\ngitpod.io/workload_ide=true\ngitpod.io/workload_workspace_services=true\ngitpod.io/workload_workspace_regular=true\ngitpod.io/workload_workspace_headless=true","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/cluster-requirements"}}],["650",{"pageContent":"gitpod.io/workload_meta=true\ngitpod.io/workload_ide=true\ngitpod.io/workload_workspace_services=true\ngitpod.io/workload_workspace_regular=true\ngitpod.io/workload_workspace_headless=true\n\nIt is recommended to have a minimum of two node pools, grouping the meta and ide nodes into one node pool and workspace related nodes into another. These two groups of workloads have different performance characteristics. Separating them into node pools after the fact is more difficult and incurs downtime.\n\n__SPLIT_HERE__\nNode and Container Requirements\n\nThese are the components expected on each node:\n\nEither Ubuntu 18.04 with ‚â• v5.4 kernel or Ubuntu 20.04 with ‚â• v5.4 kernel\nCalico for the networking overlay and network policy\nContainerd ‚â• 1.5\nAt least 4 vCPU and 16GB of RAM\n\n__SPLIT_HERE__\nKubernetes Privilege Requirements\n\nYour Kubernetes cluster must allow Gitpod to run privileged pods and manage PodSecurityPolicies, as Gitpod depends on these privileges to provide workspace isolation.","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/cluster-requirements"}}],["651",{"pageContent":"Your Kubernetes cluster must allow Gitpod to run privileged pods and manage PodSecurityPolicies, as Gitpod depends on these privileges to provide workspace isolation.\n\n__SPLIT_HERE__\nLoad Balancer Requirements\n\nGitpod uses LoadBalancer type services to expose the Gitpod Dashboard, browser-based IDEs, and SSH connections used by desktop IDEs. Your Kubernetes cluster must be able to provision layer 4 or layer 7 load balancers for LoadBalancer type services that can route HTTP(S) connections to Gitpod services. If you intend to use desktop IDEs or SSH to workspaces then your cluster must also be able to provision layer 4 load balancers that can route SSH connection to Gitpod services.\n\nAll supported Kubernetes distributions provide load balancers that meet Gitpod&#39;s needs. For more information see the Kubernetes distribution documentation below:\n\nGoogle Kubernetes Engine\nAmazon Elastic Kubernetes Engine:Layer 4/7 (default): Classic Load Balancer\nLayer 4 only: Network Load Balancing","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/cluster-requirements"}}],["652",{"pageContent":"Google Kubernetes Engine\nAmazon Elastic Kubernetes Engine:Layer 4/7 (default): Classic Load Balancer\nLayer 4 only: Network Load Balancing\n\n\nMicrosoft Azure Kubernetes Service\nK3s","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/cluster-requirements"}}],["653",{"pageContent":"__SPLIT_HERE__\nGitpod Configuration Patches\n\n‚ö†Ô∏è Self-hosted as a product is no longer supported\n\nThe last official update of this product is the November 2022 self-hosted release. We no longer sell commercial self-hosted licenses. If you want to self-host Gitpod, you can still request our free community license. However, we no longer offer support or updates for it. If you are interested in an isolated, private installation of Gitpod, take a look at Gitpod Dedicated.\nRead our blog on Gitpod Dedicated to learn why we made the decision to discontinue self-hosted.\n\nFurther customization of your installation is possible within the installation UI, where Gitpod can provide you with a config patch to tailor the installation to your specific needs. In the ‚ÄúAdditional Options‚Äù section, click the ‚ÄúEnable additional options‚Äù checkbox, and upload the file in the ‚ÄúGitpod config patch‚Äù field.\n\nconfig patch\n\nThe patch file is effectively a patch for the internally used Gitpod Installer config file. It gives you access to all configuration options that Gitpod accepts - even those not present in the UI. All values that are set in the patch file will override the generated config file values.","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/config-patches"}}],["654",{"pageContent":"__SPLIT_HERE__\nConfiguring workspace resources\n\n‚ö†Ô∏è Self-hosted as a product is no longer supported\n\nThe last official update of this product is the November 2022 self-hosted release. We no longer sell commercial self-hosted licenses. If you want to self-host Gitpod, you can still request our free community license. However, we no longer offer support or updates for it. If you are interested in an isolated, private installation of Gitpod, take a look at Gitpod Dedicated.\nRead our blog on Gitpod Dedicated to learn why we made the decision to discontinue self-hosted.\n\nConfiguring workspace resources and limits is essential to balancing the following factors:\n\nWorkspace performance: The amount of compute available to each workspace\nWorkspace startup times: Having smaller workspaces on a node increases the chances of there being space available for another workspace, meaning that a new node does not need to be spun up. On the other extreme: one workspace per node means a new node needs to be spun up for every new workspace\nYour cost of compute: The fewer resources your workspaces request, the more you can fit on the node - and the fewer nodes you have to pay for\n\n__SPLIT_HERE__\nHow to configure workspace requests and limits\n\nYou should always be setting limits for your workspaces in order to avoid a process taking up the resources of an entire node, starving all other processes. We recommend sizing workspaces onto a node such that 4 cores and 8 GiB of RAM are left unused for Gitpod&#39;s services (mainly ws-daemon) and other processes (e.g. the kubelet).\n\nCurrently, workspace resources and limits can be set via a config-patch.\n\nFor example, assuming a machine with 16 CPUs and 64 GB of memory, we recommend the following config-patch:\n\n```yaml\nworkspace:\n  resources:\n    requests:\n      cpu: \"4\"\n      memory: 16Gi\n    limits:\n      cpu: \"4\"\n      memory: 16Gi\n```\n\nWith this configuration, 3 workspaces should fit onto the aforementioned 16 CPU / 64 GB memory node (with CPU cores being the limiting factor). A workspace would always have 4 CPUs and 16 GB of RAM available. These numbers are also used when scheduling workspaces onto pods - workspaces are only scheduled onto nodes that have at least these amounts of resources available.\n\nThis is intentionally on the conservative side due to potential resource conflicts concerning I/O bandwidth.","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/configuring-workspace-resources"}}],["655",{"pageContent":"__SPLIT_HERE__\nBusiness Continuity and Disaster Recovery Considerations with Gitpod\n\n‚ö†Ô∏è Self-hosted as a product is no longer supported\n\nThe last official update of this product is the November 2022 self-hosted release. We no longer sell commercial self-hosted licenses. If you want to self-host Gitpod, you can still request our free community license. However, we no longer offer support or updates for it. If you are interested in an isolated, private installation of Gitpod, take a look at Gitpod Dedicated.\nRead our blog on Gitpod Dedicated to learn why we made the decision to discontinue self-hosted.\n\nNote: There is a lot more to disaster recovery than we can cover here. This is just a high-level overview that speaks to how disaster recovery relates to Gitpod - it does not aim to be a complete guide to the topic.\n\nDisaster Recovery Principles\n\nThinking about disaster recovery with Gitpod is essential for business continuity and compliance reasons given how critical Gitpod is within your business‚Äô practices: it is not only used to write code for new features but also e.g. to fix a security vulnerability.\n\nWhen evaluating different disaster recovery strategies, it is important to keep in mind the business impact of different strategies. This impact is often defined by these interconnected metrics:\n\nRecovery Time Objective (RTO): this is the amount of time it takes to recover from a catastrophic failure. Applying this to Gitpod, this would be the time between a major outage that renders Gitpod unusable and the point at which Gitpod is restored and developers can develop again.\nRecovery Point Objective (RPO): This is the maximum amount of data loss (measured by time) during an outage that is acceptable to an organisation.\nAcceptable Cost: Different disaster recovery strategies come with different cost profiles. You need to know the acceptable cost level for your business to help choose the right strategy.\n\nThe accepted value of each key metric will depend on your business‚Äô risk appetite and acceptable cost levels. These metrics can be used to better understand and categorise the different disaster recovery options available with Gitpod.\n\n__SPLIT_HERE__\nDisaster Recovery Strategies\n\nNote: Whichever disaster recovery strategy you chose, make sure that you practice it end-to-end regularly to ensure that you can execute it successfully if ever it does become necessary.\n\nPlease refer to our guide around backing up and restoring Gitpod to learn more about which data Gitpod produces and how it can be backed up.\n\nBackup And Restore (Higher RTO)\n\nWith this strategy, you aim to replace a failed Gitpod instance or Kubernetes cluster by spinning up an entirely new cluster. You can find out more on how to do this in our How to Backup and Restore Guide.\n\nThis strategy has the benefit of being cost-effective because you only operate a single cluster at a time. However, the time to spin up a new cluster and install Gitpod can be high increasing the time to recover. Thus, depending on your recovery time objective, it may be beneficial to evaluate the strategies mentioned below.\n\nPilot Light (Medium RTO)\n\nWith this strategy, you keep a secondary Kubernetes cluster running that is identical to the one used in production - but in a separate data center and scaled down to the minimum set of nodes to save cost. This means that you do not need to first spin up a cluster in case of disaster but can rather use the one already running to install Gitpod onto (using the same external dependencies and thus data as your production cluster) and then shift traffic to. This can significantly reduce your time to recovery but comes with the cost of running an additional cluster.","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/disaster-recovery"}}],["656",{"pageContent":"&lt;OpenGraph\ndata={{\n    description:\n      &quot;Install and run Gitpod with full control on public cloud providers or self-managed Kubernetes clusters. Enterprise-grade security within corporate firewalls and air-gapped networks. Requirements. Installation. Configuration. GKE. EKS. AKS. Open-source.&quot;,\n    title: &quot;Gitpod Self-Hosted installation guide&quot;,\n    keywords: &quot;installation&quot;,\n  }}\n/&gt;\n\n__SPLIT_HERE__\nSelf-Hosted\n\n‚ö†Ô∏è Self-hosted as a product is no longer supported\n\nThe last official update of this product is the November 2022 self-hosted release. We no longer sell commercial self-hosted licenses. If you want to self-host Gitpod, you can still request our free community license. However, we no longer offer support or updates for it. If you are interested in an isolated, private installation of Gitpod, take a look at Gitpod Dedicated.\nRead our blog on Gitpod Dedicated to learn why we made the decision to discontinue self-hosted.\n\nGitpod can be deployed and operated on your own infrastructure. It supports different cloud providers, self-managed Kubernetes clusters, corporate firewalls, and even off-grid / air-gapped networks.\n\n__SPLIT_HERE__\nLocal Preview\n\nThe Local Preview installation of Gitpod Self-Hosted is the easiest way to try out Gitpod locally in situations where you cannot use the SaaS version and cannot easily spin up a Kubernetes cluster to use the Proof-of-Value reference architecture.\n\nIt is intended for preview purposes only - we strongly encourage the Kubernetes-based installation below for continuous usage.\n\n__SPLIT_HERE__\nPrerequisites to Install Gitpod Self-Hosted\n\nNote: Gitpod is not just a simple Kubernetes application like a web shop app. It is more of an infrastructure tool comparable to a build system that heavily makes use of Kubernetes internals to build and deploy images, control Kubernetes containers (the workspaces) and more. This is why it needs more permissions in Kubernetes than a simple web app.\n\nKubernetes expertise \nGitpod is a Kubernetes application that makes heavy use of various Kubernetes features. It is highly recommended to have sufficient Kubernetes experience in order to install Gitpod. These docs expect that you are able to create and maintain a Kubernetes cluster that meets our requirements on your own.\n\n\nCompatible Kubernetes cluster \nTo install Gitpod you need to have a Kubernetes cluster up and running. There are a few requirements that must be met. Please see the product compatibility matrix supported Kubernetes distributions. To help you get started, there are several different situation-dependent reference architectures for all major cloud providers that include both a detailed guide as well as terraform configuration.\n\n\nCert-Manager \nGitpod expects a properly configured cert-manager that runs in the cluster. It is used to issue internal certificates for the Gitpod installation and to create certificates for the Gitpod domain (unless you bring your own domain certificates).\n\n\nDNS setup \nFor your Gitpod installation you need a properly configured domain. The domain itself and the wildcard subdomain *.example.com, *.ws.example.com (replace example.com with your Gitpod domain) need to point to the cluster ingress.\n\n\nGitpod product license \nTo install Gitpod, you need a license that you can get here.\n\n__SPLIT_HERE__\nInstalling Gitpod\n\nThe installation guide provides you with step-by-step instructions on how to install Gitpod on your infrastructure.\n\n__SPLIT_HERE__\nTroubleshooting\n\nRefer to the troubleshooting section for help with your Gitpod Self-Hosted Instance. You can also take a look at our support page to learn how to reach our community and support team.","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/index"}}],["657",{"pageContent":"__SPLIT_HERE__\nInstallation Guides\n\n‚ö†Ô∏è Self-hosted as a product is no longer supported\n\nThe last official update of this product is the November 2022 self-hosted release. We no longer sell commercial self-hosted licenses. If you want to self-host Gitpod, you can still request our free community license. However, we no longer offer support or updates for it. If you are interested in an isolated, private installation of Gitpod, take a look at Gitpod Dedicated.\nRead our blog on Gitpod Dedicated to learn why we made the decision to discontinue self-hosted.\n\nThis section has the guides you need to install Gitpod:\n\nLocal Preview - Try out Gitpod locally without having to set up a Kubernetes cluster\nReference Architectures - Help with setting up your Kubernetes cluster to run Gitpod on\nInstallation guide - How to install Gitpod onto an Kubernetes cluster\nAdvanced Installation Guides - Help with advanced installation topics","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/installation-guides"}}],["658",{"pageContent":"__SPLIT_HERE__\nInstalling Gitpod Self-Hosted\n\n‚ö†Ô∏è Self-hosted as a product is no longer supported\n\nThe last official update of this product is the November 2022 self-hosted release. We no longer sell commercial self-hosted licenses. If you want to self-host Gitpod, you can still request our free community license. However, we no longer offer support or updates for it. If you are interested in an isolated, private installation of Gitpod, take a look at Gitpod Dedicated.\nRead our blog on Gitpod Dedicated to learn why we made the decision to discontinue self-hosted.\n\nNote: Setting up a self-hosted Gitpod instance needs some Kubernetes experience. Detailed guidance on how to setup and maintain a Kubernetes cluster is behind the scope of these docs. Please also see the prerequisites below.\n\n__SPLIT_HERE__\nPrerequisites\n\nThese prerequisites are fulfilled already if you used one of the reference architectures. We strongly encourage the use of these reference architectures. Please see the requirements for more information on what Gitpod needs to function.\n\nGitpod is a Kubernetes application that uses Kubernetes internally to provision workspaces as Kubernetes pods. Before you can start installing Gitpod, you need to create a compatible Kubernetes cluster. The reference architectures will help you to get started with your favorite cloud provider. If you are creating a cluster yourself, it&#39;s up to you to set up a cluster that meets the requirements.\n\nOnce you have created your Kubernetes cluster you need to install cert-manager. cert-manager is needed even when you bring your own TLS certificate for your domain. Please consider the cert-manager documentation on how to install it.\n\nTo install Gitpod you need a domain with a TLS certificate. The DNS setup to your domain needs to be configured such that it points to the ingress of your Kubernetes cluster. You need to configure your actual domain (say example.com) as well as the wildcard subdomains *.example.com and *.ws.example.com. Alternatively, you can rely on a configured Issuer/ClusterIssuer plus a Certificate (that also includes the wildcard domains) for cert-manager:\n\nCreating TLS certs for your domain with cert-manager\n\ncert-manager provides the Gitpod installation with certificates for internal communication. Besides this, cert-manager can also create a TLS certificate for your domain. Since Gitpod needs wildcard certificates, you must use the DNS-01 challenge. Please consult the cert-manager documentation for instructions. You can use either an Issuer or ClusterIssuer.\n\nFollowing the cert-manager instructions, you will have an Issuer or ClusterIssuer with a configured dns01 solver (most probably with a proper secret with credentials for your DNS provider) as well a Certificate with the following dnsNames:\n\nexample.com\n*.example.com\n*.ws.example.com\n\n(replace example.com with your Gitpod domain)","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/installing-gitpod"}}],["659",{"pageContent":"Install Gitpod\n\nTo start with installing Gitpod, you need a terminal where you can run kubectl against your cluster. First, install the KOTS kubectl plugin:\n\n```shell\ncurl https://kots.io/install | bash\n```\n\nNow, you are ready to install Gitpod. Run the following command in your terminal:\n\n```shell\nkubectl kots install gitpod\n```\n\nYou will be asked for the namespace you want to install Gitpod to as well as a password for the admin console. After some time, you will see the following output:\n\n```\n  ‚Ä¢ Press Ctrl+C to exit\n  ‚Ä¢ Go to http://localhost:8800 to access the Admin Console\n```\n\nOpen your favorite browser and go to http://localhost:8800 (port 8800 is opened on your node on localhost only--you may want to forward the port to your workstation in order to access the admin console).\n\nThe first page will ask you to upload your Gitpod license which you can get here For more information about our licenses and respective pricing plans, please visit our self-hosted pricing page.\n\nAfter uploading the license, you will be forwarded to the config page. On this page, you need to enter your domain name for your Gitpod installation. You can also configure to use external components (by default internal ones are installed) as well as your TLS certs setup or your workspace size. Click ‚ÄúContinue‚Äù to proceed with the installation.\n\nkots-install-config\n\nIn the next step, the installer runs a preflight check. This validates your cluster meets the minimum requirements. Everything is green? Awesome! Click ‚ÄúContinue‚Äù to proceed.\n\nkots-preflights-results\n\nNow, you are seeing the installation admin page. Once the installation has been finished successfully, you will see the status ‚ÄúReady‚Äù with a small green indicator next to the Gitpod logo. You will also see which version you installed and which license you are using.\n\nkots-admin-dashboard\n\nOpen your Gitpod domain in your browser to access your running Gitpod instance. You should be greeted by the following screen:\n\nwelcome screen\n\nYou will then be asked to configure a git integration:\n\ngit integration setup\n\nThis git integration will also serve as the way that you and your users get authenticated against your Gitpod installation. You can find out more in the Integrations section.\n\nImportant: Public (SaaS) Source Control Management Systems (SCMs) (i.e. GitLab.com, GitHub.com and Bitbucket.org) are not integrated by default with a Self-Hosted Gitpod instance because OAuth apps are tied to domains. Therefore, these public SCMs need to be integrated manually with an OAuth application you specifically create for your domain. This is done similarly to how it is done for the private/self-hosted versions of each SCM. As such their respective guides also apply here:\n\nFollow these steps to integrate GitLab.com with your self-hosted Gitpod instance. You will need to enter gitlab.com as the Provider Host Name in the New Git Integration Modal.\nFollow these steps to integrate GitHub.com with your self-hosted Gitpod instance. You will need to enter github.com as the Provider Host Name in the New Git Integration Modal.\nFollow these steps to integrate Bitbucket.org with your self-hosted Gitpod instance. Select Bitbucket as the Provider Type in the New Git Integration Modal. For bitbucket.org this requires configuring an &quot;OAuth consumer&quot; on a &quot;workspace&quot;. This is slightly different from the documented Bitbucket Server integration. See gitpod PR #9894 for an example.\n\nNote: Your first workspace start can take a bit of time because the workspace image first needs to be built and then downloaded. Subsequent workspace starts should be much quicker.\n\nOnce you are all set up, you can visit the getting started with Gitpod page to start learning about using Gitpod. You should also familiarise yourself with our guides around operating Gitpod Self-Hosted, especially the guide that explains how to update Gitpod.","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/installing-gitpod"}}],["660",{"pageContent":"__SPLIT_HERE__\nHow to Install the Local Preview of Gitpod Self-Hosted\n\n‚ö†Ô∏è Self-hosted as a product is no longer supported\n\nThe last official update of this product is the November 2022 self-hosted release. We no longer sell commercial self-hosted licenses. If you want to self-host Gitpod, you can still request our free community license. However, we no longer offer support or updates for it. If you are interested in an isolated, private installation of Gitpod, take a look at Gitpod Dedicated.\nRead our blog on Gitpod Dedicated to learn why we made the decision to discontinue self-hosted.\n\n\nStatus:\nIntended for: The Local Preview allows you to experience Gitpod Self-Hosted on your local machine without having to set up a Kubernetes cluster. It is purely intended for testing purposes. Please see the installation guides section for recommended sustainable installation methods.\nLimitations: - Performance is limited by the capabilities of your machine. Your experience is likely to be better when using the SaaS version (gitpod.io) or when running on one of our reference architectures  - Minimum of 4 cores and 6GB of ram required. Macs with Apple Silicon (e.g. M1) are currently not supported. See the relevant issue for more information  - Prebuilds are not supported because they require webhooks\n\nThe Local Preview of Gitpod Self-Hosted is the easiest way to try out Gitpod locally in situations where you cannot use the SaaS version (gitpod.io) and cannot easily spin up a Kubernetes cluster to use the Proof-of-Value Reference Architecture. It allows you to try Gitpod Self-Hosted locally with minimal effort and resource requirements. As a result, this is not intended for production nor continuous usage. Please refer to the installation guide for instructions on how to install Gitpod for continuous usage. \n\nThis install method runs a K3s cluster inside a Docker container. Self-signed certificates are automatically created and a Gitpod instance using these certificates will be installed into the k3s cluster. See our TLS page for more information about Gitpod and certificates.\n\n__SPLIT_HERE__\n1. Running the Docker container\n\nRun the following command to get the local-preview Docker container up and running:\n\n```bash\ndocker run -p 443:443 --privileged --name gitpod -it --mount type=volume,source=gitpod,destination=/var/gitpod eu.gcr.io/gitpod-core-dev/build/local-preview\n```\n\nUnpacking the above command:\n\n-p 443:443 to map the 443 container port to host.\n--privileged to be able to run docker (and hence k3s) inside the container. This is necessary.\n--name gitpod to set the name of the docker container for further access.\n--rm to delete the Docker container after stopping.\n--mount type=volume,source=gitpod,destination=/var/gitpod to create a volume called gitpod, and mounting it to the container.\n\nNote: By default, preview.gitpod-self-hosted.com is the DOMAIN to access Gitpod which routes to 127.0.0.1 localhost IP address. To use another host network IP Address, the DOMAIN environment can be set accordingly via an -e flag in the above command. This is useful to share access to the Gitpod Self-Hosted instance running on your machine within your local network. For Example, 192.168.0.42 Host Network IP would be 192-168-0-42.nip.io, set by appending -e DOMAIN=192-168-0-42.nip.io.","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/local-preview"}}],["661",{"pageContent":"2. Accessing Gitpod\n\nNote: It usually takes around 5 minutes to go from the starting Gitpod status to Gitpod is running. Among other things, this will depend on the speed of your internet connection. Once Gitpod is ready, it will look as follows:\n\ngitpod is ready\n\nAs this is a self-signed instance of Gitpod, the Gitpod root CA cert has to be imported into your browser manually to access the full functionality of Gitpod. The certificate can be retrieved by running the following:\n\n```bash\ndocker cp gitpod:/var/gitpod/gitpod-ca.crt $HOME/gitpod-ca.crt\n```\n\nThis certificate is saved at $HOME/gitpod-ca.crt and can then be loaded into your browser. Most browsers also require a restart before they can start to use the imported certificate. For instructions on how to load the certificate, choose your setup below:\n\nOnce the certificate is loaded and Gitpod is ready, the URL to access the Gitpod instance would be https://preview.gitpod-self-hosted.com unless the DOMAIN environment is overridden in which case the same has to be used.\n\nYou should be greeted by the following screen:\n\nwelcome screen\n\nYou will then be asked to configure a git integration:\n\ngit integration setup\n\nThis git integration will also serve as the way that you and your users get authenticated against your Gitpod installation. You can find out more in the Integrations section.\n\nImportant: Public (SaaS) Source Control Management Systems (SCMs) (i.e. GitLab.com, GitHub.com and Bitbucket.org) are not integrated by default with a Self-Hosted Gitpod instance because OAuth apps are tied to domains. Therefore, these public SCMs need to be integrated manually with an OAuth application you specifically create for your domain. This is done similarly to how it is done for the private/self-hosted versions of each SCM. As such their respective guides also apply here:\n\nFollow these steps to integrate GitLab.com with your self-hosted Gitpod instance. You will need to enter gitlab.com as the Provider Host Name in the New Git Integration Modal.\nFollow these steps to integrate GitHub.com with your self-hosted Gitpod instance. You will need to enter github.com as the Provider Host Name in the New Git Integration Modal.\nFollow these steps to integrate Bitbucket.org with your self-hosted Gitpod instance. Select Bitbucket as the Provider Type in the New Git Integration Modal. For bitbucket.org this requires configuring an &quot;OAuth consumer&quot; on a &quot;workspace&quot;. This is slightly different from the documented Bitbucket Server integration. See gitpod PR #9894 for an example.\n\nNote: Your first workspace start can take a bit of time because the workspace image first needs to be built and then downloaded. Subsequent workspace starts should be much quicker.\n\nOnce you are all set up, you can visit the getting started with Gitpod page to start learning about using Gitpod.","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/local-preview"}}],["662",{"pageContent":"__SPLIT_HERE__\nManage Cluster Nodes\n\n‚ö†Ô∏è Self-hosted as a product is no longer supported\n\nThe last official update of this product is the November 2022 self-hosted release. We no longer sell commercial self-hosted licenses. If you want to self-host Gitpod, you can still request our free community license. However, we no longer offer support or updates for it. If you are interested in an isolated, private installation of Gitpod, take a look at Gitpod Dedicated.\nRead our blog on Gitpod Dedicated to learn why we made the decision to discontinue self-hosted.\n\nSometimes nodes become unhealthy, or you need to prevent the autoscaler from removing the node from your cluster.\n\n__SPLIT_HERE__\nAvoiding Node Scale-down\n\nIf you wish to cordon a node with terminating workspaces, or, keep a node so you have time to manually backup user data:\n\n```shell\n# reference: https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/FAQ.md#how-can-i-prevent-cluster-autoscaler-from-scaling-down-a-particular-node\n$ kubectl annotate node <nodename> cluster-autoscaler.kubernetes.io/scale-down-disabled=true\n```\n\n__SPLIT_HERE__\nHandling Unhealthy Nodes\n\nPrevent new workspaces from being scheduled to a node if they become unhealthy:\n\n```shell\n$ kubectl cordon <nodename>\n```","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/manage-cluster-nodes"}}],["663",{"pageContent":"This guide aims at helping you set up basic monitoring of your Gitpod instance. In the end, you will have a continuous, high-level view of the health of your installation that you can monitor and alert on to respond to any issues quicker.\n\n__SPLIT_HERE__\nMonitoring\n\n‚ö†Ô∏è Self-hosted as a product is no longer supported\n\nThe last official update of this product is the November 2022 self-hosted release. We no longer sell commercial self-hosted licenses. If you want to self-host Gitpod, you can still request our free community license. However, we no longer offer support or updates for it. If you are interested in an isolated, private installation of Gitpod, take a look at Gitpod Dedicated.\nRead our blog on Gitpod Dedicated to learn why we made the decision to discontinue self-hosted.\n\nOnce you have Gitpod self-hosted up and running, the next step is making sure it continues to run as expected. This guide shows you how to set up a monitoring solution that consumes the data that Gitpod produces in order to help you understand the overall state of your Gitpod installation.\n\nNote All metrics shown on this page are experimental and might change in the future.\n\n__SPLIT_HERE__\nMetrics collection\n\nSeveral components of Gitpod expose metrics using the Prometheus exposition format, but for this guide, we&#39;ll focus on the most important one that makes sure that Workspaces are starting and running reasonably.\n\nGitpod is all about Workspaces, so the information that you want to keep an eye on is:\n\nHow many workspaces are currently running.\nWorkspaces are starting.\nWorkspaces are starting in a reasonable time frame.\nRunning workspaces don&#39;t stop unexpectedly.\n\nws-manager is the component responsible for measuring and exposing such data, so you want to make sure that your Prometheus instance is scraping metrics from this specific component. Metrics are exposed through port 9500, at the /metrics endpoint.\n\nWe recommend using the Prometheus-Operator and the ServiceMonitor or PodMonitor CRDs to simplify the configuration surface.\n\n__SPLIT_HERE__\nDashboards and Alerts\n\nTo have all useful data available and presented in a friendly way, it is recommend building Grafana Dashboards with the most important metrics (the ones shown in this guide). If you prefer, you can import one of our examples as a baseline to your own dashboards.\n\nAlerting can be done with Prometheus itself. If you are using the Prometheus-Operator as we recommended, you can also use the PrometheusRule CRD to simplify alerting configuration. The Alertmanager CRD can be used to configure alert routing to different popular platform such as PagerDuty or Slack.","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/monitoring"}}],["664",{"pageContent":"What you should keep an eye on\n\nHow many workspaces are currently running\n\nTo discover how many workspaces are currently running, use the PromQL query below:\n\n```promql\nsum(gitpod_ws_manager_workspace_phase_total{phase=\"RUNNING\"}) by (type)\n```\n\ngitpod_ws_manager_workspace_phase_total is a Gauge. Although not suitable for alerting (because the amount of workspaces say little about your installation&#39;s health), with this query, you&#39;re able to tell how many workspaces, prebuilds and imagebuilds are running. This can be good information to tell how saturated your Gitpod instance is.\n\nWorkspaces are starting\n\nThe metric for this one is very similar to the one mentioned above, we&#39;re just changing the phase to PENDING instead of RUNNING.\n\n```promql\nsum(gitpod_ws_manager_workspace_phase_total{phase=\"PENDING\"}) by (type)\n```\n\nThis metric is a good candidate for alerting. If this number is steadily going up, it means that Workspaces are having a hard time getting to the RUNNING state, which is a good indicator of bad user experience. A good threshold changes from organization to organization, it is recommended to periodically review this alert&#39;s threshold as the usage of Gitpod increases or decreases.\n\nWorkspaces are starting in a reasonable time frame\n\nTo ensure a good user experience, you&#39;ll also want to make sure that Workspaces are starting swiftly! Histograms are used to capture this information. With histograms, it&#39;s possible to measure different percentiles and capture a high-level overview and outliers at the same time.\n\nExample queries are shown below:\n\n```promql\n# 95th percentile\nhistogram_quantile(0.95,\n    sum(rate(gitpod_ws_manager_workspace_startup_seconds_bucket{type=\"REGULAR\"}[5m])) by (le)\n)\n\n# 50th percentile\nhistogram_quantile(0.5,\n    sum(rate(gitpod_ws_manager_workspace_startup_seconds_bucket{type=\"REGULAR\"}[5m])) by (le)\n)\n```\n\nSluggishness, depending on how bad it is, can be even worst than a fast failure. For that reason, alerting on workspaces taking too long to start is a good idea. It is suggested to collect feedback from users of your Gitpod installation to decide the correct thresholds for the alert on this metric.\n\nRunning workspaces don&#39;t stop unexpectedly\n\nLast but not less important, you want to make sure that running workspaces do not fail and stop abruptly. ws-manager exposes a counter that counts all workspace failures, making it possible to measure workspace failure rate (i.e. how many workspaces are failing per second).\n\nThe query is shown below:\n\n```promql\nsum(rate(gitpod_ws_manager_workspace_stops_total{reason=\"failed\"}[5m])) by (type)\n```\n\nThe goal is that this metric stays as close to 0 as possible. If it starts to increase it means something is going wrong! Alerting can be set for high error rates, but just like the ones above the threshold will come from experience operating Gitpod. It is suggested to periodically review the threshold as your installation increases or decreases usage.\n\n__SPLIT_HERE__\nTroubleshooting\n\nPlease refer to the troubleshooting docs.","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/monitoring"}}],["665",{"pageContent":"__SPLIT_HERE__\nOperational Guides\n\n‚ö†Ô∏è Self-hosted as a product is no longer supported\n\nThe last official update of this product is the November 2022 self-hosted release. We no longer sell commercial self-hosted licenses. If you want to self-host Gitpod, you can still request our free community license. However, we no longer offer support or updates for it. If you are interested in an isolated, private installation of Gitpod, take a look at Gitpod Dedicated.\nRead our blog on Gitpod Dedicated to learn why we made the decision to discontinue self-hosted.\n\nThis section has the guides you need to operate Gitpod:\n\nHow to update Gitpod - This guide shows you how to update Gitpod\nHow to monitor Gitpod - This guide shows you how to set up monitoring via metrics for your Gitpod installation\nHow to configure workspace resources - This guide shows you how to configure workspace resources to ensure performance and reliability\nHow to backup and restore Gitpod - This guide shows you how to back up and then restore your Gitpod installation for disaster recovery purposes","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/operational-guides"}}],["666",{"pageContent":"__SPLIT_HERE__\nPrevent Workspace Starts\n\n‚ö†Ô∏è Self-hosted as a product is no longer supported\n\nThe last official update of this product is the November 2022 self-hosted release. We no longer sell commercial self-hosted licenses. If you want to self-host Gitpod, you can still request our free community license. However, we no longer offer support or updates for it. If you are interested in an isolated, private installation of Gitpod, take a look at Gitpod Dedicated.\nRead our blog on Gitpod Dedicated to learn why we made the decision to discontinue self-hosted.\n\nIt may be necessary for you to prevent users from starting Gitpod workspaces (in a &lt;namespace&gt;). Please see the update guide for more information.\n\nIt is required to prevent workspace starts when updating Gitpod and using the Single Cluster Reference Architecture because it is not highly-available.\n\nThis can be done with kubectl, after which, users won&#39;t be able to start workspaces until the ws-manager pod is running again.\n\nCaution: You must stop running workspaces and wait for them to terminate before proceeding. Failure to do so can result in user data loss, because the workspaces will not be able to reliably back-up.\n\nTo scale-down the ws-manager component and prevent workspace starts:\n\n```shell\nkubectl scale --replicas=0 deployment/ws-manager -n <namespace>\n```\n\nAfter which, users will receive an error when trying to start workspaces. Once Gitpod is redeployed, this change will be reset automatically and workspaces will be allowed to start again.","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/prevent-workspace-starts"}}],["667",{"pageContent":"__SPLIT_HERE__\nGitpod Self-Hosted Reference\n\n‚ö†Ô∏è Self-hosted as a product is no longer supported\n\nThe last official update of this product is the November 2022 self-hosted release. We no longer sell commercial self-hosted licenses. If you want to self-host Gitpod, you can still request our free community license. However, we no longer offer support or updates for it. If you are interested in an isolated, private installation of Gitpod, take a look at Gitpod Dedicated.\nRead our blog on Gitpod Dedicated to learn why we made the decision to discontinue self-hosted.\n\nReference information for Gitpod Self-Hosted:\n\nRequirements - Information on which components Gitpod requires\nProduct compatibility Matrix - Information on which versions of components do and do not work with Gitpod\nReleases - Information about how Gitpod is released\nTelemetry - Information about the telemetry that is gathered\nUpgrade Guides - Information to take into account when upgrading to a specific version","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference"}}],["668",{"pageContent":"__SPLIT_HERE__\nGitpod Self-Hosted Requirements\n\n‚ö†Ô∏è Self-hosted as a product is no longer supported\n\nThe last official update of this product is the November 2022 self-hosted release. We no longer sell commercial self-hosted licenses. If you want to self-host Gitpod, you can still request our free community license. However, we no longer offer support or updates for it. If you are interested in an isolated, private installation of Gitpod, take a look at Gitpod Dedicated.\nRead our blog on Gitpod Dedicated to learn why we made the decision to discontinue self-hosted.\n\nGitpod has certain expectations on the characteristics of the cluster it is running on as well as the (software) components connected to it.\n\nPlease refer to the product compatibility matrix for the supported types and versions of these components.\n\n__SPLIT_HERE__\nCluster Requirements\n\ncluster requirements\n\nReference Architectures\n\nWe have created a set of reference architectures for all the major cloud providers that fulfill the requirements below. These are intended as a starting point for you to create an environment to install Gitpod into. If you wish to use K3s, please refer to the k3s guide. Please see the product compatibility matrix for the current level of k3s support.\n\nSupported Kubernetes Versions and distributions\n\nPlease refer to the product compatibility matrix for supported Kubernetes versions and distributions.\n\nNode Affinity Labels Requirements\n\nYour Kubernetes cluster must have node(s) with the following labels applied to them:\n\ngitpod.io/workload_meta=true\ngitpod.io/workload_ide=true\ngitpod.io/workload_workspace_services=true\ngitpod.io/workload_workspace_regular=true\ngitpod.io/workload_workspace_headless=true\n\nIt is recommended to have a minimum of two node pools, grouping the meta and ide nodes into one node pool and workspace related nodes into another. These two groups of workloads have different performance characteristics. Separating them into node pools after the fact is more difficult and incurs downtime. A further improvement is to also separate the headless workspaces (these are prebuilds) and regular workspaces into separate node pools. Prebuilds can use up a lot of compute and this might impact regular workspaces if they are running on the same node.\n\nNode and Container Requirements\n\nThese are the components expected on each node (see product compatibility matrix for supported versions):\n\nUbuntu Linux\nCalico for the networking overlay and network policy\nContainerd\nAt least 4 vCPU and 16GB of RAM\n\nKubernetes Privilege Requirements\n\nYour Kubernetes cluster must allow Gitpod to run privileged pods, as Gitpod depends on these privileges to provide workspace isolation.\n\nLoad Balancer Requirements\n\nGitpod uses LoadBalancer type services to expose the Gitpod Dashboard, browser-based IDEs, and SSH connections used by desktop IDEs. Your Kubernetes cluster must be able to provision layer 4 or layer 7 load balancers for LoadBalancer type services that can route HTTP(S) connections to Gitpod services. If you intend to use desktop IDEs or SSH to workspaces then your cluster must also be able to provision layer 4 load balancers that can route SSH connection to Gitpod services.\n\nAll supported Kubernetes distributions provide load balancers that meet Gitpod&#39;s needs. For more information see the Kubernetes distribution documentation below:\n\nGoogle Kubernetes Engine\nAmazon Elastic Kubernetes Engine:Layer 4/7 (default): Classic Load Balancer\nLayer 4 only: Network Load Balancing\n\n\nMicrosoft Azure Kubernetes Service\nK3s","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/requirements"}}],["669",{"pageContent":"Required Components\n\nGitpod relies on certain components and services for it to function. By default, most of these can be automatically installed in-cluster during installation. However, you can also configure Gitpod to use your own version of these that may or may not live inside the cluster. We recommend using external components when running Gitpod for sustained usage because this avoids the risk of data loss when the cluster goes down.\n\nPlease refer to the product compatibility matrix for the supported types and versions of these components.\n\nComponent Required?\nBucket Storage Use default or bring your own\nDatabase Use default or bring your own\nImage Registry Use default or bring your own\nSource Control Management System Yes (cloud or self-hosted SCM)\nCert-manager Yes\n\nBucket Storage\n\nBy default, MinIO is installed in the cluster to store static content and to back an in-cluster image registry. During the installation process you can also configure Gitpod to use an external storage providers like S3.\n\nDatabase\n\nGitpod uses a MySQL database to store user data. By default Gitpod ships with a MySQL database built-in and data is stored using a Kubernetes PersistentVolume. For production settings, we recommend operating your own MySQL database (version v5.7 or newer). Which database is used can be configured during installation. \n\nImage Registry\n\nGitpod relies on an image registry to store images used to start workspaces. By default, a docker based image registry backed by MiniIO is installed in the cluster (this can be configured during the installation). However, Gitpod is also compatible with any registry that implements the Docker Registry HTTP API V2 specification.\n\nSource Control Management System\n\nGitpod expects to be connected to a Source Control Management System (SCM) such as GitLab in order to function. You can find out more about which SCMs are supported and how to connect to them in the Integrations section. You will also be guided through connecting your SCM once you access your Gitpod installation for the first time.\n\nCert Manager\n\nCert-manager must be installed in your cluster before you can install Gitpod. It is used to create and manage certificates needed to secure communication between the various internal Gitpod components. It can also be used to fetch a TLS certificate for your Gitpod instance from Let&#39;s Encrypt for example. Please consider the cert-manager documentation on how to install it.","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/requirements"}}],["670",{"pageContent":"__SPLIT_HERE__\nHow To Configure Gitpod To Work With Certain External Components\n\n‚ö†Ô∏è Self-hosted as a product is no longer supported\n\nThe last official update of this product is the November 2022 self-hosted release. We no longer sell commercial self-hosted licenses. If you want to self-host Gitpod, you can still request our free community license. However, we no longer offer support or updates for it. If you are interested in an isolated, private installation of Gitpod, take a look at Gitpod Dedicated.\nRead our blog on Gitpod Dedicated to learn why we made the decision to discontinue self-hosted.\n\nGitpod has three resource dependencies that are required to function correctly. For convenience, you can use the in-cluster dependencies, but you should use external resources for a high-performance application.\n\nThis page highlights some of the common gotchas found when working with cloud resources and how to overcome them.\n\n__SPLIT_HERE__\nContainer Registry\n\nAmazon Elastic Container Registry (ECR)\n\nAmazon ECR does not fully implement the Docker v2 API, namely it does not automatically create the remote image if it does not already exist when pushed. For that reason, ECR is not supported with Gitpod.\n\nWhen using AWS, you should select an in-cluster registry and use S3 as your in-cluster storage provider. This will use the in-cluster registry as a facade for an S3 bucket where all the images will be stored.\n\nIf using a region other than us-east-1, you will need to change the endpoint to be s3.&lt;region&gt;.amazonaws.com.\n\nGoogle Container Registry (GCR)\n\nThis example uses the format gcr.io, which is the global hostnames. This can be swapped with any of the regional hostnames and it will work in the same way.\n\nGoogle Container Registry authentication requires specific configuration. The &quot;Container registry URL&quot; will be in a format similar to gcr.io/&lt;project-name&gt;/gitpod. In order for the authentication to work, you must also enter the &quot;Container registry server&quot;. This will always be your GCR hostname, eg gcr.io.\n\nGoogle Artifact Registry (GAR)\n\nAs with GCR, Google Artifact Registry requires both the &quot;Container registry URL&quot; and &quot;Container registry server&quot; to be completed. The URL will be in the format &lt;region&gt;-docker.pkg.dev/&lt;project-name&gt;/gitpod and the server address will be &lt;region&gt;-docker.pkg.dev.","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/resource-configuration"}}],["671",{"pageContent":"__SPLIT_HERE__\nStop Workspaces\n\n‚ö†Ô∏è Self-hosted as a product is no longer supported\n\nThe last official update of this product is the November 2022 self-hosted release. We no longer sell commercial self-hosted licenses. If you want to self-host Gitpod, you can still request our free community license. However, we no longer offer support or updates for it. If you are interested in an isolated, private installation of Gitpod, take a look at Gitpod Dedicated.\nRead our blog on Gitpod Dedicated to learn why we made the decision to discontinue self-hosted.\n\nSometimes it becomes necessary to stop Gitpod workspaces (in a &lt;namespace&gt;). Usually this needs to be done when updating Gitpod. Please see the update guide for more information.\n\nThis can be done with kubectl, and when done so, the IDE is closed, data in /workspace is backed up, and then the pod finally terminates.\n\n__SPLIT_HERE__\nA Single Workspace\n\n```shell\n$ kubectl delete pods <workspace-or-headless-pod-name> -n <namespace>\n```\n\n__SPLIT_HERE__\nAll Workspaces\n\nCaution: This will delete all actively running workspaces.\n\nCan be done prior to outage windows, or for troubleshooting.\n\n```shell\n$ kubectl delete pods -l component=workspace -n <namespace>\n```","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/stop-workspaces"}}],["672",{"pageContent":"__SPLIT_HERE__\nGenerating a Support Bundle\n\nSomething is wrong with your Gitpod installation? This guide shows you how you can create a support bundle.\n\nAt first, you need to start the installation admin console. In a terminal with configured kubectl run the following command (&lt;namespace&gt; is the Kubernetes namespace your Gitpod installation has been installed to):\n\n```shell\n$ kubectl kots admin-console --namespace <namespace>\n```\n\nOpen your favorite browser and go to http://localhost:8800 (port 8800 is opened on your node on localhost only--you may want to forward the port to your workstation to access the admin console). Enter your password and click on ‚ÄúTroubleshoot‚Äù in the top menu. Click ‚ÄúAnalyze Gitpod‚Äù to create a support bundle that contains relevant logs and configs.\n\nkots-troubleshoot\n\nCreating the support bundle will take some while. Once it is ready, you can inspect the content. Nothing will be shared with us unless you have explicitly chosen to do so.\n\nkots-troubleshoot","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/support-bundle"}}],["673",{"pageContent":"__SPLIT_HERE__\nTelemetry\n\n‚ö†Ô∏è Self-hosted as a product is no longer supported\n\nThe last official update of this product is the November 2022 self-hosted release. We no longer sell commercial self-hosted licenses. If you want to self-host Gitpod, you can still request our free community license. However, we no longer offer support or updates for it. If you are interested in an isolated, private installation of Gitpod, take a look at Gitpod Dedicated.\nRead our blog on Gitpod Dedicated to learn why we made the decision to discontinue self-hosted.\n\nWe optionally collect telemetry from Gitpod Self-Hosted installations to better understand the needs and use cases of the Gitpod community. Collected telemetry contains simple usage statistics like the number of users and workspaces. Our Privacy Policy describes in detail how we use this data.\n\nTo provide individualized support to enterprise customers we optionally collect a customer ID. This customer ID provides insights into enterprise adoption of Gitpod and helps us ensure that customers get the best value from their installations. Self-hosted installations using the community license do not have a customer ID and will be anonymous.\n\n__SPLIT_HERE__\nControlling your telemetry\n\nYou can preview your usage telemetry, control how much information you share, and enable/disable all usage telemetry on Settings tab on the Admin dashboard. To anonymize your usage telemetry, uncheck the Include customer ID in telemetry option. To fully disable telemetry, uncheck the Enable usage telemetry option.\n\nA preview of your usage telemetry is available on the settings page to provide transparency about the data we&#39;d like to collect.\n\nEnable Service Ping in Admin Settings","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/telemetry"}}],["674",{"pageContent":"__SPLIT_HERE__\nTroubleshooting Self-Hosted Gitpod\n\n‚ö†Ô∏è Self-hosted as a product is no longer supported\n\nThe last official update of this product is the November 2022 self-hosted release. We no longer sell commercial self-hosted licenses. If you want to self-host Gitpod, you can still request our free community license. However, we no longer offer support or updates for it. If you are interested in an isolated, private installation of Gitpod, take a look at Gitpod Dedicated.\nRead our blog on Gitpod Dedicated to learn why we made the decision to discontinue self-hosted.\n\nSomething is wrong with your Gitpod installation? Please refer to the following troubleshooting resources. You can also take a look at our support page to learn how to reach our community and support team for help.\n\nGenerating a Support Bundle\nGitpod provided Config Patches\nStop running workspaces\nPrevent workspace starts\nManage cluster nodes","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/troubleshooting"}}],["675",{"pageContent":"__SPLIT_HERE__\nHow to Update your Gitpod Installation\n\n‚ö†Ô∏è Self-hosted as a product is no longer supported\n\nThe last official update of this product is the November 2022 self-hosted release. We no longer sell commercial self-hosted licenses. If you want to self-host Gitpod, you can still request our free community license. However, we no longer offer support or updates for it. If you are interested in an isolated, private installation of Gitpod, take a look at Gitpod Dedicated.\nRead our blog on Gitpod Dedicated to learn why we made the decision to discontinue self-hosted.\n\nAt first, you must decide on an update strategy, and follow related instructions.\n\nAfter following instructions for your desired update strategy, you need to start the installation admin console. In a terminal with configured kubectl run the following command (&lt;namespace&gt; is the Kubernetes namespace your Gitpod installation has been installed to):\n\n```shell\n$ kubectl kots admin-console --namespace <namespace>\n```\n\nOpen¬†http://localhost:8800¬†(port¬†8800¬†is opened on your node on¬†localhost¬†only‚Äîyou may want to forward the port to your workstation to access the admin console). Enter your password. Click on ‚ÄúCheck for update‚Äù.\n\nNote: For air gapped installations, you need to click Upload a new version to upload a new version and then deploy it. A new version is made available to you to download via the download portal provided to you by Gitpod.\n\nWhen an update is available, you will be asked to deploy the new version. You can run preflight checks on the new version and when you press deploy your current running version will be updated.\n\nIn most cases, updates should work without further effort - and your existing data is carried over. In some cases (with breaking changes) we will provide instructions on how to upgrade to a specific version in our Update Guides.\n\nGitpod allows you to apply custom labels, annotations and environment variables to your resources. When using this feature, you will need to manually delete resources that have immutable labels on them for updates to take effect. See the documentation for full details.\n\nkots-admin-dashboard","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/updating"}}],["676",{"pageContent":"Update Strategies\n\nYou can deploy different strategies to update your Gitpod instance. Each strategy comes with trade-offs regarding downtime, risk, and cost. In any case, you should ensure that the chosen strategy matches your (company‚Äôs) risk profile and that every part of your update strategy (incl. rollbacks) is regularly practiced.\n\nPlease refer to Update Guides to check for breaking changes that need to be handled as part of your upgrade.\n\nMaintenance Window (Higher downtime, low risk and medium cost) - Recommended\n\nImportant: Single Cluster Reference Architecture is not highly-available, please stop workspaces and prevent workspace starts prior to proceeding.\n\nIn this strategy, you have scheduled maintenance windows where you take down your entire Gitpod installation, update it, test it, and then make it available again. Ideally, this is done during times of low demand, e.g. outside of work hours.\n\nSecondary Staging Deployment (medium downtime, lower risk, higher cost)\n\nImportant: Single Cluster Reference Architecture is not highly-available, please stop workspaces and prevent workspace starts prior to proceeding.\n\nIn this strategy, you run the newest version of Gitpod on a secondary (staging) cluster to ensure compatibility/fitness of the newest version within your specific environment. Given that you are testing on a secondary cluster, you save on downtime in your primary cluster. If you are confident in the release, you can then also apply the update to your primary cluster. Given that workspace startups may fail for a brief period during the update process, a maintenance window (albeit smaller) will still be required.\n\nLive update (not available, yet)\n\nImportant: Please check back soon, we&#39;re planning high-availability reference architecture.\n\nThe Single Cluster Reference Architecture does not support live update. Please choose another update strategy.","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/updating"}}],["677",{"pageContent":"__SPLIT_HERE__\nUpgrade Guides and Breaking Changes\n\n‚ö†Ô∏è Self-hosted as a product is no longer supported\n\nThe last official update of this product is the November 2022 self-hosted release. We no longer sell commercial self-hosted licenses. If you want to self-host Gitpod, you can still request our free community license. However, we no longer offer support or updates for it. If you are interested in an isolated, private installation of Gitpod, take a look at Gitpod Dedicated.\nRead our blog on Gitpod Dedicated to learn why we made the decision to discontinue self-hosted.\n\nThis page informs you if there are specific considerations to take into account when upgrading to a specific version. If no breaking changes and thus specific recommendations when updating are mentioned here (or if they do not apply to you), please follow the normal upgrade procedure mentioned on the Updating your Gitpod Installation page.\n\n__SPLIT_HERE__\n2022.09\n\nSecurity\n\nThis release includes security fixes addressing information leakage in logs; see the security announcement log for more information.\n\nBreaking Changes\n\nSingle Cluster Reference Architecture changes:Regular workspaces and headless workspaces are isolated to separate node pools to help avoid noisy neighbor issues between the two and guarantee maximum performance for workspaces\nWorkspace Services (such as ws-manager) are deployed to the services nodepool to prevent potential service degradation from high ws-daemon memory use.\nWe&#39;ve increased the default node size to 16 core / 64 GB nodes. This is to allow for more workspaces per node, and avoid the scenario where there is just one workspace per node. We&#39;ve also added documentation to detail our recommendations around workspace resources.\n\n__SPLIT_HERE__\n2022.08\n\nThere is no expected impact from these changes if using KOTS. These are documented for transparency purposes only.\nCustom labels from the pod selector labels removed\n\n11954: remove custom labels from the pod selector labels. This removes this limitation so this is a long-term improvement. The impact of this should be handled transparently for you by the KOTS installer.\n\nUsage of PodSecurityPolicies removed\n\n12336: Removal of PodSecurityPolicies. These were deprecated from Kubernetes 1.21 and removed from 1.25. This allows Gitpod to run on Kubernetes 1.25+, which is scheduled for imminent release. If you have PodSecurityPolicies enabled on your cluster, we suggest you disable them as soon as possible. If an installation is deployed to a cluster with PSPs enabled, you will need to add experimental.common.usePodSecurityPolicies = true to a config-patch file - however, do note that this is deprecated and exists to ease the transition away from PSPs.\n\n__SPLIT_HERE__\n2022.07\n\nSetting the service type of the proxy component\n\nYou can now configure the service type of the proxy service in the installation UI (see image below) - you do not need to upload a .yaml file as a config patch anymore to configure this. However, having it in the config patch will still work until December.\n\nproxy service type UI\n\nSetting the default workspace image and which image registries the default image can be pulled from\n\nWe&#39;ve moved the configuration of the default workspace image and the default base image registry whitelist out of the experimental section of the config-patch file. The latter was also renamed. Using them in the experimental section will still work for the time being (until approx. December 2022).\n\nBefore:\n\n```yaml\nexperimental:\n  webApp:\n    server:\n      defaultBaseImageRegistryWhitelist:\n        - <allowed registries>\n    workspaceDefaults:\n      workspaceImage: <path to your default workspace image>\n```\n\nAfter:\n\n```yaml\nworkspace:\n  workspaceImage: <path to your default workspace image>\ncontainerRegistry:\n  privateBaseImageAllowList:\n    - <allowed registries>\n```","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/upgrade-guides"}}],["678",{"pageContent":"__SPLIT_HERE__\nGitpod Self-Hosted\n\n‚ö†Ô∏è Deprecated Content\n\nThe content of this page assumes you are using Helm, which is now deprecated. Please use the Installer instead.\n\nGitpod, just as you know it from gitpod.io, can be deployed and operated on your own infrastructure. It supports different cloud providers, self-managed Kubernetes clusters, corporate firewalls, and even off-grid / air-gapped networks.\n\nRequirements for Gitpod Self-Hosted\nInstalling Gitpod Self-Hosted\nConfiguring Gitpod Self-Hosted\nTroubleshooting Gitpod Self-Hosted\nUpdating Gitpod Self-Hosted","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/helm-deprecated/index"}}],["679",{"pageContent":"__SPLIT_HERE__\nContribute Content\n\nCreating content (blog posts, YouTube and TikTok videos, presentations and demos) that shares tips+tricks and your experiences with Gitpod is amongst one of the most impactful ways you can help contribute. Everyone at Gitpod including our founders, engineers and product managers loves reading and watching content created by people in our community.\n\nGitpod maintains an invitational showcase of community contributed guides which are used to highlight content that is hosted elsewhere. Please do not raise pull-requests to the website that adds guides or blog posts without prior discussion and consent.\n\nInstead follow the IndieWeb guidelines of POSSE when authoring content by posting first on your own site/channel. By posting content first on your own site/channel then a direct feedback cycle forms between you and your readership through ownership of your content that helps you to improve your content.\n\nAfter the content has been published please:\n\nSend a tweet that mentions the @Gitpod Twitter account which will broadcast the content internally within the company.\n\n\nAdd a link to the content at https://github.com/shaal/awesome-gitpod\n\nThanks üß°","metadata":{"source":"https://gitpod.io/docs/help/contribute/content/index"}}],["680",{"pageContent":"__SPLIT_HERE__\nCode Style\n\n__SPLIT_HERE__\nGo\n\nWe typically follow the Uber Go Style Guide as our north star as the guide is comprehensive but not overburdening, easy to read and pretty good. Here&#39;s how our codebase differs:\n\nGitpod uses xerrors for error wrapping instead of pkg/errors\n\n__SPLIT_HERE__\nTypeScript\n\nTBA","metadata":{"source":"https://gitpod.io/docs/help/contribute/features-and-patches/code-style"}}],["681",{"pageContent":"__SPLIT_HERE__\nCommit Message Convention\n\nWe do not yet have an established convention but one is currently being discussed.","metadata":{"source":"https://gitpod.io/docs/help/contribute/features-and-patches/commit-message-convention"}}],["682",{"pageContent":"__SPLIT_HERE__\nContribute Features &amp; Patches\n\nGitpod is developed as an open core product under an OSI-approved open source license, making the majority of functionality freely usable and distributable, even for commercial use. As is typical with open core enterprise features are developed under a non OSI-approved license. Where contributions are not trivial (&quot;de minimis&quot;) Gitpod requires contributors to sign a contributors license agreement before we will be able to merge your contribution.\n\nGitpodders have built-in the open for the last decade. Transparency is key and as a company Gitpod strives to be as open about as many things as possible. This refers to both developing Gitpod in the open (public issues, public roadmap, public milestones) as well as how employees interact on a personal level with other human beings. Gitpodders are strong believers in the benefits that an open culture provides. At Gitpod we are open-minded, inclusive, transparent, and curious. We always remain students of the game, not masters of the game.\n\nCode Style\nCommit message convention\nSubmitting a pull request\n\nWe üß° the people who are involved in this project, and we‚Äôd love to help you with onboarding. Drop by the #contributing channel on the Gitpod Discord server and ask for help.","metadata":{"source":"https://gitpod.io/docs/help/contribute/features-and-patches/index"}}],["683",{"pageContent":"__SPLIT_HERE__\nSubmitting a pull request\n\nBefore you submit your pull request, please:\n\nIf you are considering submitting a pull-request that is more than a simple fix, open a discussion on GitHub first with your proposal.\nSearch GitHub for an open or closed Pull Request that relates to your submission.\n\nMake your changes in a new git branch:\n\n```shell\ngit checkout -b my-fix-branch main\n```\n\nFollow our Coding Style.\nCreate your patch, including appropriate test cases and documentation.\nRun the test suite.\nCommit your changes using a descriptive commit message that follows our commit message conventions.\n\n```shell\ngit commit -a\n```\n\nNote: the optional commit -a command line option will automatically &quot;add&quot; and &quot;rm&quot; edited files.\n\nBuild your changes locally to ensure all the tests pass.\n\n\nPush your branch to GitHub:\n\n```shell\ngit push origin my-fix-branch\n```\n\nIn GitHub, send a pull request to gitpod-io:main.\n\nIf we suggest changes, then:\n\nMake the required updates.\nRe-run the test suite to ensure tests are still passing.\nCommit your changes to your branch (e.g. my-fix-branch).\nPush the changes to your GitHub repository (this will update your Pull Request).\n\nThat&#39;s it! Thank you for your contribution!\n\n__SPLIT_HERE__\n[Optional] Submitting a pull request with Gitpod\n\nBefore you submit your pull request, please:\n\nIf you are considering submitting a pull-request that is more than a simple fix, open a discussion on GitHub first with your proposal.\nSearch GitHub for an open or closed Pull Request that relates to your submission.\n\nIf we suggest changes, then:\n\nMake the required updates.\nRe-run the test suite to ensure tests are still passing.\nCommit your changes to your branch (e.g. my-fix-branch).\nPush the changes to your GitHub repository (this will update your Pull Request).\n\nThat&#39;s it! Thank you for your contribution!","metadata":{"source":"https://gitpod.io/docs/help/contribute/features-and-patches/submitting-a-pull-request"}}],["684",{"pageContent":"__SPLIT_HERE__\nContribute Documentation\n\nGitpod has a dedicated team that looks after our documentation. You can help improve our documentation by:\n\nUsing the feedback widget at the bottom of each page in our documentation. All feedback is recorded into a spreadsheet and we use this information to drive the process to improve the Gitpod documentation.\nSubmitting documentation updates via the &quot;Edit on Gitpod button&quot; (top right on every page) when you learn something that you think other developers would also benefit from.\n\nWe üß° the people who are involved in this project, and we‚Äôd love to help you with onboarding. Drop by the #contributing channel on the Gitpod Discord server and ask for help.","metadata":{"source":"https://gitpod.io/docs/help/contribute/documentation/index"}}],["685",{"pageContent":"__SPLIT_HERE__\nAgda Quickstart\n\nLearn how to set-up and understand the benefits of Gitpod in less than 5 min with our Agda template.\n\nThe following guide will:\n\nWalk you through a real world example with an existing Gitpod config\nIntroduce you to prebuilds\nDemonstrate the benefits of ephemeral developer environments\n\nFor simplicity we use a GitHub template, but Gitpod works similarly with GitLab and Bitbucket.\n\n__SPLIT_HERE__\nStep 1: Clone Git repository\n\nCreate a new repository based on the Agda template.\nName it e.g. my-agda-template.\n\n__SPLIT_HERE__\nStep 2: Install the Gitpod app\n\nInstall the Gitpod App.\n\nGitpod&#39;s GitHub app is similar to a CI server and will continuously prepare prebuilds for all your branches and pull requests - so you don&#39;t have to wait for Maven or NPM downloading the internet when you want to start coding.\n\n__SPLIT_HERE__\nStep 3: First prebuild\n\nStart your first workspace with a prebuild by prefixing https://gitpod.io#prebuild/ to the URL of the repository.\n\nThe revised URL is: https://gitpod.io/#prebuild/https://github.com/&lt;github_username&gt;/&lt;my-agda-template&gt;\n\nGitpod displays the prebuild progress status by running the init commands in the .gitpod.yml file before you even start a workspace. Later, when you create a new workspace on a branch, or pull/merge request the workspace loads much faster, because all dependencies are already downloaded and the code is compiled. For more information see prebuilds.\n\n__SPLIT_HERE__\nStep 4: Enjoy being ready-to-code ü§ô\n\nOnce the first prebuild ran, Gitpod starts an automated and fully configured developer environment in a workspace that is now ready for you to develop.\n\nOther developers made their setup even more productive and supercharged their workflows with the following quick steps:\n\nInstalling the browser extension\n\nYou can install the Gitpod browser extension on any Chromium-based browsers such as Microsoft Edge, Brave, Chrome, and others, or on a Firefox browser.\n\nThe extension simply adds a Gitpod button on every project and branch across GitHub, and Bitbucket that prefixes the URL with gitpod.io/# so that you can easily open a new workspace from any Git context.\n\nBrowser Extension\n\nIf you prefer to not install browser extensions then you can use the Gitpod browser bookmarklet instead.\n\nFor our partner GitLab we have a native integration into their UI that you can enable here.\n\nAdd your favorite VS Code themes and extensions\n\nYou have access to all Visual Studio Code extensions published under the vendor neutral Open VSX registry. Install one by clicking the Extensions icon in the left sidebar and enter your favorite theme or VS Code extension.\n\nChanges you make in your workspace such as themes and extensions are synced automatically to other workspaces.\n\nStart throwing away workspaces like paper towels\n\nYou can now start to treat dev environments as automated resources you spin up when you need them and close down (and forget about) when you are done with your task. Dev environments become fully ephemeral.\n\nYou even can start switching between workspaces or open several workspaces on the same context - two for your feature, one for reviewing a PR/MR, one for a bug, one for another MR/PR.\n\nTry it out and open 3 workspaces on the same context (e.g. on main or on an issue). ü§ì\n\n__SPLIT_HERE__\nNext Steps\n\nYou&#39;ve successfully ran your first workspace and experienced first hand what we mean with ephemeral dev environments. This is just the first step on your journey towards being always ready to code. Helpful resources from here are:\n\nGetting started with your own project\nGit Integrations","metadata":{"source":"https://gitpod.io/docs/introduction/getting-started/quickstart/agda"}}],["686",{"pageContent":"__SPLIT_HERE__\nC Quickstart\n\nLearn how to set-up and understand the benefits of Gitpod in less than 5 min with our C template.\n\nThe following guide will:\n\nWalk you through a real world example with an existing Gitpod config\nIntroduce you to prebuilds\nDemonstrate the benefits of ephemeral developer environments\n\nFor simplicity we use a GitHub template, but Gitpod works similarly with GitLab and Bitbucket.\n\n__SPLIT_HERE__\nStep 1: Clone Git repository\n\nCreate a new repository based on the C template.\nName it e.g. my-c-template.\n\n__SPLIT_HERE__\nStep 2: Install Gitpod app\n\nInstall the Gitpod App.\n\nGitpod&#39;s GitHub app is similar to a CI server and will continuously prepare prebuilds for all your branches and pull requests - so you don&#39;t have to wait for installation of dependencies from the internet when you want to start coding.\n\n__SPLIT_HERE__\nStep 3: First prebuild\n\nStart your first workspace with a prebuild by prefixing https://gitpod.io#prebuild/ to the URL of the repository.\n\nThe revised URL is: https://gitpod.io/#prebuild/https://github.com/&lt;github_username&gt;/my-c-template\n\nGitpod displays the prebuild progress status by running the init commands in the .gitpod.yml file before you even start a workspace. Later, when you create a new workspace on a branch, or pull/merge request the workspace loads much faster, because all dependencies are already downloaded and the code is compiled. For more information see prebuilds.\n\n__SPLIT_HERE__\nStep 4: Enjoy being ready-to-code ü§ô\n\nOnce the first prebuild ran, Gitpod starts an automated and fully configured developer environment in a workspace that is now ready for you to develop.\n\nOther developers made their setup even more productive and supercharged their workflows with the following quick steps:\n\nInstalling the browser extension\n\nYou can install the Gitpod browser extension on any Chromium-based browsers such as Microsoft Edge, Brave, Chrome, and others, or on a Firefox browser.\n\nThe extension simply adds a Gitpod button on every project and branch across GitHub, and Bitbucket that prefixes the URL with gitpod.io/# so that you can easily open a new workspace from any Git context.\n\nBrowser Extension\n\nIf you prefer to not install browser extensions then you can use the Gitpod browser bookmarklet instead.\n\nFor our partner GitLab we have a native integration into their UI that you can enable here.\n\nAdd your favorite VS Code themes and extensions\n\nYou have access to all Visual Studio Code extensions published under the vendor neutral Open VSX registry. Install one by clicking the Extensions icon in the left sidebar and enter your favorite theme or VS Code extension.\n\nChanges you make in your workspace such as themes and extensions are synced automatically to other workspaces.\n\nStart throwing away workspaces like paper towels\n\nYou can now start to treat dev environments as automated resources you spin up when you need them and close down (and forget about) when you are done with your task. Dev environments become fully ephemeral.\n\nYou even can start switching between workspaces or open several workspaces on the same context - two for your feature, one for reviewing a PR/MR, one for a bug, one for another MR/PR.\n\nTry it out and open 3 workspaces on the same context (e.g. on main or on an issue). ü§ì\n\n__SPLIT_HERE__\nNext Steps\n\nYou&#39;ve successfully ran your first workspace and experienced first hand what we mean with ephemeral dev environments. This is just the first step on your journey towards being always ready to code. Helpful resources from here are:\n\nGetting started with your own project\nGit Integrations","metadata":{"source":"https://gitpod.io/docs/introduction/getting-started/quickstart/c"}}],["687",{"pageContent":"__SPLIT_HERE__\nClojure Quickstart\n\nLearn how to set-up and understand the benefits of Gitpod in less than 5 min with our Clojure template.\n\nThe following guide will:\n\nWalk you through a real world example with an existing Gitpod config\nIntroduce you to prebuilds\nDemonstrate the benefits of ephemeral developer environments\n\nFor simplicity we use a GitHub template, but Gitpod works similarly with GitLab and Bitbucket.\n\n__SPLIT_HERE__\nStep 1: Clone Git repository\n\nCreate a new repository based on the Clojure template.\nName it e.g. my-clojure-template.\n\n__SPLIT_HERE__\nStep 2: Install Gitpod app\n\nInstall the Gitpod App.\n\nGitpod&#39;s GitHub app is similar to a CI server and will continuously prepare prebuilds for all your branches and pull requests - so you don&#39;t have to wait for installation of dependencies from the internet when you want to start coding.\n\n__SPLIT_HERE__\nStep 3: First prebuild\n\nStart your first workspace with a prebuild by prefixing https://gitpod.io#prebuild/ to the URL of the repository.\n\nThe revised URL is: https://gitpod.io/#prebuild/https://github.com/&lt;github_username&gt;/my-clojure-template\n\nGitpod displays the prebuild progress status by running the init commands in the .gitpod.yml file before you even start a workspace. Later, when you create a new workspace on a branch, or pull/merge request the workspace loads much faster, because all dependencies are already downloaded and the code is compiled. For more information see prebuilds.\n\n__SPLIT_HERE__\nStep 4: Enjoy being ready-to-code ü§ô\n\nOnce the first prebuild ran, Gitpod starts an automated and fully configured developer environment in a workspace that is now ready for you to develop.\n\nOther developers made their setup even more productive and supercharged their workflows with the following quick steps:\n\nInstalling the browser extension\n\nYou can install the Gitpod browser extension on any Chromium-based browsers such as Microsoft Edge, Brave, Chrome, and others, or on a Firefox browser.\n\nThe extension simply adds a Gitpod button on every project and branch across GitHub, and Bitbucket that prefixes the URL with gitpod.io/# so that you can easily open a new workspace from any Git context.\n\nBrowser Extension\n\nIf you prefer to not install browser extensions then you can use the Gitpod browser bookmarklet instead.\n\nFor our partner GitLab we have a native integration into their UI that you can enable here.\n\nAdd your favorite VS Code themes and extensions\n\nYou have access to all Visual Studio Code extensions published under the vendor neutral Open VSX registry. Install one by clicking the Extensions icon in the left sidebar and enter your favorite theme or VS Code extension.\n\nChanges you make in your workspace such as themes and extensions are synced automatically to other workspaces.\n\nStart throwing away workspaces like paper towels\n\nYou can now start to treat dev environments as automated resources you spin up when you need them and close down (and forget about) when you are done with your task. Dev environments become fully ephemeral.\n\nYou even can start switching between workspaces or open several workspaces on the same context - two for your feature, one for reviewing a PR/MR, one for a bug, one for another MR/PR.\n\nTry it out and open 3 workspaces on the same context (e.g. on main or on an issue). ü§ì\n\n__SPLIT_HERE__\nNext Steps\n\nYou&#39;ve successfully ran your first workspace and experienced first hand what we mean with ephemeral dev environments. This is just the first step on your journey towards being always ready to code. Helpful resources from here are:\n\nGetting started with your own project\nGit Integrations","metadata":{"source":"https://gitpod.io/docs/introduction/getting-started/quickstart/clojure"}}],["688",{"pageContent":"__SPLIT_HERE__\nCoq Quickstart\n\nLearn how to set-up and understand the benefits of Gitpod in less than 5 min with our Coq template.\n\nThe following guide will:\n\nWalk you through a real world example with an existing Gitpod config\nIntroduce you to prebuilds\nDemonstrate the benefits of ephemeral developer environments\n\nFor simplicity we use a GitHub template, but Gitpod works similarly with GitLab and Bitbucket.\n\nStep 1: Clone Git repository\n\nCreate a new repository based on the Coq template.\nName it e.g. my-coq-template.\n\nStep 2: Install Gitpod app\n\nInstall the Gitpod App.\n\nGitpod&#39;s GitHub app is similar to a CI server and will continuously prepare prebuilds for all your branches and pull requests - so you don&#39;t have to wait for installation of dependencies from the internet when you want to start coding.\n\nStep 3: First prebuild\n\nStart your first workspace with a prebuild by prefixing https://gitpod.io#prebuild/ to the URL of the repository.\n\nThe revised URL is: https://gitpod.io/#prebuild/https://github.com/&lt;github_username&gt;/my-coq-template\n\nGitpod displays the prebuild progress status by running the init commands in the .gitpod.yml file before you even start a workspace. Later, when you create a new workspace on a branch, or pull/merge request the workspace loads much faster, because all dependencies are already downloaded and the code is compiled. For more information see prebuilds.\n\nStep 4: Enjoy being ready-to-code ü§ô\n\nOnce the first prebuild ran, Gitpod starts an automated and fully configured developer environment in a workspace that is now ready for you to develop.\n\nOther developers made their setup even more productive and supercharged their workflows with the following quick steps:\n\nInstalling the browser extension\n\nYou can install the Gitpod browser extension on any Chromium-based browsers such as Microsoft Edge, Brave, Chrome, and others, or on a Firefox browser.\n\nThe extension simply adds a Gitpod button on every project and branch across GitHub, and Bitbucket that prefixes the URL with gitpod.io/# so that you can easily open a new workspace from any Git context.\n\nBrowser Extension\n\nIf you prefer to not install browser extensions then you can use the Gitpod browser bookmarklet instead.\n\nFor our partner GitLab we have a native integration into their UI that you can enable here.\n\nAdd your favorite VS Code themes and extensions\n\nYou have access to all Visual Studio Code extensions published under the vendor neutral Open VSX registry. Install one by clicking the Extensions icon in the left sidebar and enter your favorite theme or VS Code extension.\n\nChanges you make in your workspace such as themes and extensions are synced automatically to other workspaces.\n\nStart throwing away workspaces like paper towels\n\nYou can now start to treat dev environments as automated resources you spin up when you need them and close down (and forget about) when you are done with your task. Dev environments become fully ephemeral.\n\nYou even can start switching between workspaces or open several workspaces on the same context - two for your feature, one for reviewing a PR/MR, one for a bug, one for another MR/PR.\n\nTry it out and open 3 workspaces on the same context (e.g. on main or on an issue). ü§ì\n\n__SPLIT_HERE__\nNext Steps\n\nYou&#39;ve successfully ran your first workspace and experienced first hand what we mean with ephemeral dev environments. This is just the first step on your journey towards being always ready to code. Helpful resources from here are:\n\nGetting started with your own project\nGit Integrations","metadata":{"source":"https://gitpod.io/docs/introduction/getting-started/quickstart/coq"}}],["689",{"pageContent":"__SPLIT_HERE__\nC++ CMake Quickstart\n\nLearn how to set-up and understand the benefits of Gitpod in less than 5 min with our C++ CMake template.\n\nThe following guide will:\n\nWalk you through a real world example with an existing Gitpod config\nIntroduce you to prebuilds\nDemonstrate the benefits of ephemeral developer environments\n\nFor simplicity we use a GitHub template, but Gitpod works similarly with GitLab and Bitbucket.\n\nStep 1: Clone Git repository\n\nCreate a new repository based on the C template.\nName it e.g. my-cpp-template.\n\nStep 2: Install Gitpod app\n\nInstall the Gitpod App.\n\nGitpod&#39;s GitHub app is similar to a CI server and will continuously prepare prebuilds for all your branches and pull requests - so you don&#39;t have to wait for installation of dependencies from the internet when you want to start coding.\n\nStep 3: First prebuild\n\nStart your first workspace with a prebuild by prefixing https://gitpod.io#prebuild/ to the URL of the repository.\n\nThe revised URL is: https://gitpod.io/#prebuild/https://github.com/&lt;github_username&gt;/my-cpp-template\n\nGitpod displays the prebuild progress status by running the init commands in the .gitpod.yml file before you even start a workspace. Later, when you create a new workspace on a branch, or pull/merge request the workspace loads much faster, because all dependencies are already downloaded and the code is compiled. For more information see prebuilds.\n\nStep 4: Enjoy being ready-to-code ü§ô\n\nOnce the first prebuild ran, Gitpod starts an automated and fully configured developer environment in a workspace that is now ready for you to develop.\n\nOther developers made their setup even more productive and supercharged their workflows with the following quick steps:\n\nInstalling the browser extension\n\nYou can install the Gitpod browser extension on any Chromium-based browsers such as Microsoft Edge, Brave, Chrome, and others, or on a Firefox browser.\n\nThe extension simply adds a Gitpod button on every project and branch across GitHub, and Bitbucket that prefixes the URL with gitpod.io/# so that you can easily open a new workspace from any Git context.\n\nBrowser Extension\n\nIf you prefer to not install browser extensions then you can use the Gitpod browser bookmarklet instead.\n\nFor our partner GitLab we have a native integration into their UI that you can enable here.\n\nAdd your favorite VS Code themes and extensions\n\nYou have access to all Visual Studio Code extensions published under the vendor neutral Open VSX registry. Install one by clicking the Extensions icon in the left sidebar and enter your favorite theme or VS Code extension.\n\nChanges you make in your workspace such as themes and extensions are synced automatically to other workspaces.\n\nStart throwing away workspaces like paper towels\n\nYou can now start to treat dev environments as automated resources you spin up when you need them and close down (and forget about) when you are done with your task. Dev environments become fully ephemeral.\n\nYou even can start switching between workspaces or open several workspaces on the same context - two for your feature, one for reviewing a PR/MR, one for a bug, one for another MR/PR.\n\nTry it out and open 3 workspaces on the same context (e.g. on main or on an issue). ü§ì\n\n__SPLIT_HERE__\nNext Steps\n\nYou&#39;ve successfully ran your first workspace and experienced first hand what we mean with ephemeral dev environments. This is just the first step on your journey towards being always ready to code. Helpful resources from here are:\n\nGetting started with your own project\nGit Integrations","metadata":{"source":"https://gitpod.io/docs/introduction/getting-started/quickstart/cpp"}}],["690",{"pageContent":"__SPLIT_HERE__\nDatasette Quickstart\n\nLearn how to set-up and understand the benefits of Gitpod in less than 5 min with our Datasette template.\n\nThe following guide will:\n\nWalk you through a real world example with an existing Gitpod config\nIntroduce you to prebuilds\nDemonstrate the benefits of ephemeral developer environments\n\nFor simplicity we use a GitHub template, but Gitpod works similarly with GitLab and Bitbucket.\n\n__SPLIT_HERE__\nStep 1: Clone Git repository\n\nCreate a new repository based on the Datasette template.\nName it e.g. my-datasette-template.\n\n__SPLIT_HERE__\nStep 2: Install the Gitpod app\n\nInstall the Gitpod App.\n\nGitpod&#39;s GitHub app is similar to a CI server and will continuously prepare prebuilds for all your branches and pull requests - so you don&#39;t have to wait for Maven or NPM downloading the internet when you want to start coding.\n\n__SPLIT_HERE__\nStep 3: First prebuild\n\nStart your first workspace with a prebuild by prefixing https://gitpod.io#prebuild/ to the URL of the repository.\n\nThe revised URL is: https://gitpod.io/#prebuild/https://github.com/&lt;github_username&gt;/&lt;my-datasette-template&gt;\n\nGitpod displays the prebuild progress status by running the init commands in the .gitpod.yml file before you even start a workspace. Later, when you create a new workspace on a branch, or pull/merge request the workspace loads much faster, because all dependencies are already downloaded and the code is compiled. For more information see prebuilds.\n\n__SPLIT_HERE__\nStep 4: Enjoy being ready-to-code ü§ô\n\nOnce the first prebuild ran, Gitpod starts an automated and fully configured developer environment in a workspace that is now ready for you to develop.\n\nOther developers made their setup even more productive and supercharged their workflows with the following quick steps:\n\nInstalling the browser extension\n\nYou can install the Gitpod browser extension on any Chromium-based browsers such as Microsoft Edge, Brave, Chrome, and others, or on a Firefox browser.\n\nThe extension simply adds a Gitpod button on every project and branch across GitHub, and Bitbucket that prefixes the URL with gitpod.io/# so that you can easily open a new workspace from any Git context.\n\nBrowser Extension\n\nIf you prefer to not install browser extensions then you can use the Gitpod browser bookmarklet instead.\n\nFor our partner GitLab we have a native integration into their UI that you can enable here.\n\nAdd your favorite VS Code themes and extensions\n\nYou have access to all Visual Studio Code extensions published under the vendor neutral Open VSX registry. Install one by clicking the Extensions icon in the left sidebar and enter your favorite theme or VS Code extension.\n\nChanges you make in your workspace such as themes and extensions are synced automatically to other workspaces.\n\nStart throwing away workspaces like paper towels\n\nYou can now start to treat dev environments as automated resources you spin up when you need them and close down (and forget about) when you are done with your task. Dev environments become fully ephemeral.\n\nYou even can start switching between workspaces or open several workspaces on the same context - two for your feature, one for reviewing a PR/MR, one for a bug, one for another MR/PR.\n\nTry it out and open 3 workspaces on the same context (e.g. on main or on an issue). ü§ì\n\n__SPLIT_HERE__\nNext Steps\n\nYou&#39;ve successfully ran your first workspace and experienced first hand what we mean with ephemeral dev environments. This is just the first step on your journey towards being always ready to code. Helpful resources from here are:\n\nGetting started with your own project\nGit Integrations","metadata":{"source":"https://gitpod.io/docs/introduction/getting-started/quickstart/datasette"}}],["691",{"pageContent":"__SPLIT_HERE__\nDeno Quickstart\n\nLearn how to set-up and understand the benefits of Gitpod in less than 5 min with our Deno template.\n\nThe following guide will:\n\nWalk you through a real world example with an existing Gitpod config\nIntroduce you to prebuilds\nDemonstrate the benefits of ephemeral developer environments\n\nFor simplicity we use a GitHub template, but Gitpod works similarly with GitLab and Bitbucket.\n\n__SPLIT_HERE__\nStep 1: Clone Git repository\n\nCreate a new repository based on the Deno template.\nName it e.g. my-typescript-deno-template.\n\n__SPLIT_HERE__\nStep 2: Install Gitpod app\n\nInstall the Gitpod App.\n\nGitpod&#39;s GitHub app is similar to a CI server and will continuously prepare prebuilds for all your branches and pull requests - so you don&#39;t have to wait for Maven or NPM downloading the internet when you want to start coding.\n\n__SPLIT_HERE__\nStep 3: First prebuild\n\nStart your first workspace with a prebuild by prefixing https://gitpod.io#prebuild/ to the URL of the repository.\n\nThe revised URL is: https://gitpod.io/#prebuild/https://github.com/&lt;github_username&gt;/my-typescript-deno-template\n\nGitpod displays the prebuild progress status by running the init commands in the .gitpod.yml file before you even start a workspace. Later, when you create a new workspace on a branch, or pull/merge request the workspace loads much faster, because all dependencies are already downloaded and the code is compiled. For more information see prebuilds.\n\n__SPLIT_HERE__\nStep 4: Enjoy being ready-to-code ü§ô\n\nOnce the first prebuild ran, Gitpod starts an automated and fully configured developer environment in a workspace that is now ready for you to develop.\n\nOther developers made their setup even more productive and supercharged their workflows with the following quick steps:\n\nInstalling the browser extension\n\nYou can install the Gitpod browser extension on any Chromium-based browsers such as Microsoft Edge, Brave, Chrome, and others, or on a Firefox browser.\n\nThe extension simply adds a Gitpod button on every project and branch across GitHub, and Bitbucket that prefixes the URL with gitpod.io/# so that you can easily open a new workspace from any Git context.\n\nBrowser Extension\n\nIf you prefer to not install browser extensions then you can use the Gitpod browser bookmarklet instead.\n\nFor our partner GitLab we have a native integration into their UI that you can enable here.\n\nAdd your favorite VS Code themes and extensions\n\nYou have access to all Visual Studio Code extensions published under the vendor neutral Open VSX registry. Install one by clicking the Extensions icon in the left sidebar and enter your favorite theme or VS Code extension.\n\nChanges you make in your workspace such as themes and extensions are synced automatically to other workspaces.\n\nStart throwing away workspaces like paper towels\n\nYou can now start to treat dev environments as automated resources you spin up when you need them and close down (and forget about) when you are done with your task. Dev environments become fully ephemeral.\n\nYou even can start switching between workspaces or open several workspaces on the same context - two for your feature, one for reviewing a PR/MR, one for a bug, one for another MR/PR.\n\nTry it out and open 3 workspaces on the same context (e.g. on main or on an issue). ü§ì\n\n__SPLIT_HERE__\nNext Steps\n\nYou&#39;ve successfully ran your first workspace and experienced first hand what we mean with ephemeral dev environments. This is just the first step on your journey towards being always ready to code. Helpful resources from here are:\n\nGetting started with your own project\nGit Integrations","metadata":{"source":"https://gitpod.io/docs/introduction/getting-started/quickstart/deno"}}],["692",{"pageContent":"__SPLIT_HERE__\nDocker Compose Quickstart\n\nLearn how to set-up and understand the benefits of Gitpod in less than 5 min with our Docker Compose template.\n\nThe following guide will:\n\nWalk you through a real world example with an existing Gitpod config\nIntroduce you to prebuilds\nDemonstrate the benefits of ephemeral developer environments\n\nFor simplicity we use a GitHub template, but Gitpod works similarly with GitLab and Bitbucket.\n\n__SPLIT_HERE__\nStep 1: Clone Git repository\n\nCreate a new repository based on the Docker Compose template.\nName it e.g. my-docker-compose-template.\n\n__SPLIT_HERE__\nStep 2: Install the Gitpod app\n\nInstall the Gitpod App.\n\nGitpod&#39;s GitHub app is similar to a CI server and will continuously prepare prebuilds for all your branches and pull requests - so you don&#39;t have to wait for Maven or NPM downloading the internet when you want to start coding.\n\n__SPLIT_HERE__\nStep 3: First prebuild\n\nStart your first workspace with a prebuild by prefixing https://gitpod.io#prebuild/ to the URL of the repository.\n\nThe revised URL is: https://gitpod.io/#prebuild/https://github.com/&lt;github_username&gt;/&lt;my-docker-compose-template&gt;\n\nGitpod displays the prebuild progress status by running the init commands in the .gitpod.yml file before you even start a workspace. Later, when you create a new workspace on a branch, or pull/merge request the workspace loads much faster, because all dependencies are already downloaded and the code is compiled. For more information see prebuilds.\n\n__SPLIT_HERE__\nStep 4: Enjoy being ready-to-code ü§ô\n\nOnce the first prebuild ran, Gitpod starts an automated and fully configured developer environment in a workspace that is now ready for you to develop.\n\nOther developers made their setup even more productive and supercharged their workflows with the following quick steps:\n\nInstalling the browser extension\n\nYou can install the Gitpod browser extension on any Chromium-based browsers such as Microsoft Edge, Brave, Chrome, and others, or on a Firefox browser.\n\nThe extension simply adds a Gitpod button on every project and branch across GitHub, and Bitbucket that prefixes the URL with gitpod.io/# so that you can easily open a new workspace from any Git context.\n\nBrowser Extension\n\nIf you prefer to not install browser extensions then you can use the Gitpod browser bookmarklet instead.\n\nFor our partner GitLab we have a native integration into their UI that you can enable here.\n\nAdd your favorite VS Code themes and extensions\n\nYou have access to all Visual Studio Code extensions published under the vendor neutral Open VSX registry. Install one by clicking the Extensions icon in the left sidebar and enter your favorite theme or VS Code extension.\n\nChanges you make in your workspace such as themes and extensions are synced automatically to other workspaces.\n\nStart throwing away workspaces like paper towels\n\nYou can now start to treat dev environments as automated resources you spin up when you need them and close down (and forget about) when you are done with your task. Dev environments become fully ephemeral.\n\nYou even can start switching between workspaces or open several workspaces on the same context - two for your feature, one for reviewing a PR/MR, one for a bug, one for another MR/PR.\n\nTry it out and open 3 workspaces on the same context (e.g. on main or on an issue). ü§ì\n\n__SPLIT_HERE__\nNext Steps\n\nYou&#39;ve successfully ran your first workspace and experienced first hand what we mean with ephemeral dev environments. This is just the first step on your journey towards being always ready to code. Helpful resources from here are:\n\nGetting started with your own project\nGit Integrations","metadata":{"source":"https://gitpod.io/docs/introduction/getting-started/quickstart/docker-compose"}}],["693",{"pageContent":"__SPLIT_HERE__\nC# .NET Quickstart\n\nLearn how to set-up and understand the benefits of Gitpod in less than 5 min with our C# .NET template.\n\nThe following guide will:\n\nWalk you through a real world example with an existing Gitpod config\nIntroduce you to prebuilds\nDemonstrate the benefits of ephemeral developer environments\n\nFor simplicity we use a GitHub template, but Gitpod works similarly with GitLab and Bitbucket.\n\nStep 1: Clone Git repository\n\nCreate a new repository based on the C# template.\nName it e.g. my-dotnet-template.\n\nStep 2: Install Gitpod app\n\nInstall the Gitpod App.\n\nGitpod&#39;s GitHub app is similar to a CI server and will continuously prepare prebuilds for all your branches and pull requests - so you don&#39;t have to wait for installation of dependencies from the internet when you want to start coding.\n\nStep 3: First prebuild\n\nStart your first workspace with a prebuild by prefixing https://gitpod.io#prebuild/ to the URL of the repository.\n\nThe revised URL is: https://gitpod.io/#prebuild/https://github.com/&lt;github_username&gt;/my-dotnet-template\n\nGitpod displays the prebuild progress status by running the init commands in the .gitpod.yml file before you even start a workspace. Later, when you create a new workspace on a branch, or pull/merge request the workspace loads much faster, because all dependencies are already downloaded and the code is compiled. For more information see prebuilds.\n\nStep 4: Enjoy being ready-to-code ü§ô\n\nOnce the first prebuild ran, Gitpod starts an automated and fully configured developer environment in a workspace that is now ready for you to develop.\n\nOther developers made their setup even more productive and supercharged their workflows with the following quick steps:\n\nInstalling the browser extension\n\nYou can install the Gitpod browser extension on any Chromium-based browsers such as Microsoft Edge, Brave, Chrome, and others, or on a Firefox browser.\n\nThe extension simply adds a Gitpod button on every project and branch across GitHub, and Bitbucket that prefixes the URL with gitpod.io/# so that you can easily open a new workspace from any Git context.\n\nBrowser Extension\n\nIf you prefer to not install browser extensions then you can use the Gitpod browser bookmarklet instead.\n\nFor our partner GitLab we have a native integration into their UI that you can enable here.\n\nAdd your favorite VS Code themes and extensions\n\nYou have access to all Visual Studio Code extensions published under the vendor neutral Open VSX registry. Install one by clicking the Extensions icon in the left sidebar and enter your favorite theme or VS Code extension.\n\nChanges you make in your workspace such as themes and extensions are synced automatically to other workspaces.\n\nStart throwing away workspaces like paper towels\n\nYou can now start to treat dev environments as automated resources you spin up when you need them and close down (and forget about) when you are done with your task. Dev environments become fully ephemeral.\n\nYou even can start switching between workspaces or open several workspaces on the same context - two for your feature, one for reviewing a PR/MR, one for a bug, one for another MR/PR.\n\nTry it out and open 3 workspaces on the same context (e.g. on main or on an issue). ü§ì\n\n__SPLIT_HERE__\nNext Steps\n\nYou&#39;ve successfully ran your first workspace and experienced first hand what we mean with ephemeral dev environments. This is just the first step on your journey towards being always ready to code. Helpful resources from here are:\n\nGetting started with your own project\nGit Integrations\n.NET in Gitpod","metadata":{"source":"https://gitpod.io/docs/introduction/getting-started/quickstart/dotnet"}}],["694",{"pageContent":"__SPLIT_HERE__\nDrupal Quickstart\n\nLearn how to set-up and understand the benefits of Gitpod in less than 5 min with our Drupal template.\n\nThe following guide will:\n\nWalk you through a real world example with an existing Gitpod config\nIntroduce you to prebuilds\nDemonstrate the benefits of ephemeral developer environments\n\nFor simplicity we use a GitHub template, but Gitpod works similarly with GitLab and Bitbucket.\n\n__SPLIT_HERE__\nStep 1: Clone Git repository\n\nCreate a new repository based on the Drupal template.\nName it e.g. my-drupal-template.\n\n__SPLIT_HERE__\nStep 2: Install the Gitpod app\n\nInstall the Gitpod App.\n\nGitpod&#39;s GitHub app is similar to a CI server and will continuously prepare prebuilds for all your branches and pull requests - so you don&#39;t have to wait for Maven or NPM downloading the internet when you want to start coding.\n\n__SPLIT_HERE__\nStep 3: First prebuild\n\nStart your first workspace with a prebuild by prefixing https://gitpod.io#prebuild/ to the URL of the repository.\n\nThe revised URL is: https://gitpod.io/#prebuild/https://github.com/&lt;github_username&gt;/&lt;my-drupal-template&gt;\n\nGitpod displays the prebuild progress status by running the init commands in the .gitpod.yml file before you even start a workspace. Later, when you create a new workspace on a branch, or pull/merge request the workspace loads much faster, because all dependencies are already downloaded and the code is compiled. For more information see prebuilds.\n\n__SPLIT_HERE__\nStep 4: Enjoy being ready-to-code ü§ô\n\nOnce the first prebuild ran, Gitpod starts an automated and fully configured developer environment in a workspace that is now ready for you to develop.\n\nOther developers made their setup even more productive and supercharged their workflows with the following quick steps:\n\nInstalling the browser extension\n\nYou can install the Gitpod browser extension on any Chromium-based browsers such as Microsoft Edge, Brave, Chrome, and others, or on a Firefox browser.\n\nThe extension simply adds a Gitpod button on every project and branch across GitHub, and Bitbucket that prefixes the URL with gitpod.io/# so that you can easily open a new workspace from any Git context.\n\nBrowser Extension\n\nIf you prefer to not install browser extensions then you can use the Gitpod browser bookmarklet instead.\n\nFor our partner GitLab we have a native integration into their UI that you can enable here.\n\nAdd your favorite VS Code themes and extensions\n\nYou have access to all Visual Studio Code extensions published under the vendor neutral Open VSX registry. Install one by clicking the Extensions icon in the left sidebar and enter your favorite theme or VS Code extension.\n\nChanges you make in your workspace such as themes and extensions are synced automatically to other workspaces.\n\nStart throwing away workspaces like paper towels\n\nYou can now start to treat dev environments as automated resources you spin up when you need them and close down (and forget about) when you are done with your task. Dev environments become fully ephemeral.\n\nYou even can start switching between workspaces or open several workspaces on the same context - two for your feature, one for reviewing a PR/MR, one for a bug, one for another MR/PR.\n\nTry it out and open 3 workspaces on the same context (e.g. on main or on an issue). ü§ì\n\n__SPLIT_HERE__\nNext Steps\n\nYou&#39;ve successfully ran your first workspace and experienced first hand what we mean with ephemeral dev environments. This is just the first step on your journey towards being always ready to code. Helpful resources from here are:\n\nGetting started with your own project\nGit Integrations","metadata":{"source":"https://gitpod.io/docs/introduction/getting-started/quickstart/drupal"}}],["695",{"pageContent":"__SPLIT_HERE__\nElixir Quickstart\n\nLearn how to set-up and understand the benefits of Gitpod in less than 5 min with an Elixir template.\n\nThank you @tnb24 for creating the repository üôè!\n\nThe following guide will:\n\nWalk you through a real world example with an existing Gitpod config\nIntroduce you to prebuilds\nDemonstrate the benefits of ephemeral developer environments\n\nFor simplicity we use a GitHub template, but Gitpod works similarly with GitLab and Bitbucket.\n\n__SPLIT_HERE__\nStep 1: Clone Git repository\n\nCreate a new repository based on the Elixir template.\nName it e.g. my-elixir-template.\n\n__SPLIT_HERE__\nStep 2: Install Gitpod app\n\nInstall the Gitpod App.\n\nGitpod&#39;s GitHub app is similar to a CI server and will continuously prepare prebuilds for all your branches and pull requests - so you don&#39;t have to wait for Maven or NPM downloading the internet when you want to start coding.\n\n__SPLIT_HERE__\nStep 3: First prebuild\n\nStart your first workspace with a prebuild by prefixing https://gitpod.io#prebuild/ to the URL of the repository.\n\nThe revised URL is: https://gitpod.io/#prebuild/https://github.com/&lt;github_username&gt;/my-elixir-template\n\nGitpod displays the prebuild progress status by running the init commands in the .gitpod.yml file before you even start a workspace. Later, when you create a new workspace on a branch, or pull/merge request the workspace loads much faster, because all dependencies are already downloaded and the code is compiled. For more information see prebuilds.\n\n__SPLIT_HERE__\nStep 4: Enjoy being ready-to-code ü§ô\n\nOnce the first prebuild ran, Gitpod starts an automated and fully configured developer environment in a workspace that is now ready for you to develop.\n\nOther developers made their setup even more productive and supercharged their workflows with the following quick steps:\n\nInstalling the browser extension\n\nYou can install the Gitpod browser extension on any Chromium-based browsers such as Microsoft Edge, Brave, Chrome, and others, or on a Firefox browser.\n\nThe extension simply adds a Gitpod button on every project and branch across GitHub, and Bitbucket that prefixes the URL with gitpod.io/# so that you can easily open a new workspace from any Git context.\n\nBrowser Extension\n\nIf you prefer to not install browser extensions then you can use the Gitpod browser bookmarklet instead.\n\nFor our partner GitLab we have a native integration into their UI that you can enable here.\n\nAdd your favorite VS Code themes and extensions\n\nYou have access to all Visual Studio Code extensions published under the vendor neutral Open VSX registry. Install one by clicking the Extensions icon in the left sidebar and enter your favorite theme or VS Code extension.\n\nChanges you make in your workspace such as themes and extensions are synced automatically to other workspaces.\n\nStart throwing away workspaces like paper towels\n\nYou can now start to treat dev environments as automated resources you spin up when you need them and close down (and forget about) when you are done with your task. Dev environments become fully ephemeral.\n\nYou even can start switching between workspaces or open several workspaces on the same context - two for your feature, one for reviewing a PR/MR, one for a bug, one for another MR/PR.\n\nTry it out and open 3 workspaces on the same context (e.g. on main or on an issue). ü§ì\n\n__SPLIT_HERE__\nNext Steps\n\nYou&#39;ve successfully ran your first workspace and experienced first hand what we mean with ephemeral dev environments. This is just the first step on your journey towards being always ready to code. Helpful resources from here are:\n\nGetting started with your own project\nGit Integrations","metadata":{"source":"https://gitpod.io/docs/introduction/getting-started/quickstart/elixir"}}],["696",{"pageContent":"__SPLIT_HERE__\nElm Quickstart\n\nLearn how to set-up and understand the benefits of Gitpod in less than 5 min with an Elm template.\n\nThank you @avh4 for creating the repository üôè!\n\nThe following guide will:\n\nWalk you through a real world example with an existing Gitpod config\nIntroduce you to prebuilds\nDemonstrate the benefits of ephemeral developer environments\n\nFor simplicity we use a GitHub template, but Gitpod works similarly with GitLab and Bitbucket.\n\n__SPLIT_HERE__\nStep 1: Clone Git repository\n\nCreate a new repository based on the Elm template.\nName it e.g. my-elm-template.\n\n__SPLIT_HERE__\nStep 2: Install Gitpod app\n\nInstall the Gitpod App.\n\nGitpod&#39;s GitHub app is similar to a CI server and will continuously prepare prebuilds for all your branches and pull requests - so you don&#39;t have to wait for Maven or NPM downloading the internet when you want to start coding.\n\n__SPLIT_HERE__\nStep 3: First prebuild\n\nStart your first workspace with a prebuild by prefixing https://gitpod.io#prebuild/ to the URL of the repository.\n\nThe revised URL is: https://gitpod.io/#prebuild/https://github.com/&lt;github_username&gt;/my-elm-template\n\nGitpod displays the prebuild progress status by running the init commands in the .gitpod.yml file before you even start a workspace. Later, when you create a new workspace on a branch, or pull/merge request the workspace loads much faster, because all dependencies are already downloaded and the code is compiled. For more information see prebuilds.\n\n__SPLIT_HERE__\nStep 4: Enjoy being ready-to-code ü§ô\n\nOnce the first prebuild ran, Gitpod starts an automated and fully configured developer environment in a workspace that is now ready for you to develop.\n\nOther developers made their setup even more productive and supercharged their workflows with the following quick steps:\n\nInstalling the browser extension\n\nYou can install the Gitpod browser extension on any Chromium-based browsers such as Microsoft Edge, Brave, Chrome, and others, or on a Firefox browser.\n\nThe extension simply adds a Gitpod button on every project and branch across GitHub, and Bitbucket that prefixes the URL with gitpod.io/# so that you can easily open a new workspace from any Git context.\n\nBrowser Extension\n\nIf you prefer to not install browser extensions then you can use the Gitpod browser bookmarklet instead.\n\nFor our partner GitLab we have a native integration into their UI that you can enable here.\n\nAdd your favorite VS Code themes and extensions\n\nYou have access to all Visual Studio Code extensions published under the vendor neutral Open VSX registry. Install one by clicking the Extensions icon in the left sidebar and enter your favorite theme or VS Code extension.\n\nChanges you make in your workspace such as themes and extensions are synced automatically to other workspaces.\n\nStart throwing away workspaces like paper towels\n\nYou can now start to treat dev environments as automated resources you spin up when you need them and close down (and forget about) when you are done with your task. Dev environments become fully ephemeral.\n\nYou even can start switching between workspaces or open several workspaces on the same context - two for your feature, one for reviewing a PR/MR, one for a bug, one for another MR/PR.\n\nTry it out and open 3 workspaces on the same context (e.g. on main or on an issue). ü§ì\n\n__SPLIT_HERE__\nNext Steps\n\nYou&#39;ve successfully ran your first workspace and experienced first hand what we mean with ephemeral dev environments. This is just the first step on your journey towards being always ready to code. Helpful resources from here are:\n\nGetting started with your own project\nGit Integrations","metadata":{"source":"https://gitpod.io/docs/introduction/getting-started/quickstart/elm"}}],["697",{"pageContent":"__SPLIT_HERE__\nFlask Quickstart\n\nLearn how to set-up and understand the benefits of Gitpod in less than 5 min with our Flask template.\n\nThe following guide will:\n\nWalk you through a real world example with an existing Gitpod config\nIntroduce you to prebuilds\nDemonstrate the benefits of ephemeral developer environments\n\nFor simplicity we use a GitHub template, but Gitpod works similarly with GitLab and Bitbucket.\n\n__SPLIT_HERE__\nStep 1: Clone Git repository\n\nCreate a new repository based on the Flask template.\nName it e.g. my-flask-template.\n\n__SPLIT_HERE__\nStep 2: Install the Gitpod app\n\nInstall the Gitpod App.\n\nGitpod&#39;s GitHub app is similar to a CI server and will continuously prepare prebuilds for all your branches and pull requests - so you don&#39;t have to wait for Maven or NPM downloading the internet when you want to start coding.\n\n__SPLIT_HERE__\nStep 3: First prebuild\n\nStart your first workspace with a prebuild by prefixing https://gitpod.io#prebuild/ to the URL of the repository.\n\nThe revised URL is: https://gitpod.io/#prebuild/https://github.com/&lt;github_username&gt;/&lt;my-flask-template&gt;\n\nGitpod displays the prebuild progress status by running the init commands in the .gitpod.yml file before you even start a workspace. Later, when you create a new workspace on a branch, or pull/merge request the workspace loads much faster, because all dependencies are already downloaded and the code is compiled. For more information see prebuilds.\n\n__SPLIT_HERE__\nStep 4: Enjoy being ready-to-code ü§ô\n\nOnce the first prebuild ran, Gitpod starts an automated and fully configured developer environment in a workspace that is now ready for you to develop.\n\nOther developers made their setup even more productive and supercharged their workflows with the following quick steps:\n\nInstalling the browser extension\n\nYou can install the Gitpod browser extension on any Chromium-based browsers such as Microsoft Edge, Brave, Chrome, and others, or on a Firefox browser.\n\nThe extension simply adds a Gitpod button on every project and branch across GitHub, and Bitbucket that prefixes the URL with gitpod.io/# so that you can easily open a new workspace from any Git context.\n\nBrowser Extension\n\nIf you prefer to not install browser extensions then you can use the Gitpod browser bookmarklet instead.\n\nFor our partner GitLab we have a native integration into their UI that you can enable here.\n\nAdd your favorite VS Code themes and extensions\n\nYou have access to all Visual Studio Code extensions published under the vendor neutral Open VSX registry. Install one by clicking the Extensions icon in the left sidebar and enter your favorite theme or VS Code extension.\n\nChanges you make in your workspace such as themes and extensions are synced automatically to other workspaces.\n\nStart throwing away workspaces like paper towels\n\nYou can now start to treat dev environments as automated resources you spin up when you need them and close down (and forget about) when you are done with your task. Dev environments become fully ephemeral.\n\nYou even can start switching between workspaces or open several workspaces on the same context - two for your feature, one for reviewing a PR/MR, one for a bug, one for another MR/PR.\n\nTry it out and open 3 workspaces on the same context (e.g. on main or on an issue). ü§ì\n\n__SPLIT_HERE__\nNext Steps\n\nYou&#39;ve successfully ran your first workspace and experienced first hand what we mean with ephemeral dev environments. This is just the first step on your journey towards being always ready to code. Helpful resources from here are:\n\nGetting started with your own project\nGit Integrations","metadata":{"source":"https://gitpod.io/docs/introduction/getting-started/quickstart/flask"}}],["698",{"pageContent":"__SPLIT_HERE__\nFlutter Quickstart\n\nLearn how to set-up and understand the benefits of Gitpod in less than 5 min with our Flutter template.\n\nThe following guide will:\n\nWalk you through a real world example with an existing Gitpod config\nIntroduce you to prebuilds\nDemonstrate the benefits of ephemeral developer environments\n\nFor simplicity we use a GitHub template, but Gitpod works similarly with GitLab and Bitbucket.\n\nStep 1: Clone Git repository\n\nCreate a new repository based on the Flutter template.\nName it e.g. my-flutter-template.\n\nStep 2: Install Gitpod app\n\nInstall the Gitpod App.\n\nGitpod&#39;s GitHub app is similar to a CI server and will continuously prepare prebuilds for all your branches and pull requests - so you don&#39;t have to wait for installation of dependencies from the internet when you want to start coding.\n\nStep 3: First prebuild\n\nStart your first workspace with a prebuild by prefixing https://gitpod.io#prebuild/ to the URL of the repository.\n\nThe revised URL is: https://gitpod.io/#prebuild/https://github.com/&lt;github_username&gt;/my-flutter-template\n\nGitpod displays the prebuild progress status by running the init commands in the .gitpod.yml file before you even start a workspace. Later, when you create a new workspace on a branch, or pull/merge request the workspace loads much faster, because all dependencies are already downloaded and the code is compiled. For more information see prebuilds.\n\nStep 4: Enjoy being ready-to-code ü§ô\n\nOnce the first prebuild ran, Gitpod starts an automated and fully configured developer environment in a workspace that is now ready for you to develop.\n\nOther developers made their setup even more productive and supercharged their workflows with the following quick steps:\n\nInstalling the browser extension\n\nYou can install the Gitpod browser extension on any Chromium-based browsers such as Microsoft Edge, Brave, Chrome, and others, or on a Firefox browser.\n\nThe extension simply adds a Gitpod button on every project and branch across GitHub, and Bitbucket that prefixes the URL with gitpod.io/# so that you can easily open a new workspace from any Git context.\n\nBrowser Extension\n\nIf you prefer to not install browser extensions then you can use the Gitpod browser bookmarklet instead.\n\nFor our partner GitLab we have a native integration into their UI that you can enable here.\n\nAdd your favorite VS Code themes and extensions\n\nYou have access to all Visual Studio Code extensions published under the vendor neutral Open VSX registry. Install one by clicking the Extensions icon in the left sidebar and enter your favorite theme or VS Code extension.\n\nChanges you make in your workspace such as themes and extensions are synced automatically to other workspaces.\n\nStart throwing away workspaces like paper towels\n\nYou can now start to treat dev environments as automated resources you spin up when you need them and close down (and forget about) when you are done with your task. Dev environments become fully ephemeral.\n\nYou even can start switching between workspaces or open several workspaces on the same context - two for your feature, one for reviewing a PR/MR, one for a bug, one for another MR/PR.\n\nTry it out and open 3 workspaces on the same context (e.g. on main or on an issue). ü§ì\n\n__SPLIT_HERE__\nNext Steps\n\nYou&#39;ve successfully ran your first workspace and experienced first hand what we mean with ephemeral dev environments. This is just the first step on your journey towards being always ready to code. Helpful resources from here are:\n\nGetting started with your own project\nGit Integrations","metadata":{"source":"https://gitpod.io/docs/introduction/getting-started/quickstart/flutter"}}],["699",{"pageContent":"__SPLIT_HERE__\nGo Quickstart\n\nLearn how to set-up and understand the benefits of Gitpod in less than 5 min with our Golang template.\n\nThe following guide will:\n\nWalk you through a real world example with an existing Gitpod config\nIntroduce you to prebuilds\nDemonstrate the benefits of ephemeral developer environments\n\nFor simplicity we use a GitHub template, but Gitpod works similarly with GitLab and Bitbucket.\n\n__SPLIT_HERE__\nStep 1: Clone Git repository\n\nCreate a new repository based on the Go template.\nName it e.g. my-go-template.\n\n__SPLIT_HERE__\nStep 2: Install Gitpod app\n\nInstall the Gitpod App.\n\nGitpod&#39;s GitHub app is similar to a CI server and will continuously prepare prebuilds for all your branches and pull requests - so you don&#39;t have to wait for Maven or NPM downloading the internet when you want to start coding.\n\n__SPLIT_HERE__\nStep 3: First prebuild\n\nStart your first workspace with a prebuild by prefixing https://gitpod.io#prebuild/ to the URL of the repository.\n\nThe revised URL is: https://gitpod.io/#prebuild/https://github.com/&lt;github_username&gt;/template-golang-cli\n\nGitpod displays the prebuild progress status by running the init commands in the .gitpod.yml file before you even start a workspace. Later, when you create a new workspace on a branch, or pull/merge request the workspace loads much faster, because all dependencies are already downloaded and the code is compiled. For more information see prebuilds.\n\n__SPLIT_HERE__\nStep 4: Enjoy being ready-to-code ü§ô\n\nOnce the first prebuild ran, Gitpod starts an automated and fully configured developer environment in a workspace that is now ready for you to develop.\n\nOther developers made their setup even more productive and supercharged their workflows with the following quick steps:\n\nInstalling the browser extension\n\nYou can install the Gitpod browser extension on any Chromium-based browsers such as Microsoft Edge, Brave, Chrome, and others, or on a Firefox browser.\n\nThe extension simply adds a Gitpod button on every project and branch across GitHub, and Bitbucket that prefixes the URL with gitpod.io/# so that you can easily open a new workspace from any Git context.\n\nBrowser Extension\n\nIf you prefer to not install browser extensions then you can use the Gitpod browser bookmarklet instead.\n\nFor our partner GitLab we have a native integration into their UI that you can enable here.\n\nAdd your favorite VS Code themes and extensions\n\nYou have access to all Visual Studio Code extensions published under the vendor neutral Open VSX registry. Install one by clicking the Extensions icon in the left sidebar and enter your favorite theme or VS Code extension.\n\nChanges you make in your workspace such as themes and extensions are synced automatically to other workspaces.\n\nStart throwing away workspaces like paper towels\n\nYou can now start to treat dev environments as automated resources you spin up when you need them and close down (and forget about) when you are done with your task. Dev environments become fully ephemeral.\n\nYou even can start switching between workspaces or open several workspaces on the same context - two for your feature, one for reviewing a PR/MR, one for a bug, one for another MR/PR.\n\nTry it out and open 3 workspaces on the same context (e.g. on main or on an issue). ü§ì\n\n__SPLIT_HERE__\nNext Steps\n\nYou&#39;ve successfully ran your first workspace and experienced first hand what we mean with ephemeral dev environments. This is just the first step on your journey towards being always ready to code. Helpful resources from here are:\n\nGetting started with your own project\nGit Integrations","metadata":{"source":"https://gitpod.io/docs/introduction/getting-started/quickstart/go"}}],["700",{"pageContent":"__SPLIT_HERE__\nGrain Quickstart\n\nLearn how to set-up and understand the benefits of Gitpod in less than 5 min with our Grain template.\n\nThe following guide will:\n\nWalk you through a real world example with an existing Gitpod config\nIntroduce you to prebuilds\nDemonstrate the benefits of ephemeral developer environments\n\nFor simplicity we use a GitHub template, but Gitpod works similarly with GitLab and Bitbucket.\n\nStep 1: Clone Git repository\n\nCreate a new repository based on the Grain template.\nName it e.g. my-grain-template.\n\nStep 2: Install Gitpod app\n\nInstall the Gitpod App.\n\nGitpod&#39;s GitHub app is similar to a CI server and will continuously prepare prebuilds for all your branches and pull requests - so you don&#39;t have to wait for installation of dependencies from the internet when you want to start coding.\n\nStep 3: First prebuild\n\nStart your first workspace with a prebuild by prefixing https://gitpod.io#prebuild/ to the URL of the repository.\n\nThe revised URL is: https://gitpod.io/#prebuild/https://github.com/&lt;github_username&gt;/my-grain-template\n\nGitpod displays the prebuild progress status by running the init commands in the .gitpod.yml file before you even start a workspace. Later, when you create a new workspace on a branch, or pull/merge request the workspace loads much faster, because all dependencies are already downloaded and the code is compiled. For more information see prebuilds.\n\nStep 4: Enjoy being ready-to-code ü§ô\n\nOnce the first prebuild ran, Gitpod starts an automated and fully configured developer environment in a workspace that is now ready for you to develop.\n\nOther developers made their setup even more productive and supercharged their workflows with the following quick steps:\n\nInstalling the browser extension\n\nYou can install the Gitpod browser extension on any Chromium-based browsers such as Microsoft Edge, Brave, Chrome, and others, or on a Firefox browser.\n\nThe extension simply adds a Gitpod button on every project and branch across GitHub, and Bitbucket that prefixes the URL with gitpod.io/# so that you can easily open a new workspace from any Git context.\n\nBrowser Extension\n\nIf you prefer to not install browser extensions then you can use the Gitpod browser bookmarklet instead.\n\nFor our partner GitLab we have a native integration into their UI that you can enable here.\n\nAdd your favorite VS Code themes and extensions\n\nYou have access to all Visual Studio Code extensions published under the vendor neutral Open VSX registry. Install one by clicking the Extensions icon in the left sidebar and enter your favorite theme or VS Code extension.\n\nChanges you make in your workspace such as themes and extensions are synced automatically to other workspaces.\n\nStart throwing away workspaces like paper towels\n\nYou can now start to treat dev environments as automated resources you spin up when you need them and close down (and forget about) when you are done with your task. Dev environments become fully ephemeral.\n\nYou even can start switching between workspaces or open several workspaces on the same context - two for your feature, one for reviewing a PR/MR, one for a bug, one for another MR/PR.\n\nTry it out and open 3 workspaces on the same context (e.g. on main or on an issue). ü§ì\n\n__SPLIT_HERE__\nNext Steps\n\nYou&#39;ve successfully ran your first workspace and experienced first hand what we mean with ephemeral dev environments. This is just the first step on your journey towards being always ready to code. Helpful resources from here are:\n\nGetting started with your own project\nGit Integrations","metadata":{"source":"https://gitpod.io/docs/introduction/getting-started/quickstart/grain"}}],["701",{"pageContent":"__SPLIT_HERE__\nIHP Quickstart\n\nLearn how to set-up and understand the benefits of Gitpod in less than 5 min with the official IHP template.\n\nThe following guide will:\n\nWalk you through a real world example with an existing Gitpod config\nIntroduce you to prebuilds\nDemonstrate the benefits of ephemeral development environments\n\nFor simplicity we use a GitHub template, but Gitpod works similarly with GitLab and Bitbucket.\n\n__SPLIT_HERE__\nStep 1: Clone Git repository\n\nCreate a new repository based on the IHP template.\nName it e.g. my-ihp-app.\n\n__SPLIT_HERE__\nStep 2: Install the Gitpod app\n\nInstall the Gitpod App.\n\nGitpod&#39;s GitHub app is similar to a CI server and will continuously prepare prebuilds for all your branches and pull requests - so you don&#39;t have to wait for Maven or NPM downloading the internet when you want to start coding.\n\n__SPLIT_HERE__\nStep 3: First prebuild\n\nStart your first workspace with a prebuild by prefixing https://gitpod.io#prebuild/ to the URL of the repository.\n\nThe revised URL is: https://gitpod.io/#prebuild/https://github.com/&lt;github_username&gt;/&lt;my-ihp-app&gt;\n\nGitpod displays the prebuild progress status by running the init commands in the .gitpod.yml file before you even start a workspace. Later, when you create a new workspace on a branch, or pull/merge request the workspace loads much faster, because all dependencies are already downloaded and the code is compiled. For more information see prebuilds.\n\n__SPLIT_HERE__\nStep 4: Enjoy being ready-to-code ü§ô\n\nOnce the first prebuild ran, Gitpod starts an automated and fully configured development environment in a workspace that is now ready for you to develop.\n\nOther developers made their setup even more productive and supercharged their workflows with the following quick steps:\n\nInstalling the browser extension\n\nYou can install the Gitpod browser extension on any Chromium-based browsers such as Microsoft Edge, Brave, Chrome, and others, or on a Firefox browser.\n\nThe extension simply adds a Gitpod button on every project and branch across GitHub, and Bitbucket that prefixes the URL with gitpod.io/# so that you can easily open a new workspace from any Git context.\n\nBrowser Extension\n\nIf you prefer to not install browser extensions then you can use the Gitpod browser bookmarklet instead.\n\nFor our partner GitLab we have a native integration into their UI that you can enable here.\n\nAdd your favorite VS Code themes and extensions\n\nYou have access to all Visual Studio Code extensions published under the vendor neutral Open VSX registry. Install one by clicking the Extensions icon in the left sidebar and enter your favorite theme or VS Code extension.\n\nChanges you make in your workspace such as themes and extensions are synced automatically to other workspaces.\n\nStart throwing away workspaces like paper towels\n\nYou can now start to treat dev environments as automated resources you spin up when you need them and close down (and forget about) when you are done with your task. Dev environments become fully ephemeral.\n\nYou even can start switching between workspaces or open several workspaces on the same context - two for your feature, one for reviewing a PR/MR, one for a bug, one for another MR/PR.\n\nTry it out and open 3 workspaces on the same context (e.g. on main or on an issue). ü§ì\n\n__SPLIT_HERE__\nNext Steps\n\nYou&#39;ve successfully ran your first workspace and experienced first hand what we mean with ephemeral dev environments. This is just the first step on your journey towards being always ready to code. Helpful resources from here are:\n\nGetting started with your own project\nGit Integrations","metadata":{"source":"https://gitpod.io/docs/introduction/getting-started/quickstart/ihp"}}],["702",{"pageContent":"&lt;OpenGraph\ndata={{\n    description:\n      &quot;Learn how to start using Gitpod on an example project/template that is hosted on GitHub in less than 5 minutes. Get up and running with Gitpod quickly.&quot;,\n    title: &quot;Quickstart - Gitpod&quot;,\n    keywords: &quot;template, get started, example&quot;,\n  }}\n/&gt;\n\n__SPLIT_HERE__\nQuickstart\n\nLearn how to start using Gitpod on an example project that is hosted on GitHub in less than 5 minutes. For simplicity we use GitHub as the git hoster but the steps outlined work equally well for GitLab and Bitbucket. This section helps you understand the features and advantages of Gitpod in a learning environment. All templates are pre-configured to use Gitpod and ready-to-code:\n\n__SPLIT_HERE__\nTemplates\n\nPopular Templates\n\nFind your template\n\nüí° Find more such templates on Gitpod Samples\n\n__SPLIT_HERE__\nInstalling the Gitpod browser extension\n\nYou can install the Gitpod browser extension in any Chromium-based browser such as Google Chrome, Microsoft Edge, Brave, and others, or in Firefox.\n\nThe Gitpod extension adds a Gitpod button on every project and branch across GitLab, GitHub, and Bitbucket so that you can easily open a new workspace for any project.\n\nBrowser Extension\n\nIf you prefer to not install browser extensions then you can use the Gitpod browser bookmarklet instead.\n\n__SPLIT_HERE__\nNext Steps\n\nWith Gitpod you start treating your dev environments as something ephemeral: you start them, you code, you push your code, and you forget about them. For your next task, you&#39;ll use a fresh dev environment.\n\nGetting started with your own project","metadata":{"source":"https://gitpod.io/docs/introduction/getting-started/quickstart/index"}}],["703",{"pageContent":"__SPLIT_HERE__\nHaskell Quickstart\n\nLearn how to set-up and understand the benefits of Gitpod in less than 5 min with our Haskell template.\n\nThe following guide will:\n\nWalk you through a real world example with an existing Gitpod config\nIntroduce you to prebuilds\nDemonstrate the benefits of ephemeral developer environments\n\nFor simplicity we use a GitHub template, but Gitpod works similarly with GitLab and Bitbucket.\n\n__SPLIT_HERE__\nStep 1: Clone Git repository\n\nCreate a new repository based on the Haskell template.\nName it e.g. my-haskell-template.\n\n__SPLIT_HERE__\nStep 2: Install the Gitpod app\n\nInstall the Gitpod App.\n\nGitpod&#39;s GitHub app is similar to a CI server and will continuously prepare prebuilds for all your branches and pull requests - so you don&#39;t have to wait for Maven or NPM downloading the internet when you want to start coding.\n\n__SPLIT_HERE__\nStep 3: First prebuild\n\nStart your first workspace with a prebuild by prefixing https://gitpod.io#prebuild/ to the URL of the repository.\n\nThe revised URL is: https://gitpod.io/#prebuild/https://github.com/&lt;github_username&gt;/&lt;my-haskell-template&gt;\n\nGitpod displays the prebuild progress status by running the init commands in the .gitpod.yml file before you even start a workspace. Later, when you create a new workspace on a branch, or pull/merge request the workspace loads much faster, because all dependencies are already downloaded and the code is compiled. For more information see prebuilds.\n\n__SPLIT_HERE__\nStep 4: Enjoy being ready-to-code ü§ô\n\nOnce the first prebuild ran, Gitpod starts an automated and fully configured developer environment in a workspace that is now ready for you to develop.\n\nOther developers made their setup even more productive and supercharged their workflows with the following quick steps:\n\nInstalling the browser extension\n\nYou can install the Gitpod browser extension on any Chromium-based browsers such as Microsoft Edge, Brave, Chrome, and others, or on a Firefox browser.\n\nThe extension simply adds a Gitpod button on every project and branch across GitHub, and Bitbucket that prefixes the URL with gitpod.io/# so that you can easily open a new workspace from any Git context.\n\nBrowser Extension\n\nIf you prefer to not install browser extensions then you can use the Gitpod browser bookmarklet instead.\n\nFor our partner GitLab we have a native integration into their UI that you can enable here.\n\nAdd your favorite VS Code themes and extensions\n\nYou have access to all Visual Studio Code extensions published under the vendor neutral Open VSX registry. Install one by clicking the Extensions icon in the left sidebar and enter your favorite theme or VS Code extension.\n\nChanges you make in your workspace such as themes and extensions are synced automatically to other workspaces.\n\nStart throwing away workspaces like paper towels\n\nYou can now start to treat dev environments as automated resources you spin up when you need them and close down (and forget about) when you are done with your task. Dev environments become fully ephemeral.\n\nYou even can start switching between workspaces or open several workspaces on the same context - two for your feature, one for reviewing a PR/MR, one for a bug, one for another MR/PR.\n\nTry it out and open 3 workspaces on the same context (e.g. on main or on an issue). ü§ì\n\n__SPLIT_HERE__\nNext Steps\n\nYou&#39;ve successfully ran your first workspace and experienced first hand what we mean with ephemeral dev environments. This is just the first step on your journey towards being always ready to code. Helpful resources from here are:\n\nGetting started with your own project\nGit Integrations","metadata":{"source":"https://gitpod.io/docs/introduction/getting-started/quickstart/haskell"}}],["704",{"pageContent":"__SPLIT_HERE__\nJulia Quickstart\n\nLearn how to set-up and understand the benefits of Gitpod in less than 5 min with our Julia template.\n\nThe following guide will:\n\nWalk you through a real world example with an existing Gitpod config\nIntroduce you to prebuilds\nDemonstrate the benefits of ephemeral developer environments\n\nFor simplicity we use a GitHub template, but Gitpod works similarly with GitLab and Bitbucket.\n\n__SPLIT_HERE__\nStep 1: Clone Git repository\n\nCreate a new repository based on the Julia template.\nName it e.g. my-julia-template.\n\n__SPLIT_HERE__\nStep 2: Install Gitpod app\n\nInstall the Gitpod App.\n\nGitpod&#39;s GitHub app is similar to a CI server and will continuously prepare prebuilds for all your branches and pull requests - so you don&#39;t have to wait for Julia packages downloading from the internet when you want to start coding.\n\n__SPLIT_HERE__\nStep 3: First prebuild\n\nStart your first workspace with a prebuild by prefixing https://gitpod.io#prebuild/ to the URL of the repository.\n\nThe revised URL is: https://gitpod.io/#prebuild/https://github.com/&lt;github_username&gt;/my-julia-template\n\nGitpod displays the prebuild progress status by running the init commands in the .gitpod.yml file before you even start a workspace. Later, when you create a new workspace on a branch, or pull/merge request the workspace loads much faster, because all dependencies are already downloaded and the code is compiled. For more information see prebuilds.\n\n__SPLIT_HERE__\nStep 4: Enjoy being ready-to-code ü§ô\n\nOnce the first prebuild ran, Gitpod starts an automated and fully configured developer environment in a workspace that is now ready for you to develop.\n\nOther developers made their setup even more productive and supercharged their workflows with the following quick steps:\n\nInstalling the browser extension\n\nYou can install the Gitpod browser extension on any Chromium-based browsers such as Microsoft Edge, Brave, Chrome, and others, or on a Firefox browser.\n\nThe extension simply adds a Gitpod button on every project and branch across GitHub, and Bitbucket that prefixes the URL with gitpod.io/# so that you can easily open a new workspace from any Git context.\n\nBrowser Extension\n\nIf you prefer to not install browser extensions then you can use the Gitpod browser bookmarklet instead.\n\nFor our partner GitLab we have a native integration into their UI that you can enable here.\n\nAdd your favorite VS Code themes and extensions\n\nYou have access to all Visual Studio Code extensions published under the vendor neutral Open VSX registry. Install one by clicking the Extensions icon in the left sidebar and enter your favorite theme or VS Code extension.\n\nChanges you make in your workspace such as themes and extensions are synced automatically to other workspaces.\n\nStart throwing away workspaces like paper towels\n\nYou can now start to treat dev environments as automated resources you spin up when you need them and close down (and forget about) when you are done with your task. Dev environments become fully ephemeral.\n\nYou even can start switching between workspaces or open several workspaces on the same context - two for your feature, one for reviewing a PR/MR, one for a bug, one for another MR/PR.\n\nTry it out and open 3 workspaces on the same context (e.g. on main or on an issue). ü§ì\n\n__SPLIT_HERE__\nNext Steps\n\nYou&#39;ve successfully ran your first workspace and experienced first hand what we mean with ephemeral dev environments. This is just the first step on your journey towards being always ready to code. Helpful resources from here are:\n\nGetting started with your own project\nGit Integrations","metadata":{"source":"https://gitpod.io/docs/introduction/getting-started/quickstart/julia"}}],["705",{"pageContent":"__SPLIT_HERE__\nLaravel Quickstart\n\nLearn how to set-up and understand the benefits of Gitpod in less than 5 min with our Laravel template.\n\nThe following guide will:\n\nWalk you through a real world example with an existing Gitpod config\nIntroduce you to prebuilds\nDemonstrate the benefits of ephemeral developer environments\n\nFor simplicity we use a GitHub template, but Gitpod works similarly with GitLab and Bitbucket.\n\n__SPLIT_HERE__\nStep 1: Clone Git repository\n\nCreate a new repository based on the Laravel template.\nName it e.g. my-laravel-template.\n\n__SPLIT_HERE__\nStep 2: Install the Gitpod app\n\nInstall the Gitpod App.\n\nGitpod&#39;s GitHub app is similar to a CI server and will continuously prepare prebuilds for all your branches and pull requests - so you don&#39;t have to wait for Maven or NPM downloading the internet when you want to start coding.\n\n__SPLIT_HERE__\nStep 3: First prebuild\n\nStart your first workspace with a prebuild by prefixing https://gitpod.io#prebuild/ to the URL of the repository.\n\nThe revised URL is: https://gitpod.io/#prebuild/https://github.com/&lt;github_username&gt;/&lt;my-laravel-template&gt;\n\nGitpod displays the prebuild progress status by running the init commands in the .gitpod.yml file before you even start a workspace. Later, when you create a new workspace on a branch, or pull/merge request the workspace loads much faster, because all dependencies are already downloaded and the code is compiled. For more information see prebuilds.\n\n__SPLIT_HERE__\nStep 4: Enjoy being ready-to-code ü§ô\n\nOnce the first prebuild ran, Gitpod starts an automated and fully configured developer environment in a workspace that is now ready for you to develop.\n\nOther developers made their setup even more productive and supercharged their workflows with the following quick steps:\n\nInstalling the browser extension\n\nYou can install the Gitpod browser extension on any Chromium-based browsers such as Microsoft Edge, Brave, Chrome, and others, or on a Firefox browser.\n\nThe extension simply adds a Gitpod button on every project and branch across GitHub, and Bitbucket that prefixes the URL with gitpod.io/# so that you can easily open a new workspace from any Git context.\n\nBrowser Extension\n\nIf you prefer to not install browser extensions then you can use the Gitpod browser bookmarklet instead.\n\nFor our partner GitLab we have a native integration into their UI that you can enable here.\n\nAdd your favorite VS Code themes and extensions\n\nYou have access to all Visual Studio Code extensions published under the vendor neutral Open VSX registry. Install one by clicking the Extensions icon in the left sidebar and enter your favorite theme or VS Code extension.\n\nChanges you make in your workspace such as themes and extensions are synced automatically to other workspaces.\n\nStart throwing away workspaces like paper towels\n\nYou can now start to treat dev environments as automated resources you spin up when you need them and close down (and forget about) when you are done with your task. Dev environments become fully ephemeral.\n\nYou even can start switching between workspaces or open several workspaces on the same context - two for your feature, one for reviewing a PR/MR, one for a bug, one for another MR/PR.\n\nTry it out and open 3 workspaces on the same context (e.g. on main or on an issue). ü§ì\n\n__SPLIT_HERE__\nNext Steps\n\nYou&#39;ve successfully ran your first workspace and experienced first hand what we mean with ephemeral dev environments. This is just the first step on your journey towards being always ready to code. Helpful resources from here are:\n\nGetting started with your own project\nGit Integrations","metadata":{"source":"https://gitpod.io/docs/introduction/getting-started/quickstart/laravel"}}],["706",{"pageContent":"__SPLIT_HERE__\nJava Quickstart\n\nLearn how to set-up and understand the benefits of Gitpod in less than 5 min with our Java Spring template.\n\nThe following guide will:\n\nWalk you through a real world example with an existing Gitpod config\nIntroduce you to prebuilds\nDemonstrate the benefits of ephemeral developer environments\n\nFor simplicity we use a GitHub template, but Gitpod works similarly with GitLab and Bitbucket.\n\n__SPLIT_HERE__\nStep 1: Clone Git repository\n\nCreate a new repository based on the Java template.\nName it e.g. my-java-template.\n\n__SPLIT_HERE__\nStep 2: Install Gitpod app\n\nInstall the Gitpod App.\n\nGitpod&#39;s GitHub app is similar to a CI server and will continuously prepare prebuilds for all your branches and pull requests - so you don&#39;t have to wait for Maven or NPM downloading the internet when you want to start coding.\n\n__SPLIT_HERE__\nStep 3: First prebuild\n\nStart your first workspace with a prebuild by prefixing https://gitpod.io#prebuild/ to the URL of the repository.\n\nThe revised URL is: https://gitpod.io/#prebuild/https://github.com/&lt;github_username&gt;/spring-petclinic\n\nGitpod displays the prebuild progress status by running the init commands in the .gitpod.yml file before you even start a workspace. Later, when you create a new workspace on a branch, or pull/merge request the workspace loads much faster, because all dependencies are already downloaded and the code is compiled. For more information see prebuilds.\n\n__SPLIT_HERE__\nStep 4: Enjoy being ready-to-code ü§ô\n\nOnce the first prebuild ran, Gitpod starts an automated and fully configured developer environment in a workspace that is now ready for you to develop.\n\nOther developers made their setup even more productive and supercharged their workflows with the following quick steps:\n\nInstalling the browser extension\n\nYou can install the Gitpod browser extension on any Chromium-based browsers such as Microsoft Edge, Brave, Chrome, and others, or on a Firefox browser.\n\nThe extension simply adds a Gitpod button on every project and branch across GitHub, and Bitbucket that prefixes the URL with gitpod.io/# so that you can easily open a new workspace from any Git context.\n\nBrowser Extension\n\nIf you prefer to not install browser extensions then you can use the Gitpod browser bookmarklet instead.\n\nFor our partner GitLab we have a native integration into their UI that you can enable here.\n\nAdd your favorite VS Code themes and extensions\n\nYou have access to all Visual Studio Code extensions published under the vendor neutral Open VSX registry. Install one by clicking the Extensions icon in the left sidebar and enter your favorite theme or VS Code extension.\n\nChanges you make in your workspace such as themes and extensions are synced automatically to other workspaces.\n\nStart throwing away workspaces like paper towels\n\nYou can now start to treat dev environments as automated resources you spin up when you need them and close down (and forget about) when you are done with your task. Dev environments become fully ephemeral.\n\nYou even can start switching between workspaces or open several workspaces on the same context - two for your feature, one for reviewing a PR/MR, one for a bug, one for another MR/PR.\n\nTry it out and open 3 workspaces on the same context (e.g. on main or on an issue). ü§ì\n\n__SPLIT_HERE__\nNext Steps\n\nYou&#39;ve successfully ran your first workspace and experienced first hand what we mean with ephemeral dev environments. This is just the first step on your journey towards being always ready to code. Helpful resources from here are:\n\nGetting started with your own project\nGit Integrations","metadata":{"source":"https://gitpod.io/docs/introduction/getting-started/quickstart/java"}}],["707",{"pageContent":"__SPLIT_HERE__\nNextJS Quickstart\n\nLearn how to set-up and understand the benefits of Gitpod in less than 5 min with our NextJS template.\n\nThe following guide will:\n\nWalk you through a real world example with an existing Gitpod config\nIntroduce you to prebuilds\nDemonstrate the benefits of ephemeral developer environments\n\nFor simplicity we use a GitHub template, but Gitpod works similarly with GitLab and Bitbucket.\n\nStep 1: Clone Git repository\n\nCreate a new repository based on the NextJS template.\nName it e.g. my-nextjs-template.\n\nStep 2: Install Gitpod app\n\nInstall the Gitpod App.\n\nGitpod&#39;s GitHub app is similar to a CI server and will continuously prepare prebuilds for all your branches and pull requests - so you don&#39;t have to wait for installation of dependencies from the internet when you want to start coding.\n\nStep 3: First prebuild\n\nStart your first workspace with a prebuild by prefixing https://gitpod.io#prebuild/ to the URL of the repository.\n\nThe revised URL is: https://gitpod.io/#prebuild/https://github.com/&lt;github_username&gt;/my-nextjs-template\n\nGitpod displays the prebuild progress status by running the init commands in the .gitpod.yml file before you even start a workspace. Later, when you create a new workspace on a branch, or pull/merge request the workspace loads much faster, because all dependencies are already downloaded and the code is compiled. For more information see prebuilds.\n\nStep 4: Enjoy being ready-to-code ü§ô\n\nOnce the first prebuild ran, Gitpod starts an automated and fully configured developer environment in a workspace that is now ready for you to develop.\n\nOther developers made their setup even more productive and supercharged their workflows with the following quick steps:\n\nInstalling the browser extension\n\nYou can install the Gitpod browser extension on any Chromium-based browsers such as Microsoft Edge, Brave, Chrome, and others, or on a Firefox browser.\n\nThe extension simply adds a Gitpod button on every project and branch across GitHub, and Bitbucket that prefixes the URL with gitpod.io/# so that you can easily open a new workspace from any Git context.\n\nBrowser Extension\n\nIf you prefer to not install browser extensions then you can use the Gitpod browser bookmarklet instead.\n\nFor our partner GitLab we have a native integration into their UI that you can enable here.\n\nAdd your favorite VS Code themes and extensions\n\nYou have access to all Visual Studio Code extensions published under the vendor neutral Open VSX registry. Install one by clicking the Extensions icon in the left sidebar and enter your favorite theme or VS Code extension.\n\nChanges you make in your workspace such as themes and extensions are synced automatically to other workspaces.\n\nStart throwing away workspaces like paper towels\n\nYou can now start to treat dev environments as automated resources you spin up when you need them and close down (and forget about) when you are done with your task. Dev environments become fully ephemeral.\n\nYou even can start switching between workspaces or open several workspaces on the same context - two for your feature, one for reviewing a PR/MR, one for a bug, one for another MR/PR.\n\nTry it out and open 3 workspaces on the same context (e.g. on main or on an issue). ü§ì\n\n__SPLIT_HERE__\nNext Steps\n\nYou&#39;ve successfully ran your first workspace and experienced first hand what we mean with ephemeral dev environments. This is just the first step on your journey towards being always ready to code. Helpful resources from here are:\n\nGetting started with your own project\nGit Integrations","metadata":{"source":"https://gitpod.io/docs/introduction/getting-started/quickstart/nextjs"}}],["708",{"pageContent":"__SPLIT_HERE__\nNix Quickstart\n\nLearn how to set-up and understand the benefits of Gitpod in less than 5 min with our Nix template.\n\nThe following guide will:\n\nWalk you through a real world example with an existing Gitpod config\nIntroduce you to prebuilds\nDemonstrate the benefits of ephemeral developer environments\n\nFor simplicity we use a GitHub template, but Gitpod works similarly with GitLab and Bitbucket.\n\n__SPLIT_HERE__\nStep 1: Clone Git repository\n\nCreate a new repository based on the Nix template.\nName it e.g. my-nix-template.\n\n__SPLIT_HERE__\nStep 2: Install the Gitpod app\n\nInstall the Gitpod App.\n\nGitpod&#39;s GitHub app is similar to a CI server and will continuously prepare prebuilds for all your branches and pull requests - so you don&#39;t have to wait for Maven or NPM downloading the internet when you want to start coding.\n\n__SPLIT_HERE__\nStep 3: First prebuild\n\nStart your first workspace with a prebuild by prefixing https://gitpod.io#prebuild/ to the URL of the repository.\n\nThe revised URL is: https://gitpod.io/#prebuild/https://github.com/&lt;github_username&gt;/&lt;my-nix-template&gt;\n\nGitpod displays the prebuild progress status by running the init commands in the .gitpod.yml file before you even start a workspace. Later, when you create a new workspace on a branch, or pull/merge request the workspace loads much faster, because all dependencies are already downloaded and the code is compiled. For more information see prebuilds.\n\n__SPLIT_HERE__\nStep 4: Enjoy being ready-to-code ü§ô\n\nOnce the first prebuild ran, Gitpod starts an automated and fully configured developer environment in a workspace that is now ready for you to develop.\n\nOther developers made their setup even more productive and supercharged their workflows with the following quick steps:\n\nInstalling the browser extension\n\nYou can install the Gitpod browser extension on any Chromium-based browsers such as Microsoft Edge, Brave, Chrome, and others, or on a Firefox browser.\n\nThe extension simply adds a Gitpod button on every project and branch across GitHub, and Bitbucket that prefixes the URL with gitpod.io/# so that you can easily open a new workspace from any Git context.\n\nBrowser Extension\n\nIf you prefer to not install browser extensions then you can use the Gitpod browser bookmarklet instead.\n\nFor our partner GitLab we have a native integration into their UI that you can enable here.\n\nAdd your favorite VS Code themes and extensions\n\nYou have access to all Visual Studio Code extensions published under the vendor neutral Open VSX registry. Install one by clicking the Extensions icon in the left sidebar and enter your favorite theme or VS Code extension.\n\nChanges you make in your workspace such as themes and extensions are synced automatically to other workspaces.\n\nStart throwing away workspaces like paper towels\n\nYou can now start to treat dev environments as automated resources you spin up when you need them and close down (and forget about) when you are done with your task. Dev environments become fully ephemeral.\n\nYou even can start switching between workspaces or open several workspaces on the same context - two for your feature, one for reviewing a PR/MR, one for a bug, one for another MR/PR.\n\nTry it out and open 3 workspaces on the same context (e.g. on main or on an issue). ü§ì\n\n__SPLIT_HERE__\nNext Steps\n\nYou&#39;ve successfully ran your first workspace and experienced first hand what we mean with ephemeral dev environments. This is just the first step on your journey towards being always ready to code. Helpful resources from here are:\n\nGetting started with your own project\nGit Integrations","metadata":{"source":"https://gitpod.io/docs/introduction/getting-started/quickstart/nix"}}],["709",{"pageContent":"__SPLIT_HERE__\nOcaml Quickstart\n\nLearn how to set-up and understand the benefits of Gitpod in less than 5 min with our OCaml template.\n\nThe following guide will:\n\nWalk you through a real world example with an existing Gitpod config\nIntroduce you to prebuilds\nDemonstrate the benefits of ephemeral developer environments\n\nFor simplicity we use a GitHub template, but Gitpod works similarly with GitLab and Bitbucket.\n\n__SPLIT_HERE__\nStep 1: Clone Git repository\n\nCreate a new repository based on the OCaml template.\nName it e.g. my-ocaml-template.\n\n__SPLIT_HERE__\nStep 2: Install the Gitpod app\n\nInstall the Gitpod App.\n\nGitpod&#39;s GitHub app is similar to a CI server and will continuously prepare prebuilds for all your branches and pull requests - so you don&#39;t have to wait for Maven or NPM downloading the internet when you want to start coding.\n\n__SPLIT_HERE__\nStep 3: First prebuild\n\nStart your first workspace with a prebuild by prefixing https://gitpod.io#prebuild/ to the URL of the repository.\n\nThe revised URL is: https://gitpod.io/#prebuild/https://github.com/&lt;github_username&gt;/&lt;my-ocaml-template&gt;\n\nGitpod displays the prebuild progress status by running the init commands in the .gitpod.yml file before you even start a workspace. Later, when you create a new workspace on a branch, or pull/merge request the workspace loads much faster, because all dependencies are already downloaded and the code is compiled. For more information see prebuilds.\n\n__SPLIT_HERE__\nStep 4: Enjoy being ready-to-code ü§ô\n\nOnce the first prebuild ran, Gitpod starts an automated and fully configured developer environment in a workspace that is now ready for you to develop.\n\nOther developers made their setup even more productive and supercharged their workflows with the following quick steps:\n\nInstalling the browser extension\n\nYou can install the Gitpod browser extension on any Chromium-based browsers such as Microsoft Edge, Brave, Chrome, and others, or on a Firefox browser.\n\nThe extension simply adds a Gitpod button on every project and branch across GitHub, and Bitbucket that prefixes the URL with gitpod.io/# so that you can easily open a new workspace from any Git context.\n\nBrowser Extension\n\nIf you prefer to not install browser extensions then you can use the Gitpod browser bookmarklet instead.\n\nFor our partner GitLab we have a native integration into their UI that you can enable here.\n\nAdd your favorite VS Code themes and extensions\n\nYou have access to all Visual Studio Code extensions published under the vendor neutral Open VSX registry. Install one by clicking the Extensions icon in the left sidebar and enter your favorite theme or VS Code extension.\n\nChanges you make in your workspace such as themes and extensions are synced automatically to other workspaces.\n\nStart throwing away workspaces like paper towels\n\nYou can now start to treat dev environments as automated resources you spin up when you need them and close down (and forget about) when you are done with your task. Dev environments become fully ephemeral.\n\nYou even can start switching between workspaces or open several workspaces on the same context - two for your feature, one for reviewing a PR/MR, one for a bug, one for another MR/PR.\n\nTry it out and open 3 workspaces on the same context (e.g. on main or on an issue). ü§ì\n\n__SPLIT_HERE__\nNext Steps\n\nYou&#39;ve successfully ran your first workspace and experienced first hand what we mean with ephemeral dev environments. This is just the first step on your journey towards being always ready to code. Helpful resources from here are:\n\nGetting started with your own project\nGit Integrations","metadata":{"source":"https://gitpod.io/docs/introduction/getting-started/quickstart/ocaml"}}],["710",{"pageContent":"__SPLIT_HERE__\nPerl Quickstart\n\nLearn how to set-up and understand the benefits of Gitpod in less than 5 min with our Perl template.\n\nThe following guide will:\n\nWalk you through a real world example with an existing Gitpod config\nIntroduce you to prebuilds\nDemonstrate the benefits of ephemeral developer environments\n\nFor simplicity we use a GitHub template, but Gitpod works similarly with GitLab and Bitbucket.\n\n__SPLIT_HERE__\nStep 1: Clone Git repository\n\nCreate a new repository based on the Perl template.\nName it e.g. my-perl-template.\n\n__SPLIT_HERE__\nStep 2: Install Gitpod app\n\nInstall the Gitpod App.\n\nGitpod&#39;s GitHub app is similar to a CI server and will continuously prepare prebuilds for all your branches and pull requests - so you don&#39;t have to wait for CPAN downloading the internet when you want to start coding.\n\n__SPLIT_HERE__\nStep 3: First prebuild\n\nStart your first workspace with a prebuild by prefixing https://gitpod.io#prebuild/ to the URL of the repository.\n\nThe revised URL is: https://gitpod.io/#prebuild/https://github.com/&lt;github_username&gt;/my-perl-template\n\nGitpod displays the prebuild progress status by running the init commands in the .gitpod.yml file before you even start a workspace. Later, when you create a new workspace on a branch, or pull/merge request the workspace loads much faster, because all dependencies are already downloaded and the code is compiled. For more information see prebuilds.\n\n__SPLIT_HERE__\nStep 4: Enjoy being ready-to-code ü§ô\n\nOnce the first prebuild ran, Gitpod starts an automated and fully configured developer environment in a workspace that is now ready for you to develop.\n\nOther developers made their setup even more productive and supercharged their workflows with the following quick steps:\n\nInstalling the browser extension\n\nYou can install the Gitpod browser extension on any Chromium-based browsers such as Microsoft Edge, Brave, Chrome, and others, or on a Firefox browser.\n\nThe extension simply adds a Gitpod button on every project and branch across GitHub, and Bitbucket that prefixes the URL with gitpod.io/# so that you can easily open a new workspace from any Git context.\n\nBrowser Extension\n\nIf you prefer to not install browser extensions then you can use the Gitpod browser bookmarklet instead.\n\nFor our partner GitLab we have a native integration into their UI that you can enable here.\n\nAdd your favorite VS Code themes and extensions\n\nYou have access to all Visual Studio Code extensions published under the vendor neutral Open VSX registry. Install one by clicking the Extensions icon in the left sidebar and enter your favorite theme or VS Code extension.\n\nChanges you make in your workspace such as themes and extensions are synced automatically to other workspaces.\n\nStart throwing away workspaces like paper towels\n\nYou can now start to treat dev environments as automated resources you spin up when you need them and close down (and forget about) when you are done with your task. Dev environments become fully ephemeral.\n\nYou even can start switching between workspaces or open several workspaces on the same context - two for your feature, one for reviewing a PR/MR, one for a bug, one for another MR/PR.\n\nTry it out and open 3 workspaces on the same context (e.g. on main or on an issue). ü§ì\n\n__SPLIT_HERE__\nNext Steps\n\nYou&#39;ve successfully ran your first workspace and experienced first hand what we mean with ephemeral dev environments. This is just the first step on your journey towards being always ready to code. Helpful resources from here are:\n\nGetting started with your own project\nGit Integrations","metadata":{"source":"https://gitpod.io/docs/introduction/getting-started/quickstart/perl"}}],["711",{"pageContent":"__SPLIT_HERE__\nPlanetScale Quickstart\n\nLearn how to set-up and understand the benefits of Gitpod in less than 5 min with our PlanetScale template.\n\nThe following guide will:\n\nWalk you through a real world example with an existing Gitpod config\nIntroduce you to prebuilds\nDemonstrate the benefits of ephemeral developer environments\n\nFor simplicity we use a GitHub template, but Gitpod works similarly with GitLab and Bitbucket.\n\n__SPLIT_HERE__\nStep 1: Clone Git repository\n\nCreate a new repository based on the PlanetScale template.\nName it e.g. my-planetscale-template.\n\n__SPLIT_HERE__\nStep 2: Install the Gitpod app\n\nInstall the Gitpod App.\n\nGitpod&#39;s GitHub app is similar to a CI server and will continuously prepare prebuilds for all your branches and pull requests - so you don&#39;t have to wait for Maven or NPM downloading the internet when you want to start coding.\n\n__SPLIT_HERE__\nStep 3: First prebuild\n\nStart your first workspace with a prebuild by prefixing https://gitpod.io#prebuild/ to the URL of the repository.\n\nThe revised URL is: https://gitpod.io/#prebuild/https://github.com/&lt;github_username&gt;/&lt;my-planetscale-template&gt;\n\nGitpod displays the prebuild progress status by running the init commands in the .gitpod.yml file before you even start a workspace. Later, when you create a new workspace on a branch, or pull/merge request the workspace loads much faster, because all dependencies are already downloaded and the code is compiled. For more information see prebuilds.\n\n__SPLIT_HERE__\nStep 4: Enjoy being ready-to-code ü§ô\n\nOnce the first prebuild ran, Gitpod starts an automated and fully configured developer environment in a workspace that is now ready for you to develop.\n\nOther developers made their setup even more productive and supercharged their workflows with the following quick steps:\n\nInstalling the browser extension\n\nYou can install the Gitpod browser extension on any Chromium-based browsers such as Microsoft Edge, Brave, Chrome, and others, or on a Firefox browser.\n\nThe extension simply adds a Gitpod button on every project and branch across GitHub, and Bitbucket that prefixes the URL with gitpod.io/# so that you can easily open a new workspace from any Git context.\n\nBrowser Extension\n\nIf you prefer to not install browser extensions then you can use the Gitpod browser bookmarklet instead.\n\nFor our partner GitLab we have a native integration into their UI that you can enable here.\n\nAdd your favorite VS Code themes and extensions\n\nYou have access to all Visual Studio Code extensions published under the vendor neutral Open VSX registry. Install one by clicking the Extensions icon in the left sidebar and enter your favorite theme or VS Code extension.\n\nChanges you make in your workspace such as themes and extensions are synced automatically to other workspaces.\n\nStart throwing away workspaces like paper towels\n\nYou can now start to treat dev environments as automated resources you spin up when you need them and close down (and forget about) when you are done with your task. Dev environments become fully ephemeral.\n\nYou even can start switching between workspaces or open several workspaces on the same context - two for your feature, one for reviewing a PR/MR, one for a bug, one for another MR/PR.\n\nTry it out and open 3 workspaces on the same context (e.g. on main or on an issue). ü§ì\n\n__SPLIT_HERE__\nNext Steps\n\nYou&#39;ve successfully ran your first workspace and experienced first hand what we mean with ephemeral dev environments. This is just the first step on your journey towards being always ready to code. Helpful resources from here are:\n\nGetting started with your own project\nGit Integrations","metadata":{"source":"https://gitpod.io/docs/introduction/getting-started/quickstart/planetscale"}}],["712",{"pageContent":"__SPLIT_HERE__\nPython Django Quickstart\n\nLearn how to set-up and understand the benefits of Gitpod in less than 5 min with our Python template.\n\nThe following guide will:\n\nWalk you through a real world example with an existing Gitpod config\nIntroduce you to prebuilds\nDemonstrate the benefits of ephemeral developer environments\n\nFor simplicity we use a GitHub template, but Gitpod works similarly with GitLab and Bitbucket.\n\n__SPLIT_HERE__\nStep 1: Clone Git repository\n\nCreate a new repository based on the Python template.\nName it e.g. my-python-template.\n\n__SPLIT_HERE__\nStep 2: Install the Gitpod app\n\nInstall the Gitpod App.\n\nGitpod&#39;s GitHub app is similar to a CI server and will continuously prepare prebuilds for all your branches and pull requests - so you don&#39;t have to wait for Maven or NPM downloading the internet when you want to start coding.\n\n__SPLIT_HERE__\nStep 3: First prebuild\n\nStart your first workspace with a prebuild by prefixing https://gitpod.io#prebuild/ to the URL of the repository.\n\nThe revised URL is: https://gitpod.io/#prebuild/https://github.com/&lt;github_username&gt;/&lt;my-python-template&gt;\n\nGitpod displays the prebuild progress status by running the init commands in the .gitpod.yml file before you even start a workspace. Later, when you create a new workspace on a branch, or pull/merge request the workspace loads much faster, because all dependencies are already downloaded and the code is compiled. For more information see prebuilds.\n\n__SPLIT_HERE__\nStep 4: Enjoy being ready-to-code ü§ô\n\nOnce the first prebuild ran, Gitpod starts an automated and fully configured developer environment in a workspace that is now ready for you to develop.\n\nOther developers made their setup even more productive and supercharged their workflows with the following quick steps:\n\nInstalling the browser extension\n\nYou can install the Gitpod browser extension on any Chromium-based browsers such as Microsoft Edge, Brave, Chrome, and others, or on a Firefox browser.\n\nThe extension simply adds a Gitpod button on every project and branch across GitHub, and Bitbucket that prefixes the URL with gitpod.io/# so that you can easily open a new workspace from any Git context.\n\nBrowser Extension\n\nIf you prefer to not install browser extensions then you can use the Gitpod browser bookmarklet instead.\n\nFor our partner GitLab we have a native integration into their UI that you can enable here.\n\nAdd your favorite VS Code themes and extensions\n\nYou have access to all Visual Studio Code extensions published under the vendor neutral Open VSX registry. Install one by clicking the Extensions icon in the left sidebar and enter your favorite theme or VS Code extension.\n\nChanges you make in your workspace such as themes and extensions are synced automatically to other workspaces.\n\nStart throwing away workspaces like paper towels\n\nYou can now start to treat dev environments as automated resources you spin up when you need them and close down (and forget about) when you are done with your task. Dev environments become fully ephemeral.\n\nYou even can start switching between workspaces or open several workspaces on the same context - two for your feature, one for reviewing a PR/MR, one for a bug, one for another MR/PR.\n\nTry it out and open 3 workspaces on the same context (e.g. on main or on an issue). ü§ì\n\n__SPLIT_HERE__\nNext Steps\n\nYou&#39;ve successfully ran your first workspace and experienced first hand what we mean with ephemeral dev environments. This is just the first step on your journey towards being always ready to code. Helpful resources from here are:\n\nGetting started with your own project\nGit Integrations","metadata":{"source":"https://gitpod.io/docs/introduction/getting-started/quickstart/python"}}],["713",{"pageContent":"__SPLIT_HERE__\nReact Quickstart\n\nLearn how to set-up and understand the benefits of Gitpod in less than 5 min with our React template.\n\nThe following guide will:\n\nWalk you through a real world example with an existing Gitpod config\nIntroduce you to prebuilds\nDemonstrate the benefits of ephemeral developer environments\n\nFor simplicity we use a GitHub template, but Gitpod works similarly with GitLab and Bitbucket.\n\n__SPLIT_HERE__\nStep 1: Clone Git repository\n\nCreate a new repository based on the React template.\nName it e.g. my-react-template.\n\n__SPLIT_HERE__\nStep 2: Install the Gitpod app\n\nInstall the Gitpod App.\n\nGitpod&#39;s GitHub app is similar to a CI server and will continuously prepare prebuilds for all your branches and pull requests - so you don&#39;t have to wait for Maven or NPM downloading the internet when you want to start coding.\n\n__SPLIT_HERE__\nStep 3: First prebuild\n\nStart your first workspace with a prebuild by prefixing https://gitpod.io#prebuild/ to the URL of the repository.\n\nThe revised URL is: https://gitpod.io/#prebuild/https://github.com/&lt;github_username&gt;/&lt;my-react-template&gt;\n\nGitpod displays the prebuild progress status by running the init commands in the .gitpod.yml file before you even start a workspace. Later, when you create a new workspace on a branch, or pull/merge request the workspace loads much faster, because all dependencies are already downloaded and the code is compiled. For more information see prebuilds.\n\n__SPLIT_HERE__\nStep 4: Enjoy being ready-to-code ü§ô\n\nOnce the first prebuild ran, Gitpod starts an automated and fully configured developer environment in a workspace that is now ready for you to develop.\n\nOther developers made their setup even more productive and supercharged their workflows with the following quick steps:\n\nInstalling the browser extension\n\nYou can install the Gitpod browser extension on any Chromium-based browsers such as Microsoft Edge, Brave, Chrome, and others, or on a Firefox browser.\n\nThe extension simply adds a Gitpod button on every project and branch across GitHub, and Bitbucket that prefixes the URL with gitpod.io/# so that you can easily open a new workspace from any Git context.\n\nBrowser Extension\n\nIf you prefer to not install browser extensions then you can use the Gitpod browser bookmarklet instead.\n\nFor our partner GitLab we have a native integration into their UI that you can enable here.\n\nAdd your favorite VS Code themes and extensions\n\nYou have access to all Visual Studio Code extensions published under the vendor neutral Open VSX registry. Install one by clicking the Extensions icon in the left sidebar and enter your favorite theme or VS Code extension.\n\nChanges you make in your workspace such as themes and extensions are synced automatically to other workspaces.\n\nStart throwing away workspaces like paper towels\n\nYou can now start to treat dev environments as automated resources you spin up when you need them and close down (and forget about) when you are done with your task. Dev environments become fully ephemeral.\n\nYou even can start switching between workspaces or open several workspaces on the same context - two for your feature, one for reviewing a PR/MR, one for a bug, one for another MR/PR.\n\nTry it out and open 3 workspaces on the same context (e.g. on main or on an issue). ü§ì\n\n__SPLIT_HERE__\nNext Steps\n\nYou&#39;ve successfully ran your first workspace and experienced first hand what we mean with ephemeral dev environments. This is just the first step on your journey towards being always ready to code. Helpful resources from here are:\n\nGetting started with your own project\nGit Integrations","metadata":{"source":"https://gitpod.io/docs/introduction/getting-started/quickstart/react"}}],["714",{"pageContent":"__SPLIT_HERE__\nRuby on Rails Quickstart\n\nLearn how to set-up and understand the benefits of Gitpod in less than 5 min with our Ruby on Rails template.\n\nThe following guide will:\n\nWalk you through a real world example with an existing Gitpod config\nIntroduce you to prebuilds\nDemonstrate the benefits of ephemeral developer environments\n\nFor simplicity we use a GitHub template, but Gitpod works similarly with GitLab and Bitbucket.\n\n__SPLIT_HERE__\nStep 1: Clone Git repository\n\nCreate a new repository based on the Ruby on Rails template.\nName it e.g. my-ruby-on-rails-template.\n\n__SPLIT_HERE__\nStep 2: Install the Gitpod app\n\nInstall the Gitpod App.\n\nGitpod&#39;s GitHub app is similar to a CI server and will continuously prepare prebuilds for all your branches and pull requests - so you don&#39;t have to wait for Maven or NPM downloading the internet when you want to start coding.\n\n__SPLIT_HERE__\nStep 3: First prebuild\n\nStart your first workspace with a prebuild by prefixing https://gitpod.io#prebuild/ to the URL of the repository.\n\nThe revised URL is: https://gitpod.io/#prebuild/https://github.com/&lt;github_username&gt;/&lt;my-ruby-on-rails-template&gt;\n\nGitpod displays the prebuild progress status by running the init commands in the .gitpod.yml file before you even start a workspace. Later, when you create a new workspace on a branch, or pull/merge request the workspace loads much faster, because all dependencies are already downloaded and the code is compiled. For more information see prebuilds.\n\n__SPLIT_HERE__\nStep 4: Enjoy being ready-to-code ü§ô\n\nOnce the first prebuild ran, Gitpod starts an automated and fully configured developer environment in a workspace that is now ready for you to develop.\n\nOther developers made their setup even more productive and supercharged their workflows with the following quick steps:\n\nInstalling the browser extension\n\nYou can install the Gitpod browser extension on any Chromium-based browsers such as Microsoft Edge, Brave, Chrome, and others, or on a Firefox browser.\n\nThe extension simply adds a Gitpod button on every project and branch across GitHub, and Bitbucket that prefixes the URL with gitpod.io/# so that you can easily open a new workspace from any Git context.\n\nBrowser Extension\n\nIf you prefer to not install browser extensions then you can use the Gitpod browser bookmarklet instead.\n\nFor our partner GitLab we have a native integration into their UI that you can enable here.\n\nAdd your favorite VS Code themes and extensions\n\nYou have access to all Visual Studio Code extensions published under the vendor neutral Open VSX registry. Install one by clicking the Extensions icon in the left sidebar and enter your favorite theme or VS Code extension.\n\nChanges you make in your workspace such as themes and extensions are synced automatically to other workspaces.\n\nStart throwing away workspaces like paper towels\n\nYou can now start to treat dev environments as automated resources you spin up when you need them and close down (and forget about) when you are done with your task. Dev environments become fully ephemeral.\n\nYou even can start switching between workspaces or open several workspaces on the same context - two for your feature, one for reviewing a PR/MR, one for a bug, one for another MR/PR.\n\nTry it out and open 3 workspaces on the same context (e.g. on main or on an issue). ü§ì\n\n__SPLIT_HERE__\nNext Steps\n\nYou&#39;ve successfully ran your first workspace and experienced first hand what we mean with ephemeral dev environments. This is just the first step on your journey towards being always ready to code. Helpful resources from here are:\n\nGetting started with your own project\nGit Integrations","metadata":{"source":"https://gitpod.io/docs/introduction/getting-started/quickstart/ruby-on-rails"}}],["715",{"pageContent":"__SPLIT_HERE__\nRust Quickstart\n\nLearn how to set-up and understand the benefits of Gitpod in less than 5 min with our Rust template.\n\nThe following guide will:\n\nWalk you through a real world example with an existing Gitpod config\nIntroduce you to prebuilds\nDemonstrate the benefits of ephemeral developer environments\n\nFor simplicity we use a GitHub template, but Gitpod works similarly with GitLab and Bitbucket.\n\n__SPLIT_HERE__\nStep 1: Clone Git repository\n\nCreate a new repository based on the Rust template.\nName it e.g. my-rust-template.\n\n__SPLIT_HERE__\nStep 2: Install Gitpod app\n\nInstall the Gitpod App.\n\nGitpod&#39;s GitHub app is similar to a CI server and will continuously prepare prebuilds for all your branches and pull requests - so you don&#39;t have to wait for Maven or NPM downloading the internet when you want to start coding.\n\n__SPLIT_HERE__\nStep 3: First prebuild\n\nStart your first workspace with a prebuild by prefixing https://gitpod.io#prebuild/ to the URL of the repository.\n\nThe revised URL is: https://gitpod.io/#prebuild/https://github.com/&lt;github_username&gt;/my-rust-template\n\nGitpod displays the prebuild progress status by running the init commands in the .gitpod.yml file before you even start a workspace. Later, when you create a new workspace on a branch, or pull/merge request the workspace loads much faster, because all dependencies are already downloaded and the code is compiled. For more information see prebuilds.\n\n__SPLIT_HERE__\nStep 4: Enjoy being ready-to-code ü§ô\n\nOnce the first prebuild ran, Gitpod starts an automated and fully configured developer environment in a workspace that is now ready for you to develop.\n\nOther developers made their setup even more productive and supercharged their workflows with the following quick steps:\n\nInstalling the browser extension\n\nYou can install the Gitpod browser extension on any Chromium-based browsers such as Microsoft Edge, Brave, Chrome, and others, or on a Firefox browser.\n\nThe extension simply adds a Gitpod button on every project and branch across GitHub, and Bitbucket that prefixes the URL with gitpod.io/# so that you can easily open a new workspace from any Git context.\n\nBrowser Extension\n\nIf you prefer to not install browser extensions then you can use the Gitpod browser bookmarklet instead.\n\nFor our partner GitLab we have a native integration into their UI that you can enable here.\n\nAdd your favorite VS Code themes and extensions\n\nYou have access to all Visual Studio Code extensions published under the vendor neutral Open VSX registry. Install one by clicking the Extensions icon in the left sidebar and enter your favorite theme or VS Code extension.\n\nChanges you make in your workspace such as themes and extensions are synced automatically to other workspaces.\n\nStart throwing away workspaces like paper towels\n\nYou can now start to treat dev environments as automated resources you spin up when you need them and close down (and forget about) when you are done with your task. Dev environments become fully ephemeral.\n\nYou even can start switching between workspaces or open several workspaces on the same context - two for your feature, one for reviewing a PR/MR, one for a bug, one for another MR/PR.\n\nTry it out and open 3 workspaces on the same context (e.g. on main or on an issue). ü§ì\n\n__SPLIT_HERE__\nNext Steps\n\nYou&#39;ve successfully ran your first workspace and experienced first hand what we mean with ephemeral dev environments. This is just the first step on your journey towards being always ready to code. Helpful resources from here are:\n\nGetting started with your own project\nGit Integrations","metadata":{"source":"https://gitpod.io/docs/introduction/getting-started/quickstart/rust"}}],["716",{"pageContent":"__SPLIT_HERE__\nScala Quickstart\n\nLearn how to set-up and understand the benefits of Gitpod in less than 5 min with our Scala template.\n\nThe following guide will:\n\nWalk you through a real world example with an existing Gitpod config\nIntroduce you to prebuilds\nDemonstrate the benefits of ephemeral developer environments\n\nFor simplicity we use a GitHub template, but Gitpod works similarly with GitLab and Bitbucket.\n\n__SPLIT_HERE__\nStep 1: Clone Git repository\n\nCreate a new repository based on the Scala template.\nName it e.g. my-scala-template.\n\n__SPLIT_HERE__\nStep 2: Install the Gitpod app\n\nInstall the Gitpod App.\n\nGitpod&#39;s GitHub app is similar to a CI server and will continuously prepare prebuilds for all your branches and pull requests - so you don&#39;t have to wait for Maven or NPM downloading the internet when you want to start coding.\n\n__SPLIT_HERE__\nStep 3: First prebuild\n\nStart your first workspace with a prebuild by prefixing https://gitpod.io#prebuild/ to the URL of the repository.\n\nThe revised URL is: https://gitpod.io/#prebuild/https://github.com/&lt;github_username&gt;/&lt;my-scala-template&gt;\n\nGitpod displays the prebuild progress status by running the init commands in the .gitpod.yml file before you even start a workspace. Later, when you create a new workspace on a branch, or pull/merge request the workspace loads much faster, because all dependencies are already downloaded and the code is compiled. For more information see prebuilds.\n\n__SPLIT_HERE__\nStep 4: Enjoy being ready-to-code ü§ô\n\nOnce the first prebuild ran, Gitpod starts an automated and fully configured developer environment in a workspace that is now ready for you to develop.\n\nOther developers made their setup even more productive and supercharged their workflows with the following quick steps:\n\nInstalling the browser extension\n\nYou can install the Gitpod browser extension on any Chromium-based browsers such as Microsoft Edge, Brave, Chrome, and others, or on a Firefox browser.\n\nThe extension simply adds a Gitpod button on every project and branch across GitHub, and Bitbucket that prefixes the URL with gitpod.io/# so that you can easily open a new workspace from any Git context.\n\nBrowser Extension\n\nIf you prefer to not install browser extensions then you can use the Gitpod browser bookmarklet instead.\n\nFor our partner GitLab we have a native integration into their UI that you can enable here.\n\nAdd your favorite VS Code themes and extensions\n\nYou have access to all Visual Studio Code extensions published under the vendor neutral Open VSX registry. Install one by clicking the Extensions icon in the left sidebar and enter your favorite theme or VS Code extension.\n\nChanges you make in your workspace such as themes and extensions are synced automatically to other workspaces.\n\nStart throwing away workspaces like paper towels\n\nYou can now start to treat dev environments as automated resources you spin up when you need them and close down (and forget about) when you are done with your task. Dev environments become fully ephemeral.\n\nYou even can start switching between workspaces or open several workspaces on the same context - two for your feature, one for reviewing a PR/MR, one for a bug, one for another MR/PR.\n\nTry it out and open 3 workspaces on the same context (e.g. on main or on an issue). ü§ì\n\n__SPLIT_HERE__\nNext Steps\n\nYou&#39;ve successfully ran your first workspace and experienced first hand what we mean with ephemeral dev environments. This is just the first step on your journey towards being always ready to code. Helpful resources from here are:\n\nGetting started with your own project\nGit Integrations","metadata":{"source":"https://gitpod.io/docs/introduction/getting-started/quickstart/scala"}}],["717",{"pageContent":"__SPLIT_HERE__\nSvelte Quickstart\n\nLearn how to set-up and understand the benefits of Gitpod in less than 5 min with our SvelteJS template.\n\nThe following guide will:\n\nWalk you through a real world example with an existing Gitpod config\nIntroduce you to prebuilds\nDemonstrate the benefits of ephemeral developer environments\n\nFor simplicity we use a GitHub template, but Gitpod works similarly with GitLab and Bitbucket.\n\n__SPLIT_HERE__\nStep 1: Clone Git repository\n\nCreate a new repository based on the SvelteJS template.\nName it e.g. my-svelte-template.\n\n__SPLIT_HERE__\nStep 2: Install Gitpod app\n\nInstall the Gitpod App.\n\nGitpod&#39;s GitHub app is similar to a CI server and will continuously prepare prebuilds for all your branches and pull requests - so you don&#39;t have to wait for Maven or NPM downloading the internet when you want to start coding.\n\n__SPLIT_HERE__\nStep 3: First prebuild\n\nStart your first workspace with a prebuild by prefixing https://gitpod.io#prebuild/ to the URL of the repository.\n\nThe revised URL is: https://gitpod.io/#prebuild/https://github.com/&lt;github_username&gt;/my-svelte-template\n\nGitpod displays the prebuild progress status by running the init commands in the .gitpod.yml file before you even start a workspace. Later, when you create a new workspace on a branch, or pull/merge request the workspace loads much faster, because all dependencies are already downloaded and the code is compiled. For more information see prebuilds.\n\n__SPLIT_HERE__\nStep 4: Enjoy being ready-to-code ü§ô\n\nOnce the first prebuild ran, Gitpod starts an automated and fully configured developer environment in a workspace that is now ready for you to develop.\n\nOther developers made their setup even more productive and supercharged their workflows with the following quick steps:\n\nInstalling the browser extension\n\nYou can install the Gitpod browser extension on any Chromium-based browsers such as Microsoft Edge, Brave, Chrome, and others, or on a Firefox browser.\n\nThe extension simply adds a Gitpod button on every project and branch across GitHub, and Bitbucket that prefixes the URL with gitpod.io/# so that you can easily open a new workspace from any Git context.\n\nBrowser Extension\n\nIf you prefer to not install browser extensions then you can use the Gitpod browser bookmarklet instead.\n\nFor our partner GitLab we have a native integration into their UI that you can enable here.\n\nAdd your favorite VS Code themes and extensions\n\nYou have access to all Visual Studio Code extensions published under the vendor neutral Open VSX registry. Install one by clicking the Extensions icon in the left sidebar and enter your favorite theme or VS Code extension.\n\nChanges you make in your workspace such as themes and extensions are synced automatically to other workspaces.\n\nStart throwing away workspaces like paper towels\n\nYou can now start to treat dev environments as automated resources you spin up when you need them and close down (and forget about) when you are done with your task. Dev environments become fully ephemeral.\n\nYou even can start switching between workspaces or open several workspaces on the same context - two for your feature, one for reviewing a PR/MR, one for a bug, one for another MR/PR.\n\nTry it out and open 3 workspaces on the same context (e.g. on main or on an issue). ü§ì\n\n__SPLIT_HERE__\nNext Steps\n\nYou&#39;ve successfully ran your first workspace and experienced first hand what we mean with ephemeral dev environments. This is just the first step on your journey towards being always ready to code. Helpful resources from here are:\n\nGetting started with your own project\nGit Integrations","metadata":{"source":"https://gitpod.io/docs/introduction/getting-started/quickstart/svelte"}}],["718",{"pageContent":"__SPLIT_HERE__\nSvelteKit Quickstart\n\nLearn how to set-up and understand the benefits of Gitpod in less than 5 min with our SvelteKit template.\n\nThe following guide will:\n\nWalk you through a real world example with an existing Gitpod config\nIntroduce you to prebuilds\nDemonstrate the benefits of ephemeral developer environments\n\nFor simplicity we use a GitHub template, but Gitpod works similarly with GitLab and Bitbucket.\n\n__SPLIT_HERE__\nStep 1: Clone Git repository\n\nCreate a new repository based on the SvelteKit template.\nName it e.g. my-sveltekit-template.\n\n__SPLIT_HERE__\nStep 2: Install Gitpod app\n\nInstall the Gitpod App.\n\nGitpod&#39;s GitHub app is similar to a CI server and will continuously prepare prebuilds for all your branches and pull requests - so you don&#39;t have to wait for Maven or NPM downloading the internet when you want to start coding.\n\n__SPLIT_HERE__\nStep 3: First prebuild\n\nStart your first workspace with a prebuild by prefixing https://gitpod.io#prebuild/ to the URL of the repository.\n\nThe revised URL is: https://gitpod.io/#prebuild/https://github.com/&lt;github_username&gt;/my-svelte-template\n\nGitpod displays the prebuild progress status by running the init commands in the .gitpod.yml file before you even start a workspace. Later, when you create a new workspace on a branch, or pull/merge request the workspace loads much faster, because all dependencies are already downloaded and the code is compiled. For more information see prebuilds.\n\n__SPLIT_HERE__\nStep 4: Enjoy being ready-to-code ü§ô\n\nOnce the first prebuild ran, Gitpod starts an automated and fully configured developer environment in a workspace that is now ready for you to develop.\n\nOther developers made their setup even more productive and supercharged their workflows with the following quick steps:\n\nInstalling the browser extension\n\nYou can install the Gitpod browser extension on any Chromium-based browsers such as Microsoft Edge, Brave, Chrome, and others, or on a Firefox browser.\n\nThe extension simply adds a Gitpod button on every project and branch across GitHub, and Bitbucket that prefixes the URL with gitpod.io/# so that you can easily open a new workspace from any Git context.\n\nBrowser Extension\n\nIf you prefer to not install browser extensions then you can use the Gitpod browser bookmarklet instead.\n\nFor our partner GitLab we have a native integration into their UI that you can enable here.\n\nAdd your favorite VS Code themes and extensions\n\nYou have access to all Visual Studio Code extensions published under the vendor neutral Open VSX registry. Install one by clicking the Extensions icon in the left sidebar and enter your favorite theme or VS Code extension.\n\nChanges you make in your workspace such as themes and extensions are synced automatically to other workspaces.\n\nStart throwing away workspaces like paper towels\n\nYou can now start to treat dev environments as automated resources you spin up when you need them and close down (and forget about) when you are done with your task. Dev environments become fully ephemeral.\n\nYou even can start switching between workspaces or open several workspaces on the same context - two for your feature, one for reviewing a PR/MR, one for a bug, one for another MR/PR.\n\nTry it out and open 3 workspaces on the same context (e.g. on main or on an issue). ü§ì\n\n__SPLIT_HERE__\nNext Steps\n\nYou&#39;ve successfully ran your first workspace and experienced first hand what we mean with ephemeral dev environments. This is just the first step on your journey towards being always ready to code. Helpful resources from here are:\n\nGetting started with your own project\nGit Integrations","metadata":{"source":"https://gitpod.io/docs/introduction/getting-started/quickstart/sveltekit"}}],["719",{"pageContent":"__SPLIT_HERE__\nTLA+ Quickstart\n\nLearn how to set-up and understand the benefits of Gitpod in less than 5 min with our TLA+ template.\n\nThe following guide will:\n\nWalk you through a real world example with an existing Gitpod config\nIntroduce you to prebuilds\nDemonstrate the benefits of ephemeral developer environments\n\nFor simplicity we use a GitHub template, but Gitpod works similarly with GitLab and Bitbucket.\n\nStep 1: Clone Git repository\n\nCreate a new repository based on the TLA+ template.\nName it e.g. my-tlaplus-template.\n\nStep 2: Install Gitpod app\n\nInstall the Gitpod App.\n\nGitpod&#39;s GitHub app is similar to a CI server and will continuously prepare prebuilds for all your branches and pull requests - so you don&#39;t have to wait for installation of dependencies from the internet when you want to start coding.\n\nStep 3: First prebuild\n\nStart your first workspace with a prebuild by prefixing https://gitpod.io#prebuild/ to the URL of the repository.\n\nThe revised URL is: https://gitpod.io/#prebuild/https://github.com/&lt;github_username&gt;/my-nextjs-template\n\nGitpod displays the prebuild progress status by running the init commands in the .gitpod.yml file before you even start a workspace. Later, when you create a new workspace on a branch, or pull/merge request the workspace loads much faster, because all dependencies are already downloaded and the code is compiled. For more information see prebuilds.\n\nStep 4: Enjoy being ready-to-code ü§ô\n\nOnce the first prebuild ran, Gitpod starts an automated and fully configured developer environment in a workspace that is now ready for you to develop.\n\nOther developers made their setup even more productive and supercharged their workflows with the following quick steps:\n\nInstalling the browser extension\n\nYou can install the Gitpod browser extension on any Chromium-based browsers such as Microsoft Edge, Brave, Chrome, and others, or on a Firefox browser.\n\nThe extension simply adds a Gitpod button on every project and branch across GitHub, and Bitbucket that prefixes the URL with gitpod.io/# so that you can easily open a new workspace from any Git context.\n\nBrowser Extension\n\nIf you prefer to not install browser extensions then you can use the Gitpod browser bookmarklet instead.\n\nFor our partner GitLab we have a native integration into their UI that you can enable here.\n\nAdd your favorite VS Code themes and extensions\n\nYou have access to all Visual Studio Code extensions published under the vendor neutral Open VSX registry. Install one by clicking the Extensions icon in the left sidebar and enter your favorite theme or VS Code extension.\n\nChanges you make in your workspace such as themes and extensions are synced automatically to other workspaces.\n\nStart throwing away workspaces like paper towels\n\nYou can now start to treat dev environments as automated resources you spin up when you need them and close down (and forget about) when you are done with your task. Dev environments become fully ephemeral.\n\nYou even can start switching between workspaces or open several workspaces on the same context - two for your feature, one for reviewing a PR/MR, one for a bug, one for another MR/PR.\n\nTry it out and open 3 workspaces on the same context (e.g. on main or on an issue). ü§ì\n\n__SPLIT_HERE__\nNext Steps\n\nYou&#39;ve successfully ran your first workspace and experienced first hand what we mean with ephemeral dev environments. This is just the first step on your journey towards being always ready to code. Helpful resources from here are:\n\nGetting started with your own project\nGit Integrations","metadata":{"source":"https://gitpod.io/docs/introduction/getting-started/quickstart/tlaplus"}}],["720",{"pageContent":"__SPLIT_HERE__\nNode/TypeScript/Express Quickstart\n\nLearn how to set-up and understand the benefits of Gitpod in less than 5 min with our Node/TypeScript/Express template.\n\nThe following guide will:\n\nWalk you through a real world example with an existing Gitpod config\nIntroduce you to prebuilds\nDemonstrate the benefits of ephemeral developer environments\n\nFor simplicity we use a GitHub template, but Gitpod works similarly with GitLab and Bitbucket.\n\n__SPLIT_HERE__\nStep 1: Clone Git repository\n\nCreate a new repository based on the Node/TypeScript template.\nName it e.g. my-typescript-template.\n\n__SPLIT_HERE__\nStep 2: Install Gitpod app\n\nInstall the Gitpod App.\n\nGitpod&#39;s GitHub app is similar to a CI server and will continuously prepare prebuilds for all your branches and pull requests - so you don&#39;t have to wait for Maven or NPM downloading from the internet when you want to start coding.\n\n__SPLIT_HERE__\nStep 3: First prebuild\n\nStart your first workspace with a prebuild by prefixing https://gitpod.io#prebuild/ to the URL of the repository.\n\nThe revised URL is: https://gitpod.io/#prebuild/https://github.com/&lt;github_username&gt;/my-typescript-template\n\nGitpod displays the prebuild progress status by running the init commands in the .gitpod.yml file before you even start a workspace. Later, when you create a new workspace on a branch, or pull/merge request the workspace loads much faster, because all dependencies are already downloaded and the code is compiled. For more information see prebuilds.\n\n__SPLIT_HERE__\nStep 4: Enjoy being ready-to-code ü§ô\n\nOnce the first prebuild ran, Gitpod starts an automated and fully configured developer environment in a workspace that is now ready for you to develop.\n\nOther developers made their setup even more productive and supercharged their workflows with the following quick steps:\n\nInstalling the browser extension\n\nYou can install the Gitpod browser extension on any Chromium-based browsers such as Microsoft Edge, Brave, Chrome, and others, or on a Firefox browser.\n\nThe extension simply adds a Gitpod button on every project and branch across GitHub, and Bitbucket that prefixes the URL with gitpod.io/# so that you can easily open a new workspace from any Git context.\n\nBrowser Extension\n\nIf you prefer to not install browser extensions then you can use the Gitpod browser bookmarklet instead.\n\nFor our partner GitLab we have a native integration into their UI that you can enable here.\n\nAdd your favorite VS Code themes and extensions\n\nYou have access to all Visual Studio Code extensions published under the vendor neutral Open VSX registry. Install one by clicking the Extensions icon in the left sidebar and enter your favorite theme or VS Code extension.\n\nChanges you make in your workspace such as themes and extensions are synced automatically to other workspaces.\n\nStart throwing away workspaces like paper towels\n\nYou can now start to treat dev environments as automated resources you spin up when you need them and close down (and forget about) when you are done with your task. Dev environments become fully ephemeral.\n\nYou even can start switching between workspaces or open several workspaces on the same context - two for your feature, one for reviewing a PR/MR, one for a bug, one for another MR/PR.\n\nTry it out and open 3 workspaces on the same context (e.g. on main or on an issue). ü§ì\n\n__SPLIT_HERE__\nNext Steps\n\nYou&#39;ve successfully ran your first workspace and experienced first hand what we mean with ephemeral dev environments. This is just the first step on your journey towards being always ready to code. Helpful resources from here are:\n\nGetting started with your own project\nGit Integrations","metadata":{"source":"https://gitpod.io/docs/introduction/getting-started/quickstart/typescript"}}],["721",{"pageContent":"__SPLIT_HERE__\nWasp Quickstart\n\nLearn how to set-up and understand the benefits of Gitpod in less than 5 min with our Wasp template.\n\nThe following guide will:\n\nWalk you through a real world example with an existing Gitpod config\nIntroduce you to prebuilds\nDemonstrate the benefits of ephemeral developer environments\n\nFor simplicity we use a GitHub template, but Gitpod works similarly with GitLab and Bitbucket.\n\n__SPLIT_HERE__\nStep 1: Clone Git repository\n\nCreate a new repository based on the Wasp template.\nName it e.g. my-wasp-template.\n\n__SPLIT_HERE__\nStep 2: Install the Gitpod app\n\nInstall the Gitpod App.\n\nGitpod&#39;s GitHub app is similar to a CI server and will continuously prepare prebuilds for all your branches and pull requests - so you don&#39;t have to wait for Maven or NPM downloading the internet when you want to start coding.\n\n__SPLIT_HERE__\nStep 3: First prebuild\n\nStart your first workspace with a prebuild by prefixing https://gitpod.io#prebuild/ to the URL of the repository.\n\nThe revised URL is: https://gitpod.io/#prebuild/https://github.com/&lt;github_username&gt;/&lt;my-wasp-template&gt;\n\nGitpod displays the prebuild progress status by running the init commands in the .gitpod.yml file before you even start a workspace. Later, when you create a new workspace on a branch, or pull/merge request the workspace loads much faster, because all dependencies are already downloaded and the code is compiled. For more information see prebuilds.\n\n__SPLIT_HERE__\nStep 4: Enjoy being ready-to-code ü§ô\n\nOnce the first prebuild ran, Gitpod starts an automated and fully configured developer environment in a workspace that is now ready for you to develop.\n\nOther developers made their setup even more productive and supercharged their workflows with the following quick steps:\n\nInstalling the browser extension\n\nYou can install the Gitpod browser extension on any Chromium-based browsers such as Microsoft Edge, Brave, Chrome, and others, or on a Firefox browser.\n\nThe extension simply adds a Gitpod button on every project and branch across GitHub, and Bitbucket that prefixes the URL with gitpod.io/# so that you can easily open a new workspace from any Git context.\n\nBrowser Extension\n\nIf you prefer to not install browser extensions then you can use the Gitpod browser bookmarklet instead.\n\nFor our partner GitLab we have a native integration into their UI that you can enable here.\n\nAdd your favorite VS Code themes and extensions\n\nYou have access to all Visual Studio Code extensions published under the vendor neutral Open VSX registry. Install one by clicking the Extensions icon in the left sidebar and enter your favorite theme or VS Code extension.\n\nChanges you make in your workspace such as themes and extensions are synced automatically to other workspaces.\n\nStart throwing away workspaces like paper towels\n\nYou can now start to treat dev environments as automated resources you spin up when you need them and close down (and forget about) when you are done with your task. Dev environments become fully ephemeral.\n\nYou even can start switching between workspaces or open several workspaces on the same context - two for your feature, one for reviewing a PR/MR, one for a bug, one for another MR/PR.\n\nTry it out and open 3 workspaces on the same context (e.g. on main or on an issue). ü§ì\n\n__SPLIT_HERE__\nNext Steps\n\nYou&#39;ve successfully ran your first workspace and experienced first hand what we mean with ephemeral dev environments. This is just the first step on your journey towards being always ready to code. Helpful resources from here are:\n\nGetting started with your own project\nGit Integrations","metadata":{"source":"https://gitpod.io/docs/introduction/getting-started/quickstart/wasp"}}],["722",{"pageContent":"__SPLIT_HERE__\nWordpress Quickstart\n\nLearn how to set-up and understand the benefits of Gitpod in less than 5 min with our Wordpress template.\n\nThe following guide will:\n\nWalk you through a real world example with an existing Gitpod config\nIntroduce you to prebuilds\nDemonstrate the benefits of ephemeral developer environments\n\nFor simplicity we use a GitHub template, but Gitpod works similarly with GitLab and Bitbucket.\n\nStep 1: Clone Git repository\n\nCreate a new repository based on the Wordpress template.\nName it e.g. my-wordpress-template.\n\nStep 2: Install Gitpod app\n\nInstall the Gitpod App.\n\nGitpod&#39;s GitHub app is similar to a CI server and will continuously prepare prebuilds for all your branches and pull requests - so you don&#39;t have to wait for installation of dependencies from the internet when you want to start coding.\n\nStep 3: First prebuild\n\nStart your first workspace with a prebuild by prefixing https://gitpod.io#prebuild/ to the URL of the repository.\n\nThe revised URL is: https://gitpod.io/#prebuild/https://github.com/&lt;github_username&gt;/my-wordpress-template\n\nGitpod displays the prebuild progress status by running the init commands in the .gitpod.yml file before you even start a workspace. Later, when you create a new workspace on a branch, or pull/merge request the workspace loads much faster, because all dependencies are already downloaded and the code is compiled. For more information see prebuilds.\n\nStep 4: Enjoy being ready-to-code ü§ô\n\nOnce the first prebuild ran, Gitpod starts an automated and fully configured developer environment in a workspace that is now ready for you to develop.\n\nOther developers made their setup even more productive and supercharged their workflows with the following quick steps:\n\nInstalling the browser extension\n\nYou can install the Gitpod browser extension on any Chromium-based browsers such as Microsoft Edge, Brave, Chrome, and others, or on a Firefox browser.\n\nThe extension simply adds a Gitpod button on every project and branch across GitHub, and Bitbucket that prefixes the URL with gitpod.io/# so that you can easily open a new workspace from any Git context.\n\nBrowser Extension\n\nIf you prefer to not install browser extensions then you can use the Gitpod browser bookmarklet instead.\n\nFor our partner GitLab we have a native integration into their UI that you can enable here.\n\nAdd your favorite VS Code themes and extensions\n\nYou have access to all Visual Studio Code extensions published under the vendor neutral Open VSX registry. Install one by clicking the Extensions icon in the left sidebar and enter your favorite theme or VS Code extension.\n\nChanges you make in your workspace such as themes and extensions are synced automatically to other workspaces.\n\nStart throwing away workspaces like paper towels\n\nYou can now start to treat dev environments as automated resources you spin up when you need them and close down (and forget about) when you are done with your task. Dev environments become fully ephemeral.\n\nYou even can start switching between workspaces or open several workspaces on the same context - two for your feature, one for reviewing a PR/MR, one for a bug, one for another MR/PR.\n\nTry it out and open 3 workspaces on the same context (e.g. on main or on an issue). ü§ì\n\n__SPLIT_HERE__\nNext Steps\n\nYou&#39;ve successfully ran your first workspace and experienced first hand what we mean with ephemeral dev environments. This is just the first step on your journey towards being always ready to code. Helpful resources from here are:\n\nGetting started with your own project\nGit Integrations","metadata":{"source":"https://gitpod.io/docs/introduction/getting-started/quickstart/wordpress"}}],["723",{"pageContent":"__SPLIT_HERE__\nX11 VNC Quickstart\n\nLearn how to set-up and understand the benefits of Gitpod in less than 5 min with our X11 VNC template.\n\nThe following guide will:\n\nWalk you through a real world example with an existing Gitpod config\nIntroduce you to prebuilds\nDemonstrate the benefits of ephemeral developer environments\n\nFor simplicity we use a GitHub template, but Gitpod works similarly with GitLab and Bitbucket.\n\nStep 1: Clone Git repository\n\nCreate a new repository based on the X11 VNC template.\nName it e.g. my-x11-vnc-template.\n\nStep 2: Install Gitpod app\n\nInstall the Gitpod App.\n\nGitpod&#39;s GitHub app is similar to a CI server and will continuously prepare prebuilds for all your branches and pull requests - so you don&#39;t have to wait for installation of dependencies from the internet when you want to start coding.\n\nStep 3: First prebuild\n\nStart your first workspace with a prebuild by prefixing https://gitpod.io#prebuild/ to the URL of the repository.\n\nThe revised URL is: https://gitpod.io/#prebuild/https://github.com/&lt;github_username&gt;/my-x11-vnc-template\n\nGitpod displays the prebuild progress status by running the init commands in the .gitpod.yml file before you even start a workspace. Later, when you create a new workspace on a branch, or pull/merge request the workspace loads much faster, because all dependencies are already downloaded and the code is compiled. For more information see prebuilds.\n\nStep 4: Enjoy being ready-to-code ü§ô\n\nOnce the first prebuild ran, Gitpod starts an automated and fully configured developer environment in a workspace that is now ready for you to develop.\n\nOther developers made their setup even more productive and supercharged their workflows with the following quick steps:\n\nInstalling the browser extension\n\nYou can install the Gitpod browser extension on any Chromium-based browsers such as Microsoft Edge, Brave, Chrome, and others, or on a Firefox browser.\n\nThe extension simply adds a Gitpod button on every project and branch across GitHub, and Bitbucket that prefixes the URL with gitpod.io/# so that you can easily open a new workspace from any Git context.\n\nBrowser Extension\n\nIf you prefer to not install browser extensions then you can use the Gitpod browser bookmarklet instead.\n\nFor our partner GitLab we have a native integration into their UI that you can enable here.\n\nAdd your favorite VS Code themes and extensions\n\nYou have access to all Visual Studio Code extensions published under the vendor neutral Open VSX registry. Install one by clicking the Extensions icon in the left sidebar and enter your favorite theme or VS Code extension.\n\nChanges you make in your workspace such as themes and extensions are synced automatically to other workspaces.\n\nStart throwing away workspaces like paper towels\n\nYou can now start to treat dev environments as automated resources you spin up when you need them and close down (and forget about) when you are done with your task. Dev environments become fully ephemeral.\n\nYou even can start switching between workspaces or open several workspaces on the same context - two for your feature, one for reviewing a PR/MR, one for a bug, one for another MR/PR.\n\nTry it out and open 3 workspaces on the same context (e.g. on main or on an issue). ü§ì\n\n__SPLIT_HERE__\nNext Steps\n\nYou&#39;ve successfully ran your first workspace and experienced first hand what we mean with ephemeral dev environments. This is just the first step on your journey towards being always ready to code. Helpful resources from here are:\n\nGetting started with your own project\nGit Integrations","metadata":{"source":"https://gitpod.io/docs/introduction/getting-started/quickstart/x11-vnc"}}],["724",{"pageContent":"__SPLIT_HERE__\nYasm Quickstart\n\nLearn how to set-up and understand the benefits of Gitpod in less than 5 min with our Yasm template.\n\nThe following guide will:\n\nWalk you through a real world example with an existing Gitpod config\nIntroduce you to prebuilds\nDemonstrate the benefits of ephemeral development environments\n\nFor simplicity we use a GitHub template, but Gitpod works similarly with GitLab and Bitbucket.\n\n__SPLIT_HERE__\nStep 1: Clone Git repository\n\nCreate a new repository based on the C template.\nName it e.g. my-yasm-template.\n\n__SPLIT_HERE__\nStep 2: Install Gitpod app\n\nInstall the Gitpod App.\n\nGitpod&#39;s GitHub app is similar to a CI server and will continuously prepare prebuilds for all your branches and pull requests - so you don&#39;t have to wait for installation of dependencies from the internet when you want to start coding.\n\n__SPLIT_HERE__\nStep 3: First prebuild\n\nStart your first workspace with a prebuild by prefixing https://gitpod.io#prebuild/ to the URL of the repository.\n\nThe revised URL is: https://gitpod.io/#prebuild/https://github.com/&lt;github_username&gt;/my-yasm-template\n\nGitpod displays the prebuild progress status by running the init commands in the .gitpod.yml file before you even start a workspace. Later, when you create a new workspace on a branch, or pull/merge request the workspace loads much faster, because all dependencies are already downloaded and the code is compiled. For more information see prebuilds.\n\n__SPLIT_HERE__\nStep 4: Enjoy being ready-to-code ü§ô\n\nOnce the first prebuild ran, Gitpod starts an automated and fully configured development environment in a workspace that is now ready for you to develop.\n\nOther developers made their setup even more productive and supercharged their workflows with the following quick steps:\n\nInstalling the browser extension\n\nYou can install the Gitpod browser extension on any Chromium-based browsers such as Microsoft Edge, Brave, Chrome, and others, or on a Firefox browser.\n\nThe extension simply adds a Gitpod button on every project and branch across GitHub, and Bitbucket that prefixes the URL with gitpod.io/# so that you can easily open a new workspace from any Git context.\n\nBrowser Extension\n\nIf you prefer to not install browser extensions then you can use the Gitpod browser bookmarklet instead.\n\nFor our partner GitLab we have a native integration into their UI that you can enable here.\n\nAdd your favorite VS Code themes and extensions\n\nYou have access to all Visual Studio Code extensions published under the vendor neutral Open VSX registry. Install one by clicking the Extensions icon in the left sidebar and enter your favorite theme or VS Code extension.\n\nChanges you make in your workspace such as themes and extensions are synced automatically to other workspaces.\n\nStart throwing away workspaces like paper towels\n\nYou can now start to treat dev environments as automated resources you spin up when you need them and close down (and forget about) when you are done with your task. Dev environments become fully ephemeral.\n\nYou even can start switching between workspaces or open several workspaces on the same context - two for your feature, one for reviewing a PR/MR, one for a bug, one for another MR/PR.\n\nTry it out and open 3 workspaces on the same context (e.g. on main or on an issue). ü§ì\n\n__SPLIT_HERE__\nNext Steps\n\nYou&#39;ve successfully ran your first workspace and experienced first hand what we mean with ephemeral dev environments. This is just the first step on your journey towards being always ready to code. Helpful resources from here are:\n\nGetting started with your own project\nGit Integrations","metadata":{"source":"https://gitpod.io/docs/introduction/getting-started/quickstart/yasm"}}],["725",{"pageContent":"__SPLIT_HERE__\nInstall Gitpod in an Air Gapped Network\n\n‚ö†Ô∏è Self-hosted as a product is no longer supported\n\nThe last official update of this product is the November 2022 self-hosted release. We no longer sell commercial self-hosted licenses. If you want to self-host Gitpod, you can still request our free community license. However, we no longer offer support or updates for it. If you are interested in an isolated, private installation of Gitpod, take a look at Gitpod Dedicated.\nRead our blog on Gitpod Dedicated to learn why we made the decision to discontinue self-hosted.\n\nNote: Installing Gitpod in an air gapped network is a feature limited to our Professional Plan. We support air-gap mode for paying customers only.\n\nIn this guide, we expect you to have a cluster up and running that meets the requirements and have the required components installed and configured (at least cert-manager is needed).\n\n__SPLIT_HERE__\nPreparation\n\nBefore you can start with the installation, you need to prepare the following:\n\nYou need to have a Docker registry available in your network where you can push images to and where your Kubernetes cluster can pull images from.\nYou need to download installation bundles.\n\nWe provide you with a URL and password to a download portal. There you will find the following bundles that you need to download:\n\nKOTS CLI package kots_linux_amd64.tar.gz  (provides you with the kubectl kots CLI binary)\nKOTS Airgap Bundle kotsadm.tar.gz  (provides you with the Docker images you need for the Gitpod KOTS installer)\nGitpod Airgap Bundle gitpod-&lt;version&gt;.airgap  (provides you with the Gitpod Docker images)\n\nkots-airgap-download\n\nCopy the KOTS CLI package as well as the KOTS Airgap Bundle to the machine where you are able to run kubectl.\n\n__SPLIT_HERE__\nInstall KOTS CLI\n\nUnpack the KOTS CLI package kots_linux_amd64.tar.gz, rename the binary kots to kubectl-kots, and copy it to /usr/local/bin/ (or to any other folder that is in your PATH).\n\nNow, you should be able to run the following command:\n\n```shell\n$ kubectl kots help\n```","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/advanced/air-gap"}}],["726",{"pageContent":"Install Gitpod\n\nAt first, you need to push the images that are needed for the installation admin console to your registry.\n\n```bash\n$ kubectl kots admin-console push-images \\\n    ./kotsadm.tar.gz \\\n    <registry> \\\n    --registry-username <username> \\\n    --registry-password <password>\n```\n\nReplace the following placeholder:\n\nPlaceholder\n&lt;registry&gt; The registry URI in the form &lt;host&gt;:&lt;port&gt;/&lt;namespace&gt;, e.g. my-registry.example.com:443/gitpod.\n&lt;username&gt; The username for the registry that has write access (is allowed to push).\n&lt;password&gt; The password to the username.\n\nNext, you can start installing Gitpod like this:\n\n```bash\n$ kubectl kots install gitpod \\\n    --kotsadm-namespace <namespace> \\\n    --kotsadm-registry <registry> \\\n    --registry-username <username> \\\n    --registry-password <password>\n```\n\nReplace the following placeholder:\n\nPlaceholder\n&lt;namespace&gt; Namespace that is used in the registry URI above.\n&lt;registry&gt; The hostname of your registry, e.g. my-registry.example.com:443.\n&lt;username&gt; The username for the registry that has read access (is allowed to pull).\n&lt;password&gt; The password to the username.\n\nYou will be asked for the namespace you want to install Gitpod to as well as a password for the admin console. After some time, you will see the following output:\n\n```\n  ‚Ä¢ Press Ctrl+C to exit\n  ‚Ä¢ Go to http://localhost:8800 to access the Admin Console\n```\n\nOpen your favorite browser and go to http://localhost:8800 (port 8800 is opened on your node on localhost only--you may want to forward the port to your workstation in order to access the admin console).\n\nNow, you will be asked for the password and the license. On the next page, you have to set:\n\nthe hostname of your registry (e.g. my-registry.example.com:443),\nusername and password (read access), as well as\nthe namespace that you used in the registry URI above (e.g. gitpod).\n\nClick on ‚Äúchoose a bundle to upload‚Äù and select your gitpod-&lt;version&gt;.airgap file on your local computer. Then hit the ‚ÄúUpload airgap bundle‚Äù button.\n\nkots-airgap-upload\n\nUploading this file and pushing the images to your registry will take a while (could take several hours depending on your internet connection). Grab a cup of coffee or tea and wait for it to be ready. ‚òï\n\nOnce the images has been pushed to your registry, you can continue to install Gitpod as described in the installation guide. Happy coding!","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/advanced/air-gap"}}],["727",{"pageContent":"__SPLIT_HERE__\nComponent Customization\n\n‚ö†Ô∏è Self-hosted as a product is no longer supported\n\nThe last official update of this product is the November 2022 self-hosted release. We no longer sell commercial self-hosted licenses. If you want to self-host Gitpod, you can still request our free community license. However, we no longer offer support or updates for it. If you are interested in an isolated, private installation of Gitpod, take a look at Gitpod Dedicated.\nRead our blog on Gitpod Dedicated to learn why we made the decision to discontinue self-hosted.\n\nIn this guide, we expect you to have a cluster up and running that meets the requirements and has the required components installed and configured (at least cert-manager is needed).\n\nThis guide assumes that you are using our default installation method from our installation guide.\n\n__SPLIT_HERE__\nRationale\n\nGitpod self-hosted is built to work by default, but it also has to be incredibly flexible. Our installation defaults will work for the vast majority of users, but there will be occassions when it does not. In order to add more flexibility, you have the ability to customise some of Gitpod&#39;s components.\n\nIn your KOTS dashboard, you will need to enable advanced options. This will enable the &quot;Components&quot; section.\n\nkots-advanced\n\nProxy service type\n\nAll web traffic enters the application through the Proxy component. By default, this is a LoadBalancer type which will expose the application through the cloud provider&#39;s load balancer.\n\nUnder certain circumstances, this may be undesirable. Under the &quot;Advanced&quot; section, you may select a different service type - all Kubernetes service types are supported, except ExternalName. If you are using anything other than LoadBalancer, you are responsible for configuring your network to route traffic through to the proxy service.","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/advanced/components"}}],["728",{"pageContent":"__SPLIT_HERE__\nSetting an installation-wide default workspace image\n\n‚ö†Ô∏è Self-hosted as a product is no longer supported\n\nThe last official update of this product is the November 2022 self-hosted release. We no longer sell commercial self-hosted licenses. If you want to self-host Gitpod, you can still request our free community license. However, we no longer offer support or updates for it. If you are interested in an isolated, private installation of Gitpod, take a look at Gitpod Dedicated.\nRead our blog on Gitpod Dedicated to learn why we made the decision to discontinue self-hosted.\n\nThis guide describes how to set a default workspace image that will apply to your entire Gitpod Self-Hosted installation. Please refer to the Docker image documentation for more information about workspace images.\n\nNote: there are two ways of setting an image for a workspace: via the installation-wide default workspaceImage (mentioned here) and the .gitpod.yml file. The .gitpod.yml file will take precedence if both are set.\n\n__SPLIT_HERE__\nSetting a default workspace image\n\nNote: this will apply to your entire installation. If you are using a private registry for your image, please ensure you add it to the allow list and provide credentials for it - for guidance, see using private registries.\n\nCurrently, the default workspace image can only be set via the config patch. In the future, we plan to also allow you to set this via the installation UI.\n\n```yaml\nworkspace:\n  workspaceImage: string\n```","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/advanced/default-workspace-image"}}],["729",{"pageContent":"__SPLIT_HERE__\nSetting up your EKS cluster with dual ALB + NLB load balancers\n\n‚ö†Ô∏è Self-hosted as a product is no longer supported\n\nThe last official update of this product is the November 2022 self-hosted release. We no longer sell commercial self-hosted licenses. If you want to self-host Gitpod, you can still request our free community license. However, we no longer offer support or updates for it. If you are interested in an isolated, private installation of Gitpod, take a look at Gitpod Dedicated.\nRead our blog on Gitpod Dedicated to learn why we made the decision to discontinue self-hosted.\n\nIf you are unable to use an AWS classic load balancer (CLB) (e.g. because you want to use SSL Certificates generated by AWS) you need to set up an Application Load Balancer (ALB) for HTTPS traffic (e.g. when using VS Code in the browser). If you wish to use Desktop IDEs together with Gitpod Self-Hosted, which use SSH for networking, and thus require a Level 4 load balancer, you also need to create a Network Load balancer (NLB) (which is a Level 4 load balancer that can handle ssh traffic). AWS&#39; ALB is a level 7 load balancer and can only handle HTTPS traffic.\n\nThis guide shows how to install both an ALB and an NLB into an EKS cluster. It is meant to be used as a supplement to the Single Cluster Reference Architecture (AWS) which only installs a CLB by default. You will configure your DNS to point ssh traffic to the NLB and HTTPS traffic to the ALB.\n\nNote: This guide assumes that you will be using AWS to manage your SSL certificates.","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/advanced/eks-with-alb-and-nlb"}}],["730",{"pageContent":"Setting up an ALB and NLB\n\n0. Node configuration\n\nBecause we need to use an internal CA for communication that has to be distributed to the nodes, we need to ensure all managed nodes have /etc/containerd/certs.d in their /etc/containerd/config.toml to load the self-signed certificate used for internal communication.\n\n```toml\n[plugins.\"io.containerd.grpc.v1.cri\".registry]\n  config_path = \"/etc/containerd/certs.d\"\n```\n\nThese are two examples to enforce this:\n\nUse python to insert the values into the toml file respecting the formatting:\n\n```shell\napt-get update && apt-get install -y python3-pip\npip3 install toml mergedeep\n/usr/bin/env python3 - << EOF > /var/log/update-containerd-config-out.txt 2>&1\nimport toml\nfrom mergedeep import merge\nc = toml.load('/etc/containerd/config.toml')\nmerge(c, {'plugins': {'io.containerd.grpc.v1.cri': {'registry': {'config_path': '/etc/containerd/certs.d'}}}})\nwith open('/etc/containerd/config.toml', 'w') as f:\n  toml.dump(c, f)\nEOF\nservice containerd restart\n```","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/advanced/eks-with-alb-and-nlb"}}],["731",{"pageContent":"Bruteforce method that will just append the lines to /etc/containerd/config.toml which will work if there are no other registry settings present in your config.toml file\n\n```\ncat << CONFIG >> /etc/containerd/config.toml\n\n[plugins.\"io.containerd.grpc.v1.cri\".registry]\nconfig_path = \"/etc/containerd/certs.d\"\n\nCONFIG\n\nservice containerd restart\n```\n\n```yaml\noverrideBootstrapCommand: |\n  #!/bin/bash\n  set -x\n  export CLUSTERNAME=gitpod\n  export NODEGROUP=services\n  export CONTAINER_RUNTIME=containerd\n  declare -a LABELS=(\n  eks.amazonaws.com/nodegroup=\"${NODEGROUP}\"\n      gitpod.io/workload_meta=true\n      gitpod.io/workload_ide=true\n    )\n    export USE_MAX_PODS=false\n    export KUBELET_EXTRA_ARGS=\"$(printf -- \"--node-labels=%s\" $(IFS=$','; echo \"${LABELS[*]}\"))\"\n  /etc/eks/bootstrap.sh ${CLUSTERNAME} --use-max-pods false\n\n  # Update containerd config while waiting on https://github.com/gitpod-io/gitpod/issues/11005","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/advanced/eks-with-alb-and-nlb"}}],["732",{"pageContent":"# Update containerd config while waiting on https://github.com/gitpod-io/gitpod/issues/11005\n\n  apt-get update && apt-get install -y python3-pip\n  pip3 install toml mergedeep\n  /usr/bin/env python3 - << EOF > /var/log/update-containerd-config-out.txt 2>&1\n  import toml\n  from mergedeep import merge\n  c = toml.load('/etc/containerd/config.toml')\n  merge(c, {'plugins': {'io.containerd.grpc.v1.cri': {'registry': {'config_path': '/etc/containerd/certs.d'}}}})\n  with open('/etc/containerd/config.toml', 'w') as f:\n    toml.dump(c, f)\n  EOF\n  service containerd restart\n```\n\n1. Install AWS load balancer controller\n\nInstall the AWS load balancer controller. The below example assumes you have created the user aws-load-balancer-controller with the correct IAM permissions already. --set hostNetwork=true is required by Calico.","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/advanced/eks-with-alb-and-nlb"}}],["733",{"pageContent":"```shell\nhelm repo add eks https://aws.github.io/eks-charts\nhelm repo update\nhelm upgrade aws-load-balancer-controller \\\n    eks/aws-load-balancer-controller \\\n    --atomic \\\n    --cleanup-on-fail \\\n    --install \\\n    --reset-values \\\n    --namespace kube-system \\\n    --set clusterName=<insert cluster name> \\\n    --set serviceAccount.create=false \\\n    --set serviceAccount.name=aws-load-balancer-controller \\\n    --set hostNetwork=true\n```\n\n2. Install Gitpod\n\nEnsure that you&#39;ve created all the required components as per the reference architecture guide: Object Storage, OCI Image Registry, Database. Then install Gitpod. While configuring your Gitpod installation, make sure to check &#39;use self-signed certificate&#39;. Make sure that you select node port as the service type for the proxy service in the components section of the installation UI (this assumes you are using version 2022.07 or later):\n\nproxy service type","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/advanced/eks-with-alb-and-nlb"}}],["734",{"pageContent":"proxy service type\n\nYou will also need to make sure that the &quot;allow login via SSH&quot; box is ticked:\n\nssh gateway\n\n3. Create alb-ingresss.yaml\n\nUpdate the alb-ingress.yaml below with your site-specific options (you need to customize anything tagged with &lt;..&gt;):\n\nalb-ingress.yaml","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/advanced/eks-with-alb-and-nlb"}}],["735",{"pageContent":"```yaml\n---\napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  annotations:\n    kubernetes.io/ingress.class: alb\n    alb.ingress.kubernetes.io/actions.ssl-redirect: |-\n      {\n        \"Type\": \"redirect\",\n        \"RedirectConfig\": {\n          \"Protocol\": \"HTTPS\",\n          \"Port\": \"443\",\n          \"StatusCode\": \"HTTP_301\"\n        }\n      }\n    alb.ingress.kubernetes.io/backend-protocol: HTTPS\n    alb.ingress.kubernetes.io/healthcheck-protocol: HTTPS\n    alb.ingress.kubernetes.io/listen-ports: |-\n      [{\n        \"HTTP\": 80\n      }, {\n        \"HTTPS\": 443\n      }]\n    alb.ingress.kubernetes.io/load-balancer-attributes: idle_timeout.timeout_seconds=3600\n    alb.ingress.kubernetes.io/tags: Purpose=Gitpod,Service=proxy\n    alb.ingress.kubernetes.io/target-group-attributes: deregistration_delay.timeout_seconds=30\n    alb.ingress.kubernetes.io/target-node-labels: gitpod.io/workload_meta=true\n    alb.ingress.kubernetes.io/target-type: instance","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/advanced/eks-with-alb-and-nlb"}}],["736",{"pageContent":"alb.ingress.kubernetes.io/target-node-labels: gitpod.io/workload_meta=true\n    alb.ingress.kubernetes.io/target-type: instance\n    alb.ingress.kubernetes.io/ssl-policy: ELBSecurityPolicy-FS-1-2-Res-2020-10\n    alb.ingress.kubernetes.io/certificate-arn: <YOUR-AWS-SSL-PROVIDED_CERTIFICATE>\n    alb.ingress.kubernetes.io/scheme: <SET THIS -> internet-facing or internal>\n    alb.ingress.kubernetes.io/load-balancer-name: <GITPOD-LOAD-BALANCER-NAME>\n  name: gitpod\nspec:\n  defaultBackend:\n    service:\n      name: proxy\n      port:\n        number: 80\n  rules:\n    - http:\n        paths:\n          - backend:\n              service:\n                name: proxy\n                port:\n                  number: 443\n            path: /\n            pathType: Prefix\n```","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/advanced/eks-with-alb-and-nlb"}}],["737",{"pageContent":"4. Install ALB and NLB\n\nInstall the ALB (for HTTPS traffic) and NLB (for SSH traffic) using the .yaml file customized above as well as this one:\n\nnlb-ssh-service.yaml","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/advanced/eks-with-alb-and-nlb"}}],["738",{"pageContent":"```yaml\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: gitpod-ssh\n  labels:\n    app: gitpod\n    component: ws-proxy-ssh\n  annotations:\n    service.beta.kubernetes.io/aws-load-balancer-name: gitpod-ssh-gateway\n    service.beta.kubernetes.io/aws-load-balancer-type: external\n    service.beta.kubernetes.io/aws-load-balancer-nlb-target-type: \"instance\"\n    service.beta.kubernetes.io/aws-load-balancer-ip-address-type: ipv4\n    service.beta.kubernetes.io/aws-load-balancer-backend-protocol: tcp\n    service.beta.kubernetes.io/aws-load-balancer-target-node-labels: gitpod.io/workload_workspace_services=true\n    service.beta.kubernetes.io/aws-load-balancer-target-group-attributes: stickiness.enabled=true,stickiness.type=source_ip,preserve_client_ip.enabled=true\n    service.beta.kubernetes.io/aws-load-balancer-additional-resource-tags: Project=gitpod-alb\nspec:\n  ports:\n    - name: ssh\n      protocol: TCP\n      port: 22\n      targetPort: 2200\n  selector:\n    app: gitpod\n    component: ws-proxy\n  type: LoadBalancer\n```","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/advanced/eks-with-alb-and-nlb"}}],["739",{"pageContent":"```\nkubectl apply -f alb-ingress.yaml\nkubectl apply -f nlb-ssh-service.yaml\n```\n\n5. Check if installed properly\n\nIf installed properly, then this should be the shell output given the command below:\n\n```bash\n> kubectl get ingress gitpod -n gitpod\nNAME     CLASS    HOSTS   ADDRESS                                                   PORTS   AGE\ngitpod   <none>   *       gitpod-airgap-alb-339697413.eu-west-1.elb.amazonaws.com   80      41s\n\n> kubectl get service gitpod-ssh -n gitpod\nNAME         TYPE           CLUSTER-IP       EXTERNAL-IP                                                       PORT(S)        AGE\ngitpod-ssh   LoadBalancer   172.20.162.102   gitpod-ssh-gateway-6588d186387780e5.elb.eu-west-1.amazonaws.com   22:30003/TCP   76s\n```\n\n6. Update DNS records\n\nUpdate DNS as follows to point to your newly created loadbalancers depending on the type of traffic:\n\n```\ngitpod.domain.com           --> ALB ADDRESS\n*.gitpod.domain.com         --> ALB ADDRESS\n*.ssh.ws.gitpod.domain.com  --> NLB ADDRESS\n```","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/advanced/eks-with-alb-and-nlb"}}],["740",{"pageContent":"__SPLIT_HERE__\nAdvanced Installation of Gitpod Self-Hosted\n\n‚ö†Ô∏è Self-hosted as a product is no longer supported\n\nThe last official update of this product is the November 2022 self-hosted release. We no longer sell commercial self-hosted licenses. If you want to self-host Gitpod, you can still request our free community license. However, we no longer offer support or updates for it. If you are interested in an isolated, private installation of Gitpod, take a look at Gitpod Dedicated.\nRead our blog on Gitpod Dedicated to learn why we made the decision to discontinue self-hosted.\n\nHere you can find advanced topics related to installing Gitpod:\n\nTLS configuration for Gitpod Self-Hosted\nInstall Gitpod on an Air Gapped Network\nConfiguring popular container registries\nSetting a default workspace image\nUsing private image registries with Gitpod Self-Hosted\nSetting up your EKS cluster with dual ALB + NLB load balancers\nApplying custom annotations, labels and environment variables\nComponent Customization","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/advanced/index"}}],["741",{"pageContent":"__SPLIT_HERE__\nUsing private image registries with Gitpod Self-Hosted\n\n‚ö†Ô∏è Self-hosted as a product is no longer supported\n\nThe last official update of this product is the November 2022 self-hosted release. We no longer sell commercial self-hosted licenses. If you want to self-host Gitpod, you can still request our free community license. However, we no longer offer support or updates for it. If you are interested in an isolated, private installation of Gitpod, take a look at Gitpod Dedicated.\nRead our blog on Gitpod Dedicated to learn why we made the decision to discontinue self-hosted.\n\nThis guide outlines the considerations to take when using images for workspaces that originate from private image registries that are not stored in the image registry already configured in the KOTS Installation UI. This is useful when, for example, you want to pull private base images from one registry and then store the built images in another.\n\nPlease refer to the Docker image documentation for more information about workspace images.\n\nNote: there are two ways of setting an image for a workspace: via the installation-wide default workspaceImage and the .gitpod.yml file. The .gitpod.yml file will take precedence if both are set.\n\n__SPLIT_HERE__\nCredentials\n\nTo access private registries, Gitpod needs to have the corresponding access credentials. These can be supplied in the KOTS installation UI:\n\nregistry credentials UI\n\n__SPLIT_HERE__\nAllowlist\n\nGitpod also has an allow list for private base image registries. Any private image registry that is used throughout an installation needs to be on this allowlist.\n\nImportant: Any registry for which credentials are supplied is automatically added to this allowlist!\n\nRegistries can be added to the allowlist via the config patch in the following format:\n\n```yaml\ncontainerRegistry:\n  privateBaseImageAllowList:\n    - <your_registry-url.com>\n    - <another_registry-url.com>\n```","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/advanced/private-registries"}}],["742",{"pageContent":"__SPLIT_HERE__\nTLS configuration for Gitpod Self-Hosted\n\n‚ö†Ô∏è Self-hosted as a product is no longer supported\n\nThe last official update of this product is the November 2022 self-hosted release. We no longer sell commercial self-hosted licenses. If you want to self-host Gitpod, you can still request our free community license. However, we no longer offer support or updates for it. If you are interested in an isolated, private installation of Gitpod, take a look at Gitpod Dedicated.\nRead our blog on Gitpod Dedicated to learn why we made the decision to discontinue self-hosted.\n\nTo run your own Gitpod instance, you need a TLS certificate for your Gitpod domain. There are three options to provide these TLS certificates.\n\n__SPLIT_HERE__\nOption 1: Cert-Manager\n\nConfigure cert-manager to issue these certificates (usually with a DNS-01 challenge and services like Let&#39;s encrypt). See the installation guide) for more information.\n\nkots-tls-cert-manager\n\n__SPLIT_HERE__\nOption 2: Self-signed by Gitpod\n\nWe usually do not recommend this option for production usage.\n\nLet Gitpod generate self-signed certificates for your installation. This option can be used in case your load balancer does the TLS termination or for testing settings. For the latter case, you need to add the custom CA to your browser to let it accept the self-signed certificate. Use this command to export the CA:\n\n```\n$ kubectl get secrets -n <namespace> ca-issuer-ca -o jsonpath='{.data.ca\\.crt}' | base64 -d > ~/ca.crt\n```\n\nkots-tls-self-signed\n\n__SPLIT_HERE__\nOption 3: Bring your own certificate\n\n‚ö†Ô∏è Limitation\n\nAdding custom CA certificates is currently not supported on Google Kubernetes Engine (GKE) because on GKE containerd does not support custom certificates.\n\nUpload your own TLS certificate, key, and (optionally) CA certificate. When your TLS certificate is signed by a publicly accepted TLS authority, you just need to upload your certificate and key. In case it is a self-signed certificate (e.g. signed by a corporate CA), you also need to upload your CA.\n\nkots-tls-bring-own","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/advanced/tls"}}],["743",{"pageContent":"__SPLIT_HERE__\nApplying custom annotations, labels and environment variables\n\n‚ö†Ô∏è Self-hosted as a product is no longer supported\n\nThe last official update of this product is the November 2022 self-hosted release. We no longer sell commercial self-hosted licenses. If you want to self-host Gitpod, you can still request our free community license. However, we no longer offer support or updates for it. If you are interested in an isolated, private installation of Gitpod, take a look at Gitpod Dedicated.\nRead our blog on Gitpod Dedicated to learn why we made the decision to discontinue self-hosted.\n\nIn this guide, we expect you to have a cluster up and running that meets the requirements and has the required components installed and configured (at least cert-manager is needed).\n\nThis guide assumes that you are using our default installation method from our installation guide.\n\n__SPLIT_HERE__\nRationale\n\nThere are times when it is necessary to add custom annotations, environment variables and labels to your installation in order to add it to your environment. For example, one may need to support specific monitoring and observability software or want to target a specific load balancer type.\n\n__SPLIT_HERE__\nConfiguration\n\nBefore you start, you will need to create a YAML file that is subsequently used to describe your customizations. The structure is based upon the standard Kubernetes resource definition.\n\nOnce created, this file can be uploaded to the Installation Admin UI during installation under the advanced features section (bottom).\n\nkots-advanced-customization\n\nAnnotations and labels\n\nFor these to be applied to a resource, these must match the apiVersion, kind and metadata.name properties of the target resource. These accept any value that is valid as per the Kubernetes specifications and also an * as a wildcard.\n\nAny properties in metadata.annotations and metadata.labels are then applied to the matching resource(s). These are key/value maps, where both key and value are strings.\n\nIMPORTANT You cannot directly customize the properties on a Pod. Instead, these will inherit the annotation/label customization from its parent (Deployment, DaemonSet, StatefulSet, Job etc).\n\nEnvironment variables\n\nFor environment variables, these must match metadata.name. apiVersion and kind are ignored as these are only implemented on resources with containers.\n\nAny properties in spec.env are then applied. These should have a name and value as per the Kubernetes specification.","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/advanced/customization"}}],["744",{"pageContent":"Example Configuration\n\n```yaml\ncustomization:\n  - apiVersion: \"*\"\n    kind: \"*\"\n    metadata:\n      name: \"*\"\n      annotations:\n        appliedToAll: value\n        hello: world\n      labels:\n        appliedToAll: value\n        hello: world\n  - apiVersion: \"apps/v1\"\n    kind: \"Deployment\"\n    metadata:\n      name: \"ws-manager\"\n      annotations:\n        hello: ws-manager\n      labels:\n        hello: ws-manager\n    spec:\n      env:\n        - name: HELLO\n          value: world\n```\n\nThis example would generate the following spec (these are simplified for readability reasons):\n\n```yaml\n---\n# apps/v1/DaemonSet ws-daemon\napiVersion: apps/v1\nkind: DaemonSet\nmetadata:\n  labels:\n    app: gitpod # system-value\n    component: ws-daemon # system-value\n    appliedToAll: value\n    hello: world\n  annotations:\n    appliedToAll: value\n    hello: world\n  name: ws-daemon\n---\n# apps/v1/Deployment ws-manager\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  labels:\n    app: gitpod\n    component: ws-manager\n    appliedToAll: value\n    hello: ws-manager\n  annotations:\n    appliedToAll: value\n    hello: ws-manager\n  name: ws-manager\nspec:\n  template:\n    # The custom annotations/labels are inherited from the Deployment spec\n    metadata:\n      annotations:\n        appliedToAll: value\n        gitpod.io/checksum_config: xxxx\n        hello: ws-manager\n      labels:\n        app: gitpod\n        component: ws-manager\n        appliedToAll: value\n        hello: ws-manager\n      name: ws-manager\n    spec:\n      containers:\n        - env:\n            - name: HELLO\n              value: world\n```\n\nIn the event of multiple matches, the final matching customization is applied. Therefore, it is a good idea to structure your customization from least to most specific.\n\nImportant: System-generated values will never be overridden.\n\n__SPLIT_HERE__\nAWS Proxy Service Example\n\nThis is an example configuration for working with AWS Load Balancer Controllers of the Network Load Balancer variety, when deployed in AWS EKS. This example creates a load balancer with a public IP, references two subnets: [subnet-012e8ff1de0654321,subnet-0a6d28629bc123456], tunes timeouts, and ensures the tags project:gitpod-docs and team:cs are applied to the AWS resources it creates.\n\n```yaml\n---\ncustomization:\n  - apiVersion: \"*\"\n    kind: \"Service\"\n    metadata:\n      name: \"proxy\"\n      annotations:\n        service.beta.kubernetes.io/aws-load-balancer-scheme: \"internet-facing\"\n        service.beta.kubernetes.io/aws-load-balancer-nlb-target-type: \"instance\"\n        service.beta.kubernetes.io/aws-load-balancer-subnets: \"subnet-012e8ff1de0654321,subnet-0a6d28629bc123456\"\n        alb.ingress.kubernetes.io/load-balancer-attributes: \"idle_timeout.timeout_seconds=3600\"\n        service.beta.kubernetes.io/aws-load-balancer-additional-resource-tags: \"project=gitpod-docs,team=cs\"\n```\n\n__SPLIT_HERE__\nLimitations\n\nThis limitation has been removed as of 2022.08.0.\n\nLabels are immutable on some Kubernetes resources, such as Deployments, DaemonSets and StatefulSets.\n\nIf you wish to change a label on one of these resources, you must destroy that resource first. This can be achieved by running kubectl delete &lt;resource&gt; --namespace &lt;namespace&gt; &lt;name&gt; prior to running the KOTS deployment.\n\nIn the event of there being multiple resources that need to be amended, you can run helm uninstall --namespace &lt;namespace&gt; gitpod. If you are using an in-cluster database or object storage, you should not run this command without taking a backup of your persistent volumes first.\n\nWARNING: If deleting Kubernetes resources, your Gitpod instance is likely to become inaccessible and unstable. This should not be attempted while it is being used for normal development as data loss is likely.","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/advanced/customization"}}],["745",{"pageContent":"__SPLIT_HERE__\nHow To Configure Gitpod To Work With Certain External Components\n\n‚ö†Ô∏è Self-hosted as a product is no longer supported\n\nThe last official update of this product is the November 2022 self-hosted release. We no longer sell commercial self-hosted licenses. If you want to self-host Gitpod, you can still request our free community license. However, we no longer offer support or updates for it. If you are interested in an isolated, private installation of Gitpod, take a look at Gitpod Dedicated.\nRead our blog on Gitpod Dedicated to learn why we made the decision to discontinue self-hosted.\n\nGitpod has three resource dependencies that are required to function correctly. For convenience, you can use the in-cluster dependencies, but you should use external resources for a high-performance application.\n\nThis page highlights some of the common gotchas found when working with cloud resources and how to overcome them.\n\n__SPLIT_HERE__\nContainer Registry\n\nAmazon Elastic Container Registry (ECR)\n\nAmazon ECR does not fully implement the Docker v2 API, namely it does not automatically create the remote image if it does not already exist when pushed. For that reason, ECR is not supported with Gitpod.\n\nWhen using AWS, you should select an in-cluster registry and use S3 as your in-cluster storage provider. This will use the in-cluster registry as a facade for an S3 bucket where all the images will be stored.\n\nIf using a region other than us-east-1, you will need to change the endpoint to be s3.&lt;region&gt;.amazonaws.com.\n\nGoogle Container Registry (GCR)\n\nThis example uses the format gcr.io, which is the global hostnames. This can be swapped with any of the regional hostnames and it will work in the same way.\n\nGoogle Container Registry authentication requires specific configuration. The &quot;Container registry URL&quot; will be in a format similar to gcr.io/&lt;project-name&gt;/gitpod. In order for the authentication to work, you must also enter the &quot;Container registry server&quot;. This will always be your GCR hostname, eg gcr.io.\n\nGoogle Artifact Registry (GAR)\n\nAs with GCR, Google Artifact Registry requires both the &quot;Container registry URL&quot; and &quot;Container registry server&quot; to be completed. The URL will be in the format &lt;region&gt;-docker.pkg.dev/&lt;project-name&gt;/gitpod and the server address will be &lt;region&gt;-docker.pkg.dev.","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/advanced/resource-configuration"}}],["746",{"pageContent":"__SPLIT_HERE__\nHow to Create a Cluster on Amazon Elastic Kubernetes Service (EKS)\n\n‚ö†Ô∏è Self-hosted as a product is no longer supported\n\nThe last official update of this product is the November 2022 self-hosted release. We no longer sell commercial self-hosted licenses. If you want to self-host Gitpod, you can still request our free community license. However, we no longer offer support or updates for it. If you are interested in an isolated, private installation of Gitpod, take a look at Gitpod Dedicated.\nRead our blog on Gitpod Dedicated to learn why we made the decision to discontinue self-hosted.\n\nThis guide has been deprecated. Please use the Single Cluster Reference Architecture instead.","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/cluster-set-up/on-amazon-eks"}}],["747",{"pageContent":"__SPLIT_HERE__\nHow to Create a Cluster on Google Kubernetes Engine (GKE)\n\n‚ö†Ô∏è Self-hosted as a product is no longer supported\n\nThe last official update of this product is the November 2022 self-hosted release. We no longer sell commercial self-hosted licenses. If you want to self-host Gitpod, you can still request our free community license. However, we no longer offer support or updates for it. If you are interested in an isolated, private installation of Gitpod, take a look at Gitpod Dedicated.\nRead our blog on Gitpod Dedicated to learn why we made the decision to discontinue self-hosted.\n\nThis guide has been deprecated. Please use the Single Cluster Reference Architecture instead.","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/cluster-set-up/on-gke"}}],["748",{"pageContent":"__SPLIT_HERE__\nHow to Create a Cluster with K3s\n\n‚ö†Ô∏è Self-hosted as a product is no longer supported\n\nThe last official update of this product is the November 2022 self-hosted release. We no longer sell commercial self-hosted licenses. If you want to self-host Gitpod, you can still request our free community license. However, we no longer offer support or updates for it. If you are interested in an isolated, private installation of Gitpod, take a look at Gitpod Dedicated.\nRead our blog on Gitpod Dedicated to learn why we made the decision to discontinue self-hosted.\n\nIn this guide, we show you how to set up a Kubernetes cluster with K3s that is ready to install Gitpod. In this example we expect to have at least 2 nodes with Ubuntu 20.04 (a single node setup would work as well, see hint below):\n\nnode0: main node where the Gitpod service pods will be deployed to\nnode1: worker node where the Gitpod workspace pods will be deployed to\noptional: one or more additional worker nodes node2 ‚Ä¶ nodeN\n\nOn each node, we install K3s. We configure K3s by setting the following environment variables on the nodes.\n\nK3s config for main node node0:\n\n```shell\nexport INSTALL_K3S_EXEC=\"server --disable traefik --flannel-backend=none --node-label gitpod.io/workload_meta=true --node-label gitpod.io/workload_ide=true\"\nexport K3S_CLUSTER_SECRET=\"<your random secret string that is the same on all nodes>\"\n```\n\nK3s config for all other nodes:\n\n```shell\nexport INSTALL_K3S_EXEC=\"agent --node-label gitpod.io/workload_workspace_services=true --node-label gitpod.io/workload_workspace_regular=true --node-label gitpod.io/workload_workspace_headless=true\"\nexport K3S_CLUSTER_SECRET=\"<your random secret string that is the same on all nodes>\"\nexport K3S_URL=\"https://node0:6443\"\n```\n\nHint: In case you would like to set up a single node cluster (only the main node) add the --node-label arguments of the bottom &quot;other&quot; nodes config to the INSTALL_K3S_EXEC variable of the main node config.\n\nAfter setting the environment variables, install K3s on every node like this:\n\n```shell\n$ curl -sfL https://get.k3s.io | sh -\n```\n\nNow, you have to install Calico. Download the Calico manifest and add the following line to the plugins section of the cni_network_config:\n\n```json\n\"container_settings\": { \"allow_ip_forwarding\": true }\n```\n\nThe section in the calico-vxlan.yaml file should look like this:\n\n```json\n[...]\n  cni_network_config: |-\n    {\n      \"name\": \"k8s-pod-network\",\n      \"cniVersion\": \"0.3.1\",\n      \"plugins\": [\n        {\n          \"type\": \"calico\",\n          \"log_level\": \"info\",\n          \"log_file_path\": \"/var/log/calico/cni/cni.log\",\n          \"datastore_type\": \"kubernetes\",\n          \"nodename\": \"__KUBERNETES_NODE_NAME__\",\n          \"mtu\": __CNI_MTU__,\n          \"ipam\": {\n              \"type\": \"calico-ipam\"\n          },\n          \"policy\": {\n              \"type\": \"k8s\"\n          },\n          \"kubernetes\": {\n              \"kubeconfig\": \"__KUBECONFIG_FILEPATH__\"\n          },\n          \"container_settings\": { \"allow_ip_forwarding\": true }\n        },\n[...]\n```\n\nCopy that file to node0 in the following folder (create folder if missing):\n\n```\n/var/lib/rancher/k3s/server/manifests/\n```\n\nThat&#39;s it. Your K3s cluster is ready to install Gitpod. The next step is to install cert-manager. Just follow the instructions of the installation guide to install !","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/cluster-set-up/on-k3s"}}],["749",{"pageContent":"__SPLIT_HERE__\nHow to Create a Cluster on Microsoft Azure Kubernetes Service (AKS)\n\n‚ö†Ô∏è Self-hosted as a product is no longer supported\n\nThe last official update of this product is the November 2022 self-hosted release. We no longer sell commercial self-hosted licenses. If you want to self-host Gitpod, you can still request our free community license. However, we no longer offer support or updates for it. If you are interested in an isolated, private installation of Gitpod, take a look at Gitpod Dedicated.\nRead our blog on Gitpod Dedicated to learn why we made the decision to discontinue self-hosted.\n\nInstructions on how to create a Microsoft AKS environment that is ready to install Gitpod are located in the gitpod-io/gitpod-microsoft-aks-guide repository on GitHub. The installation process takes around twenty minutes. In the end, the following resources are created:\n\nAn Microsoft AKS cluster running Kubernetes v1.21.\nAn Microsoft Azure load balancer.\nAn Microsoft Azure DNS zone.\nAn Microsoft Azure container registry.\nMySQL will be provided by Helm under #5508 solved.\nMinio will be used until Microsoft Azure storage gateway is configured.\nInstallation of calico as CNI and NetworkPolicy implementation\nInstallation of cert-manager for self-signed SSL certificates\n\nUpon completion, this script will print the config for the resources created (including passwords) and what is the next relevant step in the installation process. Note that you will be able to skip steps 2 and 3 in the getting started guide because the script can do these steps for you.","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/cluster-set-up/on-microsoft-aks"}}],["750",{"pageContent":"__SPLIT_HERE__\nReference Architectures\n\n‚ö†Ô∏è Self-hosted as a product is no longer supported\n\nThe last official update of this product is the November 2022 self-hosted release. We no longer sell commercial self-hosted licenses. If you want to self-host Gitpod, you can still request our free community license. However, we no longer offer support or updates for it. If you are interested in an isolated, private installation of Gitpod, take a look at Gitpod Dedicated.\nRead our blog on Gitpod Dedicated to learn why we made the decision to discontinue self-hosted.\n\nBelow you will find reference architectures supported and recommended by Gitpod for different situations and all major cloud providers. They help you create the infrastructure needed to run Gitpod Self-Hosted and come in the form of a guide and terraform configuration. These are used to create the infrastructure for our nightly testing and fulfil the requirements Gitpod has on a cluster.\n\nNote: You should see these reference architectures as a starting point for creating infrastructure that works with both Gitpod and your own infrastructure requirements and policies. However, the further you deviate from these recommended architectures, the higher the potential for Gitpod to not behave as expected.\n\n\nProof-of-Value Reference Architecture Aimed at creating a minimal set of infrastructure for evaluation and testing purposes\nSingle-Cluster Reference Architecture for Production Purposes  Aimed at creating hardened infrastructure for a continuous operation of Gitpod\nMulti-Cluster High-Availiability Reference Architecture","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/index"}}],["751",{"pageContent":"__SPLIT_HERE__\nProof-of-Value Reference Architecture\n\n‚ö†Ô∏è Self-hosted as a product is no longer supported\n\nThe last official update of this product is the November 2022 self-hosted release. We no longer sell commercial self-hosted licenses. If you want to self-host Gitpod, you can still request our free community license. However, we no longer offer support or updates for it. If you are interested in an isolated, private installation of Gitpod, take a look at Gitpod Dedicated.\nRead our blog on Gitpod Dedicated to learn why we made the decision to discontinue self-hosted.\n\n\nStatus:\nIntended for: Trying out Gitpod in a representative way but with only the minimum of infrastructure required\nLimitations: - Not intended for long-term, production usage  - Higher risk of data loss due to in-cluster dependencies - if you lose your cluster, you may lose your data  - Data is not carried over when moving to the Single Cluster Reference Architecture for production purposes\n\n__SPLIT_HERE__\nOverview\n\nThis reference architecture provides you with a setup where all components that are needed to operate Gitpod are deployed within the Kubernetes cluster. In contrast to a production-oriented setup, this means that the required database, object storage, well as a registry are deployed for you within the cluster. All cluster services and workspaces are deployed on a single autoscaling node group.\n\nIf you are looking for a scalable and reliable way to run Gitpod, please take a look at our Single Cluster Reference Architecture.\n\n__SPLIT_HERE__\nCloud Provider Preparations","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/proof-of-value"}}],["752",{"pageContent":"Kubernetes Cluster\n\nThe heart of this reference architecture is a Kubernetes cluster where all components are deployed to. This cluster has a single node pool that needs to have all of the following labels:\n\ngitpod.io/workload_meta=true\ngitpod.io/workload_ide=true\ngitpod.io/workload_workspace_services=true\ngitpod.io/workload_workspace_regular=true\ngitpod.io/workload_workspace_headless=true\n\nThe following table gives an overview of the node types for the different cloud providers that are used by this reference architecture.\n\nGCP AWS\nGitpod Node Pool n2d-standard-16 m6i.4xlarge\n\nFirst, we create a service account for the cluster. The service account needs to have the following roles:\n\nRoles\nroles/logging.logWriter\nroles/monitoring.metricWriter\nroles/container.admin\n\nRun the following commands to create the service account:","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/proof-of-value"}}],["753",{"pageContent":"Roles\nroles/logging.logWriter\nroles/monitoring.metricWriter\nroles/container.admin\n\nRun the following commands to create the service account:\n\n```bash\nGKE_SA=gitpod-gke\nGKE_SA_EMAIL=\"${GKE_SA}\"@\"${PROJECT_NAME}\".iam.gserviceaccount.com\ngcloud iam service-accounts create \"${GKE_SA}\" --display-name \"${GKE_SA}\"\ngcloud projects add-iam-policy-binding \"${PROJECT_NAME}\" --member serviceAccount:\"${GKE_SA_EMAIL}\" --role=\"roles/logging.logWriter\"\ngcloud projects add-iam-policy-binding \"${PROJECT_NAME}\" --member serviceAccount:\"${GKE_SA_EMAIL}\" --role=\"roles/monitoring.metricWriter\"\ngcloud projects add-iam-policy-binding \"${PROJECT_NAME}\" --member serviceAccount:\"${GKE_SA_EMAIL}\" --role=\"roles/container.admin\"\n```\n\nAfter that, we create a Kubernetes cluster.","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/proof-of-value"}}],["754",{"pageContent":"After that, we create a Kubernetes cluster.\n\n\nImage Type UBUNTU_CONTAINERD\nMachine Type n2d-standard-16\nCluster Version Choose latest from regular channel\nEnable Autoscaling,Autorepair,IP Alias,Network Policy\nDisable Autoupgrademetadata=disable-legacy-endpoints=true\nCreate Subnetwork gitpod-${CLUSTER_NAME}\nNumber of nodes 1\nMin Nodes 1\nMax Nodes 50\nMax Pods per Node 110\nAddons HorizontalPodAutoscaling,NodeLocalDNS,NetworkPolicy\nScopes gke-default,https://www.googleapis.com/auth/ndev.clouddns.readwrite\nRegion Choose your region and zones\nNode Labels gitpod.io/workload_meta=true,gitpod.io/workload_ide=true,gitpod.io/workload_workspace_services=true,gitpod.io/workload_workspace_regular=true,gitpod.io/workload_workspace_headless=true\n\n```bash\nCLUSTER_NAME=gitpod\nREGION=us-central1-b\nGKE_VERSION=1.21.12","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/proof-of-value"}}],["755",{"pageContent":"gcloud container clusters \\\n    create \"${CLUSTER_NAME}\" \\\n    --disk-type=\"pd-ssd\" \\\n    --disk-size=\"100GB\" \\\n    --image-type=\"UBUNTU_CONTAINERD\" \\\n    --machine-type=\"n2d-standard-16\" \\\n    --cluster-version=\"${GKE_VERSION}\" \\\n    --zone=\"${ZONE}\" \\\n    --service-account \"${GKE_SA_EMAIL}\" \\\n    --num-nodes=1 \\\n    --no-enable-basic-auth \\\n    --enable-autoscaling \\\n    --enable-autorepair \\\n    --no-enable-autoupgrade \\\n    --enable-ip-alias \\\n    --enable-network-policy \\\n    --create-subnetwork name=\"gitpod-${CLUSTER_NAME}\" \\\n    --metadata=disable-legacy-endpoints=true \\\n    --scopes=\"gke-default,https://www.googleapis.com/auth/ndev.clouddns.readwrite\" \\\n    --node-labels=\"gitpod.io/workload_meta=true,gitpod.io/workload_ide=true,gitpod.io/workload_workspace_services=true,gitpod.io/workload_workspace_regular=true,gitpod.io/workload_workspace_headless=true\" \\\n    --min-nodes=1 \\\n    --max-nodes=50 \\\n    --addons=HorizontalPodAutoscaling,NodeLocalDNS,NetworkPolicy\n```","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/proof-of-value"}}],["756",{"pageContent":"Now, you can connect kubectl to your newly created cluster.\n\n```bash\ngcloud container clusters get-credentials --zone=\"${ZONE}\" \"${CLUSTER_NAME}\"\n```\n\nAfter that, you need to create cluster role bindings to allow the current user to create new RBAC rules.\n\n```bash\nkubectl create clusterrolebinding cluster-admin-binding \\\n    --clusterrole=cluster-admin \\\n    --user=\"$(gcloud config get-value core/account)\"\n```\n\nFor eksctl, configuring the cluster and the node groups cannot happen simultaneously. You need to deploy the cluster control plane first, do modifications to the network stack (Calico), and then provision the node groups. This ensures you have the maximum number of pods available (110 in most cases) to run Gitpod workspaces.\n\nThe example eksctl config file includes services accounts that might not be relevant to a particular deployment, but are included for reference.","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/proof-of-value"}}],["757",{"pageContent":"The example eksctl config file includes services accounts that might not be relevant to a particular deployment, but are included for reference.\n\ncert-manager provided for the required cert-manager tooling. If using DNS-01 challenges for Let&#39;s Encrypt with a Route53 zone, then enable the cert-manager wellKnownPolicies or ensure one exists with permissions to modify records in the zone\naws-load-balancer-controller enables ELB creation for LoadBalancer services and integration with AWS Application Load Balancers\ncluster-autoscaler connects to the AWS autoscaler\nebs-csi-controller-sa enables provisioning of the EBS volumes for PVC storage\nexternal-dns creates DNS records for external-facing Gitpod services\n\nProvided below is a complete eksctl configuration file that will deploy all the components required for an EKS installation to support Gitpod. All references to a gitpod-cluster.yaml file refer to this reference.\n\ngitpod-cluster.yaml","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/proof-of-value"}}],["758",{"pageContent":"gitpod-cluster.yaml\n\n```yaml\napiVersion: eksctl.io/v1alpha5\nkind: ClusterConfig\nmetadata:\n  name: gitpod-pov\n  region: eu-west-1\n  version: \"1.22\"\n  # Update tags on your other Gitpod AWS resources (such as securitygroup rules)\n  # to match these tags.\n  tags:\n    department: eng\n    team: selfhosted\n    owner: alt\n    project: gitpod-pov\n\niam:\n  withOIDC: true","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/proof-of-value"}}],["759",{"pageContent":"iam:\n  withOIDC: true\n\n  serviceAccounts:\n    - metadata:\n        name: aws-load-balancer-controller\n        namespace: kube-system\n      wellKnownPolicies:\n        awsLoadBalancerController: true\n    - metadata:\n        name: ebs-csi-controller-sa\n        namespace: kube-system\n      wellKnownPolicies:\n        ebsCSIController: true\n    - metadata:\n        name: cluster-autoscaler\n        namespace: kube-system\n      wellKnownPolicies:\n        autoScaler: true\n    - metadata:\n        name: cert-manager\n        namespace: cert-manager\n      wellKnownPolicies:\n        certManager: true\n    - metadata:\n        name: external-dns\n        namespace: external-dns\n      wellKnownPolicies:\n        externalDNS: true\n\n# Uncomment and update for your region if you wish to use fewer availability zones\n# availabilityZones:\n#   - eu-west-1a\n#   - eu-west-1b\n#   - eu-west-1c","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/proof-of-value"}}],["760",{"pageContent":"# Uncomment and update for your region if you wish to use fewer availability zones\n# availabilityZones:\n#   - eu-west-1a\n#   - eu-west-1b\n#   - eu-west-1c\n\n# By default we create a dedicated VPC for the cluster\n# You can use an existing VPC by supplying private and/or public subnets. Please check\n# https://eksctl.io/usage/vpc-networking/#use-existing-vpc-other-custom-configuration\nvpc:\n  autoAllocateIPv6: false\n  nat:\n    # For production environments use HighlyAvailable, for an initial deployment Single adequate\n    # HighlyAvailable will consume 3 Elastic IPs so ensure your region has capacity before using\n    # https://eksctl.io/usage/vpc-networking/#nat-gateway\n    gateway: Single","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/proof-of-value"}}],["761",{"pageContent":"# Cluster endpoints and public access\n  # Private access ensures that nodes can communicate internally in case of NAT failure\n  # For customizing for your environment review https://eksctl.io/usage/vpc-cluster-access/\n  clusterEndpoints:\n    privateAccess: true\n    publicAccess: true\n  publicAccessCIDRs: [\"0.0.0.0/0\"]\n\n# Logging settings\ncloudWatch:\n  clusterLogging:\n    enableTypes: [\"*\"]\n\n# Nodegroups / Compute settings\nmanagedNodeGroups:\n  - name: default\n    amiFamily: Ubuntu2004\n    spot: false\n    instanceTypes: [\"m6i.4xlarge\"]\n    desiredCapacity: 1\n    minSize: 1\n    maxSize: 50\n    maxPodsPerNode: 110\n    disableIMDSv1: false\n    volumeSize: 512\n    volumeType: gp3\n    volumeIOPS: 6000\n    volumeThroughput: 500\n    ebsOptimized: true\n    privateNetworking: true\n    propagateASGTags: true","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/proof-of-value"}}],["762",{"pageContent":"iam:\n      attachPolicyARNs:\n        - arn:aws:iam::aws:policy/AmazonEC2ContainerRegistryReadOnly\n        - arn:aws:iam::aws:policy/AmazonEKSWorkerNodePolicy\n        - arn:aws:iam::aws:policy/AmazonEKS_CNI_Policy\n        - arn:aws:iam::aws:policy/ElasticLoadBalancingFullAccess\n        - arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore\n\n    tags:\n      k8s.io/cluster-autoscaler/enabled: \"true\"\n      # Important - If you change the name of your EKS cluster from the\n      # default cluster name (\"gitpod-pov\"), update this tag to match\n      # your cluster (`k8s.io/cluster-autoscaler/<cluster-name>: \"owned\"`)\n      #\n      # For example: `k8s.io/cluster-autoscaler/gitpod-corp-pov: \"owned\"`\n      k8s.io/cluster-autoscaler/gitpod-pov: \"owned\"\n\n    labels:\n      gitpod.io/workload_meta: \"true\"\n      gitpod.io/workload_ide: \"true\"\n      gitpod.io/workload_workspace_regular: \"true\"\n      gitpod.io/workload_workspace_services: \"true\"\n      gitpod.io/workload_workspace_headless: \"true\"","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/proof-of-value"}}],["763",{"pageContent":"preBootstrapCommands:\n      - echo \"export USE_MAX_PODS=false\" >> /etc/profile.d/bootstrap.sh\n      - echo \"export CONTAINER_RUNTIME=containerd\" >> /etc/profile.d/bootstrap.sh\n      - sed -i '/^set -o errexit/a\\\\nsource /etc/profile.d/bootstrap.sh' /etc/eks/bootstrap.sh\n```\n\nTo ensure there are enough IPs and networking policy enforcement is in place, this proof of value reference architecture uses Calico for networking. To enable Calico in an EKS installation it must be done after the control plane has been provisioned and before the nodegroups have been created.\n\nFirst: Run eksctl with the --without-nodegroup flag to provision just the control plane defined in the gitpod-cluster.yaml:\n\n```bash\neksctl create cluster --without-nodegroup --config-file gitpod-cluster.yaml\n```\n\nThis should result in the following output:","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/proof-of-value"}}],["764",{"pageContent":"```bash\neksctl create cluster --without-nodegroup --config-file gitpod-cluster.yaml\n```\n\nThis should result in the following output:\n\n```\n2022-08-11 22:10:23 [‚Ñπ]  eksctl version 0.107.0\n2022-08-11 22:10:23 [‚Ñπ]  using region eu-west-1\n2022-08-11 22:10:23 [‚Ñπ]  setting availability zones to [eu-west-1b eu-west-1a eu-west-1c]\n2022-08-11 22:10:23 [‚Ñπ]  subnets for eu-west-1b - public:192.168.0.0/19 private:192.168.96.0/19\n2022-08-11 22:10:23 [‚Ñπ]  subnets for eu-west-1a - public:192.168.32.0/19 private:192.168.128.0/19\n2022-08-11 22:10:23 [‚Ñπ]  subnets for eu-west-1c - public:192.168.64.0/19 private:192.168.160.0/19\n2022-08-11 22:10:23 [‚Ñπ]  using Kubernetes version 1.22\n[...]\n2022-08-11 22:27:06 [‚úî]  EKS cluster \"gitpod-pov\" in \"eu-west-1\" region is ready\n```\n\nAfter this command finishes, check that eksctl also created the kubeconfig properly by running the command kubectl get pods -n kube-system. If deployed correctly one should see the list of pods in a pending state.","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/proof-of-value"}}],["765",{"pageContent":"```bash\nkubectl get pods -n kube-system\n```\n\nThis should result in:\n\n```\nNAME                       READY   STATUS    RESTARTS   AGE\ncoredns-5947f47f5f-79vqv   0/1     Pending   0          22m\ncoredns-5947f47f5f-97f8m   0/1     Pending   0          22m\n```\n\nCalico Installation\n\nThis is following the instructions provided by Tigera.\n\nTo install Calico, first remove the default AWS-provided networking component:\n\n```bash\nkubectl delete daemonset -n kube-system aws-node\n```\n\nInstall the Calico manifest:\n\n```bash\nkubectl apply -f https://projectcalico.docs.tigera.io/manifests/calico-vxlan.yaml\n```\n\nNow configure Calico for EKS-specific support with the following command:\n\n```bash\nkubectl -n kube-system set env daemonset/calico-node FELIX_AWSSRCDSTCHECK=Disable\n```\n\nSSH Access to nodegroups","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/proof-of-value"}}],["766",{"pageContent":"Now configure Calico for EKS-specific support with the following command:\n\n```bash\nkubectl -n kube-system set env daemonset/calico-node FELIX_AWSSRCDSTCHECK=Disable\n```\n\nSSH Access to nodegroups\n\neksctl allows for ssh keys to be added to your nodegroups for troubleshooting. By default, the gitpod-cluster.yaml does not configure this. AWS Systems Manager is enabled by default, allowing for connectivity through multiple methods to each instance in your nodegroup.\n\nCreate the gitpod nodegroup\n\nOnce the Calico CNI has been provisioned the gitpod nodegroup can be created.\n\nCreate the Gitpod nodegroup:\n\n```bash\neksctl create nodegroup --include=default --config-file gitpod-cluster.yaml\n```\n\nThis should result in:","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/proof-of-value"}}],["767",{"pageContent":"Create the Gitpod nodegroup:\n\n```bash\neksctl create nodegroup --include=default --config-file gitpod-cluster.yaml\n```\n\nThis should result in:\n\n```\n2022-08-11 22:52:10 [‚Ñπ]  nodegroup \"default\" will use \"ami-0733d755ed2c97a4d\" [Ubuntu2004/1.22]\n2022-08-11 22:52:13 [‚Ñπ]  combined include rules: default\n2022-08-11 22:52:13 [‚Ñπ]  1 nodegroup (default) was included (based on the include/exclude rules)\n2022-08-11 22:52:13 [‚Ñπ]  will create a CloudFormation stack for each of 1 managed nodegroups in cluster \"gitpod-pov\"\n[...]\n2022-08-11 22:56:53 [‚Ñπ]  node \"ip-192-168-104-44.eu-west-1.compute.internal\" is ready\n2022-08-11 22:56:53 [‚úî]  created 1 managed nodegroup(s) in cluster \"gitpod-pov\"\n2022-08-11 22:56:57 [‚Ñπ]  checking security group configuration for all nodegroups\n2022-08-11 22:56:57 [‚Ñπ]  all nodegroups have up-to-date cloudformation templates\n```","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/proof-of-value"}}],["768",{"pageContent":"You can verify that your installation was deployed properly with the custom kubectl command provided below which will let you review maxpods, kernel and containerd versions to ensure they are meeting our minimum requirements as intended.\n\n```bash\nkubectl get nodes -o=custom-columns=\"NAME:.metadata.name,\\\nRUNTIME:.status.nodeInfo.containerRuntimeVersion,\\\nMAXPODS:.status.capacity.pods,\\\nKERNEL:.status.nodeInfo.kernelVersion,\\\nAMIFAMILY:.status.nodeInfo.osImage,\\\nK8S:.status.nodeInfo.kubeletVersion,\\\nInstance-ID:.spec.providerID\"\n```\n\nEnable cluster autoscaling\n\nGitpod&#39;s resource usage will vary depending on the number of active workspaces and image prebuilds during the day. The use of a cluster autoscaler is recommended to provision and remove EKS nodes on demand.\n\n```bash\nCLUSTER_NAME=\"gitpod-pov\"\nAWS_REGION=\"eu-west-1\"","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/proof-of-value"}}],["769",{"pageContent":"```bash\nCLUSTER_NAME=\"gitpod-pov\"\nAWS_REGION=\"eu-west-1\"\n\nhelm repo add autoscaler https://kubernetes.github.io/autoscaler\nhelm repo update\nhelm upgrade \\\n    --atomic \\\n    --cleanup-on-fail \\\n    --install \\\n    --namespace kube-system \\\n    --reset-values \\\n    --wait \\\n    --set cloudProvider=aws \\\n    --set awsRegion=$AWS_REGION \\\n    --set autoDiscovery.clusterName=$CLUSTER_NAME \\\n    --set rbac.serviceAccount.create=false \\\n    --set rbac.serviceAccount.name=cluster-autoscaler \\\n    --set securityContext.fsGroup=65534 \\\n    --set extraArgs.skip-nodes-with-local-storage=false \\\n    --set extraArgs.skip-nodes-with-system-pods=false \\\n    --set extraArgs.expander=least-waste \\\n    --set extraArgs.balance-similar-node-groups=true \\\n    --set extraArgs.scale-down-utilization-threshold=0.2 \\\n    --set extraArgs.v=2 \\\n    autoscaler autoscaler/cluster-autoscaler\n```\n\nDeleting the cluster","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/proof-of-value"}}],["770",{"pageContent":"Deleting the cluster\n\nWhen deleting this cluster following your proof of value evaluation, any additional resources added to the VPC will need to be deleted before deleting the cluster, otherwise, cloudformations will fail to delete the VPC and complete deleting the cluster. The alternative is to create a VPC managed separately and install EKS using the additions for working with existing VPCs in eksctl.\n\nFull removal of the installed components would look something like this (commands are grouped for brevity):\n\n```bash\neksctl delete cluster --name gitpod --force --disable-nodegroup-eviction --wait\n\n#### The following removal steps are optional; if you plan on creating another Gitpod installation then the S3 bucket,\n#### access account, key, and policy can be kept for later use.\n\n#### delete s3 resources\naws s3 rm s3://${S3_BUCKET_NAME} --recursive\naws s3 rb s3://${S3_BUCKET_NAME} --force","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/proof-of-value"}}],["771",{"pageContent":"#### delete s3 resources\naws s3 rm s3://${S3_BUCKET_NAME} --recursive\naws s3 rb s3://${S3_BUCKET_NAME} --force\n\n#### delete iam resources\naws iam detach-user-policy --user-name gitpod-s3-access --policy-arn 'arn:aws:iam::12344:policy/gitpod_s3_access_policy'\n\n# delete access keys:\naws iam list-access-keys --user-name gitpod-s3-access\naws iam delete-access-key --user-name gitpod-s3-access --access-key-id AKI---------\naws iam delete-user --user-name gitpod-s3-access\n\n# ensure that nothing else is attached to this policy\naws iam list-entities-for-policy --policy-arn 'arn:aws:iam::12344:policy/gitpod_s3_access_policy'\naws iam delete-policy --policy-arn 'arn:aws:iam::12344:policy/gitpod_s3_access_policy'\n```","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/proof-of-value"}}],["772",{"pageContent":"Networking\n\n__SPLIT_HERE__\nInstall Gitpod\n\nCongratulations. You have set up your cluster. Now, you are ready to install Gitpod. Follow the instructions of the installation guide.\n\nIf you followed the steps to create your infrastructure of this guide, you need to use the following config settings for your Gitpod installation:\n\nGeneral settings\nDomain name value of $DOMAIN\n\nKeep cert-manager selected for the TLS certificates options.\n\nTLS certificates &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\nSelf-signed TLS certificate no\ncert-manager yes\nIssuer name gitpod-issuer\nIssuer type Select ‚Äúcluster issuer‚Äù\n\nAdditional features &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\nAllow login to your workspace via SSH (if you wish to use desktop IDEs) ‚úÖ","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/proof-of-value"}}],["773",{"pageContent":"__SPLIT_HERE__\nSingle-Cluster Reference Architecture for Production Purposes\n\n‚ö†Ô∏è Self-hosted as a product is no longer supported\n\nThe last official update of this product is the November 2022 self-hosted release. We no longer sell commercial self-hosted licenses. If you want to self-host Gitpod, you can still request our free community license. However, we no longer offer support or updates for it. If you are interested in an isolated, private installation of Gitpod, take a look at Gitpod Dedicated.\nRead our blog on Gitpod Dedicated to learn why we made the decision to discontinue self-hosted.\n\n\nStatus:\nIntended for: Continous usage of Gitpod at a company-wide scale in a reliable way by leveraging popular cloud provider services such as S3 and RDS.\nLimitations: - This is bound to a single cluster. Deploying in several regions currently requires setting up several Gitpod installations  - Creates external dependencies for Gitpod componenents (object storage, registry, database)  - This is not highly available and requires downtime to upgrade (high availability requires a governed workspace cluster, which is beyond the scope of this reference architecture)\nTerraform:  - Example Terraform configuration for GCP  - Example Terraform configuration for AWS\nCost Estimates:  High-level cost estimates*:  - GCP  - AWS\n\nThis guide describes a single-cluster reference architecture for Gitpod aimed at production environments: continuous deployments of Gitpod used in anger by your engineers. It consists of a Kubernetes cluster, cert-manager, external MySQL database, external OCI image registry, and external object storage. It includes instructions on how to set up this reference architecture on the officially supported cloud providers.\n\nThis reference architecture can be used as a blueprint for your Gitpod installation: Start with this reference architecture and adapt it to your needs. The reference architecture as described in this guide is what Gitpod supports, and is used to test against every self-hosted Gitpod release.\n\nTo use Gitpod, you also need a Git source code management system (SCM) like GitLab, GitHub, or Bitbucket. You will find the supported SCMs in the product compatibility matrix your own SCM is beyond the scope of this guide. However, you can simply use the cloud versions of GitLab, GitHub, or Bitbucket as well as the possible existing installation in your corporate network.\n\n__SPLIT_HERE__\nOverview\n\n__SPLIT_HERE__\nCloud Provider Preparations\n\n\n\n__SPLIT_HERE__\nKubernetes Cluster\n\n__SPLIT_HERE__\nNetworking\n\n__SPLIT_HERE__\nObject Storage\n\n__SPLIT_HERE__\nOCI Image Registry\n\n__SPLIT_HERE__\nDatabase\n\n__SPLIT_HERE__\nInstall Gitpod","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/single-cluster-ref-arch"}}],["774",{"pageContent":"__SPLIT_HERE__\nSelf-Hosted Gitpod Releases and Versioning\n\n‚ö†Ô∏è Self-hosted as a product is no longer supported\n\nThe last official update of this product is the November 2022 self-hosted release. We no longer sell commercial self-hosted licenses. If you want to self-host Gitpod, you can still request our free community license. However, we no longer offer support or updates for it. If you are interested in an isolated, private installation of Gitpod, take a look at Gitpod Dedicated.\nRead our blog on Gitpod Dedicated to learn why we made the decision to discontinue self-hosted.\n\nRelease Policy\n\nGitpod Self-Hosted is released once a month, usually at the end of each month. The versioning schema is: YYYY.MM.V. Each new version of self-hosted Gitpod includes all of the changes made to Gitpod up to the release date. This means that the self-hosted version of Gitpod is at most one month behind the SaaS version. Outside of the regular monthly releases, hot-fix releases are possible to add functionality or fix bugs. Hot fix releases increment the V in the aforementioned versioning schema.\n\nSupport Policy\n\nGitpod is committed to supporting the last 2 versions of self-hosted Gitpod with patches and security updates.\n\nRoll out Policy\n\nNew versions are first rolled out to all users that are on the community license, i.e. are on the stable branch. Customers with a paid license receive the newest version one week later.\n\nTesting Policy\n\nFor each release, we validate that core Gitpod workflows function as expected via a series of automated and manual tests. These tests are performed on different Gitpod installations running on our reference architectures. This should help ensure that Gitpod works for you, assuming your architecture is close to the reference architecture.","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/releases/index"}}],["775",{"pageContent":"__SPLIT_HERE__\nConfigure the authentication used by your Gitpod Self-Hosted installation\n\n‚ö†Ô∏è Deprecated Content\n\nThe content of this page assumes you are using Helm, which is now deprecated. Please use the Installer instead.\n\nGitpod does not implement user authentication itself, but integrates with other auth provider using OAuth2.\nUsually your Git hosting solution (e.g. GitHub or GitLab) acts as the OAuth auth provider. This way we control access to Gitpod while at\nthe same time making sure every user has proper access to their Git repository.\n\nGitpod supports the following authentication providers:\n\ngithub.com\nGitHub Enterprise in version 2.16.x and higher\ngitlab.com\nGitLab Community Edition in version 11.7.x and higher\nGitLab Enterprise Edition in version 11.7.x and higher\nBitbucket ‚Äî coming soon\nCustom Auth Provider ‚Äì Inquiry TypeFox for a quote\n\n__SPLIT_HERE__\nGitHub\n\nTo authenticate your users with GitHub you need to create a GitHub OAuth App.\nFollow the guide linked above and:\n\nset &quot;Authentication callback URL&quot; to after replacing example.com with your domain name:\n\nhttps://example.com/auth/github/callback\n\n\ncopy the following values and configure them in values.yaml:\n\nclientId\nclientSecret\n\n__SPLIT_HERE__\nGitLab\n\nTo authenticate your users with GitLab you need to create an GitLab OAuth application.\nFollow the guide linked above and:\n\nset &quot;Authentication callback URL&quot; to:\n\nhttps://&lt;your-domain.com&gt;/auth/&lt;gitlab.com-OR-your-gitlab.com&gt;/callback\n\n\nset &quot;Scopes&quot; to api, read_user and read_repository.\n\n\ncopy the following values and configure them in values.yaml:\n\nclientId is the &quot;Application ID&quot; from the GitLab OAuth application\nclientSecret is the &quot;Secret&quot; from the GitLab OAuth application","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/helm-deprecated/configuration/authentication"}}],["776",{"pageContent":"__SPLIT_HERE__\nConfigure the database used by your Gitpod installation\n\n‚ö†Ô∏è Deprecated Content\n\nThe content of this page assumes you are using Helm, which is now deprecated. Please use the Installer instead.\n\nGitpod uses a MySQL database to store user data. By default Gitpod ships with a MySQL database built-in. If you operate your own MySQL database (which we&#39;d recommend in a production setting) you can use that one. You have the following options:\n\nIntegrated database: If not disabled, this MySQL database is installed in a Kubernetes pod as a part of Gitpod‚Äôs Helm chart.\nThe database uses a Kubernetes PersistentVolume. We do not recommend using this option for a production setting.\n\n\nOwn MySQL database: Gitpod requires MySQL in version 5.7 or newer.\n\nThis chart installs a MySQL database that gets Gitpod up and running but is not suitable for production (the data is lost on each restart of the DB pod). To connect to a proper MySQL installation:\n\nCopy the DB init scripts into your local folder:\n\n```bash\nmkdir -p gpinstall\necho exit | docker run -v $PWD/gpinstall:/workspace -u $(id -u) -i gcr.io/gitpod-io/self-hosted/installer:latest bash\nmkdir -p ./db-init\ncp gpinstall/gitpod/helm/gitpod/config/db/init/*.sql ./db-init/\nrm -Rf gpinstall\n```\n\n\nInitialize your MySQL database using the SQL files in config/db/init/. E.g. in a mysql session connected to your database server run:\n\n```sql\nSET @gitpodDbPassword = IFNULL(@gitpodDbPassword, 'your-password-goes-here');\nsource db-init/00-testdb-user.sql;\nsource db-init/01-create-user.sql;\nsource db-init/02-create-and-init-sessions-db.sql;\nsource db-init/03-recreate-gitpod-db.sql;\n```\n\n\nMerge the following into your values.custom.yaml:\n\n```yaml\ndb:\n  host: db\n  port: 3306\n  password: your-password-goes-here\n\n# Disable built-in MySQL instance\nmysql:\n  enabled: false\n```\n\n\nDo a helm upgrade --install -f values.custom.yaml gitpod gitpod.io/gitpod --version=0.10.0 to apply the changes.","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/helm-deprecated/configuration/database"}}],["777",{"pageContent":"__SPLIT_HERE__\nConfiguring Gitpod Self-Hosted\n\n‚ö†Ô∏è Deprecated Content\n\nThe content of this page assumes you are using Helm, which is now deprecated. Please use the Installer instead.\n\nConfigure the database used by your Gitpod Self-Hosted installation\nConfigure the Docker registry used by your Gitpod Self-Hosted installation\nConfigure the ingress to your Gitpod Self-Hosted installation\nConfigure the Kubernetes nodes in your Gitpod Self-Hosted installation\nConfigure the storage used by your Gitpod installation\nConfigure the Gitpod Workspaces in your Gitpod Self-Hosted installation\nConfigure the authentication used by your Gitpod Self-Hosted installation\nConfigure the VSX registry used by your Gitpod Self-Hosted installation","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/helm-deprecated/configuration/index"}}],["778",{"pageContent":"__SPLIT_HERE__\nConfigure the ingress to your Gitpod installation\n\n‚ö†Ô∏è Deprecated Content\n\nThe content of this page assumes you are using Helm, which is now deprecated. Please use the Installer instead.\n\nConfiguring ingress into your Gitpod installation requires two things:\n\nthree DNS entries pointing at the IP of Gitpod&#39;s proxy service, and\nHTTPS certificates.\n\n__SPLIT_HERE__\n1. DNS Entries\n\nGitpod requires a domain resolvable by some nameserver (typically a public domain name, e.g. your-domain.com).\nAs Gitpod launches services and workspaces on additional subdomains it also needs two wildcard domains.\nFor example:\n\n```undefined\nyour-domain.com\n*.your-domain.com\n*.ws.your-domain.com\n```\n\nInstalling Gitpod on a subdomain works as well. For example:\n\n```undefined\ngitpod.your-domain.com\n*.gitpod.your-domain.com\n*.ws.gitpod.your-domain.com\n```\n\nSetup A records for all three (sub)domains. To learn your installation&#39;s IP run:\n\n```bash\nkubectl describe svc proxy | grep -i ingress\n```\n\n\nMerge the following into your values.custom.yaml file:\n\n```yaml\nhostname: your-domain.com\ncomponents:\n  proxy:\n    loadBalancerIP: <your-IP>\n```\n\nSpecifying the loadBalancerIP make sure it stays the same across all redeploys.\n\n__SPLIT_HERE__\n2. HTTPS\n\nGitpod requires HTTPS certificates to function properly. We recommend using Let&#39;s Encrypt for retrieving certificates as we do for gitpod.io.\n\nImportant: The HTTPS certificates for your domain must include your-domain.com, *.your-domain.com and *.ws.your-domain.com. Beware that wildcard certificates are valid for one level only (i.e. *.a.com is not valid for c.b.a.com).\n\nTo configure the HTTPS certificates for your domain\n\nGenerate certificates and put your certificate files under secrets/https-certificates/:```text\nsecrets/https-certificates:\n  |- tls.crt\n  |- tls.key\n```\n\n\nGenerate the dhparams.pem file using:```bash\nopenssl dhparam -out secrets/https-certificates/dhparams.pem 2048\n```\n\n\nCreate a kubernetes secret using:```bash\nkubectl create secret generic https-certificates --from-file=secrets/https-certificates\n```\n\n\nAfterwards, do an helm upgrade --install -f values.custom.yaml gitpod gitpod.io/gitpod --version=0.10.0 to apply the changes.\n\nUsing Let&#39;s Encrypt to generate HTTPS certificates\n\nThe most accessible means of obtaining HTTPS certificates is using Let&#39;s Encrypt. It provides free certificates to anybody who can prove ownership of a domain.\nLet&#39;s Encrypt offers a program called certbot to make acquiring certificates as straightforward as possible.\n\nAssuming you have certbot installed, the following script will generate and configure the required certificates (notice the placeholders):\n\n```bash\nexport DOMAIN=your-domain.com\nexport EMAIL=your@email.here\nexport WORKDIR=$PWD/letsencrypt\n\ncertbot certonly \\\n    --config-dir $WORKDIR/config \\\n    --work-dir $WORKDIR/work \\\n    --logs-dir $WORKDIR/logs \\\n    --manual \\\n    --preferred-challenges=dns \\\n    --email $EMAIL \\\n    --server https://acme-v02.api.letsencrypt.org/directory \\\n    --agree-tos \\\n    -d *.ws.$DOMAIN \\\n    -d *.$DOMAIN \\\n    -d $DOMAIN\n\n# move them into place\nmkdir -p secrets/https-certificates\ncp $WORKDIR/config/live/fullchain.pem secrets/https-certificates/tls.crt\ncp $WORKDIR/config/live/privkey.pem secrets/https-certificates/tls.key\n```\n\nNote: Do not refrain if certbot fails on first execution: Depending on the challenge used you might have to restart it once.","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/helm-deprecated/configuration/ingress"}}],["779",{"pageContent":"__SPLIT_HERE__\nConfigure the Kubernetes nodes in your Gitpod Self-Hosted installation\n\n‚ö†Ô∏è Deprecated Content\n\nThe content of this page assumes you are using Helm, which is now deprecated. Please use the Installer instead.\n\nConfigure the nodes (computers or virtual machines) that Kubernetes runs Gitpod&#39;s workspace pods on.\n\n__SPLIT_HERE__\nAssign workload to Nodes\n\nGitpod schedules two kinds of workloads: the Gitpod installation itself (which we refer to as meta) and the workspaces. Ideally both types of workloads run on separate nodes to make makes scaling easier.\nDepending on your cluster size that may not be feasible though. Either way, you need two node labels in your cluster:\n\ngitpod.io/workload_meta=true which marks the &quot;meta&quot; nodes and\ngitpod.io/workload_workspace=true  which marks the workspace nodes.\n\nIf you want to &quot;mix &#39;n match&quot;, i.e., don&#39;t separate the nodes, you can simply run:\n\n```bash\nkubectl label node --all gitpod.io/workload_meta=true gitpod.io/workload_workspace=true\n```\n\n__SPLIT_HERE__\nNode Filesystem Layout\n\nGitpod relies on the node&#39;s filesystem for making workspace content available, as well as for storing Theia. By default workspace data is placed in /data and Theia is copied to /theia. Depending on your node setup the root filesystem maybe read-only or slow.\nWe recommend you change those two paths so that they&#39;re located on an SSD or some other form of fast local storage.\n\nTo do this:\n\nMerge the following into your values.custom.yaml:\n\n```yaml\ncomponents:\n  imageBuilder:\n    # The image builder deploys a Docker-in-Docker-daemon. By default that Docker daemon works in an empty-dir on the node.\n    # Depending on the types of node you operate that may cause image builds to fail or not perform well. We recommend you give the Docker daemon\n    # fast storage on the node, e.g. an SSD.\n    hostDindData: /mnt/disks/ssd0/docker\n  wsDaemon:\n    # Workspace data is stored on the nodes. This setting configures where on the node the workspace data lives.\n    # The faster this location is (in terms of IO) the faster workspaces will initialize.\n    hostWorkspaceArea: /mnt/disks/ssd0/workspaces\n```\n\n\nDo a helm upgrade --install -f values.custom.yaml gitpod gitpod.io/gitpod --version=0.10.0 to apply the changes.\n\nNote that Helm does not merge hierarchies in a single file. Please make sure there is only ever one components hierarchy or the last one overwrites all previous values.","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/helm-deprecated/configuration/nodes"}}],["780",{"pageContent":"__SPLIT_HERE__\nConfigure the Docker registry used by your Gitpod Self-Hosted installation\n\n‚ö†Ô∏è Deprecated Content\n\nThe content of this page assumes you are using Helm, which is now deprecated. Please use the Installer instead.\n\nGitpod builds Docker images during workspace startup. This enables custom Dockerfiles as part of your workspace config, but is also required for Gitpod itself to function.\nTo this end, Gitpod requires a container registry where it can push the images it builds.\n\nBy default Gitpod ships with a built-in Docker registry. If you operate your own Docker registry (which we&#39;d recommend in a production setting) you can use that one. You have the following options:\n\nIntegrated Docker registry: If not disabled, this Docker registry is installed in a Kubernetes Pod as a dependency of Gitpod‚Äôs Helm chart.\nThe Docker registry requires a Kubernetes PersistentVolume. This registry is not recommended to be used for production.\nOwn Docker registry: Gitpod can connect to your own Docker registry. Compared to its built-in counterpart this enables performance gains and access to otherwise private images.\n\nThis helm chart can either deploy its own registry (default but requires HTTPS certs) or use an existing one.\n\n__SPLIT_HERE__\nConfiguration\n\nTo connect to an existing Docker registry, perform the following steps:\n\nMerge the following into your values.custom.yaml:\n\n```yaml\ncomponents:\n  imageBuilder:\n    registryCerts: []\n    registry:\n      # name must not end with a \"/\"\n      name: your.registry.com/gitpod\n      secretName: image-builder-registry-secret\n      path: secrets/registry-auth.json\n\n  workspace:\n    pullSecret:\n      secretName: image-builder-registry-secret\n\ndocker-registry:\n  enabled: false\n```\n\nReplace your.registry.com/gitpod with the domain your registry is available at.\n\nNote that Helm does not merge hierarchies in a single file. Please make sure there is only ever one components hierarchy or the last one overwrites all previous values.\n\n\nPersist your registry authentication token to the secrets/ folder.\n\n```bash\nmkdir -p secrets\ndocker login your.registry.com/gitpod\ncp ~/.docker/config.json secrets/registry-auth.json\n```\n\nThis does not work for Google Cloud Registries because their login tokens are short-lived. See the example below on how to configure it.\n\n\nDo a helm upgrade --install -f values.custom.yaml gitpod gitpod.io/gitpod --version=0.10.0 to apply the changes.\n\nMake sure the resulting JSON file contains the credentials (there should be an auths section containing them as base64 encoded string).\n\nIf that&#39;s not the case you might have a credential store/helper set up (e.g. on macOS the Securely store Docker logins in macOS keychain setting).\n\nExample Google Cloud Registry Credentials\n\nPrerequisites:\n\ngcloud installed and authenticated\n\nHow to use Google Cloud Registry as Docker registry for Gitpod:\n\nGo to https://console.cloud.google.com/gcr/images/&lt;your-project-id&gt;?project=&lt;your-project-id&gt; and hit &quot;Enable Registry API&quot; (if not already enabled).\n\n\nExecute the following commands:\n\n```bash\nexport PROJECT_ID=\"<your-project-id>\"\n\ngcloud iam service-accounts create gitpod-registry-full --project=$PROJECT_ID\ngcloud projects add-iam-policy-binding $PROJECT_ID --member=\"serviceAccount:gitpod-registry-full@$PROJECT_ID.iam.gserviceaccount.com\" --role=roles/storage.admin\ngcloud iam service-accounts keys create gitpod-registry-full-key.json --iam-account=gitpod-registry-full@$PROJECT_ID.iam.gserviceaccount.com\n\necho \"{\\\"auths\\\":{\\\"gcr.io\\\": {\\\"auth\\\": \\\"$(echo -n \"$(echo -n \"_json_key:\"; cat gitpod-registry-full-key.json)\" | base64 -w 0)\\\"}}}\" > secrets/registry-auth.json\n```\n\nThis should result in a secrets/registry-auth.json like this:\n\n```json\n{\n  \"auths\": {\n    \"gcr.io\": {\n      \"auth\": \"<long-base64-string>\"\n    }\n  }\n}\n```\n\nIf you want to use the localized versions of gcr.io (eu.gcr.io, for instance) make sure to update the json file accordingly.","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/helm-deprecated/configuration/docker-registry"}}],["781",{"pageContent":"__SPLIT_HERE__\nConfigure the storage used by your Gitpod installation\n\n‚ö†Ô∏è Deprecated Content\n\nThe content of this page assumes you are using Helm, which is now deprecated. Please use the Installer instead.\n\nGitpod uses bucket storage to persist the contents of workspaces. Each workspace is tarballed into a single archive file which is then uploaded to a separate bucket.\n\nBy default Gitpod installs MinIO as built-in bucket storage which uses a persistent volume to store workspace content.\n\nFor more complex use case we recommend configuring more permanent means of persistence by either:\n\nConfigure the contained MinIO-instance to serve as a gateway OR configure one of a wide range of storage backends.\nBring your own storage bucket: Configure Gitpod to either connect to:your own installation of MinIO\na Google Cloud Storage compatible storage solution\n\n__SPLIT_HERE__\na) Configure custom MinIO instance\n\nCreate a file values.custom.yaml with this content:\n\n```yaml\ncomponents:\n  contentService:\n    remoteStorage:\n      kind: minio\n      minio:\n        endpoint: your-minio-installation.somewhere-else.com:8080\n        accessKey: enterKeyHere\n        secretKey: superSecretKeyGoesHere\n        tmpdir: /tmp\n\n# Disable built-in minio instance\nminio:\n  enabled: false\n```\n\n\nRedeploy Gitpod using helm upgrade --install -f values.custom.yaml gitpod gitpod.io/gitpod --version=0.10.0 to apply the changes\n\nNote that Helm does not merge hierarchies in a single file. Please make sure there is only ever one components hierarchy or the last one overwrites all previous values.\n\n__SPLIT_HERE__\nb) Configure the built-in MinIO instance\n\nConsult the chart&#39;s documentation at https://helm.min.io/\nCreate a file values.custom.yaml with this content:```yaml\nminio:\n  accessKey: add-a-radom-access-key-here\n  secretKey: add-a-radom-secret-key-here\n  # insert custom config here\n```\n\n\nRedeploy Gitpod using helm upgrade --install -f values.custom.yaml gitpod gitpod.io/gitpod --version=0.10.0 to apply the changes","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/helm-deprecated/configuration/storage"}}],["782",{"pageContent":"__SPLIT_HERE__\nConfigure the VSX registry used by your Gitpod Self-Hosted installation\n\n‚ö†Ô∏è Deprecated Content\n\nThe content of this page assumes you are using Helm, which is now deprecated. Please use the Installer instead.\n\nGitpod uses the public OpenVSX registry as only products produced by Microsoft may access the Visual Studio Code Marketplace. This document explains how Gitpod Self-Hosted can be configured in air-gapped scenarios to connect to a private OpenVSX registry.\n\n__SPLIT_HERE__\nConfiguration\n\nTo connect to private OpenVSX registry, perform the following steps:\n\nMerge the following into your values.custom.yaml:\n\n```yaml\ncomponents:\n  openVsxProxy:\n    vsxRegistryUrl: open-vsx.org\n```\n\nReplace open-vsx.org with the domain your registry is available at.\n\n\nDo a helm upgrade --install -f values.custom.yaml gitpod gitpod.io/gitpod --version=0.10.0 to apply the changes.\n\n__SPLIT_HERE__\nAdditional resources\n\nhttps://github.com/gitpod-io/gitpod/blob/cfb528c5daf5115b666ec7404bfe25d9fc9598d6/chart/values.yaml#L137","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/helm-deprecated/configuration/vsx-registry"}}],["783",{"pageContent":"__SPLIT_HERE__\nWorkspaces\n\n‚ö†Ô∏è Deprecated Content\n\nThe content of this page assumes you are using Helm, which is now deprecated. Please use the Installer instead.\n\n__SPLIT_HERE__\nSizing\n\nGitpod schedules workspaces as Kubernetes pods. Each workspace pod requests a certain amount of memory which directly affects how many workspaces are scheduled on a single node.\nIf you want to change the default sizing (~ 8GiB per workspace) you should\n\nMerge the following into your values.custom.yaml:\n\n```yaml\n# workspaceSizing configures the resources available to each workspace. These settings directly impact how\n# desenly we pack workspaces on nodes where workspacesPerNode = memoryAvailable(node) / memoryRequest.\n#\n# Beware: if a workspace exceeds its memoryLimit, some of its processes may be terminated (OOM-kill) which\n# results in a broken user experience.\nworkspaceSizing:\n  requests:\n    cpu: \"1m\"\n    memory: \"2.25Gi\"\n    storage: \"5Gi\"\n  limits:\n    cpu: \"5\"\n    memory: \"12Gi\"\n  dynamic:\n    # Gitpod supports dynamic CPU limiting. We express those limits in \"buckets of CPU time\" (jiffies where 1 jiffie is 1% of a vCPU).\n    # Each bucket has a limit (i.e. max CPU rate in jiffies/sec, 100 jiffies/sec = 1 vCPU).\n    #\n    # For example:\n    #   # three minutes of 5 CPUs: 5 [numCPU] * 100 [jiffies/sec] * (3 * 60) [seconds] = 90000\n    #   - budget: 90000\n    #     limit: 500\n    #   # five minutes  of 4 CPUs: 4 [numCPU] * 100 [jiffies/sec] * (5 * 60) [seconds] = 120000\n    #   - budget: 120000\n    #     limit: 400\n    #   # remainder of 2 CPUs where a user has to stay below sustained use of 1.8 CPUs for 5 minutes:\n    #   #                       1.8 [numCPU] * 100 [jiffies/sec] * (5 * 60) [seconds] = 54000\n    #   - budget: 54000\n    #     limit: 200\n    #\n    # if there are no buckets configured, the dynamic CPU limiting is disabled.\n    cpu:\n      buckets: []\n      samplingPeriod: \"10s\"\n      controlPeriod: \"15m\"\n```\n\n\nDo a helm upgrade --install -f values.custom.yaml gitpod gitpod.io/gitpod --version=0.10.0 to apply the changes.","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/helm-deprecated/configuration/workspaces"}}],["784",{"pageContent":"__SPLIT_HERE__\nInstall Gitpod Self-Hosted\n\n‚ö†Ô∏è Deprecated Content\n\nThe content of this page assumes you are using Helm, which is now deprecated. Please use the Installer instead.\n\nInstall Gitpod Self-Hosted on Kubernetes","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/helm-deprecated/installation/index"}}],["785",{"pageContent":"__SPLIT_HERE__\nInstall Gitpod Self-Hosted on Kubernetes\n\n‚ö†Ô∏è Deprecated Content\n\nThe content of this page assumes you are using Helm, which is now deprecated. Please use the Installer instead.\n\nThis section describes how to install Gitpod on any Kubernetes cluster using Helm. This is the most flexible and generic way of installing Gitpod. The chart for stable releases resides in Helm repository charts.gitpod.io, charts for branch-builds can be found here, and the source of the charts is in our public git repository.\n\nFor some platforms we offer Terraform scripts that ease the infrastructure setup. Once the script has created the necessary infrastructure it will output a values.terraform.yaml that contains infrastructure-specific configuration for the helm deployment.\n\n__SPLIT_HERE__\nPrerequisites\n\nSee Installation requirements for Gitpod Self-Hosted.\n\n__SPLIT_HERE__\nInstallation\n\nTo install Gitpod in your Kubernetes cluster, follow these steps:\n\nCreate a file values.custom.yaml with the following content (please replace the keys/secrets, for instance with openssl rand -hex 20):\n\n```yaml\ndocker-registry:\n  authentication:\n    username: gitpod\n    password: your-registry-password\nrabbitmq:\n  auth:\n    username: your-rabbitmq-user\n    password: your-secret-rabbitmq-password\nminio:\n  accessKey: your-random-access-key\n  secretKey: your-random-secret-key\n```\n\nYou should replace the keys with 2 different random strings unique for your installation.\n\n\nRun the following commands in your local terminal:\n\n```bash\nhelm repo add gitpod.io https://charts.gitpod.io\n\nhelm repo update\n\nhelm install -f values.custom.yaml gitpod gitpod.io/gitpod --version=0.10.0\n```\n\n\nConfigure domain and https.\n\n\nRun kubectl get pods and verify that all pods are in state RUNNING. If some are not, please see the Troubleshooting Guide.\n\n\nGo to https://&lt;your-domain.com&gt; and follow the steps to complete the installation.\n\n__SPLIT_HERE__\nUpgrade\n\nCheck the Upgrade Guide and follow the steps outlined there.\n\n\nRun the update\n\n```bash\nhelm install -f values.custom.yaml gitpod gitpod.io/gitpod --version=0.10.0\n```\n\n\nRun kubectl get pods and verify that all pods are in state RUNNING. If some are not, please see the Troubleshooting Guide.\n\n__SPLIT_HERE__\nRecommended Configuration\n\nBy default, the Helm chart installs a working Gitpod installation in a lot of scenarios. Yet, there are certain things you might want to review when installing Gitpod for long term use and/or a bigger audience:\n\nDatabase: Configure where Gitpod stores all internal runtime data.\nStorage: Configure where Gitpod persists workspace content.\nDocker Registry: Configure where Gitpod stores workspace images.\n\n__SPLIT_HERE__\nCustomization\n\nFurther customizations:\n\nKubernetes Nodes: Configure file system layout and the workspace&#39;s node associativity.\nWorkspaces: Configure workspace sizing.","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/helm-deprecated/installation/on-kubernetes"}}],["786",{"pageContent":"__SPLIT_HERE__\nInstallation requirements for Gitpod Self-Hosted\n\n‚ö†Ô∏è Deprecated Content\n\nThe content of this page assumes you are using Helm, which is now deprecated. Please use the Installer instead.\n\nThis page details the software and hardware requirements for installing Gitpod Self-Hosted on your own infrastructure.\n\n__SPLIT_HERE__\nSupported Kubernetes distributions\n\nGitpod Self-Hosted runs well on:\n\nAmazon Elastic Kubernetes Service\nGoogle Kubernetes Engine\nK3s\nMicrosoft Azure Kubernetes Service\n\n__SPLIT_HERE__\nIncompatible Kubernetes distributions\n\nThese platforms do not currently work with Gitpod Self-Hosted but we would like to support them in the future. Gitpod is an open-source project, maybe you could contribute the required changes to help get them working sooner?\n\nRed Hat¬Æ OpenShift¬Æ\nRancher Kubernetes Engine (RKE)\n\nIf you are considering purchasing a commercial license for Gitpod Self-Hosted and need one of the above platforms then please contact us to start discussions about making support for them happen sooner.\n\n__SPLIT_HERE__\nMinimum Kubernetes requirements\n\nWe strongly recommend deploying a dedicated kubernetes cluster just for Gitpod Self-Hosted.\n\nHere are the minimum requirements:\n\nEither Ubuntu 18.04 with ‚â• v5.4 kernel or Ubuntu 20.04 with ‚â• v5.4 kernel.\nCalico for the networking overlay and network policy.\nKubernetes ‚â• 1.18.\ncontainerd ‚â• 1.2.\nhelm ‚â• 3.6.\n\n__SPLIT_HERE__\nMinimum compute resources\n\nIf you want to run Gitpod Self-Hosted at home we recommend at minimum 2vCPU&#39;s and 8GB of memory. For a better experience we recommend at least 4vCPUs and 16GB RAM for workspace nodes. For cost efficiency, we recommend enabling cluster-autoscaling when running on a commercial cloud provider.\n\n__SPLIT_HERE__\nRuntime requirements\n\nDNS\n\nGitpod requires a domain (or sub-domain on a domain) that is resolvable by your name servers. As Gitpod launches services and workspaces on additional subdomains it also needs two wildcard domains.\n\nFor example:\n\n```\nyour-domain.com\n*.your-domain.com\n*.ws.your-domain.com\n```\n\nor\n\n```\ngitpod.your-domain.com\n*.gitpod.your-domain.com\n*.ws.gitpod.your-domain.com\n```\n\nIngress\n\nGitpod is designed to serve traffic directly to your local network or internet.\nWrapping Gitpod Self-Hosted behind proxies such as nginx or configurations where URLs are rewritten are not supported.\n\nSSL\n\nGitpod requires trusted HTTPS certificates. While there is no hard requirement on any certificate authority, we recommend using an ACME certificate issuer (such as ZeroSSL or LetsEncrypt) to automatically renew and install certificates as we do for gitpod.io.\nInstallation of Gitpod with SSL certificates signed with your own CA are not currently supported. This scenario is desired and we would welcome help getting this community pull-request merged.\nThe HTTPS certificates for your domain must include your-domain.com, *.your-domain.com and *.ws.your-domain.com. Beware that wildcard certificates are valid for one level only (i.e. *.a.com is not valid for c.b.a.com)\n\nStorage\n\nEither Google Cloud Storage or Amazon S3 or MinIO Storage.\n\nDatabase\n\nGitpod uses a MySQL database to store user data.\nBy default Gitpod ships with a MySQL database built-in and data is stored using a Kubernetes PersistentVolume.\nFor production settings, we recommend operating your own MySQL database (version v5.7 or newer).\n\n__SPLIT_HERE__\nSupported web browsers\n\nGitpod Self-Hosted works with the following browsers:\n\nMozilla Firefox\nGoogle Chrome\nApple Safari (iPad OS and Desktop)\nMicrosoft Edge (Chromium)","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/helm-deprecated/requirements/index"}}],["787",{"pageContent":"__SPLIT_HERE__\nTroubleshooting Gitpod Self-Hosted\n\n‚ö†Ô∏è Deprecated Content\n\nThe content of this page assumes you are using Helm, which is now deprecated. Please use the Installer instead.\n\nThis section should solve all errors that might come up during installation of Gitpod.\n\n__SPLIT_HERE__\n1. ws-daemon is stuck in Init: 0/1\n\nkubectl describe pod ws-daemon-... gives:\nMountVolume.SetUp failed for volume &quot;node-fs1&quot; : hostPath type check failed: /run/containerd/io.containerd.runtime.v1.linux/k8s.io is not a directory\n\nSolution\n\nssh onto the node, mount | grep rootfs and find the directory where your containers are stored. Common paths are:\n\n/run/containerd/io.containerd.runtime.v1.linux/k8s.io\n/run/containerd/io.containerd.runtime.v1.linux/moby\n/run/containerd/io.containerd.runtime.v2.task/k8s.io\n\n\nMerge the following into your values.custom.yaml:\n\n```\ncomponents:\n  wsDaemon:\n    containerRuntime:\n      nodeRoots:\n      - <your path here>\n```\n\n\nDo an helm upgrade --install -f values.custom.yaml gitpod gitpod.io/gitpod --version=0.10.0 to apply the changes.\n\nExample: For k3s a common configuration looks like this:\n\n```yaml\ncomponents:\n  wsDaemon:\n    containerRuntime:\n      containerd:\n        socket: /var/run/k3s/containerd/containerd.sock\n      nodeRoots:\n        - /var/run/k3s/containerd/io.containerd.runtime.v2.task/k8s.io\n```\n\n__SPLIT_HERE__\n2. helm install fails with: &quot;minio access key is required, please add a value to your values.yaml&quot;\n\nSince 0.7.0 minio requires custom credentials to be configured.\n\nSolution\n\nFollow the Upgrade Guide.\n\n__SPLIT_HERE__\n3. After upgrade, the minio Pod is stuck in ContainerCreating\n\nThis is caused by a bug in the minio Helm chart which blocks itself on updates.\n\nSolution\n\nkubectl scale deployments/minio --replicas=0\n\n\nkubectl scale deployments/minio --replicas=1\n\n\nWait until the pod comes up.\n\n__SPLIT_HERE__\n3. agent-smith daemonset fails in deployment\n\nIn the v0.10.0 release agent-smith is incorrectly enabled in Gitpod Self-Hosted.\n\nSolution\n\nAdd the following to your values.yaml file to disable agent-smith:\n\n```yaml\ncomponents:\n  agentSmith:\n    disabled: true\n```\n\n__SPLIT_HERE__\n4. Workspaces stopping once container image downloaded\n\nThis may be caused by your host operating system not supporting shiftfs. Check the ws-daemon logs for an error message like &quot;error&quot;,&quot;message&quot;:&quot;cannot mount shiftfs mark&quot; to confirm.\n\nFurther proof can be found by checking if the shiftfs kernel module is present on your host operating system:\n\n```shell\nfind /lib/modules/ -name '*shiftfs*'\n```\n\nIf this returns nothing, shiftfs is not supported by your instance and you will need to use fuse instead.\n\nSolution\n\nAdd the following to your values.yaml file to use fuse-overlayfs:\n\n```yaml\ncomponents:\n  wsDaemon:\n    userNamespaces:\n      fsShift: fuse\n```\n\n__SPLIT_HERE__\n5. Create workspace results in 7 PERMISSION_DENIED: cannot resolve workspace image error\n\nRequest createWorkspace failed with message: 7 PERMISSION_DENIED: cannot resolve workspace image: not authorized Unknown Error\n\nIf you are using the internal Docker registry, you will need to specify the username and password so your Gitpod instance can access it.\n\nSolution\n\nAdd the following to your values.yaml file to authorize the Docker registry:\n\n```yaml\ncomponents:\n  docker-registry:\n    authentication:\n      username: gitpod\n      password: gitpod\n```\n\nReplace these with your own values.","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/helm-deprecated/troubleshooting/index"}}],["788",{"pageContent":"__SPLIT_HERE__\nUpdating Gitpod Self-Hosted\n\n‚ö†Ô∏è Deprecated Content\n\nThe content of this page assumes you are using Helm, which is now deprecated. Please use the Installer instead.\n\n__SPLIT_HERE__\nUpgrading Gitpod from v0.9.0 to v0.10.0\n\ndefault registry now requires password and username\n\nGitpod by default ships with an in-cluster docker-registry. If you use that one (instead of an external one), add the following to your values.custom.yaml:\n\n```yaml\ndocker-registry:\n  authentication:\n    username: gitpod\n    password: your-registry-password\n```\n\nAfterwards, a full redeploy is required (your DB and workspace state is kept in a PV):\n\n```bash\nhelm del gitpod\nhelm upgrade --install -f values.custom.yaml gitpod gitpod.io/gitpod --version=0.10.0\n```\n\nCertificate file names changed\n\nThe file names we expect in a secret has changed. Before we&#39;d require the default names Let&#39;s Encrypt would use. Since 0.10.0 we require a tls.key and a tls.crt.\nTo adjust this in your existing installation:\n\nexecute the following inside your config folder:\n\n```\nmv secrets/https-certificates/fullchain.pem secrets/https-certificates/tls.crt\nmv secrets/https-certificates/privkey.pem secrets/https-certificates/tls.key\n```\n\nUpgrade your installation again:\n\n```bash\nhelm install -f values.custom.yaml gitpod gitpod.io/gitpod --version=0.10.0\n```\n\n__SPLIT_HERE__\nUpgrading Gitpod from v0.8.0 to v0.10.0\n\nWith version 0.10.0 there is one change that requires user action regarding the RabbitMQ messagebus:\n\nRabbitMQ now requires explicitly set password and username\n\nGitpod uses a RabbitMQ installation for distributing messages between components. So far that has been using default credentials if not configured otherwise. With v0.10.0 this is now explicitly required.\nTo do so add the following to your values.custom.yaml:\n\n```\nrabbitmq:\n  auth:\n    username: your-rabbitmq-user\n    password: your-secret-rabbitmq-password\n```\n\nIf this is not present, helm will fail with the following message:\n\nRabbitMQ username is required, please add a value to your values.yaml or with the helm flag --set rabbitmq.auth.username=xxxxx\n\n__SPLIT_HERE__\nUpgrading Gitpod from v0.6.0 to v0.7.0\n\nWith version 0.7.0 there are two major changes that require a user action. Both relate to the remote storage.\n\nBuilt-in MinIO is now accessible at minio.your-gitpod-domain.com\n\nWhen you install Gitpod on your own Kubernetes installation, it brings a built-in MinIO object storage (unless disabled). As of v0.7.0, the built-in MinIO instance is accessible at https://minio.your-gitpod-domain.com. That&#39;s the reason that (for security reasons) we do not set a default access and secret key for the built-in MinIO installation anymore. That means, you need to add your own random keys in your values files like this:\n\n```\nminio:\n  accessKey: add-a-radom-access-key-here\n  secretKey: add-a-radom-secret-key-here\n```\n\nIf you don&#39;t do this, helm will fail with the following message:\n\nminio access key is required, please add a value to your values.yaml\n\nRemote storage config has been moved to a new component\n\nIf you have a custom remote storage config (e.g. you use your own MinIO instance or the Google Cloud Storage), you need to move the config from the component wsDaemon to the new component contentService. See the Storage Guide for an example.","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/helm-deprecated/updating/index"}}],["789",{"pageContent":"The heart of this reference architecture is a Kubernetes cluster where all Gitpod components are deployed to. This cluster consists of three node pools:\n\nServices Node Pool: The Gitpod ‚Äúapp‚Äù with all its services is deployed to these nodes. These services provide the users with the dashboard and manage the provisioning of workspaces.\nRegular Workspaces Node Pool: Gitpod deploys the actual workspaces (where the actual developer work is happening) to these nodes.\nHeadless Workspace Node Pool: Gitpod deploys the imagebuild and prebuild workspaces (where build work generally demands more CPU and disk) to these needs.\n\nGitpod services, headless, and regular workspaces have vastly differing resource and isolation requirements. These workloads are separated onto different node pools to provide a better quality of service and security guarantees.\n\nYou need to assign the following labels to the node pools to enforce that the Gitpod components are scheduled to the proper node pools:","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/cluster"}}],["790",{"pageContent":"You need to assign the following labels to the node pools to enforce that the Gitpod components are scheduled to the proper node pools:\n\nNode Pool Labels\nServices Node Pool gitpod.io/workload_meta=true,gitpod.io/workload_ide=true,gitpod.io/workload_workspace_services=true\nRegular Workspace Node Pool gitpod.io/workload_workspace_regular=true\nHeadless Workspace Node Pool gitpod.io/workload_workspace_headless=true\n\nThe following table gives an overview of the node types for the different cloud providers that are used by this reference architecture.\n\nGCP AWS Azure\nServices Node Pool n2d-standard-4 m6i.xlarge Standard_D4_v4\nRegular Workspace Node Pool n2d-standard-16 m6i.4xlarge Standard_D16_v4\nHeadless Workspace Node Pool n2d-standard-16 m6i.4xlarge Standard_D16_v4\n\nFirst, we create a service account for the cluster. The service account needs to have the following roles:\n\nRoles\nroles/storage.admin\nroles/logging.logWriter\nroles/monitoring.metricWriter\nroles/container.admin","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/cluster"}}],["791",{"pageContent":"Roles\nroles/storage.admin\nroles/logging.logWriter\nroles/monitoring.metricWriter\nroles/container.admin\n\nRun the following commands to create the service account:\n\n```bash\nGKE_SA=gitpod-gke\nGKE_SA_EMAIL=\"${GKE_SA}\"@\"${PROJECT_NAME}\".iam.gserviceaccount.com\ngcloud iam service-accounts create \"${GKE_SA}\" --display-name \"${GKE_SA}\"\ngcloud projects add-iam-policy-binding \"${PROJECT_NAME}\" --member serviceAccount:\"${GKE_SA_EMAIL}\" --role=\"roles/storage.admin\"\ngcloud projects add-iam-policy-binding \"${PROJECT_NAME}\" --member serviceAccount:\"${GKE_SA_EMAIL}\" --role=\"roles/logging.logWriter\"\ngcloud projects add-iam-policy-binding \"${PROJECT_NAME}\" --member serviceAccount:\"${GKE_SA_EMAIL}\" --role=\"roles/monitoring.metricWriter\"\ngcloud projects add-iam-policy-binding \"${PROJECT_NAME}\" --member serviceAccount:\"${GKE_SA_EMAIL}\" --role=\"roles/container.admin\"\n```\n\nAfter that, we create a Kubernetes cluster.","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/cluster"}}],["792",{"pageContent":"After that, we create a Kubernetes cluster.\n\n\nImage Type UBUNTU_CONTAINERD\nMachine Type e2-standard-2\nCluster Version Choose latest from regular channel\nEnable Autoscaling,Autorepair,IP Alias,Network Policy\nDisable Autoupgrademetadata=disable-legacy-endpoints=true\nCreate Subnetwork gitpod-${CLUSTER_NAME}\nMax Pods per Node 10\nDefault Max Pods per Node 110\nMin Nodes 0\nMax Nodes 1\nAddons HorizontalPodAutoscaling,NodeLocalDNS,NetworkPolicy\nRegion Choose your region and zones\n\n```bash\nCLUSTER_NAME=gitpod\nREGION=us-central1\nGKE_VERSION=1.22.12-gke.1200","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/cluster"}}],["793",{"pageContent":"```bash\nCLUSTER_NAME=gitpod\nREGION=us-central1\nGKE_VERSION=1.22.12-gke.1200\n\ngcloud container clusters \\\n    create \"${CLUSTER_NAME}\" \\\n    --disk-type=\"pd-ssd\" --disk-size=\"50GB\" \\\n    --image-type=\"UBUNTU_CONTAINERD\" \\\n    --machine-type=\"e2-standard-2\" \\\n    --cluster-version=\"${GKE_VERSION}\" \\\n    --region=\"${REGION}\" \\\n    --service-account \"${GKE_SA_EMAIL}\" \\\n    --num-nodes=1 \\\n    --no-enable-basic-auth \\\n    --enable-autoscaling \\\n    --enable-autorepair \\\n    --no-enable-autoupgrade \\\n    --enable-ip-alias \\\n    --enable-network-policy \\\n    --create-subnetwork name=\"gitpod-${CLUSTER_NAME}\" \\\n    --metadata=disable-legacy-endpoints=true \\\n    --max-pods-per-node=110 \\\n    --default-max-pods-per-node=110 \\\n    --min-nodes=0 \\\n    --max-nodes=1 \\\n    --addons=HorizontalPodAutoscaling,NodeLocalDNS,NetworkPolicy\n```\n\nUnfortunately, you cannot create a cluster without the default node pool. Since we need a custom node pool, you need to remove the default one.","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/cluster"}}],["794",{"pageContent":"Unfortunately, you cannot create a cluster without the default node pool. Since we need a custom node pool, you need to remove the default one.\n\n```bash\ngcloud --quiet container node-pools delete default-pool \\\n    --cluster=\"${CLUSTER_NAME}\" --region=\"${REGION}\"\n```\n\nNow, we are creating a node pool for the Gitpod services.\n\n\nImage Type UBUNTU_CONTAINERD\nMachine Type n2d-standard-4\nEnable AutoscalingAutorepairIP AliasNetwork Policy\nDisable Autoupgrademetadata=disable-legacy-endpoints=true\nCreate Subnetwork gitpod-${CLUSTER_NAME}\nNumber of nodes 1\nMin Nodes 1\nMax Nodes 50\nMax Pods per Node 110\nScopes gke-default,https://www.googleapis.com/auth/ndev.clouddns.readwrite\nRegion Choose your region and zones\nNode Labels gitpod.io/workload_meta=true,gitpod.io/workload_ide=true","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/cluster"}}],["795",{"pageContent":"```bash\ngcloud container node-pools \\\n    create \"workload-services\" \\\n    --cluster=\"${CLUSTER_NAME}\" \\\n    --disk-type=\"pd-ssd\" \\\n    --disk-size=\"100GB\" \\\n    --image-type=\"UBUNTU_CONTAINERD\" \\\n    --machine-type=\"n2d-standard-4\" \\\n    --num-nodes=1 \\\n    --no-enable-autoupgrade \\\n    --enable-autorepair \\\n    --enable-autoscaling \\\n    --metadata disable-legacy-endpoints=true \\\n    --scopes=\"gke-default,https://www.googleapis.com/auth/ndev.clouddns.readwrite\" \\\n    --node-labels=\"gitpod.io/workload_meta=true,gitpod.io/workload_ide=true,gitpod.io/workload_workspace_services=true\" \\\n    --max-pods-per-node=110 \\\n    --min-nodes=1 \\\n    --max-nodes=4 \\\n    --region=\"${REGION}\"\n```\n\nWe are also creating a node pool for the Gitpod regular workspaces.","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/cluster"}}],["796",{"pageContent":"We are also creating a node pool for the Gitpod regular workspaces.\n\n\nImage Type UBUNTU_CONTAINERD\nMachine Type n2d-standard-16\nEnable Autoscaling,Autorepair,IP Alias,Network Policy\nDisable Autoupgrademetadata=disable-legacy-endpoints=true\nCreate Subnetwork gitpod-${CLUSTER_NAME}\nNumber of nodes 1\nMin Nodes 1\nMax Nodes 50\nMax Pods per Node 110\nScopes gke-default,https://www.googleapis.com/auth/ndev.clouddns.readwrite\nRegion Choose your region and zones\nNode Labels gitpod.io/workload_workspace_regular=true","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/cluster"}}],["797",{"pageContent":"```bash\ngcloud container node-pools \\\n    create \"workload-regular-workspaces\" \\\n    --cluster=\"${CLUSTER_NAME}\" \\\n    --disk-type=\"pd-ssd\" \\\n    --disk-size=\"512GB\" \\\n    --image-type=\"UBUNTU_CONTAINERD\" \\\n    --machine-type=\"n2d-standard-16\" \\\n    --num-nodes=1 \\\n    --no-enable-autoupgrade \\\n    --enable-autorepair \\\n    --enable-autoscaling \\\n    --metadata disable-legacy-endpoints=true \\\n    --scopes=\"gke-default,https://www.googleapis.com/auth/ndev.clouddns.readwrite\" \\\n    --node-labels=\"gitpod.io/workload_workspace_regular=true\" \\\n    --max-pods-per-node=110 \\\n    --min-nodes=1 \\\n    --max-nodes=50 \\\n    --region=\"${REGION}\"\n```\n\nWe are also creating a node pool for the Gitpod headless workspaces.","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/cluster"}}],["798",{"pageContent":"We are also creating a node pool for the Gitpod headless workspaces.\n\n\nImage Type UBUNTU_CONTAINERD\nMachine Type n2d-standard-16\nEnable Autoscaling,Autorepair,IP Alias,Network Policy\nDisable Autoupgrademetadata=disable-legacy-endpoints=true\nCreate Subnetwork gitpod-${CLUSTER_NAME}\nNumber of nodes 1\nMin Nodes 1\nMax Nodes 50\nMax Pods per Node 110\nScopes gke-default,https://www.googleapis.com/auth/ndev.clouddns.readwrite\nRegion Choose your region and zones\nNode Labels gitpod.io/workload_workspace_headless=true","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/cluster"}}],["799",{"pageContent":"```bash\ngcloud container node-pools \\\n    create \"workload-headless-workspaces\" \\\n    --cluster=\"${CLUSTER_NAME}\" \\\n    --disk-type=\"pd-ssd\" \\\n    --disk-size=\"512GB\" \\\n    --image-type=\"UBUNTU_CONTAINERD\" \\\n    --machine-type=\"n2d-standard-16\" \\\n    --num-nodes=1 \\\n    --no-enable-autoupgrade \\\n    --enable-autorepair \\\n    --enable-autoscaling \\\n    --metadata disable-legacy-endpoints=true \\\n    --scopes=\"gke-default,https://www.googleapis.com/auth/ndev.clouddns.readwrite\" \\\n    --node-labels=\"gitpod.io/workload_workspace_headless=true\" \\\n    --max-pods-per-node=110 \\\n    --min-nodes=1 \\\n    --max-nodes=50 \\\n    --region=\"${REGION}\"\n```\n\nNow, you can connect kubectl to your newly created cluster.\n\n```bash\ngcloud container clusters get-credentials --region=\"${REGION}\" \"${CLUSTER_NAME}\"\n```\n\nAfter that, you need to create cluster role bindings to allow the current user to create new RBAC rules.","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/cluster"}}],["800",{"pageContent":"```bash\ngcloud container clusters get-credentials --region=\"${REGION}\" \"${CLUSTER_NAME}\"\n```\n\nAfter that, you need to create cluster role bindings to allow the current user to create new RBAC rules.\n\n```bash\nkubectl create clusterrolebinding cluster-admin-binding \\\n    --clusterrole=cluster-admin \\\n    --user=\"$(gcloud config get-value core/account)\"\n```\n\nNote: By default, when Gitpod is being installed using the instructions here, EKS will create a classic load balancer that you can point your DNS entries at. If you are unable to use a AWS Classic Load Balancer (e.g. because you use SSL certificates generated by AWS), please follow the Setting up your EKS cluster with dual ALB + NLB load balancers guide alongside this reference architecture guide.","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/cluster"}}],["801",{"pageContent":"For eksctl, configuring the cluster and the node groups cannot happen simultaneously. You need to deploy the cluster control plane first, do modifications to the network stack (Calico), and then provision the node groups. This ensures you have the maximum number of pods available (110 in most cases) to run Gitpod workspaces.\n\nThe example eksctl config file includes services accounts that might not be relevant to a particular deployment, but are included for reference.\n\ncert-manager provided for the required cert-manager tooling. If using DNS-01 challenges for Let&#39;s Encrypt with a Route53 zone, then enable the cert-manager wellKnownPolicies or ensure one exists with permissions to modify records in the zone\naws-load-balancer-controller enables ELB creation for LoadBalancer services and integration with AWS Application Load Balancers\ncluster-autoscaler connects to the AWS autoscaler\nebs-csi-controller-sa enables provisioning of the EBS volumes for PVC storage","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/cluster"}}],["802",{"pageContent":"Provided below is a complete eksctl configuration file that will deploy all the components required for an EKS installation to support Gitpod. All references to a gitpod-cluster.yaml file refer to this reference.\n\neksctl will be configuring the VPC and networking along with creating the EKS cluster itself, if you need to use pre-existing networking provisioned by another team or department, refer to the custom VPC documentation.","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/cluster"}}],["803",{"pageContent":"In this reference example, the Ubuntu2004 AMI family is used instead of listing a specific AMI ID. This simplifies portability and allows for the use of the built-in bootstrap command instead of having to create a custom one. If you want to do more customization of your bootstrap command or use a static AMI, first, replace amiFamily: Ubuntu2004 with ami: ami-customid where ami-customid is from Ubuntu&#39;s EKS AMI list or the output from the below command. You will then replace preBootstrapCommands with your bootstrap script under a new section labeled overrideBootstrapCommand.\n\n```bash\naws ec2 describe-images --owners 099720109477 \\\n    --filters 'Name=name,Values=ubuntu-eks/k8s_1.22/images/*' \\\n    --query 'sort_by(Images,&CreationDate)[-1].ImageId' \\\n    --executable-users all \\\n    --output text --region us-west-2\n```\n\nRefer to eksctl&#39;s documentation on AMI Family for more information on its behavior.\n\ngitpod-cluster.yaml","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/cluster"}}],["804",{"pageContent":"Refer to eksctl&#39;s documentation on AMI Family for more information on its behavior.\n\ngitpod-cluster.yaml\n\n```yaml\napiVersion: eksctl.io/v1alpha5\nkind: ClusterConfig\nmetadata:\n  name: gitpod\n  region: eu-west-1\n  version: \"1.22\"\n  # update tags to ensure all generated resources have atleast these tags applied\n  tags:\n    department: demo\n    project: gitpod\n\niam:\n  withOIDC: true","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/cluster"}}],["805",{"pageContent":"iam:\n  withOIDC: true\n\n  serviceAccounts:\n    - metadata:\n        name: aws-load-balancer-controller\n        namespace: kube-system\n      wellKnownPolicies:\n        awsLoadBalancerController: true\n    - metadata:\n        name: ebs-csi-controller-sa\n        namespace: kube-system\n      wellKnownPolicies:\n        ebsCSIController: true\n    - metadata:\n        name: cluster-autoscaler\n        namespace: kube-system\n      wellKnownPolicies:\n        autoScaler: true\n    - metadata:\n        name: cert-manager\n        namespace: cert-manager\n      wellKnownPolicies:\n        certManager: true\n    - metadata:\n        name: external-dns\n        namespace: external-dns\n      wellKnownPolicies:\n        externalDNS: true\n\n# Uncomment and update for your region if you wish to use fewer availability zones\n# availabilityZones:\n#   - eu-west-1a\n#   - eu-west-1b\n#   - eu-west-1c","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/cluster"}}],["806",{"pageContent":"# Uncomment and update for your region if you wish to use fewer availability zones\n# availabilityZones:\n#   - eu-west-1a\n#   - eu-west-1b\n#   - eu-west-1c\n\n# By default we create a dedicated VPC for the cluster\n# You can use an existing VPC by supplying private and/or public subnets. Please check\n# https://eksctl.io/usage/vpc-networking/#use-existing-vpc-other-custom-configuration\nvpc:\n  autoAllocateIPv6: false\n  nat:\n    # For production environments use HighlyAvailable, for an initial deployment Single adequate\n    # HighlyAvailable will consume 3 Elastic IPs so ensure your region has capacity before using\n    # https://eksctl.io/usage/vpc-networking/#nat-gateway\n    gateway: Single","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/cluster"}}],["807",{"pageContent":"# Cluster endpoints and public access\n  # Private access ensures that nodes can communicate internally in case of NAT failure\n  # For customizing for your environment review https://eksctl.io/usage/vpc-cluster-access/\n  clusterEndpoints:\n    privateAccess: true\n    publicAccess: true\n  publicAccessCIDRs: [\"0.0.0.0/0\"]\n\n# Logging settings\ncloudWatch:\n  clusterLogging:\n    enableTypes: [\"*\"]\n\n# Nodegroups / Compute settings\nmanagedNodeGroups:\n  - name: services\n    amiFamily: Ubuntu2004\n    spot: false\n    instanceTypes: [\"m6i.xlarge\"]\n    desiredCapacity: 2\n    minSize: 1\n    maxSize: 4\n    maxPodsPerNode: 110\n    disableIMDSv1: false\n    volumeSize: 300\n    volumeType: gp3\n    volumeIOPS: 6000\n    volumeThroughput: 500\n    ebsOptimized: true\n    privateNetworking: true\n    propagateASGTags: true","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/cluster"}}],["808",{"pageContent":"iam:\n      attachPolicyARNs:\n        - arn:aws:iam::aws:policy/AmazonEC2ContainerRegistryReadOnly\n        - arn:aws:iam::aws:policy/AmazonEKSWorkerNodePolicy\n        - arn:aws:iam::aws:policy/AmazonEKS_CNI_Policy\n        - arn:aws:iam::aws:policy/ElasticLoadBalancingFullAccess\n        - arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore\n\n    tags:\n      k8s.io/cluster-autoscaler/enabled: \"true\"\n      # Important - If you change the name of your EKS cluster from the\n      # default cluster name (\"gitpod\"), update this tag to match\n      # your cluster (`k8s.io/cluster-autoscaler/<cluster-name>: \"owned\"`)\n      #\n      # For example: `k8s.io/cluster-autoscaler/gitpod-corp: \"owned\"`\n      k8s.io/cluster-autoscaler/gitpod: \"owned\"\n\n    labels:\n      gitpod.io/workload_meta: \"true\"\n      gitpod.io/workload_ide: \"true\"\n      gitpod.io/workload_workspace_services: \"true\"","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/cluster"}}],["809",{"pageContent":"labels:\n      gitpod.io/workload_meta: \"true\"\n      gitpod.io/workload_ide: \"true\"\n      gitpod.io/workload_workspace_services: \"true\"\n\n    preBootstrapCommands:\n      - echo \"export USE_MAX_PODS=false\" >> /etc/profile.d/bootstrap.sh\n      - echo \"export CONTAINER_RUNTIME=containerd\" >> /etc/profile.d/bootstrap.sh\n      - sed -i '/^set -o errexit/a\\\\nsource /etc/profile.d/bootstrap.sh' /etc/eks/bootstrap.sh\n\n  - name: regular-workspaces\n    amiFamily: Ubuntu2004\n    spot: false\n    instanceTypes: [\"m6i.4xlarge\"]\n    desiredCapacity: 2\n    minSize: 1\n    maxSize: 50\n    maxPodsPerNode: 110\n    disableIMDSv1: false\n    volumeSize: 512\n    volumeType: gp3\n    volumeIOPS: 6000\n    volumeThroughput: 500\n    ebsOptimized: true\n    privateNetworking: true\n    propagateASGTags: true","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/cluster"}}],["810",{"pageContent":"iam:\n      attachPolicyARNs:\n        - arn:aws:iam::aws:policy/AmazonEC2ContainerRegistryReadOnly\n        - arn:aws:iam::aws:policy/AmazonEKSWorkerNodePolicy\n        - arn:aws:iam::aws:policy/AmazonEKS_CNI_Policy\n        - arn:aws:iam::aws:policy/ElasticLoadBalancingFullAccess\n        - arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore\n\n    tags:\n      k8s.io/cluster-autoscaler/enabled: \"true\"\n      # Important - If you change the name of your EKS cluster from the\n      # default cluster name (\"gitpod\"), update the tag below to match\n      # your cluster (`k8s.io/cluster-autoscaler/<cluster-name>: \"owned\"`)\n      #\n      # For example: `k8s.io/cluster-autoscaler/gitpod-corp: \"owned\"`\n      k8s.io/cluster-autoscaler/gitpod: \"owned\"\n\n    labels:\n      gitpod.io/workload_workspace_regular: \"true\"","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/cluster"}}],["811",{"pageContent":"labels:\n      gitpod.io/workload_workspace_regular: \"true\"\n\n    preBootstrapCommands:\n      - echo \"export USE_MAX_PODS=false\" >> /etc/profile.d/bootstrap.sh\n      - echo \"export CONTAINER_RUNTIME=containerd\" >> /etc/profile.d/bootstrap.sh\n      - sed -i '/^set -o errexit/a\\\\nsource /etc/profile.d/bootstrap.sh' /etc/eks/bootstrap.sh\n  - name: headless-workspaces\n    amiFamily: Ubuntu2004\n    spot: false\n    instanceTypes: [\"m6i.4xlarge\"]\n    desiredCapacity: 2\n    minSize: 1\n    maxSize: 50\n    maxPodsPerNode: 110\n    disableIMDSv1: false\n    volumeSize: 512\n    volumeType: gp3\n    volumeIOPS: 6000\n    volumeThroughput: 500\n    ebsOptimized: true\n    privateNetworking: true\n    propagateASGTags: true","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/cluster"}}],["812",{"pageContent":"iam:\n      attachPolicyARNs:\n        - arn:aws:iam::aws:policy/AmazonEC2ContainerRegistryReadOnly\n        - arn:aws:iam::aws:policy/AmazonEKSWorkerNodePolicy\n        - arn:aws:iam::aws:policy/AmazonEKS_CNI_Policy\n        - arn:aws:iam::aws:policy/ElasticLoadBalancingFullAccess\n        - arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore\n\n    tags:\n      k8s.io/cluster-autoscaler/enabled: \"true\"\n      # Important - If you change the name of your EKS cluster from the\n      # default cluster name (\"gitpod\"), update the tag below to match\n      # your cluster (`k8s.io/cluster-autoscaler/<cluster-name>: \"owned\"`)\n      #\n      # For example: `k8s.io/cluster-autoscaler/gitpod-corp: \"owned\"`\n      k8s.io/cluster-autoscaler/gitpod: \"owned\"\n\n    labels:\n      gitpod.io/workload_workspace_headless: \"true\"","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/cluster"}}],["813",{"pageContent":"labels:\n      gitpod.io/workload_workspace_headless: \"true\"\n\n    preBootstrapCommands:\n      - echo \"export USE_MAX_PODS=false\" >> /etc/profile.d/bootstrap.sh\n      - echo \"export CONTAINER_RUNTIME=containerd\" >> /etc/profile.d/bootstrap.sh\n      - sed -i '/^set -o errexit/a\\\\nsource /etc/profile.d/bootstrap.sh' /etc/eks/bootstrap.sh\n```\n\nTo ensure there are enough IPs and networking policy enforcement is in place, this reference architecture uses Calico for networking. To enable Calico in an EKS installation it must be done after the control plane has been provisioned and before the nodegroups have been created.\n\nFirst: Run eksctl with the --without-nodegroup flag to provision just the control plane defined in the gitpod-cluster.yaml:\n\n```bash\neksctl create cluster --without-nodegroup --config-file gitpod-cluster.yaml\n```\n\nThis should result in the following output:","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/cluster"}}],["814",{"pageContent":"```bash\neksctl create cluster --without-nodegroup --config-file gitpod-cluster.yaml\n```\n\nThis should result in the following output:\n\n```bash\n2022-06-24 09:54:59 [‚Ñπ]  eksctl version 0.102.0-dev+3229f126.2022-06-17T12:44:20Z\n2022-06-24 09:54:59 [‚Ñπ]  using region eu-west-1\n2022-06-24 09:54:59 [‚Ñπ]  setting availability zones to [eu-west-1c eu-west-1a eu-west-1b]\n2022-06-24 09:54:59 [‚Ñπ]  subnets for eu-west-1c - public:192.168.0.0/19 private:192.168.96.0/19\n2022-06-24 09:54:59 [‚Ñπ]  subnets for eu-west-1a - public:192.168.32.0/19 private:192.168.128.0/19\n2022-06-24 09:54:59 [‚Ñπ]  subnets for eu-west-1b - public:192.168.64.0/19 private:192.168.160.0/19\n2022-06-24 09:54:59 [‚Ñπ]  using Kubernetes version 1.22\n[...]\n2022-06-24 10:11:30 [‚úî]  EKS cluster \"gitpod\" in \"eu-west-1\" region is ready\n```","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/cluster"}}],["815",{"pageContent":"After this command finishes, check that eksctl also created the kubeconfig properly by running the command kubectl get pods -n kube-system. If deployed correctly one should see the list of pods in a pending state.\n\n```bash\nkubectl get pods -n kube-system\n```\n\nThis should result in:\n\n```bash\nNAME                       READY   STATUS    RESTARTS   AGE\ncoredns-5947f47f5f-69lvv   0/1     Pending   0          26m\ncoredns-5947f47f5f-srm5t   0/1     Pending   0          26m\n```\n\nCalico Installation\n\nThis is following the instructions provided by Tigera.\n\nTo install Calico, first remove the default AWS-provided networking component:\n\n```bash\nkubectl delete daemonset -n kube-system aws-node\n```\n\nInstall the Calico manifest:\n\n```bash\nkubectl apply -f https://projectcalico.docs.tigera.io/manifests/calico-vxlan.yaml\n```\n\nNow configure Calico for EKS-specific support with the following command:\n\n```bash\nkubectl -n kube-system set env daemonset/calico-node FELIX_AWSSRCDSTCHECK=Disable\n```\n\nAdditional Network configuration","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/cluster"}}],["816",{"pageContent":"Now configure Calico for EKS-specific support with the following command:\n\n```bash\nkubectl -n kube-system set env daemonset/calico-node FELIX_AWSSRCDSTCHECK=Disable\n```\n\nAdditional Network configuration\n\nTo use RDS in the VPC you will need security groups created and associated with the Services nodegroup before it is launched. RDS does not have to be deployed yet but an additional security group for the Services nodegroup needs to be created and added to your gitpod-cluster.yaml before continuing.\n\nGet the ID of the cluster eksctl just created. If you kept the tag project=gitpod in the gitpod-cluster.yaml file, retrieve the id and cidr block with:\n\n```bash\naws ec2 describe-vpcs --filters \"Name=tag:project,Values=gitpod\" --query 'Vpcs[*].[VpcId, CidrBlock]'\n```\n\nThis should result in:\n\n```bash\n[\n    [\n        \"<VPC ID similar to: vpc-09a109f23dad0a298>\",\n        \"192.168.0.0/16\"\n    ]\n]\n```","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/cluster"}}],["817",{"pageContent":"This should result in:\n\n```bash\n[\n    [\n        \"<VPC ID similar to: vpc-09a109f23dad0a298>\",\n        \"192.168.0.0/16\"\n    ]\n]\n```\n\nCreate the new security group (we do not need to have rules added to it yet) using the vpc-id from above, note how tags are auto-populated to the security group as well:\n\n```bash\naws ec2 create-security-group --description 'Gitpod Services Nodegroup' --group-name 'gitpod-services' \\\n--vpc-id <!add VPC ID from above here!> --tag-specifications 'ResourceType=security-group,Tags=[{Key=Name,Value=gitpod-services-sg},{Key=project,Value=gitpod},{Key=department,Value=demo}]'\n```\n\nThis should return something similar to:\n\n```bash\n{\n    \"GroupId\": \"<GroupID, similar to: sg-04b9a5f403307efe5>\",\n    \"Tags\": [\n        {\n            \"Key\": \"project\",\n            \"Value\": \"gitpod\"\n        },\n        {\n            \"Key\": \"department\",\n            \"Value\": \"demo\"\n        }\n    ]\n}\n```","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/cluster"}}],["818",{"pageContent":"Update your gitpod-cluster.yaml to add the GroupId from the previous command to the securityGroups.attachIDs list in the services managedNodeGroups:\n\n```yaml\nsecurityGroups:\n  attachIDs: [\"<Add your GroupId here, similar to: sg-04b9a5f403307efe5\"]\n```\n\nStore the GroupID for easier reuse when creating the RDS instance later in this guide:\n\n```bash\nexport SERVICES_SECURITYGROUP_ID=\"<add GroupID from above here, similar to: sg-04b9a5f403307efe5>\"\n```\n\nIf you destroy this cluster and recreate it, you will need to redo the above step as the old security group would have been deleted along with the VPC.\n\nSSH Access to nodegroups\n\neksctl allows for ssh keys to be added to your nodegroups for troubleshooting. By default, the gitpod-cluster.yaml does not configure this. AWS Systems Manager is enabled by default, allowing for connectivity through multiple methods to each instance in your nodegroup.\n\nCreate nodegroups","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/cluster"}}],["819",{"pageContent":"Create nodegroups\n\nTo ensure that if there are problems deploying the services nodegroup (you provided an incorrect security group ID for example) it can be deleted easily and not require having to delete a partially deployed workspaces nodegroup, create it before the workspaces nodegroup.\n\nCreate the services nodegroups with eksctl create nodegroup --include=services --config-file gitpod-cluster.yaml:\n\n```bash\neksctl create nodegroup --include=services --config-file gitpod-cluster.yaml\n```\n\nThis should result in:","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/cluster"}}],["820",{"pageContent":"```bash\neksctl create nodegroup --include=services --config-file gitpod-cluster.yaml\n```\n\nThis should result in:\n\n```bash\n2022-06-24 13:42:01 [‚Ñπ]  nodegroup \"services\" will use \"ami-0793b4124359a6ad7\" [Ubuntu2004/1.22]\n2022-06-24 13:42:01 [‚Ñπ]  nodegroup \"regular-workspaces\" will use \"ami-0793b4124359a6ad7\" [Ubuntu2004/1.22]\n2022-06-24 13:42:01 [‚Ñπ]  nodegroup \"headless-workspaces\" will use \"ami-0793b4124359a6ad7\" [Ubuntu2004/1.22]\n2022-06-24 13:42:03 [‚Ñπ]  combined include rules: services\n2022-06-24 13:42:03 [‚Ñπ]  1 nodegroup (services) was included (based on the include/exclude rules)\n2022-06-24 13:42:03 [‚Ñπ]  will create a CloudFormation stack for each of 1 managed nodegroups in cluster \"gitpod\"\n[...]\n2022-06-24 13:46:22 [‚úî]  created 1 managed nodegroup(s) in cluster \"gitpod\"\n2022-06-24 13:46:24 [‚Ñπ]  checking security group configuration for all nodegroups\n2022-06-24 13:46:24 [‚Ñπ]  all nodegroups have up-to-date cloudformation templates\n```","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/cluster"}}],["821",{"pageContent":"Create the workspaces nodegroups second if the services are deployed correctly.\n\n```bash\neksctl create nodegroup --include=regular-workspaces,headless-workspaces --config-file gitpod-cluster.yaml\n```","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/cluster"}}],["822",{"pageContent":"```bash\n2022-06-24 13:55:08 [‚Ñπ]  nodegroup \"services\" will use \"ami-0793b4124359a6ad7\" [Ubuntu2004/1.22]\n2022-06-24 13:55:08 [‚Ñπ]  nodegroup \"regular-workspaces\" will use \"ami-0793b4124359a6ad7\" [Ubuntu2004/1.22]\n2022-06-24 13:55:08 [‚Ñπ]  nodegroup \"headless-workspaces\" will use \"ami-0793b4124359a6ad7\" [Ubuntu2004/1.22]\n2022-06-24 13:55:13 [‚Ñπ]  1 existing nodegroup(s) (services) will be excluded\n2022-06-24 13:55:13 [‚Ñπ]  combined include rules: regular-workspaces,headless-workspaces\n2022-06-24 13:55:13 [‚Ñπ]  2 nodegroups (headless-workspaces, regular-workspaces) were included (based on the include/exclude rules)\n2022-06-24 13:55:13 [‚Ñπ]  will create a CloudFormation stack for each of 2 managed nodegroups in cluster \"gitpod\"\n[...]\n2022-06-24 13:59:10 [‚úî]  created 2 managed nodegroup(s) in cluster \"gitpod\"\n2022-06-24 13:59:13 [‚Ñπ]  checking security group configuration for all nodegroups\n2022-06-24 13:59:13 [‚Ñπ]  all nodegroups have up-to-date cloudformation templates\n```","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/cluster"}}],["823",{"pageContent":"You can verify that your installation was deployed properly with the custom kubectl command provided below which will let you review maxpods, kernel and containerd versions to ensure they are meeting our minimum requirements as intended.\n\n```bash\nkubectl get nodes -o=custom-columns=\"NAME:.metadata.name,\\\nNODEGROUP:.metadata.labels.eks\\.amazonaws\\.com/nodegroup,\\\nRUNTIME:.status.nodeInfo.containerRuntimeVersion,\\\nMAXPODS:.status.capacity.pods,\\\nKERNEL:.status.nodeInfo.kernelVersion,\\\nAMIFAMILY:.status.nodeInfo.osImage,\\\nK8S:.status.nodeInfo.kubeletVersion,\\\nInstance-ID:.spec.providerID\"\n```\n\nBecause of how EKS launches instances, coredns may end up running on a single node, which is against best practices. Before continuing to the next steps, restart coredns to ensure it is running on two nodes.\n\n```bash\nkubectl rollout restart deployment.apps/coredns -n kube-system\n```\n\nEnable cluster autoscaling","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/cluster"}}],["824",{"pageContent":"```bash\nkubectl rollout restart deployment.apps/coredns -n kube-system\n```\n\nEnable cluster autoscaling\n\nGitpod&#39;s resource usage will vary depending on the number of active workspaces and image prebuilds during the day. The use of a cluster autoscaler is recommended to scale EKS nodes on demand and thus minimize the cost you pay.\n\n```bash\nCLUSTER_NAME=\"gitpod\"\nAWS_REGION=\"eu-west-1\"","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/cluster"}}],["825",{"pageContent":"```bash\nCLUSTER_NAME=\"gitpod\"\nAWS_REGION=\"eu-west-1\"\n\nhelm repo add autoscaler https://kubernetes.github.io/autoscaler\nhelm repo update\nhelm upgrade \\\n    --atomic \\\n    --cleanup-on-fail \\\n    --install \\\n    --namespace kube-system \\\n    --reset-values \\\n    --wait \\\n    --set cloudProvider=aws \\\n    --set awsRegion=$AWS_REGION \\\n    --set autoDiscovery.clusterName=$CLUSTER_NAME \\\n    --set rbac.serviceAccount.create=false \\\n    --set rbac.serviceAccount.name=cluster-autoscaler \\\n    --set securityContext.fsGroup=65534 \\\n    --set extraArgs.skip-nodes-with-local-storage=false \\\n    --set extraArgs.skip-nodes-with-system-pods=false \\\n    --set extraArgs.expander=least-waste \\\n    --set extraArgs.balance-similar-node-groups=true \\\n    --set extraArgs.scale-down-utilization-threshold=0.2 \\\n    --set extraArgs.v=2 \\\n    autoscaler autoscaler/cluster-autoscaler\n```\n\nDeleting the cluster","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/cluster"}}],["826",{"pageContent":"Deleting the cluster\n\nIn the future to delete this cluster any additional resources added to the VPC will need to be deleted before deleting the cluster, otherwise, cloudformations will fail to delete the VPC and complete deleting the cluster. The alternative is to create a VPC managed separately and install EKS using the additions for working with existing VPCs in eksctl.\n\nThe order resources to delete if created:\n\nRDS First\nRDS security group\nServices Nodegroup\nServices security group\neksctl delete cluster\n\nFull removal of these installed components would look something like this (commands are grouped for brevity):\n\n```bash\n#### delete RDS resources\naws rds delete-db-instance --db-instance-identifier gitpod-instance --skip-final-snapshot --delete-automated-backups\naws ec2 delete-security-group --group-id sg-0e538ccac25bb1387\naws rds delete-db-subnet-group --db-subnet-group-name gitpod-rds","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/cluster"}}],["827",{"pageContent":"#### delete the services node group\neksctl delete nodegroup --name services --cluster gitpod --disable-eviction --parallel 4 --max-grace-period 0s --wait\n\n#### delete the security group added for rds\naws ec2 delete-security-group --group-id sg-04b9a5f403307efe5\neksctl delete cluster --name gitpod --force --disable-nodegroup-eviction --wait\n\n#### The following removal steps are optional; if you plan on creating another Gitpod installation then the S3 bucket,\n#### access account, key, and policy can be kept for later use.\n\n#### delete s3 resources\naws s3 rm s3://${S3_BUCKET_NAME} --recursive\naws s3 rb s3://${S3_BUCKET_NAME} --force\n\n#### delete iam resources\naws iam detach-user-policy --user-name gitpod-s3-access --policy-arn 'arn:aws:iam::12344:policy/gitpod_s3_access_policy'\n\n# delete access keys:\naws iam list-access-keys --user-name gitpod-s3-access\naws iam delete-access-key --user-name gitpod-s3-access --access-key-id AKI---------\naws iam delete-user --user-name gitpod-s3-access","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/cluster"}}],["828",{"pageContent":"# ensure that nothing else is attached to this policy\naws iam list-entities-for-policy --policy-arn 'arn:aws:iam::12344:policy/gitpod_s3_access_policy'\naws iam delete-policy --policy-arn 'arn:aws:iam::12344:policy/gitpod_s3_access_policy'\n```\n\nThis section will create a Kubernetes cluster based on the latest supported version of AKS, create node pools for Gitpod services, regular workspaces, and headless workspaces, and will fetch cluster credentials.\n\nFirst, determine the latest version of AKS suitable for Gitpod.\n\nGitpod supports Kubernetes 1.21 or later, but using the latest supported version of AKS is recommended.\n\n```bash\nAKS_VERSION=$(az aks get-versions \\\n    --location $LOCATION \\\n    --query \"orchestrators[?contains(orchestratorVersion, '1.24.')].orchestratorVersion | [-1]\" -o tsv)\n```\n\nCreate the AKS cluster and a default node pool. Gitpod services and other supporting components will run on this node pool.","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/cluster"}}],["829",{"pageContent":"Create the AKS cluster and a default node pool. Gitpod services and other supporting components will run on this node pool.\n\n```bash\naz aks create \\\n    --name \"${CLUSTER_NAME}\" \\\n    --nodepool-name \"services\" \\\n    --location \"${LOCATION}\" \\\n    --resource-group \"${RESOURCE_GROUP}\" \\\n    --kubernetes-version \"${AKS_VERSION}\" \\\n    --network-plugin kubenet \\\n    --network-policy calico \\\n    --enable-cluster-autoscaler \\\n    --enable-managed-identity \\\n    --min-count \"1\" \\\n    --max-count \"4\" \\\n    --max-pods \"110\" \\\n    --node-osdisk-size \"100\" \\\n    --node-vm-size \"Standard_D4_v4\" \\\n    --nodepool-labels \\\n        gitpod.io/workload_meta=true \\\n        gitpod.io/workload_ide=true \\\n        gitpod.io/workload_workspace_services=true \\\n    --no-ssh-key \\\n    --vm-set-type \"VirtualMachineScaleSets\"\n```\n\nCreate a node pool for regular workspaces.","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/cluster"}}],["830",{"pageContent":"Create a node pool for regular workspaces.\n\n```bash\naz aks nodepool add \\\n    --name \"regularws\" \\\n    --cluster-name \"${CLUSTER_NAME}\" \\\n    --resource-group \"${RESOURCE_GROUP}\" \\\n    --kubernetes-version \"${AKS_VERSION}\" \\\n    --labels gitpod.io/workload_workspace_regular=true \\\n    --enable-cluster-autoscaler \\\n    --min-count \"1\" \\\n    --max-count \"50\" \\\n    --max-pods \"110\" \\\n    --node-osdisk-size \"512\" \\\n    --node-vm-size \"Standard_D16_v4\"\n```\n\nCreate a node pool for headless workspaces.\n\n```bash\naz aks nodepool add \\\n    --name \"headlessws\" \\\n    --cluster-name \"${CLUSTER_NAME}\" \\\n    --resource-group \"${RESOURCE_GROUP}\" \\\n    --kubernetes-version \"${AKS_VERSION}\" \\\n    --labels gitpod.io/workload_workspace_headless=true \\\n    --enable-cluster-autoscaler \\\n    --node-count \"1\" \\\n    --min-count \"1\" \\\n    --max-count \"50\" \\\n    --max-pods \"110\" \\\n    --node-osdisk-size \"512\" \\\n    --node-vm-size \"Standard_D16_v4\"\n```","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/cluster"}}],["831",{"pageContent":"After the cluster and node pools have been created, fetch the AKS credentials. These credentials will be used to install external-dns, cert-manager, and install Gitpod itself.\n\n```bash\naz aks get-credentials \\\n    --name \"${CLUSTER_NAME}\" \\\n    --resource-group \"${RESOURCE_GROUP}\" \\\n    --overwrite-existing\n```","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/cluster"}}],["832",{"pageContent":"Gitpod uses a relational database management system to store structural data. Gitpod supports MySQL. The database is a central component in Gitpod where all metadata about users and workspaces as well as settings of the Gitpod instance (such as auth providers) are stored. That makes the database a critical component. In case of a database outage, you will not be able to log in, use the Gitpod dashboard, or start workspaces.\n\nIn this reference architecture, we use managed MYSQL databases provided by cloud providers.\n\nGitpod requires your database instance to have a database named gitpod in it.\n\nAs a relational database, we create a Google Cloud SQL instance with MySQL 5.7. Use the following commands to create the database instance:","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/database"}}],["833",{"pageContent":"As a relational database, we create a Google Cloud SQL instance with MySQL 5.7. Use the following commands to create the database instance:\n\n```bash\nMYSQL_INSTANCE_NAME=gitpod-mysql\ngcloud sql instances create \"${MYSQL_INSTANCE_NAME}\" \\\n    --database-version=MYSQL_5_7 \\\n    --storage-size=20 \\\n    --storage-auto-increase \\\n    --tier=db-n1-standard-2 \\\n    --region=\"${REGION}\" \\\n    --replica-type=FAILOVER \\\n    --enable-bin-log\n\ngcloud sql instances patch \"${MYSQL_INSTANCE_NAME}\" --database-flags \\\n            explicit_defaults_for_timestamp=off\n```\n\nAfter that, we create the database named gitpod as well as a dedicated Gitpod database user with a random password.\n\n```bash\ngcloud sql databases create gitpod --instance=\"${MYSQL_INSTANCE_NAME}\"\n\nMYSQL_GITPOD_USERNAME=gitpod\nMYSQL_GITPOD_PASSWORD=$(openssl rand -base64 20)\ngcloud sql users create \"${MYSQL_GITPOD_USERNAME}\" \\\n    --instance=\"${MYSQL_INSTANCE_NAME}\" \\\n    --password=\"${MYSQL_GITPOD_PASSWORD}\"\n```","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/database"}}],["834",{"pageContent":"Finally, you need to create a service account that has the roles/cloudsql.client role:\n\n```bash\nMYSQL_SA=gitpod-mysql\nMYSQL_SA_EMAIL=\"${MYSQL_SA}\"@\"${PROJECT_NAME}\".iam.gserviceaccount.com\ngcloud iam service-accounts create \"${MYSQL_SA}\" --display-name \"${MYSQL_SA}\"\ngcloud projects add-iam-policy-binding \"${PROJECT_NAME}\" \\\n    --member serviceAccount:\"${MYSQL_SA_EMAIL}\" --role=\"roles/cloudsql.client\"\n```\n\nSave the service account key to the file ./mysql-credentials.json:\n\n```bash\ngcloud iam service-accounts keys create --iam-account \"${MYSQL_SA_EMAIL}\" \\\n    ./mysql-credentials.json\n```\n\nWe will create an RDS MySQL db.m5g.large instance running MySQL 5.7. Before deploying an RDS instance, additional configuration has to be done to the VPC created by the eksctl command:\n\nCreate an RDS security group\n\nFirst, find the subnet IDs for the public subnets in your environment. For deploying RDS in private subnets replace true with false in the below command:","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/database"}}],["835",{"pageContent":"Create an RDS security group\n\nFirst, find the subnet IDs for the public subnets in your environment. For deploying RDS in private subnets replace true with false in the below command:\n\n```bash\naws ec2 describe-subnets \\\n    --filters \"Name=tag:project,Values=gitpod\" \\\n    --query 'Subnets[?MapPublicIpOnLaunch==`true`] | [*].[SubnetId, AvailabilityZone, CidrBlock, MapPublicIpOnLaunch]'\n```\n\nThis should give you an output similar to the following:\n\n```bash\n[\n    [\n        \"<SubnetID, similar to: subnet-0686443f3f2782453>\",\n        \"eu-west-1a\",\n        \"192.168.64.0/19\",\n        true\n    ],\n    [\n        \"<SubnetID, similar to: subnet-010ea25d0e398f6df>\",\n        \"eu-west-1c\",\n        \"192.168.0.0/19\",\n        true\n    ],\n    [\n        \"<SubnetID, similar to: subnet-0f0370a5697d85df2>\",\n        \"eu-west-1b\",\n        \"192.168.32.0/19\",\n        true\n    ]\n]\n```\n\nUsing the three subnet IDs, create an RDS subnet group, with the name gitpod-rds:","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/database"}}],["836",{"pageContent":"Using the three subnet IDs, create an RDS subnet group, with the name gitpod-rds:\n\n```bash\naws rds create-db-subnet-group \\\n    --db-subnet-group-name gitpod-rds \\\n    --db-subnet-group-description \"Subnet for the Gitpod RDS deployment in VPC\" \\\n    --subnet-ids '[ \"<SubnetID 1 from above, similar to: subnet-0686443f3f2782453>\", \"SubnetID 2 from above, similar to: subnet-010ea25d0e398f6df>\", \"SubnetID 3 from above, similar to: subnet-0f0370a5697d85df2>\" ]' \\\n    --tags Key=project,Value=gitpod\n```\n\nNow you will need to create a security group for the RDS instance, running a similar command as before. Note you can get your vpc-id via:\n\n```bash\naws ec2 describe-vpcs --filters \"Name=tag:project,Values=gitpod\" --query 'Vpcs[*].[VpcId, CidrBlock]'\n```\n\nCreate the security group for the RDS instance:","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/database"}}],["837",{"pageContent":"```bash\naws ec2 describe-vpcs --filters \"Name=tag:project,Values=gitpod\" --query 'Vpcs[*].[VpcId, CidrBlock]'\n```\n\nCreate the security group for the RDS instance:\n\n```bash\naws ec2 create-security-group --description 'Gitpod RDS' --group-name 'gitpod-rds' \\\n    --vpc-id <your VPC ID, similar to: vpc-09a109f23dad0a298> \\\n    --tag-specifications 'ResourceType=security-group,Tags=[{Key=Name,Value=gitpod-rds-sg},{Key=project,Value=gitpod},{Key=department,Value=demo}]'\n```\n\nThis should return an output that is similar to:\n\n```bash\n{\n    \"GroupId\": \"<GroupID similar to: sg-0e538ccac25bb1387>\",\n    \"Tags\": [\n        {\n            \"Key\": \"project\",\n            \"Value\": \"gitpod\"\n        },\n        {\n            \"Key\": \"department\",\n            \"Value\": \"demo\"\n        }\n    ]\n}\n```","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/database"}}],["838",{"pageContent":"You can now update the ingress policy for the RDS group to allow for incoming connections from the Services nodegroup on port 3306, the MySQL port. This uses the services security group ID stored in an environment variable in the cluster section above:\n\n```bash\naws ec2 authorize-security-group-ingress \\\n    --group-id <RDS securitygroup ID from above> \\\n    --protocol tcp --port 3306 \\\n    --source-group ${SERVICES_SECURITYGROUP_ID}\\\n    --tag-specifications 'ResourceType=security-group-rule,Tags=[{Key=Name,Value=rds-access},{Key=project,Value=gitpod},{Key=department,Value=demo}]'\n```\n\nNow you can create a password to use for MySQL. This will be required for the creation of the RDS instance and later for use by the Gitpod installer:\n\n```bash\nexport MYSQL_GITPOD_PW=$(openssl rand -hex 18)\necho $MYSQL_GITPOD_PW\n```\n\nNow you can create the Multi-AZ RDS instance using the MySQL password, the security group, and RDS subnet you created in the previous steps:","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/database"}}],["839",{"pageContent":"Now you can create the Multi-AZ RDS instance using the MySQL password, the security group, and RDS subnet you created in the previous steps:\n\n```bash\naws rds create-db-instance \\\n    --db-name gitpod \\\n    --db-instance-identifier gitpod-instance \\\n    --db-instance-class db.m5.large \\\n    --db-subnet-group-name gitpod-rds \\\n    --vpc-security-group-ids sg-0e538ccac25bb1387 \\\n    --multi-az \\\n    --engine mysql \\\n    --allocated-storage 20 \\\n    --max-allocated-storage 120 \\\n    --master-username gitpod \\\n    --master-user-password $MYSQL_GITPOD_PW \\\n    --engine-version 5.7 \\\n    --tags Key=project,Value=gitpod Key=Name,Value=Gitpod-MySQLDB,Key=department,Value=demo\n```\n\nThis should return an output similar to the following:","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/database"}}],["840",{"pageContent":"This should return an output similar to the following:\n\n```bash\n{\n    \"DBInstance\": {\n        \"DBInstanceIdentifier\": \"gitpod-instance\",\n        \"DBInstanceClass\": \"db.m5.large\",\n        \"Engine\": \"mysql\",\n        \"DBInstanceStatus\": \"creating\",\n        \"MasterUsername\": \"gitpod\",\n        \"DBName\": \"gitpod\",\n        \"AllocatedStorage\": 20,\n        \"PreferredBackupWindow\": \"22:11-22:41\",\n        \"BackupRetentionPeriod\": 1,\n        \"DBSecurityGroups\": [],\n        \"VpcSecurityGroups\": [\n[...]\n```\n\nTo check whether instance creation has compeleted, and to retrieve the URL to use, run this command:\n\n```bash\naws rds describe-db-instances \\\n    --db-instance-identifier gitpod-instance \\\n    --query 'DBInstances[0].[DBInstanceStatus,Endpoint.Address]'\n```\n\nReturning:\n\n```bash\n[\n    \"modifying\",\n    \"<instance endpoint, similar to: gitpod-instance.coynfywwqpjg.eu-west-1.rds.amazonaws.com>\"\n]\n```\n\nStore the MySQL instance endpoint for later use in the Gitpod installer:","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/database"}}],["841",{"pageContent":"```bash\n[\n    \"modifying\",\n    \"<instance endpoint, similar to: gitpod-instance.coynfywwqpjg.eu-west-1.rds.amazonaws.com>\"\n]\n```\n\nStore the MySQL instance endpoint for later use in the Gitpod installer:\n\n```bash\nexport MYSQL_RDS_ENDPOINT=\"$(aws rds describe-db-instances --db-instance-identifier gitpod-instance --query 'DBInstances[0].Endpoint.Address' --output text)\"\n```\n\nThis section will create an Azure MySQL server instance and database for Gitpod. This external database is required to run a Gitpod cluster for production purposes. Using a dedicated MySQL instance for Gitpod is recommended but a pre-existing MySQL instance may be used if it can host databases named gitpod and gitpod-sessions.\n\nFirst, set a MySQL server name. Azure MySQL server names must be universally unique; we recommend using a random value to avoid conflicts. Note this value for later use.\n\n```bash\nexport MYSQL_INSTANCE_NAME=\"gitpod$(openssl rand -hex 4)\"\necho \"$MYSQL_INSTANCE_NAME\"\n```","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/database"}}],["842",{"pageContent":"```bash\nexport MYSQL_INSTANCE_NAME=\"gitpod$(openssl rand -hex 4)\"\necho \"$MYSQL_INSTANCE_NAME\"\n```\n\nSet the gitpod MySQL username and password. The username of gitpod is recommended but is not required.\n\n```bash\nexport MYSQL_GITPOD_USERNAME=\"gitpod\"\nexport MYSQL_GITPOD_PASSWORD=$(openssl rand -base64 20)\necho \"$MYSQL_GITPOD_PASSWORD\"\n```\n\nWith the generated instance name and password, create the Azure MySQL server.\n\n```bash\n az mysql server create \\\n    --name \"${MYSQL_INSTANCE_NAME}\" \\\n    --resource-group \"${RESOURCE_GROUP}\" \\\n    --location \"${LOCATION}\" \\\n    --admin-user \"${MYSQL_USERNAME}\" \\\n    --admin-password \"${MYSQL_GITPOD_PASSWORD}\" \\\n    --auto-grow Enabled \\\n    --public Enabled \\\n    --sku-name GP_Gen5_2 \\\n    --ssl-enforcement Disabled \\\n    --storage-size 20480 \\\n    --version \"5.7\"\n```\n\nAfter creating the MySQL server create a database called gitpod. When Gitpod is installed it will create an additional database called gitpod-sessions.","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/database"}}],["843",{"pageContent":"After creating the MySQL server create a database called gitpod. When Gitpod is installed it will create an additional database called gitpod-sessions.\n\n```bash\naz mysql db create \\\n  --name gitpod \\\n  --resource-group \"${RESOURCE_GROUP}\" \\\n  --server-name \"${MYSQL_INSTANCE_NAME}\"\n```\n\nCreate a MySQL firewall rule allowing access from your AKS cluster to the MySQL database.\n\nüí° MySQL firewall rules with a start IP address of 0.0.0.0 and an end IP address of 0.0.0.0 restrict access to Azure resources. This is necessary to allow your Kubernetes cluster to connect to the database.\nSee the Azure MySQL firewall API documentation for more information.\n\n```bash\naz mysql server firewall-rule create \\\n --name \"Azure_Resources\" \\\n --server-name \"${MYSQL_INSTANCE_NAME}\" \\\n --resource-group \"${RESOURCE_GROUP}\" \\\n --start-ip-address \"0.0.0.0\" \\\n --end-ip-address \"0.0.0.0\"\n```","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/database"}}],["844",{"pageContent":"Congratulations. You have set up your cluster. Now, you are ready to install Gitpod. Follow the instructions in the installation guide.\n\nIf you followed the steps to create your infrastructure on GCP of this guide, you need to use the following config settings for your Gitpod installation:\n\nGeneral settings\nDomain name value of $DOMAIN_NAME\n\nUn-select the in-cluster container registry checkbox.\n\nContainer registry\nIn-cluster no\nContainer registry URL gcr.io/${PROJECT_NAME}/gitpod(replace ${PROJECT_NAME} with your GCP project name)\nContainer registry server gcr.io\nContainer registry username _json_key\nContainer registry password Content of file ./gs-credentials.jsonRemove linebreaks, e.g. with jq -c . ./gs-credentials.json\n\nUn-select the in-cluster MySQL checkbox.","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/install"}}],["845",{"pageContent":"Un-select the in-cluster MySQL checkbox.\n\nDatabase\nIn-cluster no\nGoogle Cloud SQL Proxy yes\nCloudSQL connection name ${PROJECT_NAME}:${REGION}:${MYSQL_INSTANCE_NAME}Replace variables with actual values!\nUsername value of ${MYSQL_GITPOD_USERNAME}\nPassword value of ${MYSQL_GITPOD_PASSWORD}\nGCP service account key Upload file ./mysql-credentials.json\n\nSelect GCP as object storage provider.\n\nObject storage\nStorage provider GCP\nStorage region value of ${REGION}\nProject ID value of ${PROJECT_NAME}\nService account key Upload file ./gs-credentials.json\n\nKeep cert-manager selected for the TLS certificates options.\n\nTLS certificates\nSelf-signed TLS certificate no\ncert-manager yes\nIssuer name gitpod-issuer\nIssuer type Select ‚Äúcluster issuer‚Äù\n\nIf you followed the steps to create your infrastructure on the AWS portion of this guide, you need to use the following config settings for your Gitpod installation:\n\nGeneral Settings\nDomain name value of $DOMAIN_NAME","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/install"}}],["846",{"pageContent":"General Settings\nDomain name value of $DOMAIN_NAME\n\nSelect the in-cluster registry checkbox, and select the S3 storage provider.\n\nContainer registry\nStorage region The S3 bucket region (such as eu-west-1)\nStorage endpoint s3.${S3_BUCKET_REGION}.amazonaws.com(Replace ${S3_BUCKET_REGION} with the s3 bucket region)\nS3 bucket name value of ${S3_BUCKET_NAME}\nS3 access key value of AccessKeyId\nS3 secret key value of SecretAccessKey\n\nUnselect the Use MySQL in-cluster checkbox and also make sure that the Use Google Cloud SQL Proxy checkbox is not selected.\n\nDatabase\nHostname value of ${MYSQL_RDS_ENDPOINT}\nUsername gitpod\nPassword value of ${MYSQL_GITPOD_PW}\n\nSelect S3 as the object storage provider.\n\nObject storage\nStorage region The S3 bucket region (such as eu-west-1)\nStorage endpoint s3.${S3_BUCKET_REGION}.amazonaws.com(Replace ${S3_BUCKET_REGION} with the s3 bucket region)\nS3 bucket name value of ${S3_BUCKET_NAME}\nS3 access key value of AccessKeyId\nS3 secret key value of SecretAccessKey","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/install"}}],["847",{"pageContent":"Keep cert-manager selected for the TLS certificates options.\n\nTLS certificates\nSelf-signed TLS certificate no\ncert-manager yes\nIssuer name gitpod-issuer\nIssuer type Select ‚Äúcluster issuer‚Äù\n\nIf you followed the steps to create your infrastructure on the Azure portion of this guide, use the following config settings for your Gitpod installation:\n\nGeneral Settings\nDomain name value of $DOMAIN_NAME\n\nUn-select the in-cluster container registry checkbox.\n\nContainer registry\nIn-cluster no\nContainer registry URL Value of ${AZURE_REGISTRY_URL}\nContainer registry server Leave empty\nContainer registry username Value of ${AZURE_REGISTRY_USERNAME}\nContainer registry password Value of ${AZURE_REGISTRY_PASSWORD}\n\nUn-select the in-cluster MySQL checkbox.","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/install"}}],["848",{"pageContent":"Un-select the in-cluster MySQL checkbox.\n\nDatabase\nIn-cluster no\nGoogle Cloud SQL Proxy unchecked\nHost ${MYSQL_INSTANCE_NAME}.mysql.database.azure.com (Replace ${MYSQL_INSTANCE_NAME} with the Azure database name)\nUsername Value of ${MYSQL_GITPOD_USERNAME}@${MYSQL_INSTANCE_NAME}\nPassword value of ${MYSQL_GITPOD_PASSWORD}\nPassword Use default value (3306)\n\nSelect Azure as the object storage provider.\n\nObject storage\nStorage region value of ${LOCATION}\nAccount name value of ${STORAGE_ACCOUNT_NAME}\nAccess key value of ${STORAGE_ACCOUNT_KEY}\n\nKeep cert-manager selected for the TLS certificates options.\n\nTLS certificates\nSelf-signed TLS certificate no\ncert-manager yes\nIssuer name gitpod-issuer\nIssuer type Select ‚Äúcluster issuer‚Äù","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/install"}}],["849",{"pageContent":"For each Gitpod installation, you need a domain. In this guide, we use gitpod.example.com as a placeholder for your domain. Gitpod also uses different subdomains for some components as well as dynamically for the running workspaces. That&#39;s why you need to configure your DNS server and your TLS certificates for your Gitpod domain with the following wildcards:\n\n```\ngitpod.example.com\n*.gitpod.example.com\n*.ws.gitpod.example.com\n```\n\nCluster ports\n\nThe entry point for all traffic is the proxy component which has a service of type LoadBalancer that allows inbound traffic on ports 80 (HTTP) and 443 (HTTPS) as well as port 22 (SSH access to the workspaces).\n\nSSH access is required to work with desktop IDEs, such as VS Code Desktop and JetBrains via JetBrains Gateway. To enable SSH, your load balancer needs to be capable of working with L4 protocols.","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/networking"}}],["850",{"pageContent":"SSH access is required to work with desktop IDEs, such as VS Code Desktop and JetBrains via JetBrains Gateway. To enable SSH, your load balancer needs to be capable of working with L4 protocols.\n\nIn this guide, we use load balancing through a standalone network endpoint group (NEG). For this, the Gitpod proxy service will get the following annotation by default:\n\n```bash\ncloud.google.com/neg: '{\"exposed_ports\": {\"80\":{},\"443\": {}}}'\n```\n\nFor Gitpod, we support Calico as CNI only. You need to make sure that you DO NOT use GKE Dataplan V2. That means, do not add the --enable-dataplane-v2 flag during the cluster creation.\n\nIt is suggested to create a dedicated VPC (and EKS instance) for Gitpod. eksctl can do this for you, but if VPCs have to be configured separately, follow eksctl‚Äôs suggestions.\n\nNote: You can also customize eksctl‚Äôs vpc creation to suit your existing configurations.","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/networking"}}],["851",{"pageContent":"Note: You can also customize eksctl‚Äôs vpc creation to suit your existing configurations.\n\nThe VPC needs public and private subnets. All managed node groups and Gitpod services should run in the private subnet. Inbound access to the services should be through ALB/ELB services auto-provisioned by AWS based on the configuration used (standard LoadBalancer roles or creation of an Ingress). If running a jump host or VPN endpoint, it should be deployed in the public subnet.\n\nBy default, when Gitpod is being installed, EKS will create a classic load balancer that you can point your DNS entries at. If you are unable to use a AWS Classic Load Balancer (e.g. because you use SSL certificates generated by AWS), please follow the Setting up your EKS cluster with dual ALB + NLB load balancers guide alongside this reference architecture guide.\n\nIf installing Calico, follow their installation steps and ensure you modify the hostNetwork: True option on the cert-manager installation options later.","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/networking"}}],["852",{"pageContent":"If installing Calico, follow their installation steps and ensure you modify the hostNetwork: True option on the cert-manager installation options later.\n\nAzure automatically provisions Azure public load balancers that load balance public Gitpod services and provide public Internet connectivity for Gitpod&#39;s workloads. No additional configuration is required.\n\nExternal DNS\n\nYou also need to configure your DNS server. If you have your own DNS server for your domain, make sure the domain with all wildcards points to your load balancer.\n\nCreating a dedicated DNS zone is recommended when using cert-manager or external-dns but is not required. A pre-existing DNS zone may be used as long as the cert-manager and/or external-dns services are authorized to manage DNS records within that zone. If you are providing your own TLS certificates and will manually create A records pointing to Gitpod&#39;s public load balancer IP addresses then creating a zone is unnecessary.","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/networking"}}],["853",{"pageContent":"In this reference architecture, we use Google Cloud DNS for domain name resolution. To automatically configure Cloud DNS, we use External DNS for Kubernetes.\n\nFirst, we need a service account with role roles/dns.admin. This service account is needed by cert-manager to alter the DNS settings for the DNS-01 resolution.\n\n```bash\nDNS_SA=gitpod-dns01-solver\nDNS_SA_EMAIL=\"${DNS_SA}\"@\"${PROJECT_NAME}\".iam.gserviceaccount.com\ngcloud iam service-accounts create \"${DNS_SA}\" --display-name \"${DNS_SA}\"\ngcloud projects add-iam-policy-binding \"${PROJECT_NAME}\" \\\n    --member serviceAccount:\"${DNS_SA_EMAIL}\" --role=\"roles/dns.admin\"\n```\n\nSave the service account key to the file ./dns-credentials.json:\n\n```bash\ngcloud iam service-accounts keys create --iam-account \"${DNS_SA_EMAIL}\" \\\n    ./dns-credentials.json\n```\n\nAfter that, we create a managed zone.","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/networking"}}],["854",{"pageContent":"```bash\ngcloud iam service-accounts keys create --iam-account \"${DNS_SA_EMAIL}\" \\\n    ./dns-credentials.json\n```\n\nAfter that, we create a managed zone.\n\n```bash\nDOMAIN=gitpod.example.com\ngcloud dns managed-zones create \"${CLUSTER_NAME}\" \\\n    --dns-name \"${DOMAIN}.\" \\\n    --description \"Automatically managed zone by kubernetes.io/external-dns\"\n```\n\nNow we are ready to install External DNS. Please refer to the External DNS GKE docs.\n\n```bash\nhelm repo add bitnami https://charts.bitnami.com/bitnami\nhelm repo update\nhelm upgrade \\\n    --atomic \\\n    --cleanup-on-fail \\\n    --create-namespace \\\n    --install \\\n    --namespace external-dns \\\n    --reset-values \\\n    --set provider=google \\\n    --set google.project=\"${PROJECT_NAME}\" \\\n    --set logFormat=json \\\n    --set google.serviceAccountSecretKey=dns-credentials.json \\\n    --wait \\\n    external-dns \\\n    bitnami/external-dns\n```","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/networking"}}],["855",{"pageContent":"Depending on what your DNS setup for your domain looks like, you most probably want to configure the nameservers for your domain. Run the following command to get a list of nameservers used by your Cloud DNS setup:\n\n```bash\ngcloud dns managed-zones describe ${CLUSTER_NAME} --format json | jq '.nameServers'\n```\n\nIf a Route53 zone has not yet been created, you can do so with the following command (replace gitpod.example.com. with the intended zone):\n\n```bash\nDOMAIN_NAME=\"gitpod.example.com\"\nexport ROUTE53_CALLER=$(cat /proc/sys/kernel/random/uuid)\naws route53 create-hosted-zone \\\n    --name \"${DOMAIN_NAME}.\" \\\n    --caller-reference $ROUTE53_CALLER \\\n    --hosted-zone-config Comment=\"gitpod-zone\"\n```\n\nOnce the domain has been provisioned, you can get the details with the following command and record the Id for later usage:\n\n```bash\naws route53 list-hosted-zones --query \"HostedZones[?Name==\\`$DOMAIN_NAME.\\`]\"\n```\n\nWhich should return something like:","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/networking"}}],["856",{"pageContent":"```bash\naws route53 list-hosted-zones --query \"HostedZones[?Name==\\`$DOMAIN_NAME.\\`]\"\n```\n\nWhich should return something like:\n\n```bash\n[\n    {\n        \"Id\": \"/hostedzone/Z1230498123094\",\n        \"Name\": \"gitpod.example.com.\",\n        \"CallerReference\": \"c43f5dfd-87d9-45fc-bb1f-33bf35d8244b\",\n        \"Config\": {\n            \"Comment\": \"\",\n            \"PrivateZone\": false\n        },\n        \"ResourceRecordSetCount\": 10\n    }\n]\n```\n\nStore this hosted zone in a variable for later use by external-dns and cert-manager:\n\n```bash\nHOSTED_ZONE_ID=\"$(aws route53 list-hosted-zones-by-name \\\n    --dns-name \"$DOMAIN_NAME.\" \\\n    --query \"HostedZones[0].Id\" \\\n    --output json \\\n    --out text)\"\n```\n\nThen install external-dns so that DNS records will be automatically created for Gitpod services. This can be ignored if you are managing DNS records yourself.","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/networking"}}],["857",{"pageContent":"Then install external-dns so that DNS records will be automatically created for Gitpod services. This can be ignored if you are managing DNS records yourself.\n\n```bash\nhelm repo add bitnami https://charts.bitnami.com/bitnami\nhelm repo update\nhelm upgrade \\\n    --atomic \\\n    --cleanup-on-fail \\\n    --create-namespace \\\n    --install \\\n    --namespace external-dns \\\n    --reset-values \\\n    --wait \\\n    --set provider=aws \\\n    --set aws.zoneType=public \\\n    --set txtOwnerId=\"$HOSTED_ZONE_ID\" \\\n    --set \"domainFilters[0]=$DOMAIN_NAME\" \\\n    --set serviceAccount.create=false \\\n    --set serviceAccount.name=external-dns \\\n    --set podSecurityContext.fsGroup=65534 \\\n    external-dns \\\n    bitnami/external-dns\n```\n\nWith Route53 created, you can now proceed to install cert-manager. Cert-manager is needed for Gitpod&#39;s internal networking even if you are managing DNS yourself.","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/networking"}}],["858",{"pageContent":"With Route53 created, you can now proceed to install cert-manager. Cert-manager is needed for Gitpod&#39;s internal networking even if you are managing DNS yourself.\n\nThis section will create an Azure managed zone, grant the AKS cluster permission to manage records in that zone, and install external-dns.\n\nBegin by creating a new Azure managed zone. For example, if you plan on hosting Gitpod at gitpod.svcs.example.com then create a managed zone called svcs.example.com.\n\n```bash\nDOMAIN_NAME=\"svcs.example.com\"\naz network dns zone create --name $DOMAIN_NAME --resource-group $RESOURCE_GROUP\n```\n\nAuthorize the AKS cluster to control DNS records in the zone:\n\n```bash\nZONE_ID=$(az network dns zone show --name \"${DOMAIN_NAME}\" --resource-group \"${RESOURCE_GROUP}\" --query \"id\" -o tsv)\nKUBELET_OBJECT_ID=$(az aks show --name \"${CLUSTER_NAME}\" --resource-group \"${RESOURCE_GROUP}\" --query \"identityProfile.kubeletidentity.objectId\" -o tsv)","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/networking"}}],["859",{"pageContent":"az role assignment create \\\n    --assignee \"${KUBELET_OBJECT_ID}\" \\\n    --role \"DNS Zone Contributor\" \\\n    --scope \"${ZONE_ID}\"\n```\n\nThis role assignment uses AKS Kubelet Identity\nto authorizes the entire AKS cluster to manage DNS records in the given zone, including cert-manager and external-dns.\n\nLook up the AKS kubelet client identity; external-dns will use this identity when authenticating to the Azure API.\n\n```bash\nKUBELET_CLIENT_ID=$(az aks show --name \"${CLUSTER_NAME}\" --resource-group \"${RESOURCE_GROUP}\" --query \"identityProfile.kubeletidentity.clientId\" -o tsv)\n```\n\nThen install the external-dns Helm chart:","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/networking"}}],["860",{"pageContent":"Then install the external-dns Helm chart:\n\n```bash\nhelm repo add bitnami https://charts.bitnami.com/bitnami\nhelm repo update\nhelm upgrade \\\n    --install \\\n    --atomic \\\n    --wait \\\n    --cleanup-on-fail \\\n    --create-namespace \\\n    --namespace external-dns \\\n    --reset-values \\\n    --set provider=azure \\\n    --set azure.resourceGroup=\"${RESOURCE_GROUP}\" \\\n    --set azure.subscriptionId=\"${AZURE_SUBSCRIPTION_ID}\" \\\n    --set azure.tenantId=\"${AZURE_TENANT_ID}\" \\\n    --set azure.useManagedIdentityExtension=true \\\n    --set azure.userAssignedIdentityID=\"${KUBELET_CLIENT_ID}\" \\\n    --set logFormat=json \\\n    external-dns \\\n    bitnami/external-dns\n```\n\ncert-manager\n\nGitpod uses TLS secure external traffic bound for Gitpod as well as identifying, authorizing, and securing internal traffic between Gitpod&#39;s internal components. While you can provide your own TLS certificate for securing external connections to Gitpod, cert-manager is required to generate internal TLS certificates.","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/networking"}}],["861",{"pageContent":"Refer to the cert-manager DNS01 docs for more information.\n\nExample on how to install cert-manager on GCP:\n\n```bash\nhelm repo add jetstack https://charts.jetstack.io\nhelm repo update\nhelm upgrade \\\n    --atomic \\\n    --cleanup-on-fail \\\n    --create-namespace \\\n    --install \\\n    --namespace cert-manager \\\n    --reset-values \\\n    --set installCRDs=true \\\n    --set 'extraArgs={--dns01-recursive-nameservers-only=true,--dns01-recursive-nameservers=8.8.8.8:53\\,1.1.1.1:53}' \\\n    --wait \\\n    cert-manager \\\n    jetstack/cert-manager\n```\n\nDue to the networking behavior and service accounts in EKS, cert-manager needs a different installation procedure. First, install cert-manager with the following command:","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/networking"}}],["862",{"pageContent":"Due to the networking behavior and service accounts in EKS, cert-manager needs a different installation procedure. First, install cert-manager with the following command:\n\n```bash\nhelm repo add jetstack https://charts.jetstack.io\nhelm repo update\nhelm upgrade \\\n    --atomic \\\n    --cleanup-on-fail \\\n    --create-namespace \\\n    --install \\\n    --namespace cert-manager \\\n    --reset-values \\\n    --set installCRDs=true \\\n    --set 'extraArgs={--dns01-recursive-nameservers-only=true,--dns01-recursive-nameservers=8.8.8.8:53\\,1.1.1.1:53}' \\\n    --set webhook.hostNetwork=true \\\n    --set webhook.securePort=10260 \\\n    --set serviceAccount.create=false \\\n    --set serviceAccount.name=cert-manager \\\n    --wait \\\n    cert-manager \\\n    jetstack/cert-manager\n```\n\nOnce the installation has completed, you will need to update the cert-manager security context setting for the service account provisioned for cert-manager by eksctl:","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/networking"}}],["863",{"pageContent":"Once the installation has completed, you will need to update the cert-manager security context setting for the service account provisioned for cert-manager by eksctl:\n\n```bash\nkubectl patch deployment cert-manager -n cert-manager -p \\\n  '{\"spec\":{\"template\":{\"spec\":{\"securityContext\":{\"fsGroup\":1001,\"runAsNonRoot\": true}}}}}'\n\n```\n\nInstall cert-manager with the following command:\n\n```bash\nhelm repo add jetstack https://charts.jetstack.io\nhelm repo update\nhelm upgrade \\\n    --install \\\n    --atomic \\\n    --wait \\\n    --cleanup-on-fail \\\n    --create-namespace \\\n    --namespace='cert-manager' \\\n    --reset-values \\\n    --set installCRDs=true \\\n    --set 'extraArgs={--dns01-recursive-nameservers-only=true,--dns01-recursive-nameservers=8.8.8.8:53\\,1.1.1.1:53}' \\\n    cert-manager \\\n    jetstack/cert-manager\n```\n\nTLS certificate","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/networking"}}],["864",{"pageContent":"TLS certificate\n\nIn this reference architecture, we use cert-manager to also create TLS certificates for the Gitpod domain. Since we need wildcard certificates for the subdomains, you must use the DNS-01 challenge.\n\nUsing a certificate issued by Let&#39;s Encrypt is recommended as it minimizes overhead involving TLS certificates and managing CA certificate trust, but is not required. If you already have TLS certificates for your Gitpod installation with suitable DNS names you can skip this step and use your own certificates during the installation.\n\nNow, we are configuring Google Cloud DNS for the DNS-01 challenge. For this, we need to create a secret that contains the key for the DNS service account:\n\n```bash\nCLOUD_DNS_SECRET=clouddns-dns01-solver\nkubectl create secret generic \"${CLOUD_DNS_SECRET}\" \\\n    --namespace=cert-manager \\\n    --from-file=key.json=\"./dns-credentials.json\"\n```\n\nAfter that, we are telling cert-manager which service account it should use:","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/networking"}}],["865",{"pageContent":"After that, we are telling cert-manager which service account it should use:\n\n```bash\nkubectl annotate serviceaccount --namespace=cert-manager cert-manager \\\n    --overwrite \"iam.gke.io/gcp-service-account=${DNS_SA_EMAIL}\"\n```\n\nThe next step is to create an issuer. In this guide, we create a cluster issuer. Create a file issuer.yaml like this:\n\n```yaml\n# Replace $LETSENCRYPT_EMAIL with your email and $PROJECT_NAME with your GCP project name\napiVersion: cert-manager.io/v1\nkind: ClusterIssuer\nmetadata:\n  name: gitpod-issuer\nspec:\n  acme:\n    email: $LETSENCRYPT_EMAIL\n    server: https://acme-v02.api.letsencrypt.org/directory\n    privateKeySecretRef:\n      name: issuer-account-key\n    solvers:\n      - dns01:\n          cloudDNS:\n            project: $PROJECT_NAME\n```\n\n‚Ä¶ and run:\n\n```bash\nkubectl apply -f issuer.yaml\n```","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/networking"}}],["866",{"pageContent":"‚Ä¶ and run:\n\n```bash\nkubectl apply -f issuer.yaml\n```\n\nIf using eksctl and the cert-manager service account along with well-known policies AND you have your intended zone hosted in Route53, then follow the cert-manager configuration steps. An example cluster issuer using the hosted zone and cert-manager service account created by eksctl is below:\n\n```yaml\n# Replace $LETSENCRYPT_EMAIL with your email and $DOMAIN_NAME with your gitpod domain name (eg.`gitpod.$DOMAIN_NAME`)\napiVersion: cert-manager.io/v1\nkind: ClusterIssuer\nmetadata:\n  name: gitpod-issuer\nspec:\n  acme:\n    server: https://acme-v02.api.letsencrypt.org/directory\n    email: $LETSENCRYPT_EMAIL\n    privateKeySecretRef:\n      name: letsencrypt\n    solvers:\n      - selector:\n          dnsZones:\n            - $DOMAIN_NAME\n        dns01:\n          route53:\n            region: us-east-1\n```","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/networking"}}],["867",{"pageContent":"‚ö†Ô∏è In contrast to most AWS services, Route53 does not support regional endpoints. When creating your ClusterIssuer\nbe careful to use the us-east-1 region for all regions other than the Beijing and Ningxia Regions, and cn-northwest-1\nregion for the Beijing and Ningxia regions.\n\nSee the AWS Route53 endpoints and quotas documentation for more information.\n\nThis section will create a cert-manager ClusterIssuer that will generate publicly trusted certificates using Let&#39;s Encrypt.\n\nFirst, determine your Azure subscription ID. You can typically determine your subscription ID from your Azure CLI credentials.\n\n```bash\nAZURE_SUBSCRIPTION_ID=\"$(az account subscription list --query '[0].subscriptionId' --output tsv)\"\n```\n\nThen create a file named issuer.yaml containing the following content, expanding the $AZURE_SUBSCRIPTION_ID, $RESOURCE_GROUP, and $DOMAIN_NAME variables:","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/networking"}}],["868",{"pageContent":"Then create a file named issuer.yaml containing the following content, expanding the $AZURE_SUBSCRIPTION_ID, $RESOURCE_GROUP, and $DOMAIN_NAME variables:\n\n```yaml\napiVersion: cert-manager.io/v1\nkind: ClusterIssuer\nmetadata:\n  name: gitpod-issuer\nspec:\n  acme:\n    server: https://acme-v02.api.letsencrypt.org/directory\n    privateKeySecretRef:\n      name: issuer-account-key\n    solvers:\n      - dns01:\n          azureDNS:\n            subscriptionID: $AZURE_SUBSCRIPTION_ID\n            resourceGroupName: $RESOURCE_GROUP\n            hostedZoneName: $DOMAIN_NAME\n```\n\nThen apply the ClusterIssuer resource:\n\n```bash\nkubectl apply -f issuer.yaml\n```\n\nThis example ClusterIssuer depends on Azure Managed Identity to authorize requests from cert-manager to the AzureDNS API.\nRefer to the cert-manager AzureDNS DNS01 documentation for more information on cert-manager API authorization.","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/networking"}}],["869",{"pageContent":"Reference Architecture Overview\n\nThe diagram above gives an overview of the reference architecture. Starting from the user‚Äôs workstation, access is provided using a layer 4 (L4) load balancer. An internal proxy distributes this traffic within Gitpod.\n\nThe cluster-external components are accessed by a specific set of components as shown in the diagram. The external components are:\n\nMySQL database\nSource Control Management (SCM), e.g. GitLab, GitHub, GitHub Enterprise, BitBucket, or BitBucket Server\nObject Storage, e.g. Google Cloud Storage or Amazon S3\nOCI Image Registry, e.g. Google Artifact Registry.\nNote: This registry is used by Gitpod to cache images, and store images it builds on behalf of users. This is not the registry that contains the images of Gitpod‚Äôs services.\n\nIn addition, the diagram indicates the different node pools within the cluster. Notice that we separate any user workloads from Gitpod‚Äôs services (except for ws-daemon). In this reference architecture, we create two node pools: the services node pool (upper half in the diagram) and the workspaces node pool (lower half in the diagram).","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/overview"}}],["870",{"pageContent":"You need to prepare your workstation and your cloud provider (e.g. creating a project and preparing service accounts) to be able to replicate this reference architecture.\n\nIndependent of the cloud provider you are using, you need to have kubectl installed on your workstation and configured to access your cluster after creation.\n\nIn order to deploy Gitpod on the Google Kubernetes Engine (GKE) of the Google Cloud Platform (GCP), you need to create and configure a project for your installation. In this guide, we give you examples of how to create the needed resources by using the command line tool gcloud. To follow these examples make sure you have installed the gcloud CLI and logged in to your Google Cloud account. You can also use the GCP Console or the API instead. In that case, please refer to the linked Google docs.","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/preparations"}}],["871",{"pageContent":"First, create a GCP project and enable billing (you have to enable billing to enable GKE). You can freely choose a name for your project (hereinafter referred to as environment variable PROJECT_NAME). You also need the billing account ID (referred to as BILLING_ACCOUNT). To see available lDs, run gcloud alpha billing accounts list.\n\n```bash\nPROJECT_NAME=gitpod\ngcloud projects create \"${PROJECT_NAME}\" --set-as-default\n\nBILLING_ACCOUNT=0X0X0X-0X0X0X-0X0X0X\ngcloud alpha billing projects link \"${PROJECT_NAME}\" \\\n    --billing-account \"${BILLING_ACCOUNT}\"\n```\n\nYou can verify that the proper project has been set as default with this command:\n\n```bash\ngcloud config get-value project\n```\n\nAfter you created your project, you need to enable the following services in this project:","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/preparations"}}],["872",{"pageContent":"```bash\ngcloud config get-value project\n```\n\nAfter you created your project, you need to enable the following services in this project:\n\nServices\ncloudbilling.googleapis.com Google Billing API Billing is required to set up a GKE cluster.\ncontainerregistry.googleapis.com Docker container images registry Enable this service such that Gitpod can push workspace images to that repository.\niam.googleapis.com Identity and Access Management (IAM) API To create and use service accounts for the setup.\ncompute.googleapis.com Google Compute Engine API The Google Compute Engine empowers to run virtual machines (VMs) for the Kubernetes cluster.\ncontainer.googleapis.com Kubernetes Engine API The Kubernetes engine is where we will deploy Gitpod to.\ndns.googleapis.com Cloud DNS Cloud DNS is used in this reference architecture so set up the domain name resolution.\nsqladmin.googleapis.com Cloud SQL Admin API Cloud SQL for MySQL is used as database service in this reference architecture.","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/preparations"}}],["873",{"pageContent":"Run these commands to enable the services:\n\n```bash\ngcloud services enable cloudbilling.googleapis.com\ngcloud services enable containerregistry.googleapis.com\ngcloud services enable iam.googleapis.com\ngcloud services enable compute.googleapis.com\ngcloud services enable container.googleapis.com\ngcloud services enable dns.googleapis.com\ngcloud services enable sqladmin.googleapis.com\n```\n\nNow, you are prepared to create your Kubernetes cluster.\n\nTo deploy Gitpod on Amazon Elastic Kubernetes Service (Amazon EKS), you must have an Amazon account that has permissions to deploy EKS and the underlying component services, which can include:\n\nVPCs\nSubnets\nInternet Gateways\nEC2 Instances\nAutoscaling Groups\nElastic Load Balancers\n\nSpecifically for Gitpod&#39;s use, you will also need permissions to create these additional components:","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/preparations"}}],["874",{"pageContent":"VPCs\nSubnets\nInternet Gateways\nEC2 Instances\nAutoscaling Groups\nElastic Load Balancers\n\nSpecifically for Gitpod&#39;s use, you will also need permissions to create these additional components:\n\nRoute53 DNS Zone for the intended Gitpod domain name (for use with Let&#39;s Encrypt certificate generation)\nRDS Instance running MySQL 5.7 for Gitpod&#39;s database\nS3 Bucket: Hosting Gitpod&#39;s workspace images and object storage\nAWS IAM Service account: To enable access to the S3 bucket\n\nThis guide uses the following tools:\n\nAWS CLI for creating none EKS specific services\nEKS CLI eksctl for creating the EKS cluster and nodegroups themselves\n\nAmazon has a brief run-through on how to deploy a basic cluster using the eksctl tooling if you&#39;d like to familiarize yourself before deploying the Gitpod reference architecture.","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/preparations"}}],["875",{"pageContent":"Amazon has a brief run-through on how to deploy a basic cluster using the eksctl tooling if you&#39;d like to familiarize yourself before deploying the Gitpod reference architecture.\n\nMake sure you are logged in and are connected to the proper AWS account. Ensure AWS is configured and working with the command aws sts get-caller-identity. For later steps you will need to ensure that kubectl is properly configured to authenticate to the newly provisioned EKS environment.\n\nAWS Region Setting\n\nAll commands that follow assume you have set an environment variable of AWS_REGION to your appropriate region or have it configured in your profile already and so will not include --region or --profile when running the aws command. Refer to the AWS CLI documentation for more information.\n\nTo deploy Gitpod on Azure Kubernetes Service, you must have an Azure subscription and account with permission deploy AKS clusters and associated component services, including the following:","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/preparations"}}],["876",{"pageContent":"To deploy Gitpod on Azure Kubernetes Service, you must have an Azure subscription and account with permission deploy AKS clusters and associated component services, including the following:\n\nAKS Clusters\nVirtual networks\nMySQL Databases\nStorage accounts\nAzure Container Registries\nLoad balancers\nAzure DNS managed domains (and rights to assign roles on managed zones)\nRights to make role assignments in Azure Active Directory\n\nThis guide uses the Azure CLI to create resources for your Gitpod installation and requires active Azure credentials. Credentials can be fetched by one of the following options:\n\nSign in interactively\nSign in with a Service Principal (recommended for production installations)\n\nTools\n\nThis guide uses the following tools:\n\nAzure CLI\n\nIf kubectl is not present the Azure CLI can be used to install kubectl:\n\n```bash\nsudo az aks install-cli\n```\n\nLocation and Resource Group","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/preparations"}}],["877",{"pageContent":"Tools\n\nThis guide uses the following tools:\n\nAzure CLI\n\nIf kubectl is not present the Azure CLI can be used to install kubectl:\n\n```bash\nsudo az aks install-cli\n```\n\nLocation and Resource Group\n\nAzure uses resource groups to logically group related resources. This guide uses a dedicated resource group for the Gitpod AKS cluster and all component resources. Creating a new resource group for Gitpod resources is recommended but a pre-existing resource group may be used if necessary.\n\nSet environment variables indicating the resource group and location where Gitpod resources will be created:\n\n```bash\nexport RESOURCE_GROUP=\"gitpod\"\nexport LOCATION=\"centralus\"\n```\n\nThen create a new resource group:\n\n```bash\naz group create --location $LOCATION --name \"$RESOURCE_GROUP\"\n```","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/preparations"}}],["878",{"pageContent":"Kubernetes clusters pull their components from an image registry. In Gitpod, image registries are used for three different purposes:\n\nPulling the actual Gitpod software (components like server, image-builder, etc.).\nPulling base images for workspaces. This is either a default workspace-full image or the image that is configured in the .gitpod.yml resp. .gitpod.Dockerfile in the repo.\nPushing individual workspace images that are built for workspaces during image start. That are for example custom images that are defined in a .gitpod.Dockerfile in the repo. These images are pulled by Kubernetes after image building to provision the workspace. This is the only case where Gitpod needs write access to push images.\n\nWe use a different registry for each of the three items in this reference architecture. The Gitpod images (1) are pulled from a public Google Container Registry we provide. The workspace base image (2) is pulled from Docker Hub (or from the location that is set in the Dockerfile of the corresponding repo). For the individual workspace images (3), we create an image registry that is provided by the used cloud provider. You could also configure Gitpod to use the same registry for all cases. That is particularly useful for air-gap installations where you have access to an internal image registry only.\n\nBy enabling the service containerregistry.googleapis.com (see above), your project provides you with an OCI Image Registry. As credentials, we need the object storage service account key that we will create below. Therefore, there is no further action needed to use the registry in Gitpod.\n\nECR is currently not supported, so configuring the registry will require using an S3 bucket. You can reuse the same S3 bucket used for object storage or a separate one. The steps would be identical in creation, just use different names for both the bucket and the IAM user account.\n\nPlease refer to the Object Storage section for instructions on how to create an S3 bucket. You can re-use the bucket created there as your registry storage backe-end.\n\nTo configure Gitpod to use the bucket created, ensure you select In-cluster Registry, and S3 storage in the installation UI. Then input the values of the bucket you&#39;ve created. When setting the endpoint, please include the region such that s3.amazonaws.com becomes s3.eu-west-1.amazonaws.com.\n\nThis section will create an Amazon Container Registry for workspace images.\n\nFirst, generate a name for the ACR instance. ACR instance names must be unique; using a random suffix is recommended but any unique registry name is sufficient.\n\n```bash\nREGISTRY_NAME=\"gitpod$(openssl rand -hex 4)\"\n```\n\nNote the value of $REGISTRY_NAME for later use.\n\nCreate the container registry:\n\n```bash\naz acr create \\\n  --admin-enabled true \\\n  --location \"${LOCATION}\" \\\n  --name \"${REGISTRY_NAME}\" \\\n  --resource-group \"${RESOURCE_GROUP}\" \\\n  --sku Premium\n```\n\nThe registry server, username, and password will be needed when Gitpod is installed; note these values for later.\n\n```bash\nAZURE_REGISTRY_URL=$(az acr show \\\n    --name \"${REGISTRY_NAME}\" \\\n    --output tsv \\\n    --query loginServer \\\n    --resource-group \"${RESOURCE_GROUP}\")\n\nAZURE_REGISTRY_USERNAME=$(az acr credential show \\\n    --name \"${REGISTRY_NAME}\" \\\n    --output tsv \\\n    --query username \\\n    --resource-group \"${RESOURCE_GROUP}\")\n\nAZURE_REGISTRY_PASSWORD=$(az acr credential show \\\n    --name \"${REGISTRY_NAME}\" \\\n    --output tsv \\\n    --query \"passwords[0].value\" \\\n    --resource-group \"${RESOURCE_GROUP}\")\n```","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/registry"}}],["879",{"pageContent":"Gitpod uses object storage to store blob data. This includes workspace backups that are created when a workspace stops and are used to restore state upon restart. Different user settings like IDE preferences are also stored this way.\n\nThis reference architecture uses managed object storage commonly offered by all cloud providers.\n\nFor each Gitpod user, their own bucket will be created at runtime. For this reason, Gitpod needs proper rights to create buckets in the object storage. Create a service account that has the following roles:\n\nRoles\nroles/storage.admin\nroles/storage.objectAdmin","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/storage"}}],["880",{"pageContent":"Roles\nroles/storage.admin\nroles/storage.objectAdmin\n\n```bash\nOBJECT_STORAGE_SA=gitpod-storage\nOBJECT_STORAGE_SA_EMAIL=\"${OBJECT_STORAGE_SA}\"@\"${PROJECT_NAME}\".iam.gserviceaccount.com\ngcloud iam service-accounts create \"${OBJECT_STORAGE_SA}\" --display-name \"${OBJECT_STORAGE_SA}\"\ngcloud projects add-iam-policy-binding \"${PROJECT_NAME}\" \\\n    --member serviceAccount:\"${OBJECT_STORAGE_SA_EMAIL}\" --role=\"roles/storage.admin\"\ngcloud projects add-iam-policy-binding \"${PROJECT_NAME}\" \\\n    --member serviceAccount:\"${OBJECT_STORAGE_SA_EMAIL}\" --role=\"roles/storage.objectAdmin\"\n```\n\nSave the service account key to the file ./gs-credentials.json:\n\n```bash\ngcloud iam service-accounts keys create --iam-account \"${OBJECT_STORAGE_SA_EMAIL}\" \\\n    ./gs-credentials.json\n```","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/storage"}}],["881",{"pageContent":"Save the service account key to the file ./gs-credentials.json:\n\n```bash\ngcloud iam service-accounts keys create --iam-account \"${OBJECT_STORAGE_SA_EMAIL}\" \\\n    ./gs-credentials.json\n```\n\nBelow, we create one S3 bucket and one IAM User service account to access it. These credentials and the bucket are used for both object storage and storing the workspace images via a Registry frontend deployed in Gitpod (and when Gitpod is installed). The bucket has to have a globally unique name.\n\n```bash\nexport S3_BUCKET_NAME=\"suitably-tired-puma-registry\"\necho ${S3_BUCKET_NAME}\n```\n\nCreate the S3 Bucket and ensure it is private\n\nCreate an S3 bucket using the following command:","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/storage"}}],["882",{"pageContent":"```bash\nexport S3_BUCKET_NAME=\"suitably-tired-puma-registry\"\necho ${S3_BUCKET_NAME}\n```\n\nCreate the S3 Bucket and ensure it is private\n\nCreate an S3 bucket using the following command:\n\n```bash\naws s3api create-bucket \\\n    --bucket ${S3_BUCKET_NAME} \\\n    --region eu-west-1 --create-bucket-configuration LocationConstraint=eu-west-1 \\\n    --object-ownership BucketOwnerEnforced\naws s3api put-public-access-block \\\n    --bucket ${S3_BUCKET_NAME} \\\n    --public-access-block-configuration \"BlockPublicAcls=true,IgnorePublicAcls=true,BlockPublicPolicy=true,RestrictPublicBuckets=true\"\n```\n\nCreate an IAM user for credentials with access just to this bucket\n\n```bash\naws iam create-user \\\n  --user-name gitpod-s3-access \\\n  --tags Key=project,Value=gitpod\n```\n\nSave the following file as S3_policy.json, replacing ${S3_BUCKET_NAME} with the S3 bucket you created:","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/storage"}}],["883",{"pageContent":"Save the following file as S3_policy.json, replacing ${S3_BUCKET_NAME} with the S3 bucket you created:\n\n```json\n{\n  \"Statement\": [\n    {\n      \"Action\": [\n        \"s3:ListBucketMultipartUploads\",\n        \"s3:ListBucket\",\n        \"s3:GetBucketLocation\"\n      ],\n      \"Effect\": \"Allow\",\n      \"Resource\": [\"arn:aws:s3:::${S3_BUCKET_NAME}>\"],\n      \"Sid\": \"\"\n    },\n    {\n      \"Action\": [\n        \"s3:PutObject\",\n        \"s3:ListMultipartUploadParts\",\n        \"s3:GetObject\",\n        \"s3:DeleteObject\",\n        \"s3:AbortMultipartUpload\"\n      ],\n      \"Effect\": \"Allow\",\n      \"Resource\": [\"arn:aws:s3:::${S3_BUCKET_NAME}/*\"],\n      \"Sid\": \"\"\n    }\n  ],\n  \"Version\": \"2012-10-17\"\n}\n```\n\nCreate the policy, taking note of the ARN in the output:\n\n```bash\naws iam create-policy \\\n    --policy-name gitpod_s3_access_policy \\\n    --policy-document <file://S3_policy.json> \\\n    --tags Key=project,Value=gitpod\n```\n\nThis should result in the following output:","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/storage"}}],["884",{"pageContent":"This should result in the following output:\n\n```bash\n{\n    \"Policy\": {\n        \"PolicyName\": \"gitpod_s3_access_policy\",\n        \"PolicyId\": \"ANPA2B3JAS5KQGN6MQRMW\",\n        \"Arn\": \"arn:aws:iam::691173103445:policy/gitpod_s3_access_policy\",\n        \"Path\": \"/\",\n        \"DefaultVersionId\": \"v1\",\n        \"AttachmentCount\": 0,\n        \"PermissionsBoundaryUsageCount\": 0,\n        \"IsAttachable\": true,\n        \"CreateDate\": \"2022-06-24T14:31:30+00:00\",\n        \"UpdateDate\": \"2022-06-24T14:31:30+00:00\",\n        \"Tags\": [\n            {\n                \"Key\": \"project\",\n                \"Value\": \"gitpod\"\n            }\n        ]\n    }\n}\n```\n\nAttach the policy to the IAM user you just created:\n\n```bash\naws iam attach-user-policy \\\n    --user-name gitpod-s3-access \\\n    --policy-arn '<arn from above, similar to: arn:aws:iam::691173103445:policy/gitpod_s3_access_policy>'\n```\n\nCreate and store a user access token","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/storage"}}],["885",{"pageContent":"Create and store a user access token\n\nCreate an access key with the following command, and securely record the resulting AccessKeyId and SecretAccessKey fields:\n\n```bash\naws iam create-access-key --user-name gitpod-s3-access\n```\n\nThis should result in an output similar to the following:\n\n```bash\n{\n    \"AccessKey\": {\n        \"UserName\": \"gitpod-s3-access\",\n        \"AccessKeyId\": \"<accessKeyId>\",\n        \"Status\": \"Active\",\n        \"SecretAccessKey\": \"<SecretAccessKey>\",\n        \"CreateDate\": \"2022-06-24T14:37:40+00:00\"\n    }\n}\n```\n\nTo test that these credentials provide write access to the S3 bucket, open a new shell session and configure it to use the AccessKeyId and SecretAccessKey you&#39;ve just retrieved, and attempt to upload a file and then delete it:","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/storage"}}],["886",{"pageContent":"```sh\nexport AWS_ACCESS_KEY_ID=<accessKeyId>\nexport AWS_SECRET_ACCESS_KEY=<SecretAccessKey>\naws s3 ls s3://${S3_BUCKET_NAME}\necho \"hello world\" > gitpod_test.txt\naws s3 cp gitpod_test.txt s3://${S3_BUCKET_NAME}\n# => upload: ./gitpod_test.txt to s3://$S3_BUCKET_NAME/gitpod_test.txt\naws s3 ls s3://${S3_BUCKET_NAME}\n# => 2022-06-24 15:50:20         12 gitpod_test.txt\naws s3 rm s3://${S3_BUCKET_NAME}/gitpod_test.txt\n# => delete: s3://$S3_BUCKET_NAME/gitpod_test.txt\naws s3 ls s3://${S3_BUCKET_NAME}\n# => *nothing returns if empty*\n```\n\nTo avoid impacting any further calls to AWS, unset the environment variables created:\n\n```bash\nunset AWS_ACCESS_KEY_ID\nunset AWS_SECRET_ACCESS_KEY\n```\n\nThis section will create an Azure storage account for Gitpod object storage and backups.\n\nGenerate a name for the Azure storage account. The Azure storage account name must be globally unique; using a random suffix is recommended but any unique value can be used.","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/storage"}}],["887",{"pageContent":"Generate a name for the Azure storage account. The Azure storage account name must be globally unique; using a random suffix is recommended but any unique value can be used.\n\n```bash\nexport STORAGE_ACCOUNT_NAME=\"gitpod$(openssl rand -hex 4)\"\necho \"$STORAGE_ACCOUNT_NAME\"\n```\n\nNote the value of $STORAGE_ACCOUNT_NAME for later use.\n\nCreate the storage account:\n\n```bash\naz storage account create \\\n  --access-tier Hot \\\n  --kind StorageV2 \\\n  --location \"${LOCATION}\" \\\n  --name \"${STORAGE_ACCOUNT_NAME}\" \\\n  --resource-group \"${RESOURCE_GROUP}\" \\\n  --sku Standard_LRS\n```\n\nAfter creating the storage account, grant access to Gitpod cluster to that storage account.\n\n```bash\nKUBELET_PRINCIPAL_ID=$(az aks show --name \"${CLUSTER_NAME}\" --resource-group \"${RESOURCE_GROUP}\" --query \"identityProfile.kubeletidentity.objectId\" -o tsv)\n\nSTORAGE_ACCOUNT_ID=$(az storage account show \\\n  --name \"${STORAGE_ACCOUNT_NAME}\" \\\n  --output tsv \\\n  --query id \\\n  --resource-group \"${RESOURCE_GROUP}\")","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/storage"}}],["888",{"pageContent":"STORAGE_ACCOUNT_ID=$(az storage account show \\\n  --name \"${STORAGE_ACCOUNT_NAME}\" \\\n  --output tsv \\\n  --query id \\\n  --resource-group \"${RESOURCE_GROUP}\")\n\naz role assignment create \\\n    --assignee \"${KUBELET_PRINCIPAL_ID}\" \\\n    --role \"Storage Blob Data Contributor\" \\\n    --scope \"${STORAGE_ACCOUNT_ID}\"\n```\n\nNote the storage account key for later use.\n\n```bash\nSTORAGE_ACCOUNT_KEY=$(az storage account keys list \\\n    --account-name \"${STORAGE_ACCOUNT_NAME}\" \\\n    --resource-group \"${RESOURCE_GROUP}\" \\\n    --query '[?keyName==`key1`].value' \\\n    --output tsv\n)\n```","metadata":{"source":"https://gitpod.io/docs/configure/self-hosted/latest/reference-architecture/_chunks/storage"}}]]